
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Workspace
 * 
 */
export type Workspace = $Result.DefaultSelection<Prisma.$WorkspacePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model WorkspaceUser
 * 
 */
export type WorkspaceUser = $Result.DefaultSelection<Prisma.$WorkspaceUserPayload>
/**
 * Model WorkspaceInvitation
 * 
 */
export type WorkspaceInvitation = $Result.DefaultSelection<Prisma.$WorkspaceInvitationPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model SecurityEvent
 * 
 */
export type SecurityEvent = $Result.DefaultSelection<Prisma.$SecurityEventPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model WorkspaceSettings
 * 
 */
export type WorkspaceSettings = $Result.DefaultSelection<Prisma.$WorkspaceSettingsPayload>
/**
 * Model ProcessingTemplate
 * 
 */
export type ProcessingTemplate = $Result.DefaultSelection<Prisma.$ProcessingTemplatePayload>
/**
 * Model ApiKeyManagement
 * 
 */
export type ApiKeyManagement = $Result.DefaultSelection<Prisma.$ApiKeyManagementPayload>
/**
 * Model AudioUpload
 * 
 */
export type AudioUpload = $Result.DefaultSelection<Prisma.$AudioUploadPayload>
/**
 * Model ProcessingJob
 * 
 */
export type ProcessingJob = $Result.DefaultSelection<Prisma.$ProcessingJobPayload>
/**
 * Model AudioHistory
 * 
 */
export type AudioHistory = $Result.DefaultSelection<Prisma.$AudioHistoryPayload>
/**
 * Model AudioSegment
 * 
 */
export type AudioSegment = $Result.DefaultSelection<Prisma.$AudioSegmentPayload>
/**
 * Model AudioChunk
 * 
 */
export type AudioChunk = $Result.DefaultSelection<Prisma.$AudioChunkPayload>
/**
 * Model AudioProject
 * 
 */
export type AudioProject = $Result.DefaultSelection<Prisma.$AudioProjectPayload>
/**
 * Model UsageMetric
 * 
 */
export type UsageMetric = $Result.DefaultSelection<Prisma.$UsageMetricPayload>
/**
 * Model UserQuota
 * 
 */
export type UserQuota = $Result.DefaultSelection<Prisma.$UserQuotaPayload>
/**
 * Model StorageQuota
 * 
 */
export type StorageQuota = $Result.DefaultSelection<Prisma.$StorageQuotaPayload>
/**
 * Model SubscriptionPlan
 * 
 */
export type SubscriptionPlan = $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>
/**
 * Model PlanPricing
 * 
 */
export type PlanPricing = $Result.DefaultSelection<Prisma.$PlanPricingPayload>
/**
 * Model Currency
 * 
 */
export type Currency = $Result.DefaultSelection<Prisma.$CurrencyPayload>
/**
 * Model WorkspaceSubscription
 * 
 */
export type WorkspaceSubscription = $Result.DefaultSelection<Prisma.$WorkspaceSubscriptionPayload>
/**
 * Model BillingRecord
 * 
 */
export type BillingRecord = $Result.DefaultSelection<Prisma.$BillingRecordPayload>
/**
 * Model UsageRecord
 * 
 */
export type UsageRecord = $Result.DefaultSelection<Prisma.$UsageRecordPayload>
/**
 * Model UsageCounter
 * 
 */
export type UsageCounter = $Result.DefaultSelection<Prisma.$UsageCounterPayload>
/**
 * Model PlanRecommendation
 * 
 */
export type PlanRecommendation = $Result.DefaultSelection<Prisma.$PlanRecommendationPayload>
/**
 * Model CustomPlan
 * 
 */
export type CustomPlan = $Result.DefaultSelection<Prisma.$CustomPlanPayload>
/**
 * Model FeatureFlag
 * 
 */
export type FeatureFlag = $Result.DefaultSelection<Prisma.$FeatureFlagPayload>
/**
 * Model PlanFeatureMatrix
 * 
 */
export type PlanFeatureMatrix = $Result.DefaultSelection<Prisma.$PlanFeatureMatrixPayload>
/**
 * Model EwayCustomer
 * 
 */
export type EwayCustomer = $Result.DefaultSelection<Prisma.$EwayCustomerPayload>
/**
 * Model EwayTransaction
 * 
 */
export type EwayTransaction = $Result.DefaultSelection<Prisma.$EwayTransactionPayload>
/**
 * Model EwayRecurringSchedule
 * 
 */
export type EwayRecurringSchedule = $Result.DefaultSelection<Prisma.$EwayRecurringSchedulePayload>
/**
 * Model EwayWebhookEvent
 * 
 */
export type EwayWebhookEvent = $Result.DefaultSelection<Prisma.$EwayWebhookEventPayload>
/**
 * Model ExportHistory
 * 
 */
export type ExportHistory = $Result.DefaultSelection<Prisma.$ExportHistoryPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model DataRetentionPolicy
 * 
 */
export type DataRetentionPolicy = $Result.DefaultSelection<Prisma.$DataRetentionPolicyPayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Testimonial
 * 
 */
export type Testimonial = $Result.DefaultSelection<Prisma.$TestimonialPayload>
/**
 * Model WebsiteContent
 * 
 */
export type WebsiteContent = $Result.DefaultSelection<Prisma.$WebsiteContentPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Workspaces
 * const workspaces = await prisma.workspace.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Workspaces
   * const workspaces = await prisma.workspace.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.workspaceUser`: Exposes CRUD operations for the **WorkspaceUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceUsers
    * const workspaceUsers = await prisma.workspaceUser.findMany()
    * ```
    */
  get workspaceUser(): Prisma.WorkspaceUserDelegate<ExtArgs>;

  /**
   * `prisma.workspaceInvitation`: Exposes CRUD operations for the **WorkspaceInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceInvitations
    * const workspaceInvitations = await prisma.workspaceInvitation.findMany()
    * ```
    */
  get workspaceInvitation(): Prisma.WorkspaceInvitationDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.securityEvent`: Exposes CRUD operations for the **SecurityEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityEvents
    * const securityEvents = await prisma.securityEvent.findMany()
    * ```
    */
  get securityEvent(): Prisma.SecurityEventDelegate<ExtArgs>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs>;

  /**
   * `prisma.workspaceSettings`: Exposes CRUD operations for the **WorkspaceSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceSettings
    * const workspaceSettings = await prisma.workspaceSettings.findMany()
    * ```
    */
  get workspaceSettings(): Prisma.WorkspaceSettingsDelegate<ExtArgs>;

  /**
   * `prisma.processingTemplate`: Exposes CRUD operations for the **ProcessingTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessingTemplates
    * const processingTemplates = await prisma.processingTemplate.findMany()
    * ```
    */
  get processingTemplate(): Prisma.ProcessingTemplateDelegate<ExtArgs>;

  /**
   * `prisma.apiKeyManagement`: Exposes CRUD operations for the **ApiKeyManagement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeyManagements
    * const apiKeyManagements = await prisma.apiKeyManagement.findMany()
    * ```
    */
  get apiKeyManagement(): Prisma.ApiKeyManagementDelegate<ExtArgs>;

  /**
   * `prisma.audioUpload`: Exposes CRUD operations for the **AudioUpload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioUploads
    * const audioUploads = await prisma.audioUpload.findMany()
    * ```
    */
  get audioUpload(): Prisma.AudioUploadDelegate<ExtArgs>;

  /**
   * `prisma.processingJob`: Exposes CRUD operations for the **ProcessingJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessingJobs
    * const processingJobs = await prisma.processingJob.findMany()
    * ```
    */
  get processingJob(): Prisma.ProcessingJobDelegate<ExtArgs>;

  /**
   * `prisma.audioHistory`: Exposes CRUD operations for the **AudioHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioHistories
    * const audioHistories = await prisma.audioHistory.findMany()
    * ```
    */
  get audioHistory(): Prisma.AudioHistoryDelegate<ExtArgs>;

  /**
   * `prisma.audioSegment`: Exposes CRUD operations for the **AudioSegment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioSegments
    * const audioSegments = await prisma.audioSegment.findMany()
    * ```
    */
  get audioSegment(): Prisma.AudioSegmentDelegate<ExtArgs>;

  /**
   * `prisma.audioChunk`: Exposes CRUD operations for the **AudioChunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioChunks
    * const audioChunks = await prisma.audioChunk.findMany()
    * ```
    */
  get audioChunk(): Prisma.AudioChunkDelegate<ExtArgs>;

  /**
   * `prisma.audioProject`: Exposes CRUD operations for the **AudioProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioProjects
    * const audioProjects = await prisma.audioProject.findMany()
    * ```
    */
  get audioProject(): Prisma.AudioProjectDelegate<ExtArgs>;

  /**
   * `prisma.usageMetric`: Exposes CRUD operations for the **UsageMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageMetrics
    * const usageMetrics = await prisma.usageMetric.findMany()
    * ```
    */
  get usageMetric(): Prisma.UsageMetricDelegate<ExtArgs>;

  /**
   * `prisma.userQuota`: Exposes CRUD operations for the **UserQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserQuotas
    * const userQuotas = await prisma.userQuota.findMany()
    * ```
    */
  get userQuota(): Prisma.UserQuotaDelegate<ExtArgs>;

  /**
   * `prisma.storageQuota`: Exposes CRUD operations for the **StorageQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorageQuotas
    * const storageQuotas = await prisma.storageQuota.findMany()
    * ```
    */
  get storageQuota(): Prisma.StorageQuotaDelegate<ExtArgs>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
    * ```
    */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<ExtArgs>;

  /**
   * `prisma.planPricing`: Exposes CRUD operations for the **PlanPricing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanPricings
    * const planPricings = await prisma.planPricing.findMany()
    * ```
    */
  get planPricing(): Prisma.PlanPricingDelegate<ExtArgs>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<ExtArgs>;

  /**
   * `prisma.workspaceSubscription`: Exposes CRUD operations for the **WorkspaceSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceSubscriptions
    * const workspaceSubscriptions = await prisma.workspaceSubscription.findMany()
    * ```
    */
  get workspaceSubscription(): Prisma.WorkspaceSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.billingRecord`: Exposes CRUD operations for the **BillingRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingRecords
    * const billingRecords = await prisma.billingRecord.findMany()
    * ```
    */
  get billingRecord(): Prisma.BillingRecordDelegate<ExtArgs>;

  /**
   * `prisma.usageRecord`: Exposes CRUD operations for the **UsageRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageRecords
    * const usageRecords = await prisma.usageRecord.findMany()
    * ```
    */
  get usageRecord(): Prisma.UsageRecordDelegate<ExtArgs>;

  /**
   * `prisma.usageCounter`: Exposes CRUD operations for the **UsageCounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageCounters
    * const usageCounters = await prisma.usageCounter.findMany()
    * ```
    */
  get usageCounter(): Prisma.UsageCounterDelegate<ExtArgs>;

  /**
   * `prisma.planRecommendation`: Exposes CRUD operations for the **PlanRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanRecommendations
    * const planRecommendations = await prisma.planRecommendation.findMany()
    * ```
    */
  get planRecommendation(): Prisma.PlanRecommendationDelegate<ExtArgs>;

  /**
   * `prisma.customPlan`: Exposes CRUD operations for the **CustomPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomPlans
    * const customPlans = await prisma.customPlan.findMany()
    * ```
    */
  get customPlan(): Prisma.CustomPlanDelegate<ExtArgs>;

  /**
   * `prisma.featureFlag`: Exposes CRUD operations for the **FeatureFlag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureFlags
    * const featureFlags = await prisma.featureFlag.findMany()
    * ```
    */
  get featureFlag(): Prisma.FeatureFlagDelegate<ExtArgs>;

  /**
   * `prisma.planFeatureMatrix`: Exposes CRUD operations for the **PlanFeatureMatrix** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanFeatureMatrices
    * const planFeatureMatrices = await prisma.planFeatureMatrix.findMany()
    * ```
    */
  get planFeatureMatrix(): Prisma.PlanFeatureMatrixDelegate<ExtArgs>;

  /**
   * `prisma.ewayCustomer`: Exposes CRUD operations for the **EwayCustomer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EwayCustomers
    * const ewayCustomers = await prisma.ewayCustomer.findMany()
    * ```
    */
  get ewayCustomer(): Prisma.EwayCustomerDelegate<ExtArgs>;

  /**
   * `prisma.ewayTransaction`: Exposes CRUD operations for the **EwayTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EwayTransactions
    * const ewayTransactions = await prisma.ewayTransaction.findMany()
    * ```
    */
  get ewayTransaction(): Prisma.EwayTransactionDelegate<ExtArgs>;

  /**
   * `prisma.ewayRecurringSchedule`: Exposes CRUD operations for the **EwayRecurringSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EwayRecurringSchedules
    * const ewayRecurringSchedules = await prisma.ewayRecurringSchedule.findMany()
    * ```
    */
  get ewayRecurringSchedule(): Prisma.EwayRecurringScheduleDelegate<ExtArgs>;

  /**
   * `prisma.ewayWebhookEvent`: Exposes CRUD operations for the **EwayWebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EwayWebhookEvents
    * const ewayWebhookEvents = await prisma.ewayWebhookEvent.findMany()
    * ```
    */
  get ewayWebhookEvent(): Prisma.EwayWebhookEventDelegate<ExtArgs>;

  /**
   * `prisma.exportHistory`: Exposes CRUD operations for the **ExportHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExportHistories
    * const exportHistories = await prisma.exportHistory.findMany()
    * ```
    */
  get exportHistory(): Prisma.ExportHistoryDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.dataRetentionPolicy`: Exposes CRUD operations for the **DataRetentionPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataRetentionPolicies
    * const dataRetentionPolicies = await prisma.dataRetentionPolicy.findMany()
    * ```
    */
  get dataRetentionPolicy(): Prisma.DataRetentionPolicyDelegate<ExtArgs>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs>;

  /**
   * `prisma.testimonial`: Exposes CRUD operations for the **Testimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonial.findMany()
    * ```
    */
  get testimonial(): Prisma.TestimonialDelegate<ExtArgs>;

  /**
   * `prisma.websiteContent`: Exposes CRUD operations for the **WebsiteContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebsiteContents
    * const websiteContents = await prisma.websiteContent.findMany()
    * ```
    */
  get websiteContent(): Prisma.WebsiteContentDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Workspace: 'Workspace',
    User: 'User',
    WorkspaceUser: 'WorkspaceUser',
    WorkspaceInvitation: 'WorkspaceInvitation',
    RefreshToken: 'RefreshToken',
    Session: 'Session',
    SecurityEvent: 'SecurityEvent',
    UserSettings: 'UserSettings',
    WorkspaceSettings: 'WorkspaceSettings',
    ProcessingTemplate: 'ProcessingTemplate',
    ApiKeyManagement: 'ApiKeyManagement',
    AudioUpload: 'AudioUpload',
    ProcessingJob: 'ProcessingJob',
    AudioHistory: 'AudioHistory',
    AudioSegment: 'AudioSegment',
    AudioChunk: 'AudioChunk',
    AudioProject: 'AudioProject',
    UsageMetric: 'UsageMetric',
    UserQuota: 'UserQuota',
    StorageQuota: 'StorageQuota',
    SubscriptionPlan: 'SubscriptionPlan',
    PlanPricing: 'PlanPricing',
    Currency: 'Currency',
    WorkspaceSubscription: 'WorkspaceSubscription',
    BillingRecord: 'BillingRecord',
    UsageRecord: 'UsageRecord',
    UsageCounter: 'UsageCounter',
    PlanRecommendation: 'PlanRecommendation',
    CustomPlan: 'CustomPlan',
    FeatureFlag: 'FeatureFlag',
    PlanFeatureMatrix: 'PlanFeatureMatrix',
    EwayCustomer: 'EwayCustomer',
    EwayTransaction: 'EwayTransaction',
    EwayRecurringSchedule: 'EwayRecurringSchedule',
    EwayWebhookEvent: 'EwayWebhookEvent',
    ExportHistory: 'ExportHistory',
    AuditLog: 'AuditLog',
    DataRetentionPolicy: 'DataRetentionPolicy',
    PaymentMethod: 'PaymentMethod',
    Testimonial: 'Testimonial',
    WebsiteContent: 'WebsiteContent',
    Role: 'Role',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    UserRole: 'UserRole'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "workspace" | "user" | "workspaceUser" | "workspaceInvitation" | "refreshToken" | "session" | "securityEvent" | "userSettings" | "workspaceSettings" | "processingTemplate" | "apiKeyManagement" | "audioUpload" | "processingJob" | "audioHistory" | "audioSegment" | "audioChunk" | "audioProject" | "usageMetric" | "userQuota" | "storageQuota" | "subscriptionPlan" | "planPricing" | "currency" | "workspaceSubscription" | "billingRecord" | "usageRecord" | "usageCounter" | "planRecommendation" | "customPlan" | "featureFlag" | "planFeatureMatrix" | "ewayCustomer" | "ewayTransaction" | "ewayRecurringSchedule" | "ewayWebhookEvent" | "exportHistory" | "auditLog" | "dataRetentionPolicy" | "paymentMethod" | "testimonial" | "websiteContent" | "role" | "permission" | "rolePermission" | "userRole"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Workspace: {
        payload: Prisma.$WorkspacePayload<ExtArgs>
        fields: Prisma.WorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          create: {
            args: Prisma.WorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          createMany: {
            args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          update: {
            args: Prisma.WorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspace>
          }
          groupBy: {
            args: Prisma.WorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceUser: {
        payload: Prisma.$WorkspaceUserPayload<ExtArgs>
        fields: Prisma.WorkspaceUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          findMany: {
            args: Prisma.WorkspaceUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          create: {
            args: Prisma.WorkspaceUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          createMany: {
            args: Prisma.WorkspaceUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          update: {
            args: Prisma.WorkspaceUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceUser>
          }
          groupBy: {
            args: Prisma.WorkspaceUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceUserCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceInvitation: {
        payload: Prisma.$WorkspaceInvitationPayload<ExtArgs>
        fields: Prisma.WorkspaceInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          findMany: {
            args: Prisma.WorkspaceInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          create: {
            args: Prisma.WorkspaceInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          createMany: {
            args: Prisma.WorkspaceInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          update: {
            args: Prisma.WorkspaceInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceInvitation>
          }
          groupBy: {
            args: Prisma.WorkspaceInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceInvitationCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      SecurityEvent: {
        payload: Prisma.$SecurityEventPayload<ExtArgs>
        fields: Prisma.SecurityEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          findFirst: {
            args: Prisma.SecurityEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          findMany: {
            args: Prisma.SecurityEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          create: {
            args: Prisma.SecurityEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          createMany: {
            args: Prisma.SecurityEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          delete: {
            args: Prisma.SecurityEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          update: {
            args: Prisma.SecurityEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          deleteMany: {
            args: Prisma.SecurityEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SecurityEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          aggregate: {
            args: Prisma.SecurityEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityEvent>
          }
          groupBy: {
            args: Prisma.SecurityEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityEventCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityEventCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceSettings: {
        payload: Prisma.$WorkspaceSettingsPayload<ExtArgs>
        fields: Prisma.WorkspaceSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSettingsPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSettingsPayload>
          }
          findMany: {
            args: Prisma.WorkspaceSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSettingsPayload>[]
          }
          create: {
            args: Prisma.WorkspaceSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSettingsPayload>
          }
          createMany: {
            args: Prisma.WorkspaceSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSettingsPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSettingsPayload>
          }
          update: {
            args: Prisma.WorkspaceSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSettingsPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSettingsPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceSettings>
          }
          groupBy: {
            args: Prisma.WorkspaceSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceSettingsCountAggregateOutputType> | number
          }
        }
      }
      ProcessingTemplate: {
        payload: Prisma.$ProcessingTemplatePayload<ExtArgs>
        fields: Prisma.ProcessingTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessingTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessingTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingTemplatePayload>
          }
          findFirst: {
            args: Prisma.ProcessingTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessingTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingTemplatePayload>
          }
          findMany: {
            args: Prisma.ProcessingTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingTemplatePayload>[]
          }
          create: {
            args: Prisma.ProcessingTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingTemplatePayload>
          }
          createMany: {
            args: Prisma.ProcessingTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessingTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingTemplatePayload>[]
          }
          delete: {
            args: Prisma.ProcessingTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingTemplatePayload>
          }
          update: {
            args: Prisma.ProcessingTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ProcessingTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessingTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessingTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingTemplatePayload>
          }
          aggregate: {
            args: Prisma.ProcessingTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessingTemplate>
          }
          groupBy: {
            args: Prisma.ProcessingTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessingTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessingTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessingTemplateCountAggregateOutputType> | number
          }
        }
      }
      ApiKeyManagement: {
        payload: Prisma.$ApiKeyManagementPayload<ExtArgs>
        fields: Prisma.ApiKeyManagementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyManagementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyManagementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyManagementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyManagementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>
          }
          findMany: {
            args: Prisma.ApiKeyManagementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>[]
          }
          create: {
            args: Prisma.ApiKeyManagementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>
          }
          createMany: {
            args: Prisma.ApiKeyManagementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyManagementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyManagementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>
          }
          update: {
            args: Prisma.ApiKeyManagementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyManagementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyManagementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyManagementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyManagementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKeyManagement>
          }
          groupBy: {
            args: Prisma.ApiKeyManagementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyManagementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyManagementCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyManagementCountAggregateOutputType> | number
          }
        }
      }
      AudioUpload: {
        payload: Prisma.$AudioUploadPayload<ExtArgs>
        fields: Prisma.AudioUploadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioUploadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioUploadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>
          }
          findFirst: {
            args: Prisma.AudioUploadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioUploadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>
          }
          findMany: {
            args: Prisma.AudioUploadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>[]
          }
          create: {
            args: Prisma.AudioUploadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>
          }
          createMany: {
            args: Prisma.AudioUploadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioUploadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>[]
          }
          delete: {
            args: Prisma.AudioUploadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>
          }
          update: {
            args: Prisma.AudioUploadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>
          }
          deleteMany: {
            args: Prisma.AudioUploadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioUploadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AudioUploadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>
          }
          aggregate: {
            args: Prisma.AudioUploadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioUpload>
          }
          groupBy: {
            args: Prisma.AudioUploadGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioUploadGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioUploadCountArgs<ExtArgs>
            result: $Utils.Optional<AudioUploadCountAggregateOutputType> | number
          }
        }
      }
      ProcessingJob: {
        payload: Prisma.$ProcessingJobPayload<ExtArgs>
        fields: Prisma.ProcessingJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessingJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessingJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>
          }
          findFirst: {
            args: Prisma.ProcessingJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessingJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>
          }
          findMany: {
            args: Prisma.ProcessingJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>[]
          }
          create: {
            args: Prisma.ProcessingJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>
          }
          createMany: {
            args: Prisma.ProcessingJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessingJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>[]
          }
          delete: {
            args: Prisma.ProcessingJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>
          }
          update: {
            args: Prisma.ProcessingJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>
          }
          deleteMany: {
            args: Prisma.ProcessingJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessingJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessingJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>
          }
          aggregate: {
            args: Prisma.ProcessingJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessingJob>
          }
          groupBy: {
            args: Prisma.ProcessingJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessingJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessingJobCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessingJobCountAggregateOutputType> | number
          }
        }
      }
      AudioHistory: {
        payload: Prisma.$AudioHistoryPayload<ExtArgs>
        fields: Prisma.AudioHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>
          }
          findFirst: {
            args: Prisma.AudioHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>
          }
          findMany: {
            args: Prisma.AudioHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>[]
          }
          create: {
            args: Prisma.AudioHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>
          }
          createMany: {
            args: Prisma.AudioHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>[]
          }
          delete: {
            args: Prisma.AudioHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>
          }
          update: {
            args: Prisma.AudioHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AudioHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AudioHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>
          }
          aggregate: {
            args: Prisma.AudioHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioHistory>
          }
          groupBy: {
            args: Prisma.AudioHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AudioHistoryCountAggregateOutputType> | number
          }
        }
      }
      AudioSegment: {
        payload: Prisma.$AudioSegmentPayload<ExtArgs>
        fields: Prisma.AudioSegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioSegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioSegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>
          }
          findFirst: {
            args: Prisma.AudioSegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioSegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>
          }
          findMany: {
            args: Prisma.AudioSegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>[]
          }
          create: {
            args: Prisma.AudioSegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>
          }
          createMany: {
            args: Prisma.AudioSegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioSegmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>[]
          }
          delete: {
            args: Prisma.AudioSegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>
          }
          update: {
            args: Prisma.AudioSegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>
          }
          deleteMany: {
            args: Prisma.AudioSegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioSegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AudioSegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>
          }
          aggregate: {
            args: Prisma.AudioSegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioSegment>
          }
          groupBy: {
            args: Prisma.AudioSegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioSegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioSegmentCountArgs<ExtArgs>
            result: $Utils.Optional<AudioSegmentCountAggregateOutputType> | number
          }
        }
      }
      AudioChunk: {
        payload: Prisma.$AudioChunkPayload<ExtArgs>
        fields: Prisma.AudioChunkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioChunkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioChunkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>
          }
          findFirst: {
            args: Prisma.AudioChunkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioChunkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>
          }
          findMany: {
            args: Prisma.AudioChunkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>[]
          }
          create: {
            args: Prisma.AudioChunkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>
          }
          createMany: {
            args: Prisma.AudioChunkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioChunkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>[]
          }
          delete: {
            args: Prisma.AudioChunkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>
          }
          update: {
            args: Prisma.AudioChunkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>
          }
          deleteMany: {
            args: Prisma.AudioChunkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioChunkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AudioChunkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>
          }
          aggregate: {
            args: Prisma.AudioChunkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioChunk>
          }
          groupBy: {
            args: Prisma.AudioChunkGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioChunkGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioChunkCountArgs<ExtArgs>
            result: $Utils.Optional<AudioChunkCountAggregateOutputType> | number
          }
        }
      }
      AudioProject: {
        payload: Prisma.$AudioProjectPayload<ExtArgs>
        fields: Prisma.AudioProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioProjectPayload>
          }
          findFirst: {
            args: Prisma.AudioProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioProjectPayload>
          }
          findMany: {
            args: Prisma.AudioProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioProjectPayload>[]
          }
          create: {
            args: Prisma.AudioProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioProjectPayload>
          }
          createMany: {
            args: Prisma.AudioProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioProjectPayload>[]
          }
          delete: {
            args: Prisma.AudioProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioProjectPayload>
          }
          update: {
            args: Prisma.AudioProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioProjectPayload>
          }
          deleteMany: {
            args: Prisma.AudioProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AudioProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioProjectPayload>
          }
          aggregate: {
            args: Prisma.AudioProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioProject>
          }
          groupBy: {
            args: Prisma.AudioProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioProjectCountArgs<ExtArgs>
            result: $Utils.Optional<AudioProjectCountAggregateOutputType> | number
          }
        }
      }
      UsageMetric: {
        payload: Prisma.$UsageMetricPayload<ExtArgs>
        fields: Prisma.UsageMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>
          }
          findFirst: {
            args: Prisma.UsageMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>
          }
          findMany: {
            args: Prisma.UsageMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>[]
          }
          create: {
            args: Prisma.UsageMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>
          }
          createMany: {
            args: Prisma.UsageMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>[]
          }
          delete: {
            args: Prisma.UsageMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>
          }
          update: {
            args: Prisma.UsageMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>
          }
          deleteMany: {
            args: Prisma.UsageMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsageMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>
          }
          aggregate: {
            args: Prisma.UsageMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageMetric>
          }
          groupBy: {
            args: Prisma.UsageMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageMetricCountArgs<ExtArgs>
            result: $Utils.Optional<UsageMetricCountAggregateOutputType> | number
          }
        }
      }
      UserQuota: {
        payload: Prisma.$UserQuotaPayload<ExtArgs>
        fields: Prisma.UserQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          findFirst: {
            args: Prisma.UserQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          findMany: {
            args: Prisma.UserQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>[]
          }
          create: {
            args: Prisma.UserQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          createMany: {
            args: Prisma.UserQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>[]
          }
          delete: {
            args: Prisma.UserQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          update: {
            args: Prisma.UserQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          deleteMany: {
            args: Prisma.UserQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          aggregate: {
            args: Prisma.UserQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserQuota>
          }
          groupBy: {
            args: Prisma.UserQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<UserQuotaCountAggregateOutputType> | number
          }
        }
      }
      StorageQuota: {
        payload: Prisma.$StorageQuotaPayload<ExtArgs>
        fields: Prisma.StorageQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorageQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorageQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          findFirst: {
            args: Prisma.StorageQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorageQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          findMany: {
            args: Prisma.StorageQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>[]
          }
          create: {
            args: Prisma.StorageQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          createMany: {
            args: Prisma.StorageQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StorageQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>[]
          }
          delete: {
            args: Prisma.StorageQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          update: {
            args: Prisma.StorageQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          deleteMany: {
            args: Prisma.StorageQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorageQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StorageQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          aggregate: {
            args: Prisma.StorageQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorageQuota>
          }
          groupBy: {
            args: Prisma.StorageQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorageQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorageQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<StorageQuotaCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
        fields: Prisma.SubscriptionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPlan>
          }
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanCountAggregateOutputType> | number
          }
        }
      }
      PlanPricing: {
        payload: Prisma.$PlanPricingPayload<ExtArgs>
        fields: Prisma.PlanPricingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanPricingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanPricingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>
          }
          findFirst: {
            args: Prisma.PlanPricingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanPricingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>
          }
          findMany: {
            args: Prisma.PlanPricingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>[]
          }
          create: {
            args: Prisma.PlanPricingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>
          }
          createMany: {
            args: Prisma.PlanPricingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanPricingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>[]
          }
          delete: {
            args: Prisma.PlanPricingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>
          }
          update: {
            args: Prisma.PlanPricingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>
          }
          deleteMany: {
            args: Prisma.PlanPricingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanPricingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanPricingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>
          }
          aggregate: {
            args: Prisma.PlanPricingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanPricing>
          }
          groupBy: {
            args: Prisma.PlanPricingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanPricingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanPricingCountArgs<ExtArgs>
            result: $Utils.Optional<PlanPricingCountAggregateOutputType> | number
          }
        }
      }
      Currency: {
        payload: Prisma.$CurrencyPayload<ExtArgs>
        fields: Prisma.CurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findFirst: {
            args: Prisma.CurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findMany: {
            args: Prisma.CurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          create: {
            args: Prisma.CurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          createMany: {
            args: Prisma.CurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          delete: {
            args: Prisma.CurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          update: {
            args: Prisma.CurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.CurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceSubscription: {
        payload: Prisma.$WorkspaceSubscriptionPayload<ExtArgs>
        fields: Prisma.WorkspaceSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>
          }
          findMany: {
            args: Prisma.WorkspaceSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>[]
          }
          create: {
            args: Prisma.WorkspaceSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>
          }
          createMany: {
            args: Prisma.WorkspaceSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>
          }
          update: {
            args: Prisma.WorkspaceSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceSubscription>
          }
          groupBy: {
            args: Prisma.WorkspaceSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      BillingRecord: {
        payload: Prisma.$BillingRecordPayload<ExtArgs>
        fields: Prisma.BillingRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>
          }
          findFirst: {
            args: Prisma.BillingRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>
          }
          findMany: {
            args: Prisma.BillingRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>[]
          }
          create: {
            args: Prisma.BillingRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>
          }
          createMany: {
            args: Prisma.BillingRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>[]
          }
          delete: {
            args: Prisma.BillingRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>
          }
          update: {
            args: Prisma.BillingRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>
          }
          deleteMany: {
            args: Prisma.BillingRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillingRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>
          }
          aggregate: {
            args: Prisma.BillingRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingRecord>
          }
          groupBy: {
            args: Prisma.BillingRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingRecordCountArgs<ExtArgs>
            result: $Utils.Optional<BillingRecordCountAggregateOutputType> | number
          }
        }
      }
      UsageRecord: {
        payload: Prisma.$UsageRecordPayload<ExtArgs>
        fields: Prisma.UsageRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          findFirst: {
            args: Prisma.UsageRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          findMany: {
            args: Prisma.UsageRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>[]
          }
          create: {
            args: Prisma.UsageRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          createMany: {
            args: Prisma.UsageRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>[]
          }
          delete: {
            args: Prisma.UsageRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          update: {
            args: Prisma.UsageRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          deleteMany: {
            args: Prisma.UsageRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsageRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          aggregate: {
            args: Prisma.UsageRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageRecord>
          }
          groupBy: {
            args: Prisma.UsageRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageRecordCountArgs<ExtArgs>
            result: $Utils.Optional<UsageRecordCountAggregateOutputType> | number
          }
        }
      }
      UsageCounter: {
        payload: Prisma.$UsageCounterPayload<ExtArgs>
        fields: Prisma.UsageCounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageCounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageCounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageCounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageCounterPayload>
          }
          findFirst: {
            args: Prisma.UsageCounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageCounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageCounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageCounterPayload>
          }
          findMany: {
            args: Prisma.UsageCounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageCounterPayload>[]
          }
          create: {
            args: Prisma.UsageCounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageCounterPayload>
          }
          createMany: {
            args: Prisma.UsageCounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageCounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageCounterPayload>[]
          }
          delete: {
            args: Prisma.UsageCounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageCounterPayload>
          }
          update: {
            args: Prisma.UsageCounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageCounterPayload>
          }
          deleteMany: {
            args: Prisma.UsageCounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageCounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsageCounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageCounterPayload>
          }
          aggregate: {
            args: Prisma.UsageCounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageCounter>
          }
          groupBy: {
            args: Prisma.UsageCounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageCounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageCounterCountArgs<ExtArgs>
            result: $Utils.Optional<UsageCounterCountAggregateOutputType> | number
          }
        }
      }
      PlanRecommendation: {
        payload: Prisma.$PlanRecommendationPayload<ExtArgs>
        fields: Prisma.PlanRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanRecommendationPayload>
          }
          findFirst: {
            args: Prisma.PlanRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanRecommendationPayload>
          }
          findMany: {
            args: Prisma.PlanRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanRecommendationPayload>[]
          }
          create: {
            args: Prisma.PlanRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanRecommendationPayload>
          }
          createMany: {
            args: Prisma.PlanRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanRecommendationPayload>[]
          }
          delete: {
            args: Prisma.PlanRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanRecommendationPayload>
          }
          update: {
            args: Prisma.PlanRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.PlanRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanRecommendationPayload>
          }
          aggregate: {
            args: Prisma.PlanRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanRecommendation>
          }
          groupBy: {
            args: Prisma.PlanRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<PlanRecommendationCountAggregateOutputType> | number
          }
        }
      }
      CustomPlan: {
        payload: Prisma.$CustomPlanPayload<ExtArgs>
        fields: Prisma.CustomPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPlanPayload>
          }
          findFirst: {
            args: Prisma.CustomPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPlanPayload>
          }
          findMany: {
            args: Prisma.CustomPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPlanPayload>[]
          }
          create: {
            args: Prisma.CustomPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPlanPayload>
          }
          createMany: {
            args: Prisma.CustomPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPlanPayload>[]
          }
          delete: {
            args: Prisma.CustomPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPlanPayload>
          }
          update: {
            args: Prisma.CustomPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPlanPayload>
          }
          deleteMany: {
            args: Prisma.CustomPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPlanPayload>
          }
          aggregate: {
            args: Prisma.CustomPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomPlan>
          }
          groupBy: {
            args: Prisma.CustomPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomPlanCountArgs<ExtArgs>
            result: $Utils.Optional<CustomPlanCountAggregateOutputType> | number
          }
        }
      }
      FeatureFlag: {
        payload: Prisma.$FeatureFlagPayload<ExtArgs>
        fields: Prisma.FeatureFlagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureFlagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureFlagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          findFirst: {
            args: Prisma.FeatureFlagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureFlagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          findMany: {
            args: Prisma.FeatureFlagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>[]
          }
          create: {
            args: Prisma.FeatureFlagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          createMany: {
            args: Prisma.FeatureFlagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureFlagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>[]
          }
          delete: {
            args: Prisma.FeatureFlagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          update: {
            args: Prisma.FeatureFlagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          deleteMany: {
            args: Prisma.FeatureFlagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureFlagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeatureFlagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          aggregate: {
            args: Prisma.FeatureFlagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatureFlag>
          }
          groupBy: {
            args: Prisma.FeatureFlagGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureFlagGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureFlagCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureFlagCountAggregateOutputType> | number
          }
        }
      }
      PlanFeatureMatrix: {
        payload: Prisma.$PlanFeatureMatrixPayload<ExtArgs>
        fields: Prisma.PlanFeatureMatrixFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFeatureMatrixFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeatureMatrixPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFeatureMatrixFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeatureMatrixPayload>
          }
          findFirst: {
            args: Prisma.PlanFeatureMatrixFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeatureMatrixPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFeatureMatrixFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeatureMatrixPayload>
          }
          findMany: {
            args: Prisma.PlanFeatureMatrixFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeatureMatrixPayload>[]
          }
          create: {
            args: Prisma.PlanFeatureMatrixCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeatureMatrixPayload>
          }
          createMany: {
            args: Prisma.PlanFeatureMatrixCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanFeatureMatrixCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeatureMatrixPayload>[]
          }
          delete: {
            args: Prisma.PlanFeatureMatrixDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeatureMatrixPayload>
          }
          update: {
            args: Prisma.PlanFeatureMatrixUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeatureMatrixPayload>
          }
          deleteMany: {
            args: Prisma.PlanFeatureMatrixDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanFeatureMatrixUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanFeatureMatrixUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeatureMatrixPayload>
          }
          aggregate: {
            args: Prisma.PlanFeatureMatrixAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanFeatureMatrix>
          }
          groupBy: {
            args: Prisma.PlanFeatureMatrixGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanFeatureMatrixGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanFeatureMatrixCountArgs<ExtArgs>
            result: $Utils.Optional<PlanFeatureMatrixCountAggregateOutputType> | number
          }
        }
      }
      EwayCustomer: {
        payload: Prisma.$EwayCustomerPayload<ExtArgs>
        fields: Prisma.EwayCustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EwayCustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EwayCustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>
          }
          findFirst: {
            args: Prisma.EwayCustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EwayCustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>
          }
          findMany: {
            args: Prisma.EwayCustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>[]
          }
          create: {
            args: Prisma.EwayCustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>
          }
          createMany: {
            args: Prisma.EwayCustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EwayCustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>[]
          }
          delete: {
            args: Prisma.EwayCustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>
          }
          update: {
            args: Prisma.EwayCustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>
          }
          deleteMany: {
            args: Prisma.EwayCustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EwayCustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EwayCustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>
          }
          aggregate: {
            args: Prisma.EwayCustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEwayCustomer>
          }
          groupBy: {
            args: Prisma.EwayCustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<EwayCustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.EwayCustomerCountArgs<ExtArgs>
            result: $Utils.Optional<EwayCustomerCountAggregateOutputType> | number
          }
        }
      }
      EwayTransaction: {
        payload: Prisma.$EwayTransactionPayload<ExtArgs>
        fields: Prisma.EwayTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EwayTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EwayTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>
          }
          findFirst: {
            args: Prisma.EwayTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EwayTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>
          }
          findMany: {
            args: Prisma.EwayTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>[]
          }
          create: {
            args: Prisma.EwayTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>
          }
          createMany: {
            args: Prisma.EwayTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EwayTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>[]
          }
          delete: {
            args: Prisma.EwayTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>
          }
          update: {
            args: Prisma.EwayTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>
          }
          deleteMany: {
            args: Prisma.EwayTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EwayTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EwayTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>
          }
          aggregate: {
            args: Prisma.EwayTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEwayTransaction>
          }
          groupBy: {
            args: Prisma.EwayTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EwayTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EwayTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<EwayTransactionCountAggregateOutputType> | number
          }
        }
      }
      EwayRecurringSchedule: {
        payload: Prisma.$EwayRecurringSchedulePayload<ExtArgs>
        fields: Prisma.EwayRecurringScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EwayRecurringScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EwayRecurringScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>
          }
          findFirst: {
            args: Prisma.EwayRecurringScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EwayRecurringScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>
          }
          findMany: {
            args: Prisma.EwayRecurringScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>[]
          }
          create: {
            args: Prisma.EwayRecurringScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>
          }
          createMany: {
            args: Prisma.EwayRecurringScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EwayRecurringScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>[]
          }
          delete: {
            args: Prisma.EwayRecurringScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>
          }
          update: {
            args: Prisma.EwayRecurringScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>
          }
          deleteMany: {
            args: Prisma.EwayRecurringScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EwayRecurringScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EwayRecurringScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>
          }
          aggregate: {
            args: Prisma.EwayRecurringScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEwayRecurringSchedule>
          }
          groupBy: {
            args: Prisma.EwayRecurringScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<EwayRecurringScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.EwayRecurringScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<EwayRecurringScheduleCountAggregateOutputType> | number
          }
        }
      }
      EwayWebhookEvent: {
        payload: Prisma.$EwayWebhookEventPayload<ExtArgs>
        fields: Prisma.EwayWebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EwayWebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EwayWebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>
          }
          findFirst: {
            args: Prisma.EwayWebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EwayWebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>
          }
          findMany: {
            args: Prisma.EwayWebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>[]
          }
          create: {
            args: Prisma.EwayWebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>
          }
          createMany: {
            args: Prisma.EwayWebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EwayWebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>[]
          }
          delete: {
            args: Prisma.EwayWebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>
          }
          update: {
            args: Prisma.EwayWebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.EwayWebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EwayWebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EwayWebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>
          }
          aggregate: {
            args: Prisma.EwayWebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEwayWebhookEvent>
          }
          groupBy: {
            args: Prisma.EwayWebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EwayWebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EwayWebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<EwayWebhookEventCountAggregateOutputType> | number
          }
        }
      }
      ExportHistory: {
        payload: Prisma.$ExportHistoryPayload<ExtArgs>
        fields: Prisma.ExportHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExportHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExportHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>
          }
          findFirst: {
            args: Prisma.ExportHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExportHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>
          }
          findMany: {
            args: Prisma.ExportHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>[]
          }
          create: {
            args: Prisma.ExportHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>
          }
          createMany: {
            args: Prisma.ExportHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExportHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>[]
          }
          delete: {
            args: Prisma.ExportHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>
          }
          update: {
            args: Prisma.ExportHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ExportHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExportHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExportHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>
          }
          aggregate: {
            args: Prisma.ExportHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExportHistory>
          }
          groupBy: {
            args: Prisma.ExportHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExportHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExportHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExportHistoryCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      DataRetentionPolicy: {
        payload: Prisma.$DataRetentionPolicyPayload<ExtArgs>
        fields: Prisma.DataRetentionPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataRetentionPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataRetentionPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          findFirst: {
            args: Prisma.DataRetentionPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataRetentionPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          findMany: {
            args: Prisma.DataRetentionPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>[]
          }
          create: {
            args: Prisma.DataRetentionPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          createMany: {
            args: Prisma.DataRetentionPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataRetentionPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>[]
          }
          delete: {
            args: Prisma.DataRetentionPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          update: {
            args: Prisma.DataRetentionPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          deleteMany: {
            args: Prisma.DataRetentionPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataRetentionPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataRetentionPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          aggregate: {
            args: Prisma.DataRetentionPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataRetentionPolicy>
          }
          groupBy: {
            args: Prisma.DataRetentionPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataRetentionPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataRetentionPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<DataRetentionPolicyCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Testimonial: {
        payload: Prisma.$TestimonialPayload<ExtArgs>
        fields: Prisma.TestimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findFirst: {
            args: Prisma.TestimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findMany: {
            args: Prisma.TestimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          create: {
            args: Prisma.TestimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          createMany: {
            args: Prisma.TestimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestimonialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          delete: {
            args: Prisma.TestimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          update: {
            args: Prisma.TestimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          deleteMany: {
            args: Prisma.TestimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          aggregate: {
            args: Prisma.TestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonial>
          }
          groupBy: {
            args: Prisma.TestimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestimonialCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialCountAggregateOutputType> | number
          }
        }
      }
      WebsiteContent: {
        payload: Prisma.$WebsiteContentPayload<ExtArgs>
        fields: Prisma.WebsiteContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebsiteContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebsiteContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteContentPayload>
          }
          findFirst: {
            args: Prisma.WebsiteContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebsiteContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteContentPayload>
          }
          findMany: {
            args: Prisma.WebsiteContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteContentPayload>[]
          }
          create: {
            args: Prisma.WebsiteContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteContentPayload>
          }
          createMany: {
            args: Prisma.WebsiteContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebsiteContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteContentPayload>[]
          }
          delete: {
            args: Prisma.WebsiteContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteContentPayload>
          }
          update: {
            args: Prisma.WebsiteContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteContentPayload>
          }
          deleteMany: {
            args: Prisma.WebsiteContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebsiteContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebsiteContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteContentPayload>
          }
          aggregate: {
            args: Prisma.WebsiteContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebsiteContent>
          }
          groupBy: {
            args: Prisma.WebsiteContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebsiteContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebsiteContentCountArgs<ExtArgs>
            result: $Utils.Optional<WebsiteContentCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type WorkspaceCountOutputType
   */

  export type WorkspaceCountOutputType = {
    users: number
    invitations: number
    audioHistory: number
    audioUploads: number
    projects: number
    usageMetrics: number
    subscriptions: number
    auditLogs: number
  }

  export type WorkspaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | WorkspaceCountOutputTypeCountUsersArgs
    invitations?: boolean | WorkspaceCountOutputTypeCountInvitationsArgs
    audioHistory?: boolean | WorkspaceCountOutputTypeCountAudioHistoryArgs
    audioUploads?: boolean | WorkspaceCountOutputTypeCountAudioUploadsArgs
    projects?: boolean | WorkspaceCountOutputTypeCountProjectsArgs
    usageMetrics?: boolean | WorkspaceCountOutputTypeCountUsageMetricsArgs
    subscriptions?: boolean | WorkspaceCountOutputTypeCountSubscriptionsArgs
    auditLogs?: boolean | WorkspaceCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAudioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioHistoryWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAudioUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioUploadWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioProjectWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountUsageMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageMetricWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceSubscriptionWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    audioHistory: number
    sessions: number
    workspaces: number
    refreshTokens: number
    audioUploads: number
    projects: number
    processingJobs: number
    usageMetrics: number
    exports: number
    apiKeys: number
    auditLogs: number
    securityEvents: number
    processingTemplates: number
    customPlans: number
    planRecommendations: number
    usageCounters: number
    ewayCustomers: number
    ewayTransactions: number
    ewayRecurringSchedules: number
    userRoles: number
    assignedRoles: number
    testimonials: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audioHistory?: boolean | UserCountOutputTypeCountAudioHistoryArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    workspaces?: boolean | UserCountOutputTypeCountWorkspacesArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    audioUploads?: boolean | UserCountOutputTypeCountAudioUploadsArgs
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    processingJobs?: boolean | UserCountOutputTypeCountProcessingJobsArgs
    usageMetrics?: boolean | UserCountOutputTypeCountUsageMetricsArgs
    exports?: boolean | UserCountOutputTypeCountExportsArgs
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    securityEvents?: boolean | UserCountOutputTypeCountSecurityEventsArgs
    processingTemplates?: boolean | UserCountOutputTypeCountProcessingTemplatesArgs
    customPlans?: boolean | UserCountOutputTypeCountCustomPlansArgs
    planRecommendations?: boolean | UserCountOutputTypeCountPlanRecommendationsArgs
    usageCounters?: boolean | UserCountOutputTypeCountUsageCountersArgs
    ewayCustomers?: boolean | UserCountOutputTypeCountEwayCustomersArgs
    ewayTransactions?: boolean | UserCountOutputTypeCountEwayTransactionsArgs
    ewayRecurringSchedules?: boolean | UserCountOutputTypeCountEwayRecurringSchedulesArgs
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
    assignedRoles?: boolean | UserCountOutputTypeCountAssignedRolesArgs
    testimonials?: boolean | UserCountOutputTypeCountTestimonialsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAudioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAudioUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioUploadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessingJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessingJobWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsageMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageMetricWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyManagementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSecurityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessingTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessingTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomPlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlanRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanRecommendationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsageCountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageCounterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEwayCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayCustomerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEwayTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEwayRecurringSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayRecurringScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
  }


  /**
   * Count Type AudioUploadCountOutputType
   */

  export type AudioUploadCountOutputType = {
    audioHistory: number
    processingJobs: number
    audioChunks: number
  }

  export type AudioUploadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audioHistory?: boolean | AudioUploadCountOutputTypeCountAudioHistoryArgs
    processingJobs?: boolean | AudioUploadCountOutputTypeCountProcessingJobsArgs
    audioChunks?: boolean | AudioUploadCountOutputTypeCountAudioChunksArgs
  }

  // Custom InputTypes
  /**
   * AudioUploadCountOutputType without action
   */
  export type AudioUploadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUploadCountOutputType
     */
    select?: AudioUploadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AudioUploadCountOutputType without action
   */
  export type AudioUploadCountOutputTypeCountAudioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioHistoryWhereInput
  }

  /**
   * AudioUploadCountOutputType without action
   */
  export type AudioUploadCountOutputTypeCountProcessingJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessingJobWhereInput
  }

  /**
   * AudioUploadCountOutputType without action
   */
  export type AudioUploadCountOutputTypeCountAudioChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioChunkWhereInput
  }


  /**
   * Count Type AudioHistoryCountOutputType
   */

  export type AudioHistoryCountOutputType = {
    segments: number
  }

  export type AudioHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segments?: boolean | AudioHistoryCountOutputTypeCountSegmentsArgs
  }

  // Custom InputTypes
  /**
   * AudioHistoryCountOutputType without action
   */
  export type AudioHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistoryCountOutputType
     */
    select?: AudioHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AudioHistoryCountOutputType without action
   */
  export type AudioHistoryCountOutputTypeCountSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioSegmentWhereInput
  }


  /**
   * Count Type SubscriptionPlanCountOutputType
   */

  export type SubscriptionPlanCountOutputType = {
    subscriptions: number
    planPricing: number
    planFeatures: number
    currentPlanRecommendations: number
    recommendedPlanRecommendations: number
    customPlans: number
  }

  export type SubscriptionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlanCountOutputTypeCountSubscriptionsArgs
    planPricing?: boolean | SubscriptionPlanCountOutputTypeCountPlanPricingArgs
    planFeatures?: boolean | SubscriptionPlanCountOutputTypeCountPlanFeaturesArgs
    currentPlanRecommendations?: boolean | SubscriptionPlanCountOutputTypeCountCurrentPlanRecommendationsArgs
    recommendedPlanRecommendations?: boolean | SubscriptionPlanCountOutputTypeCountRecommendedPlanRecommendationsArgs
    customPlans?: boolean | SubscriptionPlanCountOutputTypeCountCustomPlansArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlanCountOutputType
     */
    select?: SubscriptionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceSubscriptionWhereInput
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountPlanPricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanPricingWhereInput
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountPlanFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanFeatureMatrixWhereInput
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountCurrentPlanRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanRecommendationWhereInput
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountRecommendedPlanRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanRecommendationWhereInput
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountCustomPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomPlanWhereInput
  }


  /**
   * Count Type WorkspaceSubscriptionCountOutputType
   */

  export type WorkspaceSubscriptionCountOutputType = {
    billingRecords: number
    usageRecords: number
  }

  export type WorkspaceSubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingRecords?: boolean | WorkspaceSubscriptionCountOutputTypeCountBillingRecordsArgs
    usageRecords?: boolean | WorkspaceSubscriptionCountOutputTypeCountUsageRecordsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceSubscriptionCountOutputType without action
   */
  export type WorkspaceSubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscriptionCountOutputType
     */
    select?: WorkspaceSubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceSubscriptionCountOutputType without action
   */
  export type WorkspaceSubscriptionCountOutputTypeCountBillingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingRecordWhereInput
  }

  /**
   * WorkspaceSubscriptionCountOutputType without action
   */
  export type WorkspaceSubscriptionCountOutputTypeCountUsageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageRecordWhereInput
  }


  /**
   * Count Type FeatureFlagCountOutputType
   */

  export type FeatureFlagCountOutputType = {
    planFeatures: number
  }

  export type FeatureFlagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planFeatures?: boolean | FeatureFlagCountOutputTypeCountPlanFeaturesArgs
  }

  // Custom InputTypes
  /**
   * FeatureFlagCountOutputType without action
   */
  export type FeatureFlagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlagCountOutputType
     */
    select?: FeatureFlagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeatureFlagCountOutputType without action
   */
  export type FeatureFlagCountOutputTypeCountPlanFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanFeatureMatrixWhereInput
  }


  /**
   * Count Type EwayCustomerCountOutputType
   */

  export type EwayCustomerCountOutputType = {
    transactions: number
    recurringSchedules: number
  }

  export type EwayCustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | EwayCustomerCountOutputTypeCountTransactionsArgs
    recurringSchedules?: boolean | EwayCustomerCountOutputTypeCountRecurringSchedulesArgs
  }

  // Custom InputTypes
  /**
   * EwayCustomerCountOutputType without action
   */
  export type EwayCustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomerCountOutputType
     */
    select?: EwayCustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EwayCustomerCountOutputType without action
   */
  export type EwayCustomerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayTransactionWhereInput
  }

  /**
   * EwayCustomerCountOutputType without action
   */
  export type EwayCustomerCountOutputTypeCountRecurringSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayRecurringScheduleWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Workspace
   */

  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type WorkspaceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    createdAt: number
    updatedAt: number
    isActive: number
    _all: number
  }


  export type WorkspaceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type WorkspaceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type WorkspaceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    _all?: true
  }

  export type WorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithAggregationInput | WorkspaceOrderByWithAggregationInput[]
    by: WorkspaceScalarFieldEnum[] | WorkspaceScalarFieldEnum
    having?: WorkspaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceCountAggregateInputType | true
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }

  export type WorkspaceGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    users?: boolean | Workspace$usersArgs<ExtArgs>
    invitations?: boolean | Workspace$invitationsArgs<ExtArgs>
    audioHistory?: boolean | Workspace$audioHistoryArgs<ExtArgs>
    audioUploads?: boolean | Workspace$audioUploadsArgs<ExtArgs>
    projects?: boolean | Workspace$projectsArgs<ExtArgs>
    settings?: boolean | Workspace$settingsArgs<ExtArgs>
    usageMetrics?: boolean | Workspace$usageMetricsArgs<ExtArgs>
    storageQuota?: boolean | Workspace$storageQuotaArgs<ExtArgs>
    subscriptions?: boolean | Workspace$subscriptionsArgs<ExtArgs>
    auditLogs?: boolean | Workspace$auditLogsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }

  export type WorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Workspace$usersArgs<ExtArgs>
    invitations?: boolean | Workspace$invitationsArgs<ExtArgs>
    audioHistory?: boolean | Workspace$audioHistoryArgs<ExtArgs>
    audioUploads?: boolean | Workspace$audioUploadsArgs<ExtArgs>
    projects?: boolean | Workspace$projectsArgs<ExtArgs>
    settings?: boolean | Workspace$settingsArgs<ExtArgs>
    usageMetrics?: boolean | Workspace$usageMetricsArgs<ExtArgs>
    storageQuota?: boolean | Workspace$storageQuotaArgs<ExtArgs>
    subscriptions?: boolean | Workspace$subscriptionsArgs<ExtArgs>
    auditLogs?: boolean | Workspace$auditLogsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workspace"
    objects: {
      users: Prisma.$WorkspaceUserPayload<ExtArgs>[]
      invitations: Prisma.$WorkspaceInvitationPayload<ExtArgs>[]
      audioHistory: Prisma.$AudioHistoryPayload<ExtArgs>[]
      audioUploads: Prisma.$AudioUploadPayload<ExtArgs>[]
      projects: Prisma.$AudioProjectPayload<ExtArgs>[]
      settings: Prisma.$WorkspaceSettingsPayload<ExtArgs> | null
      usageMetrics: Prisma.$UsageMetricPayload<ExtArgs>[]
      storageQuota: Prisma.$StorageQuotaPayload<ExtArgs> | null
      subscriptions: Prisma.$WorkspaceSubscriptionPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      isActive: boolean
    }, ExtArgs["result"]["workspace"]>
    composites: {}
  }

  type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceDefaultArgs> = $Result.GetResult<Prisma.$WorkspacePayload, S>

  type WorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workspace'], meta: { name: 'Workspace' } }
    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFindUniqueArgs>(args: SelectSubset<T, WorkspaceFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Workspace that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFindFirstArgs>(args?: SelectSubset<T, WorkspaceFindFirstArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Workspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceFindManyArgs>(args?: SelectSubset<T, WorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
     */
    create<T extends WorkspaceCreateArgs>(args: SelectSubset<T, WorkspaceCreateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workspaces.
     * @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceCreateManyArgs>(args?: SelectSubset<T, WorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workspaces and returns the data saved in the database.
     * @param {WorkspaceCreateManyAndReturnArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDeleteArgs>(args: SelectSubset<T, WorkspaceDeleteArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUpdateArgs>(args: SelectSubset<T, WorkspaceUpdateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUpdateManyArgs>(args: SelectSubset<T, WorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUpsertArgs>(args: SelectSubset<T, WorkspaceUpsertArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workspace model
   */
  readonly fields: WorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Workspace$usersArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany"> | Null>
    invitations<T extends Workspace$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    audioHistory<T extends Workspace$audioHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$audioHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    audioUploads<T extends Workspace$audioUploadsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$audioUploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends Workspace$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioProjectPayload<ExtArgs>, T, "findMany"> | Null>
    settings<T extends Workspace$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$settingsArgs<ExtArgs>>): Prisma__WorkspaceSettingsClient<$Result.GetResult<Prisma.$WorkspaceSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    usageMetrics<T extends Workspace$usageMetricsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$usageMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "findMany"> | Null>
    storageQuota<T extends Workspace$storageQuotaArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$storageQuotaArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subscriptions<T extends Workspace$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Workspace$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workspace model
   */ 
  interface WorkspaceFieldRefs {
    readonly id: FieldRef<"Workspace", 'String'>
    readonly name: FieldRef<"Workspace", 'String'>
    readonly slug: FieldRef<"Workspace", 'String'>
    readonly description: FieldRef<"Workspace", 'String'>
    readonly createdAt: FieldRef<"Workspace", 'DateTime'>
    readonly updatedAt: FieldRef<"Workspace", 'DateTime'>
    readonly isActive: FieldRef<"Workspace", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Workspace findUnique
   */
  export type WorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findFirst
   */
  export type WorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
  }

  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace createManyAndReturn
   */
  export type WorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
  }

  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
  }

  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput
  }

  /**
   * Workspace.users
   */
  export type Workspace$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    cursor?: WorkspaceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * Workspace.invitations
   */
  export type Workspace$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    cursor?: WorkspaceInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * Workspace.audioHistory
   */
  export type Workspace$audioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    where?: AudioHistoryWhereInput
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    cursor?: AudioHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioHistoryScalarFieldEnum | AudioHistoryScalarFieldEnum[]
  }

  /**
   * Workspace.audioUploads
   */
  export type Workspace$audioUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    where?: AudioUploadWhereInput
    orderBy?: AudioUploadOrderByWithRelationInput | AudioUploadOrderByWithRelationInput[]
    cursor?: AudioUploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioUploadScalarFieldEnum | AudioUploadScalarFieldEnum[]
  }

  /**
   * Workspace.projects
   */
  export type Workspace$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectInclude<ExtArgs> | null
    where?: AudioProjectWhereInput
    orderBy?: AudioProjectOrderByWithRelationInput | AudioProjectOrderByWithRelationInput[]
    cursor?: AudioProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioProjectScalarFieldEnum | AudioProjectScalarFieldEnum[]
  }

  /**
   * Workspace.settings
   */
  export type Workspace$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSettings
     */
    select?: WorkspaceSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSettingsInclude<ExtArgs> | null
    where?: WorkspaceSettingsWhereInput
  }

  /**
   * Workspace.usageMetrics
   */
  export type Workspace$usageMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null
    where?: UsageMetricWhereInput
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[]
    cursor?: UsageMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[]
  }

  /**
   * Workspace.storageQuota
   */
  export type Workspace$storageQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    where?: StorageQuotaWhereInput
  }

  /**
   * Workspace.subscriptions
   */
  export type Workspace$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    where?: WorkspaceSubscriptionWhereInput
    orderBy?: WorkspaceSubscriptionOrderByWithRelationInput | WorkspaceSubscriptionOrderByWithRelationInput[]
    cursor?: WorkspaceSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceSubscriptionScalarFieldEnum | WorkspaceSubscriptionScalarFieldEnum[]
  }

  /**
   * Workspace.auditLogs
   */
  export type Workspace$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Workspace without action
   */
  export type WorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    isActive: boolean | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    timezone: string | null
    businessName: string | null
    mobileNumber: string | null
    country: string | null
    currency: string | null
    businessAddress: string | null
    businessPhone: string | null
    taxNumber: string | null
    companySize: string | null
    industry: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    isActive: boolean | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    timezone: string | null
    businessName: string | null
    mobileNumber: string | null
    country: string | null
    currency: string | null
    businessAddress: string | null
    businessPhone: string | null
    taxNumber: string | null
    companySize: string | null
    industry: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    role: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    isActive: number
    firstName: number
    lastName: number
    avatarUrl: number
    timezone: number
    businessName: number
    mobileNumber: number
    country: number
    currency: number
    businessAddress: number
    businessPhone: number
    taxNumber: number
    companySize: number
    industry: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    isActive?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    timezone?: true
    businessName?: true
    mobileNumber?: true
    country?: true
    currency?: true
    businessAddress?: true
    businessPhone?: true
    taxNumber?: true
    companySize?: true
    industry?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    isActive?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    timezone?: true
    businessName?: true
    mobileNumber?: true
    country?: true
    currency?: true
    businessAddress?: true
    businessPhone?: true
    taxNumber?: true
    companySize?: true
    industry?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    isActive?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    timezone?: true
    businessName?: true
    mobileNumber?: true
    country?: true
    currency?: true
    businessAddress?: true
    businessPhone?: true
    taxNumber?: true
    companySize?: true
    industry?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    passwordHash: string
    role: string
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    isActive: boolean
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    timezone: string | null
    businessName: string | null
    mobileNumber: string | null
    country: string | null
    currency: string | null
    businessAddress: string | null
    businessPhone: string | null
    taxNumber: string | null
    companySize: string | null
    industry: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    isActive?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    businessName?: boolean
    mobileNumber?: boolean
    country?: boolean
    currency?: boolean
    businessAddress?: boolean
    businessPhone?: boolean
    taxNumber?: boolean
    companySize?: boolean
    industry?: boolean
    audioHistory?: boolean | User$audioHistoryArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    audioUploads?: boolean | User$audioUploadsArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    processingJobs?: boolean | User$processingJobsArgs<ExtArgs>
    usageMetrics?: boolean | User$usageMetricsArgs<ExtArgs>
    exports?: boolean | User$exportsArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    quota?: boolean | User$quotaArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    securityEvents?: boolean | User$securityEventsArgs<ExtArgs>
    processingTemplates?: boolean | User$processingTemplatesArgs<ExtArgs>
    customPlans?: boolean | User$customPlansArgs<ExtArgs>
    planRecommendations?: boolean | User$planRecommendationsArgs<ExtArgs>
    usageCounters?: boolean | User$usageCountersArgs<ExtArgs>
    ewayCustomers?: boolean | User$ewayCustomersArgs<ExtArgs>
    ewayTransactions?: boolean | User$ewayTransactionsArgs<ExtArgs>
    ewayRecurringSchedules?: boolean | User$ewayRecurringSchedulesArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    assignedRoles?: boolean | User$assignedRolesArgs<ExtArgs>
    testimonials?: boolean | User$testimonialsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    isActive?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    businessName?: boolean
    mobileNumber?: boolean
    country?: boolean
    currency?: boolean
    businessAddress?: boolean
    businessPhone?: boolean
    taxNumber?: boolean
    companySize?: boolean
    industry?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    isActive?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    businessName?: boolean
    mobileNumber?: boolean
    country?: boolean
    currency?: boolean
    businessAddress?: boolean
    businessPhone?: boolean
    taxNumber?: boolean
    companySize?: boolean
    industry?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audioHistory?: boolean | User$audioHistoryArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    audioUploads?: boolean | User$audioUploadsArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    processingJobs?: boolean | User$processingJobsArgs<ExtArgs>
    usageMetrics?: boolean | User$usageMetricsArgs<ExtArgs>
    exports?: boolean | User$exportsArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    quota?: boolean | User$quotaArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    securityEvents?: boolean | User$securityEventsArgs<ExtArgs>
    processingTemplates?: boolean | User$processingTemplatesArgs<ExtArgs>
    customPlans?: boolean | User$customPlansArgs<ExtArgs>
    planRecommendations?: boolean | User$planRecommendationsArgs<ExtArgs>
    usageCounters?: boolean | User$usageCountersArgs<ExtArgs>
    ewayCustomers?: boolean | User$ewayCustomersArgs<ExtArgs>
    ewayTransactions?: boolean | User$ewayTransactionsArgs<ExtArgs>
    ewayRecurringSchedules?: boolean | User$ewayRecurringSchedulesArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    assignedRoles?: boolean | User$assignedRolesArgs<ExtArgs>
    testimonials?: boolean | User$testimonialsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      audioHistory: Prisma.$AudioHistoryPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      settings: Prisma.$UserSettingsPayload<ExtArgs> | null
      workspaces: Prisma.$WorkspaceUserPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      audioUploads: Prisma.$AudioUploadPayload<ExtArgs>[]
      projects: Prisma.$AudioProjectPayload<ExtArgs>[]
      processingJobs: Prisma.$ProcessingJobPayload<ExtArgs>[]
      usageMetrics: Prisma.$UsageMetricPayload<ExtArgs>[]
      exports: Prisma.$ExportHistoryPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyManagementPayload<ExtArgs>[]
      quota: Prisma.$UserQuotaPayload<ExtArgs> | null
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      securityEvents: Prisma.$SecurityEventPayload<ExtArgs>[]
      processingTemplates: Prisma.$ProcessingTemplatePayload<ExtArgs>[]
      customPlans: Prisma.$CustomPlanPayload<ExtArgs>[]
      planRecommendations: Prisma.$PlanRecommendationPayload<ExtArgs>[]
      usageCounters: Prisma.$UsageCounterPayload<ExtArgs>[]
      ewayCustomers: Prisma.$EwayCustomerPayload<ExtArgs>[]
      ewayTransactions: Prisma.$EwayTransactionPayload<ExtArgs>[]
      ewayRecurringSchedules: Prisma.$EwayRecurringSchedulePayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      assignedRoles: Prisma.$UserRolePayload<ExtArgs>[]
      testimonials: Prisma.$TestimonialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      passwordHash: string
      role: string
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
      isActive: boolean
      firstName: string | null
      lastName: string | null
      avatarUrl: string | null
      timezone: string | null
      businessName: string | null
      mobileNumber: string | null
      country: string | null
      currency: string | null
      businessAddress: string | null
      businessPhone: string | null
      taxNumber: string | null
      companySize: string | null
      industry: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audioHistory<T extends User$audioHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$audioHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    workspaces<T extends User$workspacesArgs<ExtArgs> = {}>(args?: Subset<T, User$workspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany"> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany"> | Null>
    audioUploads<T extends User$audioUploadsArgs<ExtArgs> = {}>(args?: Subset<T, User$audioUploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioProjectPayload<ExtArgs>, T, "findMany"> | Null>
    processingJobs<T extends User$processingJobsArgs<ExtArgs> = {}>(args?: Subset<T, User$processingJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findMany"> | Null>
    usageMetrics<T extends User$usageMetricsArgs<ExtArgs> = {}>(args?: Subset<T, User$usageMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "findMany"> | Null>
    exports<T extends User$exportsArgs<ExtArgs> = {}>(args?: Subset<T, User$exportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findMany"> | Null>
    quota<T extends User$quotaArgs<ExtArgs> = {}>(args?: Subset<T, User$quotaArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    securityEvents<T extends User$securityEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$securityEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findMany"> | Null>
    processingTemplates<T extends User$processingTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$processingTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessingTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    customPlans<T extends User$customPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$customPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPlanPayload<ExtArgs>, T, "findMany"> | Null>
    planRecommendations<T extends User$planRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, User$planRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "findMany"> | Null>
    usageCounters<T extends User$usageCountersArgs<ExtArgs> = {}>(args?: Subset<T, User$usageCountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageCounterPayload<ExtArgs>, T, "findMany"> | Null>
    ewayCustomers<T extends User$ewayCustomersArgs<ExtArgs> = {}>(args?: Subset<T, User$ewayCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findMany"> | Null>
    ewayTransactions<T extends User$ewayTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$ewayTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    ewayRecurringSchedules<T extends User$ewayRecurringSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$ewayRecurringSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    assignedRoles<T extends User$assignedRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    testimonials<T extends User$testimonialsArgs<ExtArgs> = {}>(args?: Subset<T, User$testimonialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly businessName: FieldRef<"User", 'String'>
    readonly mobileNumber: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly currency: FieldRef<"User", 'String'>
    readonly businessAddress: FieldRef<"User", 'String'>
    readonly businessPhone: FieldRef<"User", 'String'>
    readonly taxNumber: FieldRef<"User", 'String'>
    readonly companySize: FieldRef<"User", 'String'>
    readonly industry: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.audioHistory
   */
  export type User$audioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    where?: AudioHistoryWhereInput
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    cursor?: AudioHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioHistoryScalarFieldEnum | AudioHistoryScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.workspaces
   */
  export type User$workspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    cursor?: WorkspaceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.audioUploads
   */
  export type User$audioUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    where?: AudioUploadWhereInput
    orderBy?: AudioUploadOrderByWithRelationInput | AudioUploadOrderByWithRelationInput[]
    cursor?: AudioUploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioUploadScalarFieldEnum | AudioUploadScalarFieldEnum[]
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectInclude<ExtArgs> | null
    where?: AudioProjectWhereInput
    orderBy?: AudioProjectOrderByWithRelationInput | AudioProjectOrderByWithRelationInput[]
    cursor?: AudioProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioProjectScalarFieldEnum | AudioProjectScalarFieldEnum[]
  }

  /**
   * User.processingJobs
   */
  export type User$processingJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    where?: ProcessingJobWhereInput
    orderBy?: ProcessingJobOrderByWithRelationInput | ProcessingJobOrderByWithRelationInput[]
    cursor?: ProcessingJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessingJobScalarFieldEnum | ProcessingJobScalarFieldEnum[]
  }

  /**
   * User.usageMetrics
   */
  export type User$usageMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null
    where?: UsageMetricWhereInput
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[]
    cursor?: UsageMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[]
  }

  /**
   * User.exports
   */
  export type User$exportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportHistoryInclude<ExtArgs> | null
    where?: ExportHistoryWhereInput
    orderBy?: ExportHistoryOrderByWithRelationInput | ExportHistoryOrderByWithRelationInput[]
    cursor?: ExportHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExportHistoryScalarFieldEnum | ExportHistoryScalarFieldEnum[]
  }

  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    where?: ApiKeyManagementWhereInput
    orderBy?: ApiKeyManagementOrderByWithRelationInput | ApiKeyManagementOrderByWithRelationInput[]
    cursor?: ApiKeyManagementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyManagementScalarFieldEnum | ApiKeyManagementScalarFieldEnum[]
  }

  /**
   * User.quota
   */
  export type User$quotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    where?: UserQuotaWhereInput
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.securityEvents
   */
  export type User$securityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    where?: SecurityEventWhereInput
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    cursor?: SecurityEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * User.processingTemplates
   */
  export type User$processingTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingTemplate
     */
    select?: ProcessingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingTemplateInclude<ExtArgs> | null
    where?: ProcessingTemplateWhereInput
    orderBy?: ProcessingTemplateOrderByWithRelationInput | ProcessingTemplateOrderByWithRelationInput[]
    cursor?: ProcessingTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessingTemplateScalarFieldEnum | ProcessingTemplateScalarFieldEnum[]
  }

  /**
   * User.customPlans
   */
  export type User$customPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanInclude<ExtArgs> | null
    where?: CustomPlanWhereInput
    orderBy?: CustomPlanOrderByWithRelationInput | CustomPlanOrderByWithRelationInput[]
    cursor?: CustomPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomPlanScalarFieldEnum | CustomPlanScalarFieldEnum[]
  }

  /**
   * User.planRecommendations
   */
  export type User$planRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
    where?: PlanRecommendationWhereInput
    orderBy?: PlanRecommendationOrderByWithRelationInput | PlanRecommendationOrderByWithRelationInput[]
    cursor?: PlanRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanRecommendationScalarFieldEnum | PlanRecommendationScalarFieldEnum[]
  }

  /**
   * User.usageCounters
   */
  export type User$usageCountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageCounter
     */
    select?: UsageCounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageCounterInclude<ExtArgs> | null
    where?: UsageCounterWhereInput
    orderBy?: UsageCounterOrderByWithRelationInput | UsageCounterOrderByWithRelationInput[]
    cursor?: UsageCounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageCounterScalarFieldEnum | UsageCounterScalarFieldEnum[]
  }

  /**
   * User.ewayCustomers
   */
  export type User$ewayCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    where?: EwayCustomerWhereInput
    orderBy?: EwayCustomerOrderByWithRelationInput | EwayCustomerOrderByWithRelationInput[]
    cursor?: EwayCustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EwayCustomerScalarFieldEnum | EwayCustomerScalarFieldEnum[]
  }

  /**
   * User.ewayTransactions
   */
  export type User$ewayTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    where?: EwayTransactionWhereInput
    orderBy?: EwayTransactionOrderByWithRelationInput | EwayTransactionOrderByWithRelationInput[]
    cursor?: EwayTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EwayTransactionScalarFieldEnum | EwayTransactionScalarFieldEnum[]
  }

  /**
   * User.ewayRecurringSchedules
   */
  export type User$ewayRecurringSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    where?: EwayRecurringScheduleWhereInput
    orderBy?: EwayRecurringScheduleOrderByWithRelationInput | EwayRecurringScheduleOrderByWithRelationInput[]
    cursor?: EwayRecurringScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EwayRecurringScheduleScalarFieldEnum | EwayRecurringScheduleScalarFieldEnum[]
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.assignedRoles
   */
  export type User$assignedRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.testimonials
   */
  export type User$testimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    cursor?: TestimonialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceUser
   */

  export type AggregateWorkspaceUser = {
    _count: WorkspaceUserCountAggregateOutputType | null
    _min: WorkspaceUserMinAggregateOutputType | null
    _max: WorkspaceUserMaxAggregateOutputType | null
  }

  export type WorkspaceUserMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    lastActiveAt: Date | null
  }

  export type WorkspaceUserMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    lastActiveAt: Date | null
  }

  export type WorkspaceUserCountAggregateOutputType = {
    id: number
    workspaceId: number
    userId: number
    role: number
    joinedAt: number
    permissions: number
    lastActiveAt: number
    _all: number
  }


  export type WorkspaceUserMinAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    lastActiveAt?: true
  }

  export type WorkspaceUserMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    lastActiveAt?: true
  }

  export type WorkspaceUserCountAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    permissions?: true
    lastActiveAt?: true
    _all?: true
  }

  export type WorkspaceUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUser to aggregate.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceUsers
    **/
    _count?: true | WorkspaceUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceUserMaxAggregateInputType
  }

  export type GetWorkspaceUserAggregateType<T extends WorkspaceUserAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceUser[P]>
      : GetScalarType<T[P], AggregateWorkspaceUser[P]>
  }




  export type WorkspaceUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithAggregationInput | WorkspaceUserOrderByWithAggregationInput[]
    by: WorkspaceUserScalarFieldEnum[] | WorkspaceUserScalarFieldEnum
    having?: WorkspaceUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceUserCountAggregateInputType | true
    _min?: WorkspaceUserMinAggregateInputType
    _max?: WorkspaceUserMaxAggregateInputType
  }

  export type WorkspaceUserGroupByOutputType = {
    id: string
    workspaceId: string
    userId: string
    role: string
    joinedAt: Date
    permissions: JsonValue | null
    lastActiveAt: Date | null
    _count: WorkspaceUserCountAggregateOutputType | null
    _min: WorkspaceUserMinAggregateOutputType | null
    _max: WorkspaceUserMaxAggregateOutputType | null
  }

  type GetWorkspaceUserGroupByPayload<T extends WorkspaceUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceUserGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceUserGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    permissions?: boolean
    lastActiveAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    permissions?: boolean
    lastActiveAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    permissions?: boolean
    lastActiveAt?: boolean
  }

  export type WorkspaceUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkspaceUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkspaceUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceUser"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      userId: string
      role: string
      joinedAt: Date
      permissions: Prisma.JsonValue | null
      lastActiveAt: Date | null
    }, ExtArgs["result"]["workspaceUser"]>
    composites: {}
  }

  type WorkspaceUserGetPayload<S extends boolean | null | undefined | WorkspaceUserDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceUserPayload, S>

  type WorkspaceUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceUserCountAggregateInputType | true
    }

  export interface WorkspaceUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceUser'], meta: { name: 'WorkspaceUser' } }
    /**
     * Find zero or one WorkspaceUser that matches the filter.
     * @param {WorkspaceUserFindUniqueArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceUserFindUniqueArgs>(args: SelectSubset<T, WorkspaceUserFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkspaceUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceUserFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceUserFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkspaceUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindFirstArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceUserFindFirstArgs>(args?: SelectSubset<T, WorkspaceUserFindFirstArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkspaceUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindFirstOrThrowArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceUserFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkspaceUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceUsers
     * const workspaceUsers = await prisma.workspaceUser.findMany()
     * 
     * // Get first 10 WorkspaceUsers
     * const workspaceUsers = await prisma.workspaceUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceUserFindManyArgs>(args?: SelectSubset<T, WorkspaceUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkspaceUser.
     * @param {WorkspaceUserCreateArgs} args - Arguments to create a WorkspaceUser.
     * @example
     * // Create one WorkspaceUser
     * const WorkspaceUser = await prisma.workspaceUser.create({
     *   data: {
     *     // ... data to create a WorkspaceUser
     *   }
     * })
     * 
     */
    create<T extends WorkspaceUserCreateArgs>(args: SelectSubset<T, WorkspaceUserCreateArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkspaceUsers.
     * @param {WorkspaceUserCreateManyArgs} args - Arguments to create many WorkspaceUsers.
     * @example
     * // Create many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceUserCreateManyArgs>(args?: SelectSubset<T, WorkspaceUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceUsers and returns the data saved in the database.
     * @param {WorkspaceUserCreateManyAndReturnArgs} args - Arguments to create many WorkspaceUsers.
     * @example
     * // Create many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceUsers and only return the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceUserCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkspaceUser.
     * @param {WorkspaceUserDeleteArgs} args - Arguments to delete one WorkspaceUser.
     * @example
     * // Delete one WorkspaceUser
     * const WorkspaceUser = await prisma.workspaceUser.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceUser
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceUserDeleteArgs>(args: SelectSubset<T, WorkspaceUserDeleteArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkspaceUser.
     * @param {WorkspaceUserUpdateArgs} args - Arguments to update one WorkspaceUser.
     * @example
     * // Update one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUserUpdateArgs>(args: SelectSubset<T, WorkspaceUserUpdateArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkspaceUsers.
     * @param {WorkspaceUserDeleteManyArgs} args - Arguments to filter WorkspaceUsers to delete.
     * @example
     * // Delete a few WorkspaceUsers
     * const { count } = await prisma.workspaceUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceUserDeleteManyArgs>(args?: SelectSubset<T, WorkspaceUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUserUpdateManyArgs>(args: SelectSubset<T, WorkspaceUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkspaceUser.
     * @param {WorkspaceUserUpsertArgs} args - Arguments to update or create a WorkspaceUser.
     * @example
     * // Update or create a WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.upsert({
     *   create: {
     *     // ... data to create a WorkspaceUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceUser we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUserUpsertArgs>(args: SelectSubset<T, WorkspaceUserUpsertArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkspaceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserCountArgs} args - Arguments to filter WorkspaceUsers to count.
     * @example
     * // Count the number of WorkspaceUsers
     * const count = await prisma.workspaceUser.count({
     *   where: {
     *     // ... the filter for the WorkspaceUsers we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceUserCountArgs>(
      args?: Subset<T, WorkspaceUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceUserAggregateArgs>(args: Subset<T, WorkspaceUserAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceUserAggregateType<T>>

    /**
     * Group by WorkspaceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceUserGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceUser model
   */
  readonly fields: WorkspaceUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceUser model
   */ 
  interface WorkspaceUserFieldRefs {
    readonly id: FieldRef<"WorkspaceUser", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceUser", 'String'>
    readonly userId: FieldRef<"WorkspaceUser", 'String'>
    readonly role: FieldRef<"WorkspaceUser", 'String'>
    readonly joinedAt: FieldRef<"WorkspaceUser", 'DateTime'>
    readonly permissions: FieldRef<"WorkspaceUser", 'Json'>
    readonly lastActiveAt: FieldRef<"WorkspaceUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceUser findUnique
   */
  export type WorkspaceUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser findUniqueOrThrow
   */
  export type WorkspaceUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser findFirst
   */
  export type WorkspaceUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUsers.
     */
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser findFirstOrThrow
   */
  export type WorkspaceUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUsers.
     */
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser findMany
   */
  export type WorkspaceUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUsers to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser create
   */
  export type WorkspaceUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceUser.
     */
    data: XOR<WorkspaceUserCreateInput, WorkspaceUserUncheckedCreateInput>
  }

  /**
   * WorkspaceUser createMany
   */
  export type WorkspaceUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceUsers.
     */
    data: WorkspaceUserCreateManyInput | WorkspaceUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceUser createManyAndReturn
   */
  export type WorkspaceUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkspaceUsers.
     */
    data: WorkspaceUserCreateManyInput | WorkspaceUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceUser update
   */
  export type WorkspaceUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceUser.
     */
    data: XOR<WorkspaceUserUpdateInput, WorkspaceUserUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceUser to update.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser updateMany
   */
  export type WorkspaceUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceUsers.
     */
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceUsers to update
     */
    where?: WorkspaceUserWhereInput
  }

  /**
   * WorkspaceUser upsert
   */
  export type WorkspaceUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceUser to update in case it exists.
     */
    where: WorkspaceUserWhereUniqueInput
    /**
     * In case the WorkspaceUser found by the `where` argument doesn't exist, create a new WorkspaceUser with this data.
     */
    create: XOR<WorkspaceUserCreateInput, WorkspaceUserUncheckedCreateInput>
    /**
     * In case the WorkspaceUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUserUpdateInput, WorkspaceUserUncheckedUpdateInput>
  }

  /**
   * WorkspaceUser delete
   */
  export type WorkspaceUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceUser to delete.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser deleteMany
   */
  export type WorkspaceUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUsers to delete
     */
    where?: WorkspaceUserWhereInput
  }

  /**
   * WorkspaceUser without action
   */
  export type WorkspaceUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceInvitation
   */

  export type AggregateWorkspaceInvitation = {
    _count: WorkspaceInvitationCountAggregateOutputType | null
    _min: WorkspaceInvitationMinAggregateOutputType | null
    _max: WorkspaceInvitationMaxAggregateOutputType | null
  }

  export type WorkspaceInvitationMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    email: string | null
    role: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    acceptedAt: Date | null
    invitedById: string | null
  }

  export type WorkspaceInvitationMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    email: string | null
    role: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    acceptedAt: Date | null
    invitedById: string | null
  }

  export type WorkspaceInvitationCountAggregateOutputType = {
    id: number
    workspaceId: number
    email: number
    role: number
    token: number
    expiresAt: number
    createdAt: number
    acceptedAt: number
    invitedById: number
    _all: number
  }


  export type WorkspaceInvitationMinAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    acceptedAt?: true
    invitedById?: true
  }

  export type WorkspaceInvitationMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    acceptedAt?: true
    invitedById?: true
  }

  export type WorkspaceInvitationCountAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    acceptedAt?: true
    invitedById?: true
    _all?: true
  }

  export type WorkspaceInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceInvitation to aggregate.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceInvitations
    **/
    _count?: true | WorkspaceInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceInvitationMaxAggregateInputType
  }

  export type GetWorkspaceInvitationAggregateType<T extends WorkspaceInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceInvitation[P]>
      : GetScalarType<T[P], AggregateWorkspaceInvitation[P]>
  }




  export type WorkspaceInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithAggregationInput | WorkspaceInvitationOrderByWithAggregationInput[]
    by: WorkspaceInvitationScalarFieldEnum[] | WorkspaceInvitationScalarFieldEnum
    having?: WorkspaceInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceInvitationCountAggregateInputType | true
    _min?: WorkspaceInvitationMinAggregateInputType
    _max?: WorkspaceInvitationMaxAggregateInputType
  }

  export type WorkspaceInvitationGroupByOutputType = {
    id: string
    workspaceId: string
    email: string
    role: string
    token: string
    expiresAt: Date
    createdAt: Date
    acceptedAt: Date | null
    invitedById: string | null
    _count: WorkspaceInvitationCountAggregateOutputType | null
    _min: WorkspaceInvitationMinAggregateOutputType | null
    _max: WorkspaceInvitationMaxAggregateOutputType | null
  }

  type GetWorkspaceInvitationGroupByPayload<T extends WorkspaceInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceInvitationGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    acceptedAt?: boolean
    invitedById?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    acceptedAt?: boolean
    invitedById?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    acceptedAt?: boolean
    invitedById?: boolean
  }

  export type WorkspaceInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WorkspaceInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceInvitation"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      email: string
      role: string
      token: string
      expiresAt: Date
      createdAt: Date
      acceptedAt: Date | null
      invitedById: string | null
    }, ExtArgs["result"]["workspaceInvitation"]>
    composites: {}
  }

  type WorkspaceInvitationGetPayload<S extends boolean | null | undefined | WorkspaceInvitationDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceInvitationPayload, S>

  type WorkspaceInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceInvitationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceInvitationCountAggregateInputType | true
    }

  export interface WorkspaceInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceInvitation'], meta: { name: 'WorkspaceInvitation' } }
    /**
     * Find zero or one WorkspaceInvitation that matches the filter.
     * @param {WorkspaceInvitationFindUniqueArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceInvitationFindUniqueArgs>(args: SelectSubset<T, WorkspaceInvitationFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkspaceInvitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceInvitationFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkspaceInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindFirstArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceInvitationFindFirstArgs>(args?: SelectSubset<T, WorkspaceInvitationFindFirstArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkspaceInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindFirstOrThrowArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkspaceInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceInvitations
     * const workspaceInvitations = await prisma.workspaceInvitation.findMany()
     * 
     * // Get first 10 WorkspaceInvitations
     * const workspaceInvitations = await prisma.workspaceInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceInvitationFindManyArgs>(args?: SelectSubset<T, WorkspaceInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkspaceInvitation.
     * @param {WorkspaceInvitationCreateArgs} args - Arguments to create a WorkspaceInvitation.
     * @example
     * // Create one WorkspaceInvitation
     * const WorkspaceInvitation = await prisma.workspaceInvitation.create({
     *   data: {
     *     // ... data to create a WorkspaceInvitation
     *   }
     * })
     * 
     */
    create<T extends WorkspaceInvitationCreateArgs>(args: SelectSubset<T, WorkspaceInvitationCreateArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkspaceInvitations.
     * @param {WorkspaceInvitationCreateManyArgs} args - Arguments to create many WorkspaceInvitations.
     * @example
     * // Create many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceInvitationCreateManyArgs>(args?: SelectSubset<T, WorkspaceInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceInvitations and returns the data saved in the database.
     * @param {WorkspaceInvitationCreateManyAndReturnArgs} args - Arguments to create many WorkspaceInvitations.
     * @example
     * // Create many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceInvitations and only return the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkspaceInvitation.
     * @param {WorkspaceInvitationDeleteArgs} args - Arguments to delete one WorkspaceInvitation.
     * @example
     * // Delete one WorkspaceInvitation
     * const WorkspaceInvitation = await prisma.workspaceInvitation.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceInvitation
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceInvitationDeleteArgs>(args: SelectSubset<T, WorkspaceInvitationDeleteArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkspaceInvitation.
     * @param {WorkspaceInvitationUpdateArgs} args - Arguments to update one WorkspaceInvitation.
     * @example
     * // Update one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceInvitationUpdateArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkspaceInvitations.
     * @param {WorkspaceInvitationDeleteManyArgs} args - Arguments to filter WorkspaceInvitations to delete.
     * @example
     * // Delete a few WorkspaceInvitations
     * const { count } = await prisma.workspaceInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceInvitationDeleteManyArgs>(args?: SelectSubset<T, WorkspaceInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceInvitationUpdateManyArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkspaceInvitation.
     * @param {WorkspaceInvitationUpsertArgs} args - Arguments to update or create a WorkspaceInvitation.
     * @example
     * // Update or create a WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.upsert({
     *   create: {
     *     // ... data to create a WorkspaceInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceInvitation we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceInvitationUpsertArgs>(args: SelectSubset<T, WorkspaceInvitationUpsertArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkspaceInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationCountArgs} args - Arguments to filter WorkspaceInvitations to count.
     * @example
     * // Count the number of WorkspaceInvitations
     * const count = await prisma.workspaceInvitation.count({
     *   where: {
     *     // ... the filter for the WorkspaceInvitations we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceInvitationCountArgs>(
      args?: Subset<T, WorkspaceInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceInvitationAggregateArgs>(args: Subset<T, WorkspaceInvitationAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceInvitationAggregateType<T>>

    /**
     * Group by WorkspaceInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceInvitationGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceInvitation model
   */
  readonly fields: WorkspaceInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceInvitation model
   */ 
  interface WorkspaceInvitationFieldRefs {
    readonly id: FieldRef<"WorkspaceInvitation", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceInvitation", 'String'>
    readonly email: FieldRef<"WorkspaceInvitation", 'String'>
    readonly role: FieldRef<"WorkspaceInvitation", 'String'>
    readonly token: FieldRef<"WorkspaceInvitation", 'String'>
    readonly expiresAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
    readonly createdAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
    readonly invitedById: FieldRef<"WorkspaceInvitation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceInvitation findUnique
   */
  export type WorkspaceInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation findUniqueOrThrow
   */
  export type WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation findFirst
   */
  export type WorkspaceInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceInvitations.
     */
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation findFirstOrThrow
   */
  export type WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceInvitations.
     */
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation findMany
   */
  export type WorkspaceInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitations to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation create
   */
  export type WorkspaceInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceInvitation.
     */
    data: XOR<WorkspaceInvitationCreateInput, WorkspaceInvitationUncheckedCreateInput>
  }

  /**
   * WorkspaceInvitation createMany
   */
  export type WorkspaceInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceInvitations.
     */
    data: WorkspaceInvitationCreateManyInput | WorkspaceInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceInvitation createManyAndReturn
   */
  export type WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkspaceInvitations.
     */
    data: WorkspaceInvitationCreateManyInput | WorkspaceInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceInvitation update
   */
  export type WorkspaceInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceInvitation.
     */
    data: XOR<WorkspaceInvitationUpdateInput, WorkspaceInvitationUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceInvitation to update.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation updateMany
   */
  export type WorkspaceInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceInvitations.
     */
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceInvitations to update
     */
    where?: WorkspaceInvitationWhereInput
  }

  /**
   * WorkspaceInvitation upsert
   */
  export type WorkspaceInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceInvitation to update in case it exists.
     */
    where: WorkspaceInvitationWhereUniqueInput
    /**
     * In case the WorkspaceInvitation found by the `where` argument doesn't exist, create a new WorkspaceInvitation with this data.
     */
    create: XOR<WorkspaceInvitationCreateInput, WorkspaceInvitationUncheckedCreateInput>
    /**
     * In case the WorkspaceInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceInvitationUpdateInput, WorkspaceInvitationUncheckedUpdateInput>
  }

  /**
   * WorkspaceInvitation delete
   */
  export type WorkspaceInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceInvitation to delete.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation deleteMany
   */
  export type WorkspaceInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceInvitations to delete
     */
    where?: WorkspaceInvitationWhereInput
  }

  /**
   * WorkspaceInvitation without action
   */
  export type WorkspaceInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    revokedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date
    revokedAt: Date | null
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date
      revokedAt: Date | null
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    createdAt: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    createdAt: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    tokenHash: number
    expiresAt: number
    createdAt: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    createdAt?: true
    ipAddress?: true
    userAgent?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    createdAt?: true
    ipAddress?: true
    userAgent?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    createdAt?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    tokenHash: string
    expiresAt: Date
    createdAt: Date
    ipAddress: string | null
    userAgent: string | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokenHash: string
      expiresAt: Date
      createdAt: Date
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly tokenHash: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model SecurityEvent
   */

  export type AggregateSecurityEvent = {
    _count: SecurityEventCountAggregateOutputType | null
    _min: SecurityEventMinAggregateOutputType | null
    _max: SecurityEventMaxAggregateOutputType | null
  }

  export type SecurityEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    severity: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    resolvedAt: Date | null
  }

  export type SecurityEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    severity: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    resolvedAt: Date | null
  }

  export type SecurityEventCountAggregateOutputType = {
    id: number
    userId: number
    eventType: number
    severity: number
    description: number
    metadata: number
    ipAddress: number
    userAgent: number
    createdAt: number
    resolvedAt: number
    _all: number
  }


  export type SecurityEventMinAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    severity?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    resolvedAt?: true
  }

  export type SecurityEventMaxAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    severity?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    resolvedAt?: true
  }

  export type SecurityEventCountAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    severity?: true
    description?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type SecurityEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityEvent to aggregate.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityEvents
    **/
    _count?: true | SecurityEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityEventMaxAggregateInputType
  }

  export type GetSecurityEventAggregateType<T extends SecurityEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityEvent[P]>
      : GetScalarType<T[P], AggregateSecurityEvent[P]>
  }




  export type SecurityEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityEventWhereInput
    orderBy?: SecurityEventOrderByWithAggregationInput | SecurityEventOrderByWithAggregationInput[]
    by: SecurityEventScalarFieldEnum[] | SecurityEventScalarFieldEnum
    having?: SecurityEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityEventCountAggregateInputType | true
    _min?: SecurityEventMinAggregateInputType
    _max?: SecurityEventMaxAggregateInputType
  }

  export type SecurityEventGroupByOutputType = {
    id: string
    userId: string | null
    eventType: string
    severity: string
    description: string | null
    metadata: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    resolvedAt: Date | null
    _count: SecurityEventCountAggregateOutputType | null
    _min: SecurityEventMinAggregateOutputType | null
    _max: SecurityEventMaxAggregateOutputType | null
  }

  type GetSecurityEventGroupByPayload<T extends SecurityEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityEventGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityEventGroupByOutputType[P]>
        }
      >
    >


  export type SecurityEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    description?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    resolvedAt?: boolean
    user?: boolean | SecurityEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["securityEvent"]>

  export type SecurityEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    description?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    resolvedAt?: boolean
    user?: boolean | SecurityEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["securityEvent"]>

  export type SecurityEventSelectScalar = {
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    description?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    resolvedAt?: boolean
  }

  export type SecurityEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SecurityEvent$userArgs<ExtArgs>
  }
  export type SecurityEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SecurityEvent$userArgs<ExtArgs>
  }

  export type $SecurityEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      eventType: string
      severity: string
      description: string | null
      metadata: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["securityEvent"]>
    composites: {}
  }

  type SecurityEventGetPayload<S extends boolean | null | undefined | SecurityEventDefaultArgs> = $Result.GetResult<Prisma.$SecurityEventPayload, S>

  type SecurityEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SecurityEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SecurityEventCountAggregateInputType | true
    }

  export interface SecurityEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityEvent'], meta: { name: 'SecurityEvent' } }
    /**
     * Find zero or one SecurityEvent that matches the filter.
     * @param {SecurityEventFindUniqueArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityEventFindUniqueArgs>(args: SelectSubset<T, SecurityEventFindUniqueArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SecurityEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SecurityEventFindUniqueOrThrowArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SecurityEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindFirstArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityEventFindFirstArgs>(args?: SelectSubset<T, SecurityEventFindFirstArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SecurityEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindFirstOrThrowArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SecurityEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityEvents
     * const securityEvents = await prisma.securityEvent.findMany()
     * 
     * // Get first 10 SecurityEvents
     * const securityEvents = await prisma.securityEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityEventFindManyArgs>(args?: SelectSubset<T, SecurityEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SecurityEvent.
     * @param {SecurityEventCreateArgs} args - Arguments to create a SecurityEvent.
     * @example
     * // Create one SecurityEvent
     * const SecurityEvent = await prisma.securityEvent.create({
     *   data: {
     *     // ... data to create a SecurityEvent
     *   }
     * })
     * 
     */
    create<T extends SecurityEventCreateArgs>(args: SelectSubset<T, SecurityEventCreateArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SecurityEvents.
     * @param {SecurityEventCreateManyArgs} args - Arguments to create many SecurityEvents.
     * @example
     * // Create many SecurityEvents
     * const securityEvent = await prisma.securityEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityEventCreateManyArgs>(args?: SelectSubset<T, SecurityEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityEvents and returns the data saved in the database.
     * @param {SecurityEventCreateManyAndReturnArgs} args - Arguments to create many SecurityEvents.
     * @example
     * // Create many SecurityEvents
     * const securityEvent = await prisma.securityEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityEvents and only return the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityEventCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SecurityEvent.
     * @param {SecurityEventDeleteArgs} args - Arguments to delete one SecurityEvent.
     * @example
     * // Delete one SecurityEvent
     * const SecurityEvent = await prisma.securityEvent.delete({
     *   where: {
     *     // ... filter to delete one SecurityEvent
     *   }
     * })
     * 
     */
    delete<T extends SecurityEventDeleteArgs>(args: SelectSubset<T, SecurityEventDeleteArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SecurityEvent.
     * @param {SecurityEventUpdateArgs} args - Arguments to update one SecurityEvent.
     * @example
     * // Update one SecurityEvent
     * const securityEvent = await prisma.securityEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityEventUpdateArgs>(args: SelectSubset<T, SecurityEventUpdateArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SecurityEvents.
     * @param {SecurityEventDeleteManyArgs} args - Arguments to filter SecurityEvents to delete.
     * @example
     * // Delete a few SecurityEvents
     * const { count } = await prisma.securityEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityEventDeleteManyArgs>(args?: SelectSubset<T, SecurityEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityEvents
     * const securityEvent = await prisma.securityEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityEventUpdateManyArgs>(args: SelectSubset<T, SecurityEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SecurityEvent.
     * @param {SecurityEventUpsertArgs} args - Arguments to update or create a SecurityEvent.
     * @example
     * // Update or create a SecurityEvent
     * const securityEvent = await prisma.securityEvent.upsert({
     *   create: {
     *     // ... data to create a SecurityEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityEvent we want to update
     *   }
     * })
     */
    upsert<T extends SecurityEventUpsertArgs>(args: SelectSubset<T, SecurityEventUpsertArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventCountArgs} args - Arguments to filter SecurityEvents to count.
     * @example
     * // Count the number of SecurityEvents
     * const count = await prisma.securityEvent.count({
     *   where: {
     *     // ... the filter for the SecurityEvents we want to count
     *   }
     * })
    **/
    count<T extends SecurityEventCountArgs>(
      args?: Subset<T, SecurityEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityEventAggregateArgs>(args: Subset<T, SecurityEventAggregateArgs>): Prisma.PrismaPromise<GetSecurityEventAggregateType<T>>

    /**
     * Group by SecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityEventGroupByArgs['orderBy'] }
        : { orderBy?: SecurityEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityEvent model
   */
  readonly fields: SecurityEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SecurityEvent$userArgs<ExtArgs> = {}>(args?: Subset<T, SecurityEvent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityEvent model
   */ 
  interface SecurityEventFieldRefs {
    readonly id: FieldRef<"SecurityEvent", 'String'>
    readonly userId: FieldRef<"SecurityEvent", 'String'>
    readonly eventType: FieldRef<"SecurityEvent", 'String'>
    readonly severity: FieldRef<"SecurityEvent", 'String'>
    readonly description: FieldRef<"SecurityEvent", 'String'>
    readonly metadata: FieldRef<"SecurityEvent", 'Json'>
    readonly ipAddress: FieldRef<"SecurityEvent", 'String'>
    readonly userAgent: FieldRef<"SecurityEvent", 'String'>
    readonly createdAt: FieldRef<"SecurityEvent", 'DateTime'>
    readonly resolvedAt: FieldRef<"SecurityEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityEvent findUnique
   */
  export type SecurityEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent findUniqueOrThrow
   */
  export type SecurityEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent findFirst
   */
  export type SecurityEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityEvents.
     */
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent findFirstOrThrow
   */
  export type SecurityEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityEvents.
     */
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent findMany
   */
  export type SecurityEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvents to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent create
   */
  export type SecurityEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * The data needed to create a SecurityEvent.
     */
    data: XOR<SecurityEventCreateInput, SecurityEventUncheckedCreateInput>
  }

  /**
   * SecurityEvent createMany
   */
  export type SecurityEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityEvents.
     */
    data: SecurityEventCreateManyInput | SecurityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityEvent createManyAndReturn
   */
  export type SecurityEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SecurityEvents.
     */
    data: SecurityEventCreateManyInput | SecurityEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityEvent update
   */
  export type SecurityEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * The data needed to update a SecurityEvent.
     */
    data: XOR<SecurityEventUpdateInput, SecurityEventUncheckedUpdateInput>
    /**
     * Choose, which SecurityEvent to update.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent updateMany
   */
  export type SecurityEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityEvents.
     */
    data: XOR<SecurityEventUpdateManyMutationInput, SecurityEventUncheckedUpdateManyInput>
    /**
     * Filter which SecurityEvents to update
     */
    where?: SecurityEventWhereInput
  }

  /**
   * SecurityEvent upsert
   */
  export type SecurityEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * The filter to search for the SecurityEvent to update in case it exists.
     */
    where: SecurityEventWhereUniqueInput
    /**
     * In case the SecurityEvent found by the `where` argument doesn't exist, create a new SecurityEvent with this data.
     */
    create: XOR<SecurityEventCreateInput, SecurityEventUncheckedCreateInput>
    /**
     * In case the SecurityEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityEventUpdateInput, SecurityEventUncheckedUpdateInput>
  }

  /**
   * SecurityEvent delete
   */
  export type SecurityEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter which SecurityEvent to delete.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent deleteMany
   */
  export type SecurityEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityEvents to delete
     */
    where?: SecurityEventWhereInput
  }

  /**
   * SecurityEvent.user
   */
  export type SecurityEvent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SecurityEvent without action
   */
  export type SecurityEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _avg: UserSettingsAvgAggregateOutputType | null
    _sum: UserSettingsSumAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsAvgAggregateOutputType = {
    defaultTemperature: number | null
    defaultMaxTokens: number | null
  }

  export type UserSettingsSumAggregateOutputType = {
    defaultTemperature: number | null
    defaultMaxTokens: number | null
  }

  export type UserSettingsMinAggregateOutputType = {
    userId: string | null
    openaiApiKeyEncrypted: string | null
    elevenlabsApiKeyEncrypted: string | null
    preferredLanguage: string | null
    summaryQuality: string | null
    defaultSummaryStyle: string | null
    defaultTemperature: number | null
    defaultMaxTokens: number | null
    showCostEstimates: boolean | null
    emailNotifications: boolean | null
    processingNotifications: boolean | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    userId: string | null
    openaiApiKeyEncrypted: string | null
    elevenlabsApiKeyEncrypted: string | null
    preferredLanguage: string | null
    summaryQuality: string | null
    defaultSummaryStyle: string | null
    defaultTemperature: number | null
    defaultMaxTokens: number | null
    showCostEstimates: boolean | null
    emailNotifications: boolean | null
    processingNotifications: boolean | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    userId: number
    openaiApiKeyEncrypted: number
    elevenlabsApiKeyEncrypted: number
    preferredLanguage: number
    summaryQuality: number
    defaultSummaryStyle: number
    defaultTemperature: number
    defaultMaxTokens: number
    showCostEstimates: number
    emailNotifications: number
    processingNotifications: number
    settingsJson: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsAvgAggregateInputType = {
    defaultTemperature?: true
    defaultMaxTokens?: true
  }

  export type UserSettingsSumAggregateInputType = {
    defaultTemperature?: true
    defaultMaxTokens?: true
  }

  export type UserSettingsMinAggregateInputType = {
    userId?: true
    openaiApiKeyEncrypted?: true
    elevenlabsApiKeyEncrypted?: true
    preferredLanguage?: true
    summaryQuality?: true
    defaultSummaryStyle?: true
    defaultTemperature?: true
    defaultMaxTokens?: true
    showCostEstimates?: true
    emailNotifications?: true
    processingNotifications?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    userId?: true
    openaiApiKeyEncrypted?: true
    elevenlabsApiKeyEncrypted?: true
    preferredLanguage?: true
    summaryQuality?: true
    defaultSummaryStyle?: true
    defaultTemperature?: true
    defaultMaxTokens?: true
    showCostEstimates?: true
    emailNotifications?: true
    processingNotifications?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    userId?: true
    openaiApiKeyEncrypted?: true
    elevenlabsApiKeyEncrypted?: true
    preferredLanguage?: true
    summaryQuality?: true
    defaultSummaryStyle?: true
    defaultTemperature?: true
    defaultMaxTokens?: true
    showCostEstimates?: true
    emailNotifications?: true
    processingNotifications?: true
    settingsJson?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _avg?: UserSettingsAvgAggregateInputType
    _sum?: UserSettingsSumAggregateInputType
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    userId: string
    openaiApiKeyEncrypted: string | null
    elevenlabsApiKeyEncrypted: string | null
    preferredLanguage: string
    summaryQuality: string
    defaultSummaryStyle: string
    defaultTemperature: number
    defaultMaxTokens: number
    showCostEstimates: boolean
    emailNotifications: boolean
    processingNotifications: boolean
    settingsJson: JsonValue
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _avg: UserSettingsAvgAggregateOutputType | null
    _sum: UserSettingsSumAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    openaiApiKeyEncrypted?: boolean
    elevenlabsApiKeyEncrypted?: boolean
    preferredLanguage?: boolean
    summaryQuality?: boolean
    defaultSummaryStyle?: boolean
    defaultTemperature?: boolean
    defaultMaxTokens?: boolean
    showCostEstimates?: boolean
    emailNotifications?: boolean
    processingNotifications?: boolean
    settingsJson?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    openaiApiKeyEncrypted?: boolean
    elevenlabsApiKeyEncrypted?: boolean
    preferredLanguage?: boolean
    summaryQuality?: boolean
    defaultSummaryStyle?: boolean
    defaultTemperature?: boolean
    defaultMaxTokens?: boolean
    showCostEstimates?: boolean
    emailNotifications?: boolean
    processingNotifications?: boolean
    settingsJson?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    userId?: boolean
    openaiApiKeyEncrypted?: boolean
    elevenlabsApiKeyEncrypted?: boolean
    preferredLanguage?: boolean
    summaryQuality?: boolean
    defaultSummaryStyle?: boolean
    defaultTemperature?: boolean
    defaultMaxTokens?: boolean
    showCostEstimates?: boolean
    emailNotifications?: boolean
    processingNotifications?: boolean
    settingsJson?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      openaiApiKeyEncrypted: string | null
      elevenlabsApiKeyEncrypted: string | null
      preferredLanguage: string
      summaryQuality: string
      defaultSummaryStyle: string
      defaultTemperature: number
      defaultMaxTokens: number
      showCostEstimates: boolean
      emailNotifications: boolean
      processingNotifications: boolean
      settingsJson: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSettingsWithUserIdOnly = await prisma.userSettings.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `userId`
     * const userSettingsWithUserIdOnly = await prisma.userSettings.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */ 
  interface UserSettingsFieldRefs {
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly openaiApiKeyEncrypted: FieldRef<"UserSettings", 'String'>
    readonly elevenlabsApiKeyEncrypted: FieldRef<"UserSettings", 'String'>
    readonly preferredLanguage: FieldRef<"UserSettings", 'String'>
    readonly summaryQuality: FieldRef<"UserSettings", 'String'>
    readonly defaultSummaryStyle: FieldRef<"UserSettings", 'String'>
    readonly defaultTemperature: FieldRef<"UserSettings", 'Float'>
    readonly defaultMaxTokens: FieldRef<"UserSettings", 'Int'>
    readonly showCostEstimates: FieldRef<"UserSettings", 'Boolean'>
    readonly emailNotifications: FieldRef<"UserSettings", 'Boolean'>
    readonly processingNotifications: FieldRef<"UserSettings", 'Boolean'>
    readonly settingsJson: FieldRef<"UserSettings", 'Json'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceSettings
   */

  export type AggregateWorkspaceSettings = {
    _count: WorkspaceSettingsCountAggregateOutputType | null
    _avg: WorkspaceSettingsAvgAggregateOutputType | null
    _sum: WorkspaceSettingsSumAggregateOutputType | null
    _min: WorkspaceSettingsMinAggregateOutputType | null
    _max: WorkspaceSettingsMaxAggregateOutputType | null
  }

  export type WorkspaceSettingsAvgAggregateOutputType = {
    maxFileSize: number | null
    maxProcessingTime: number | null
  }

  export type WorkspaceSettingsSumAggregateOutputType = {
    maxFileSize: bigint | null
    maxProcessingTime: number | null
  }

  export type WorkspaceSettingsMinAggregateOutputType = {
    workspaceId: string | null
    maxFileSize: bigint | null
    maxProcessingTime: number | null
    allowPublicSharing: boolean | null
    allowGuestAccess: boolean | null
    requireApprovalForUploads: boolean | null
    webhookUrl: string | null
    webhookSecret: string | null
    updatedAt: Date | null
  }

  export type WorkspaceSettingsMaxAggregateOutputType = {
    workspaceId: string | null
    maxFileSize: bigint | null
    maxProcessingTime: number | null
    allowPublicSharing: boolean | null
    allowGuestAccess: boolean | null
    requireApprovalForUploads: boolean | null
    webhookUrl: string | null
    webhookSecret: string | null
    updatedAt: Date | null
  }

  export type WorkspaceSettingsCountAggregateOutputType = {
    workspaceId: number
    defaultProcessingOptions: number
    allowedFileTypes: number
    maxFileSize: number
    maxProcessingTime: number
    allowPublicSharing: number
    allowGuestAccess: number
    requireApprovalForUploads: number
    webhookUrl: number
    webhookSecret: number
    settingsJson: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceSettingsAvgAggregateInputType = {
    maxFileSize?: true
    maxProcessingTime?: true
  }

  export type WorkspaceSettingsSumAggregateInputType = {
    maxFileSize?: true
    maxProcessingTime?: true
  }

  export type WorkspaceSettingsMinAggregateInputType = {
    workspaceId?: true
    maxFileSize?: true
    maxProcessingTime?: true
    allowPublicSharing?: true
    allowGuestAccess?: true
    requireApprovalForUploads?: true
    webhookUrl?: true
    webhookSecret?: true
    updatedAt?: true
  }

  export type WorkspaceSettingsMaxAggregateInputType = {
    workspaceId?: true
    maxFileSize?: true
    maxProcessingTime?: true
    allowPublicSharing?: true
    allowGuestAccess?: true
    requireApprovalForUploads?: true
    webhookUrl?: true
    webhookSecret?: true
    updatedAt?: true
  }

  export type WorkspaceSettingsCountAggregateInputType = {
    workspaceId?: true
    defaultProcessingOptions?: true
    allowedFileTypes?: true
    maxFileSize?: true
    maxProcessingTime?: true
    allowPublicSharing?: true
    allowGuestAccess?: true
    requireApprovalForUploads?: true
    webhookUrl?: true
    webhookSecret?: true
    settingsJson?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceSettings to aggregate.
     */
    where?: WorkspaceSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceSettings to fetch.
     */
    orderBy?: WorkspaceSettingsOrderByWithRelationInput | WorkspaceSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceSettings
    **/
    _count?: true | WorkspaceSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkspaceSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkspaceSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceSettingsMaxAggregateInputType
  }

  export type GetWorkspaceSettingsAggregateType<T extends WorkspaceSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceSettings[P]>
      : GetScalarType<T[P], AggregateWorkspaceSettings[P]>
  }




  export type WorkspaceSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceSettingsWhereInput
    orderBy?: WorkspaceSettingsOrderByWithAggregationInput | WorkspaceSettingsOrderByWithAggregationInput[]
    by: WorkspaceSettingsScalarFieldEnum[] | WorkspaceSettingsScalarFieldEnum
    having?: WorkspaceSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceSettingsCountAggregateInputType | true
    _avg?: WorkspaceSettingsAvgAggregateInputType
    _sum?: WorkspaceSettingsSumAggregateInputType
    _min?: WorkspaceSettingsMinAggregateInputType
    _max?: WorkspaceSettingsMaxAggregateInputType
  }

  export type WorkspaceSettingsGroupByOutputType = {
    workspaceId: string
    defaultProcessingOptions: JsonValue
    allowedFileTypes: string[]
    maxFileSize: bigint
    maxProcessingTime: number
    allowPublicSharing: boolean
    allowGuestAccess: boolean
    requireApprovalForUploads: boolean
    webhookUrl: string | null
    webhookSecret: string | null
    settingsJson: JsonValue
    updatedAt: Date
    _count: WorkspaceSettingsCountAggregateOutputType | null
    _avg: WorkspaceSettingsAvgAggregateOutputType | null
    _sum: WorkspaceSettingsSumAggregateOutputType | null
    _min: WorkspaceSettingsMinAggregateOutputType | null
    _max: WorkspaceSettingsMaxAggregateOutputType | null
  }

  type GetWorkspaceSettingsGroupByPayload<T extends WorkspaceSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceSettingsGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    defaultProcessingOptions?: boolean
    allowedFileTypes?: boolean
    maxFileSize?: boolean
    maxProcessingTime?: boolean
    allowPublicSharing?: boolean
    allowGuestAccess?: boolean
    requireApprovalForUploads?: boolean
    webhookUrl?: boolean
    webhookSecret?: boolean
    settingsJson?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceSettings"]>

  export type WorkspaceSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    defaultProcessingOptions?: boolean
    allowedFileTypes?: boolean
    maxFileSize?: boolean
    maxProcessingTime?: boolean
    allowPublicSharing?: boolean
    allowGuestAccess?: boolean
    requireApprovalForUploads?: boolean
    webhookUrl?: boolean
    webhookSecret?: boolean
    settingsJson?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceSettings"]>

  export type WorkspaceSettingsSelectScalar = {
    workspaceId?: boolean
    defaultProcessingOptions?: boolean
    allowedFileTypes?: boolean
    maxFileSize?: boolean
    maxProcessingTime?: boolean
    allowPublicSharing?: boolean
    allowGuestAccess?: boolean
    requireApprovalForUploads?: boolean
    webhookUrl?: boolean
    webhookSecret?: boolean
    settingsJson?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WorkspaceSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceSettings"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      defaultProcessingOptions: Prisma.JsonValue
      allowedFileTypes: string[]
      maxFileSize: bigint
      maxProcessingTime: number
      allowPublicSharing: boolean
      allowGuestAccess: boolean
      requireApprovalForUploads: boolean
      webhookUrl: string | null
      webhookSecret: string | null
      settingsJson: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["workspaceSettings"]>
    composites: {}
  }

  type WorkspaceSettingsGetPayload<S extends boolean | null | undefined | WorkspaceSettingsDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceSettingsPayload, S>

  type WorkspaceSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceSettingsCountAggregateInputType | true
    }

  export interface WorkspaceSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceSettings'], meta: { name: 'WorkspaceSettings' } }
    /**
     * Find zero or one WorkspaceSettings that matches the filter.
     * @param {WorkspaceSettingsFindUniqueArgs} args - Arguments to find a WorkspaceSettings
     * @example
     * // Get one WorkspaceSettings
     * const workspaceSettings = await prisma.workspaceSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceSettingsFindUniqueArgs>(args: SelectSubset<T, WorkspaceSettingsFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceSettingsClient<$Result.GetResult<Prisma.$WorkspaceSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkspaceSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceSettingsFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceSettings
     * @example
     * // Get one WorkspaceSettings
     * const workspaceSettings = await prisma.workspaceSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceSettingsClient<$Result.GetResult<Prisma.$WorkspaceSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkspaceSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSettingsFindFirstArgs} args - Arguments to find a WorkspaceSettings
     * @example
     * // Get one WorkspaceSettings
     * const workspaceSettings = await prisma.workspaceSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceSettingsFindFirstArgs>(args?: SelectSubset<T, WorkspaceSettingsFindFirstArgs<ExtArgs>>): Prisma__WorkspaceSettingsClient<$Result.GetResult<Prisma.$WorkspaceSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkspaceSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSettingsFindFirstOrThrowArgs} args - Arguments to find a WorkspaceSettings
     * @example
     * // Get one WorkspaceSettings
     * const workspaceSettings = await prisma.workspaceSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceSettingsClient<$Result.GetResult<Prisma.$WorkspaceSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkspaceSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceSettings
     * const workspaceSettings = await prisma.workspaceSettings.findMany()
     * 
     * // Get first 10 WorkspaceSettings
     * const workspaceSettings = await prisma.workspaceSettings.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const workspaceSettingsWithWorkspaceIdOnly = await prisma.workspaceSettings.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends WorkspaceSettingsFindManyArgs>(args?: SelectSubset<T, WorkspaceSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkspaceSettings.
     * @param {WorkspaceSettingsCreateArgs} args - Arguments to create a WorkspaceSettings.
     * @example
     * // Create one WorkspaceSettings
     * const WorkspaceSettings = await prisma.workspaceSettings.create({
     *   data: {
     *     // ... data to create a WorkspaceSettings
     *   }
     * })
     * 
     */
    create<T extends WorkspaceSettingsCreateArgs>(args: SelectSubset<T, WorkspaceSettingsCreateArgs<ExtArgs>>): Prisma__WorkspaceSettingsClient<$Result.GetResult<Prisma.$WorkspaceSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkspaceSettings.
     * @param {WorkspaceSettingsCreateManyArgs} args - Arguments to create many WorkspaceSettings.
     * @example
     * // Create many WorkspaceSettings
     * const workspaceSettings = await prisma.workspaceSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceSettingsCreateManyArgs>(args?: SelectSubset<T, WorkspaceSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceSettings and returns the data saved in the database.
     * @param {WorkspaceSettingsCreateManyAndReturnArgs} args - Arguments to create many WorkspaceSettings.
     * @example
     * // Create many WorkspaceSettings
     * const workspaceSettings = await prisma.workspaceSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceSettings and only return the `workspaceId`
     * const workspaceSettingsWithWorkspaceIdOnly = await prisma.workspaceSettings.createManyAndReturn({ 
     *   select: { workspaceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkspaceSettings.
     * @param {WorkspaceSettingsDeleteArgs} args - Arguments to delete one WorkspaceSettings.
     * @example
     * // Delete one WorkspaceSettings
     * const WorkspaceSettings = await prisma.workspaceSettings.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceSettings
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceSettingsDeleteArgs>(args: SelectSubset<T, WorkspaceSettingsDeleteArgs<ExtArgs>>): Prisma__WorkspaceSettingsClient<$Result.GetResult<Prisma.$WorkspaceSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkspaceSettings.
     * @param {WorkspaceSettingsUpdateArgs} args - Arguments to update one WorkspaceSettings.
     * @example
     * // Update one WorkspaceSettings
     * const workspaceSettings = await prisma.workspaceSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceSettingsUpdateArgs>(args: SelectSubset<T, WorkspaceSettingsUpdateArgs<ExtArgs>>): Prisma__WorkspaceSettingsClient<$Result.GetResult<Prisma.$WorkspaceSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkspaceSettings.
     * @param {WorkspaceSettingsDeleteManyArgs} args - Arguments to filter WorkspaceSettings to delete.
     * @example
     * // Delete a few WorkspaceSettings
     * const { count } = await prisma.workspaceSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceSettingsDeleteManyArgs>(args?: SelectSubset<T, WorkspaceSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceSettings
     * const workspaceSettings = await prisma.workspaceSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceSettingsUpdateManyArgs>(args: SelectSubset<T, WorkspaceSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkspaceSettings.
     * @param {WorkspaceSettingsUpsertArgs} args - Arguments to update or create a WorkspaceSettings.
     * @example
     * // Update or create a WorkspaceSettings
     * const workspaceSettings = await prisma.workspaceSettings.upsert({
     *   create: {
     *     // ... data to create a WorkspaceSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceSettings we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceSettingsUpsertArgs>(args: SelectSubset<T, WorkspaceSettingsUpsertArgs<ExtArgs>>): Prisma__WorkspaceSettingsClient<$Result.GetResult<Prisma.$WorkspaceSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkspaceSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSettingsCountArgs} args - Arguments to filter WorkspaceSettings to count.
     * @example
     * // Count the number of WorkspaceSettings
     * const count = await prisma.workspaceSettings.count({
     *   where: {
     *     // ... the filter for the WorkspaceSettings we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceSettingsCountArgs>(
      args?: Subset<T, WorkspaceSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceSettingsAggregateArgs>(args: Subset<T, WorkspaceSettingsAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceSettingsAggregateType<T>>

    /**
     * Group by WorkspaceSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceSettingsGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceSettings model
   */
  readonly fields: WorkspaceSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceSettings model
   */ 
  interface WorkspaceSettingsFieldRefs {
    readonly workspaceId: FieldRef<"WorkspaceSettings", 'String'>
    readonly defaultProcessingOptions: FieldRef<"WorkspaceSettings", 'Json'>
    readonly allowedFileTypes: FieldRef<"WorkspaceSettings", 'String[]'>
    readonly maxFileSize: FieldRef<"WorkspaceSettings", 'BigInt'>
    readonly maxProcessingTime: FieldRef<"WorkspaceSettings", 'Int'>
    readonly allowPublicSharing: FieldRef<"WorkspaceSettings", 'Boolean'>
    readonly allowGuestAccess: FieldRef<"WorkspaceSettings", 'Boolean'>
    readonly requireApprovalForUploads: FieldRef<"WorkspaceSettings", 'Boolean'>
    readonly webhookUrl: FieldRef<"WorkspaceSettings", 'String'>
    readonly webhookSecret: FieldRef<"WorkspaceSettings", 'String'>
    readonly settingsJson: FieldRef<"WorkspaceSettings", 'Json'>
    readonly updatedAt: FieldRef<"WorkspaceSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceSettings findUnique
   */
  export type WorkspaceSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSettings
     */
    select?: WorkspaceSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSettingsInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSettings to fetch.
     */
    where: WorkspaceSettingsWhereUniqueInput
  }

  /**
   * WorkspaceSettings findUniqueOrThrow
   */
  export type WorkspaceSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSettings
     */
    select?: WorkspaceSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSettingsInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSettings to fetch.
     */
    where: WorkspaceSettingsWhereUniqueInput
  }

  /**
   * WorkspaceSettings findFirst
   */
  export type WorkspaceSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSettings
     */
    select?: WorkspaceSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSettingsInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSettings to fetch.
     */
    where?: WorkspaceSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceSettings to fetch.
     */
    orderBy?: WorkspaceSettingsOrderByWithRelationInput | WorkspaceSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceSettings.
     */
    cursor?: WorkspaceSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceSettings.
     */
    distinct?: WorkspaceSettingsScalarFieldEnum | WorkspaceSettingsScalarFieldEnum[]
  }

  /**
   * WorkspaceSettings findFirstOrThrow
   */
  export type WorkspaceSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSettings
     */
    select?: WorkspaceSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSettingsInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSettings to fetch.
     */
    where?: WorkspaceSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceSettings to fetch.
     */
    orderBy?: WorkspaceSettingsOrderByWithRelationInput | WorkspaceSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceSettings.
     */
    cursor?: WorkspaceSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceSettings.
     */
    distinct?: WorkspaceSettingsScalarFieldEnum | WorkspaceSettingsScalarFieldEnum[]
  }

  /**
   * WorkspaceSettings findMany
   */
  export type WorkspaceSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSettings
     */
    select?: WorkspaceSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSettingsInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSettings to fetch.
     */
    where?: WorkspaceSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceSettings to fetch.
     */
    orderBy?: WorkspaceSettingsOrderByWithRelationInput | WorkspaceSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceSettings.
     */
    cursor?: WorkspaceSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceSettings.
     */
    skip?: number
    distinct?: WorkspaceSettingsScalarFieldEnum | WorkspaceSettingsScalarFieldEnum[]
  }

  /**
   * WorkspaceSettings create
   */
  export type WorkspaceSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSettings
     */
    select?: WorkspaceSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceSettings.
     */
    data: XOR<WorkspaceSettingsCreateInput, WorkspaceSettingsUncheckedCreateInput>
  }

  /**
   * WorkspaceSettings createMany
   */
  export type WorkspaceSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceSettings.
     */
    data: WorkspaceSettingsCreateManyInput | WorkspaceSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceSettings createManyAndReturn
   */
  export type WorkspaceSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSettings
     */
    select?: WorkspaceSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkspaceSettings.
     */
    data: WorkspaceSettingsCreateManyInput | WorkspaceSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceSettings update
   */
  export type WorkspaceSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSettings
     */
    select?: WorkspaceSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceSettings.
     */
    data: XOR<WorkspaceSettingsUpdateInput, WorkspaceSettingsUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceSettings to update.
     */
    where: WorkspaceSettingsWhereUniqueInput
  }

  /**
   * WorkspaceSettings updateMany
   */
  export type WorkspaceSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceSettings.
     */
    data: XOR<WorkspaceSettingsUpdateManyMutationInput, WorkspaceSettingsUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceSettings to update
     */
    where?: WorkspaceSettingsWhereInput
  }

  /**
   * WorkspaceSettings upsert
   */
  export type WorkspaceSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSettings
     */
    select?: WorkspaceSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceSettings to update in case it exists.
     */
    where: WorkspaceSettingsWhereUniqueInput
    /**
     * In case the WorkspaceSettings found by the `where` argument doesn't exist, create a new WorkspaceSettings with this data.
     */
    create: XOR<WorkspaceSettingsCreateInput, WorkspaceSettingsUncheckedCreateInput>
    /**
     * In case the WorkspaceSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceSettingsUpdateInput, WorkspaceSettingsUncheckedUpdateInput>
  }

  /**
   * WorkspaceSettings delete
   */
  export type WorkspaceSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSettings
     */
    select?: WorkspaceSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSettingsInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceSettings to delete.
     */
    where: WorkspaceSettingsWhereUniqueInput
  }

  /**
   * WorkspaceSettings deleteMany
   */
  export type WorkspaceSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceSettings to delete
     */
    where?: WorkspaceSettingsWhereInput
  }

  /**
   * WorkspaceSettings without action
   */
  export type WorkspaceSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSettings
     */
    select?: WorkspaceSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSettingsInclude<ExtArgs> | null
  }


  /**
   * Model ProcessingTemplate
   */

  export type AggregateProcessingTemplate = {
    _count: ProcessingTemplateCountAggregateOutputType | null
    _avg: ProcessingTemplateAvgAggregateOutputType | null
    _sum: ProcessingTemplateSumAggregateOutputType | null
    _min: ProcessingTemplateMinAggregateOutputType | null
    _max: ProcessingTemplateMaxAggregateOutputType | null
  }

  export type ProcessingTemplateAvgAggregateOutputType = {
    temperature: number | null
    maxTokens: number | null
  }

  export type ProcessingTemplateSumAggregateOutputType = {
    temperature: number | null
    maxTokens: number | null
  }

  export type ProcessingTemplateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    summaryStyle: string | null
    temperature: number | null
    maxTokens: number | null
    language: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessingTemplateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    summaryStyle: string | null
    temperature: number | null
    maxTokens: number | null
    language: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessingTemplateCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    name: number
    description: number
    summaryStyle: number
    temperature: number
    maxTokens: number
    language: number
    configJson: number
    isPublic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProcessingTemplateAvgAggregateInputType = {
    temperature?: true
    maxTokens?: true
  }

  export type ProcessingTemplateSumAggregateInputType = {
    temperature?: true
    maxTokens?: true
  }

  export type ProcessingTemplateMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    name?: true
    description?: true
    summaryStyle?: true
    temperature?: true
    maxTokens?: true
    language?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessingTemplateMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    name?: true
    description?: true
    summaryStyle?: true
    temperature?: true
    maxTokens?: true
    language?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessingTemplateCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    name?: true
    description?: true
    summaryStyle?: true
    temperature?: true
    maxTokens?: true
    language?: true
    configJson?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProcessingTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessingTemplate to aggregate.
     */
    where?: ProcessingTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingTemplates to fetch.
     */
    orderBy?: ProcessingTemplateOrderByWithRelationInput | ProcessingTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessingTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessingTemplates
    **/
    _count?: true | ProcessingTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessingTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessingTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessingTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessingTemplateMaxAggregateInputType
  }

  export type GetProcessingTemplateAggregateType<T extends ProcessingTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessingTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessingTemplate[P]>
      : GetScalarType<T[P], AggregateProcessingTemplate[P]>
  }




  export type ProcessingTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessingTemplateWhereInput
    orderBy?: ProcessingTemplateOrderByWithAggregationInput | ProcessingTemplateOrderByWithAggregationInput[]
    by: ProcessingTemplateScalarFieldEnum[] | ProcessingTemplateScalarFieldEnum
    having?: ProcessingTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessingTemplateCountAggregateInputType | true
    _avg?: ProcessingTemplateAvgAggregateInputType
    _sum?: ProcessingTemplateSumAggregateInputType
    _min?: ProcessingTemplateMinAggregateInputType
    _max?: ProcessingTemplateMaxAggregateInputType
  }

  export type ProcessingTemplateGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    name: string
    description: string | null
    summaryStyle: string
    temperature: number
    maxTokens: number
    language: string
    configJson: JsonValue
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProcessingTemplateCountAggregateOutputType | null
    _avg: ProcessingTemplateAvgAggregateOutputType | null
    _sum: ProcessingTemplateSumAggregateOutputType | null
    _min: ProcessingTemplateMinAggregateOutputType | null
    _max: ProcessingTemplateMaxAggregateOutputType | null
  }

  type GetProcessingTemplateGroupByPayload<T extends ProcessingTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessingTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessingTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessingTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessingTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ProcessingTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    summaryStyle?: boolean
    temperature?: boolean
    maxTokens?: boolean
    language?: boolean
    configJson?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processingTemplate"]>

  export type ProcessingTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    summaryStyle?: boolean
    temperature?: boolean
    maxTokens?: boolean
    language?: boolean
    configJson?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processingTemplate"]>

  export type ProcessingTemplateSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    summaryStyle?: boolean
    temperature?: boolean
    maxTokens?: boolean
    language?: boolean
    configJson?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProcessingTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProcessingTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProcessingTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessingTemplate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      name: string
      description: string | null
      summaryStyle: string
      temperature: number
      maxTokens: number
      language: string
      configJson: Prisma.JsonValue
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["processingTemplate"]>
    composites: {}
  }

  type ProcessingTemplateGetPayload<S extends boolean | null | undefined | ProcessingTemplateDefaultArgs> = $Result.GetResult<Prisma.$ProcessingTemplatePayload, S>

  type ProcessingTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessingTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessingTemplateCountAggregateInputType | true
    }

  export interface ProcessingTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessingTemplate'], meta: { name: 'ProcessingTemplate' } }
    /**
     * Find zero or one ProcessingTemplate that matches the filter.
     * @param {ProcessingTemplateFindUniqueArgs} args - Arguments to find a ProcessingTemplate
     * @example
     * // Get one ProcessingTemplate
     * const processingTemplate = await prisma.processingTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessingTemplateFindUniqueArgs>(args: SelectSubset<T, ProcessingTemplateFindUniqueArgs<ExtArgs>>): Prisma__ProcessingTemplateClient<$Result.GetResult<Prisma.$ProcessingTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProcessingTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessingTemplateFindUniqueOrThrowArgs} args - Arguments to find a ProcessingTemplate
     * @example
     * // Get one ProcessingTemplate
     * const processingTemplate = await prisma.processingTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessingTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessingTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessingTemplateClient<$Result.GetResult<Prisma.$ProcessingTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProcessingTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingTemplateFindFirstArgs} args - Arguments to find a ProcessingTemplate
     * @example
     * // Get one ProcessingTemplate
     * const processingTemplate = await prisma.processingTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessingTemplateFindFirstArgs>(args?: SelectSubset<T, ProcessingTemplateFindFirstArgs<ExtArgs>>): Prisma__ProcessingTemplateClient<$Result.GetResult<Prisma.$ProcessingTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProcessingTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingTemplateFindFirstOrThrowArgs} args - Arguments to find a ProcessingTemplate
     * @example
     * // Get one ProcessingTemplate
     * const processingTemplate = await prisma.processingTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessingTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessingTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessingTemplateClient<$Result.GetResult<Prisma.$ProcessingTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProcessingTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessingTemplates
     * const processingTemplates = await prisma.processingTemplate.findMany()
     * 
     * // Get first 10 ProcessingTemplates
     * const processingTemplates = await prisma.processingTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processingTemplateWithIdOnly = await prisma.processingTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessingTemplateFindManyArgs>(args?: SelectSubset<T, ProcessingTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessingTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProcessingTemplate.
     * @param {ProcessingTemplateCreateArgs} args - Arguments to create a ProcessingTemplate.
     * @example
     * // Create one ProcessingTemplate
     * const ProcessingTemplate = await prisma.processingTemplate.create({
     *   data: {
     *     // ... data to create a ProcessingTemplate
     *   }
     * })
     * 
     */
    create<T extends ProcessingTemplateCreateArgs>(args: SelectSubset<T, ProcessingTemplateCreateArgs<ExtArgs>>): Prisma__ProcessingTemplateClient<$Result.GetResult<Prisma.$ProcessingTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProcessingTemplates.
     * @param {ProcessingTemplateCreateManyArgs} args - Arguments to create many ProcessingTemplates.
     * @example
     * // Create many ProcessingTemplates
     * const processingTemplate = await prisma.processingTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessingTemplateCreateManyArgs>(args?: SelectSubset<T, ProcessingTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessingTemplates and returns the data saved in the database.
     * @param {ProcessingTemplateCreateManyAndReturnArgs} args - Arguments to create many ProcessingTemplates.
     * @example
     * // Create many ProcessingTemplates
     * const processingTemplate = await prisma.processingTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessingTemplates and only return the `id`
     * const processingTemplateWithIdOnly = await prisma.processingTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessingTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessingTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessingTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProcessingTemplate.
     * @param {ProcessingTemplateDeleteArgs} args - Arguments to delete one ProcessingTemplate.
     * @example
     * // Delete one ProcessingTemplate
     * const ProcessingTemplate = await prisma.processingTemplate.delete({
     *   where: {
     *     // ... filter to delete one ProcessingTemplate
     *   }
     * })
     * 
     */
    delete<T extends ProcessingTemplateDeleteArgs>(args: SelectSubset<T, ProcessingTemplateDeleteArgs<ExtArgs>>): Prisma__ProcessingTemplateClient<$Result.GetResult<Prisma.$ProcessingTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProcessingTemplate.
     * @param {ProcessingTemplateUpdateArgs} args - Arguments to update one ProcessingTemplate.
     * @example
     * // Update one ProcessingTemplate
     * const processingTemplate = await prisma.processingTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessingTemplateUpdateArgs>(args: SelectSubset<T, ProcessingTemplateUpdateArgs<ExtArgs>>): Prisma__ProcessingTemplateClient<$Result.GetResult<Prisma.$ProcessingTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProcessingTemplates.
     * @param {ProcessingTemplateDeleteManyArgs} args - Arguments to filter ProcessingTemplates to delete.
     * @example
     * // Delete a few ProcessingTemplates
     * const { count } = await prisma.processingTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessingTemplateDeleteManyArgs>(args?: SelectSubset<T, ProcessingTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessingTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessingTemplates
     * const processingTemplate = await prisma.processingTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessingTemplateUpdateManyArgs>(args: SelectSubset<T, ProcessingTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessingTemplate.
     * @param {ProcessingTemplateUpsertArgs} args - Arguments to update or create a ProcessingTemplate.
     * @example
     * // Update or create a ProcessingTemplate
     * const processingTemplate = await prisma.processingTemplate.upsert({
     *   create: {
     *     // ... data to create a ProcessingTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessingTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ProcessingTemplateUpsertArgs>(args: SelectSubset<T, ProcessingTemplateUpsertArgs<ExtArgs>>): Prisma__ProcessingTemplateClient<$Result.GetResult<Prisma.$ProcessingTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProcessingTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingTemplateCountArgs} args - Arguments to filter ProcessingTemplates to count.
     * @example
     * // Count the number of ProcessingTemplates
     * const count = await prisma.processingTemplate.count({
     *   where: {
     *     // ... the filter for the ProcessingTemplates we want to count
     *   }
     * })
    **/
    count<T extends ProcessingTemplateCountArgs>(
      args?: Subset<T, ProcessingTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessingTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessingTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessingTemplateAggregateArgs>(args: Subset<T, ProcessingTemplateAggregateArgs>): Prisma.PrismaPromise<GetProcessingTemplateAggregateType<T>>

    /**
     * Group by ProcessingTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessingTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessingTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ProcessingTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessingTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessingTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessingTemplate model
   */
  readonly fields: ProcessingTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessingTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessingTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessingTemplate model
   */ 
  interface ProcessingTemplateFieldRefs {
    readonly id: FieldRef<"ProcessingTemplate", 'String'>
    readonly userId: FieldRef<"ProcessingTemplate", 'String'>
    readonly workspaceId: FieldRef<"ProcessingTemplate", 'String'>
    readonly name: FieldRef<"ProcessingTemplate", 'String'>
    readonly description: FieldRef<"ProcessingTemplate", 'String'>
    readonly summaryStyle: FieldRef<"ProcessingTemplate", 'String'>
    readonly temperature: FieldRef<"ProcessingTemplate", 'Float'>
    readonly maxTokens: FieldRef<"ProcessingTemplate", 'Int'>
    readonly language: FieldRef<"ProcessingTemplate", 'String'>
    readonly configJson: FieldRef<"ProcessingTemplate", 'Json'>
    readonly isPublic: FieldRef<"ProcessingTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"ProcessingTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ProcessingTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProcessingTemplate findUnique
   */
  export type ProcessingTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingTemplate
     */
    select?: ProcessingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingTemplate to fetch.
     */
    where: ProcessingTemplateWhereUniqueInput
  }

  /**
   * ProcessingTemplate findUniqueOrThrow
   */
  export type ProcessingTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingTemplate
     */
    select?: ProcessingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingTemplate to fetch.
     */
    where: ProcessingTemplateWhereUniqueInput
  }

  /**
   * ProcessingTemplate findFirst
   */
  export type ProcessingTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingTemplate
     */
    select?: ProcessingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingTemplate to fetch.
     */
    where?: ProcessingTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingTemplates to fetch.
     */
    orderBy?: ProcessingTemplateOrderByWithRelationInput | ProcessingTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessingTemplates.
     */
    cursor?: ProcessingTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessingTemplates.
     */
    distinct?: ProcessingTemplateScalarFieldEnum | ProcessingTemplateScalarFieldEnum[]
  }

  /**
   * ProcessingTemplate findFirstOrThrow
   */
  export type ProcessingTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingTemplate
     */
    select?: ProcessingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingTemplate to fetch.
     */
    where?: ProcessingTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingTemplates to fetch.
     */
    orderBy?: ProcessingTemplateOrderByWithRelationInput | ProcessingTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessingTemplates.
     */
    cursor?: ProcessingTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessingTemplates.
     */
    distinct?: ProcessingTemplateScalarFieldEnum | ProcessingTemplateScalarFieldEnum[]
  }

  /**
   * ProcessingTemplate findMany
   */
  export type ProcessingTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingTemplate
     */
    select?: ProcessingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingTemplates to fetch.
     */
    where?: ProcessingTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingTemplates to fetch.
     */
    orderBy?: ProcessingTemplateOrderByWithRelationInput | ProcessingTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessingTemplates.
     */
    cursor?: ProcessingTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingTemplates.
     */
    skip?: number
    distinct?: ProcessingTemplateScalarFieldEnum | ProcessingTemplateScalarFieldEnum[]
  }

  /**
   * ProcessingTemplate create
   */
  export type ProcessingTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingTemplate
     */
    select?: ProcessingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessingTemplate.
     */
    data: XOR<ProcessingTemplateCreateInput, ProcessingTemplateUncheckedCreateInput>
  }

  /**
   * ProcessingTemplate createMany
   */
  export type ProcessingTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessingTemplates.
     */
    data: ProcessingTemplateCreateManyInput | ProcessingTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessingTemplate createManyAndReturn
   */
  export type ProcessingTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingTemplate
     */
    select?: ProcessingTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProcessingTemplates.
     */
    data: ProcessingTemplateCreateManyInput | ProcessingTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessingTemplate update
   */
  export type ProcessingTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingTemplate
     */
    select?: ProcessingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessingTemplate.
     */
    data: XOR<ProcessingTemplateUpdateInput, ProcessingTemplateUncheckedUpdateInput>
    /**
     * Choose, which ProcessingTemplate to update.
     */
    where: ProcessingTemplateWhereUniqueInput
  }

  /**
   * ProcessingTemplate updateMany
   */
  export type ProcessingTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessingTemplates.
     */
    data: XOR<ProcessingTemplateUpdateManyMutationInput, ProcessingTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ProcessingTemplates to update
     */
    where?: ProcessingTemplateWhereInput
  }

  /**
   * ProcessingTemplate upsert
   */
  export type ProcessingTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingTemplate
     */
    select?: ProcessingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessingTemplate to update in case it exists.
     */
    where: ProcessingTemplateWhereUniqueInput
    /**
     * In case the ProcessingTemplate found by the `where` argument doesn't exist, create a new ProcessingTemplate with this data.
     */
    create: XOR<ProcessingTemplateCreateInput, ProcessingTemplateUncheckedCreateInput>
    /**
     * In case the ProcessingTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessingTemplateUpdateInput, ProcessingTemplateUncheckedUpdateInput>
  }

  /**
   * ProcessingTemplate delete
   */
  export type ProcessingTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingTemplate
     */
    select?: ProcessingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingTemplateInclude<ExtArgs> | null
    /**
     * Filter which ProcessingTemplate to delete.
     */
    where: ProcessingTemplateWhereUniqueInput
  }

  /**
   * ProcessingTemplate deleteMany
   */
  export type ProcessingTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessingTemplates to delete
     */
    where?: ProcessingTemplateWhereInput
  }

  /**
   * ProcessingTemplate without action
   */
  export type ProcessingTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingTemplate
     */
    select?: ProcessingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ApiKeyManagement
   */

  export type AggregateApiKeyManagement = {
    _count: ApiKeyManagementCountAggregateOutputType | null
    _avg: ApiKeyManagementAvgAggregateOutputType | null
    _sum: ApiKeyManagementSumAggregateOutputType | null
    _min: ApiKeyManagementMinAggregateOutputType | null
    _max: ApiKeyManagementMaxAggregateOutputType | null
  }

  export type ApiKeyManagementAvgAggregateOutputType = {
    totalRequests: number | null
    totalTokens: number | null
    totalCost: Decimal | null
  }

  export type ApiKeyManagementSumAggregateOutputType = {
    totalRequests: bigint | null
    totalTokens: bigint | null
    totalCost: Decimal | null
  }

  export type ApiKeyManagementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    provider: string | null
    keyName: string | null
    encryptedKey: string | null
    keyHash: string | null
    isActive: boolean | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    totalRequests: bigint | null
    totalTokens: bigint | null
    totalCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyManagementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    provider: string | null
    keyName: string | null
    encryptedKey: string | null
    keyHash: string | null
    isActive: boolean | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    totalRequests: bigint | null
    totalTokens: bigint | null
    totalCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyManagementCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    provider: number
    keyName: number
    encryptedKey: number
    keyHash: number
    isActive: number
    lastUsedAt: number
    expiresAt: number
    totalRequests: number
    totalTokens: number
    totalCost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiKeyManagementAvgAggregateInputType = {
    totalRequests?: true
    totalTokens?: true
    totalCost?: true
  }

  export type ApiKeyManagementSumAggregateInputType = {
    totalRequests?: true
    totalTokens?: true
    totalCost?: true
  }

  export type ApiKeyManagementMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    provider?: true
    keyName?: true
    encryptedKey?: true
    keyHash?: true
    isActive?: true
    lastUsedAt?: true
    expiresAt?: true
    totalRequests?: true
    totalTokens?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyManagementMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    provider?: true
    keyName?: true
    encryptedKey?: true
    keyHash?: true
    isActive?: true
    lastUsedAt?: true
    expiresAt?: true
    totalRequests?: true
    totalTokens?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyManagementCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    provider?: true
    keyName?: true
    encryptedKey?: true
    keyHash?: true
    isActive?: true
    lastUsedAt?: true
    expiresAt?: true
    totalRequests?: true
    totalTokens?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiKeyManagementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeyManagement to aggregate.
     */
    where?: ApiKeyManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyManagements to fetch.
     */
    orderBy?: ApiKeyManagementOrderByWithRelationInput | ApiKeyManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeyManagements
    **/
    _count?: true | ApiKeyManagementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyManagementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeyManagementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyManagementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyManagementMaxAggregateInputType
  }

  export type GetApiKeyManagementAggregateType<T extends ApiKeyManagementAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKeyManagement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKeyManagement[P]>
      : GetScalarType<T[P], AggregateApiKeyManagement[P]>
  }




  export type ApiKeyManagementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyManagementWhereInput
    orderBy?: ApiKeyManagementOrderByWithAggregationInput | ApiKeyManagementOrderByWithAggregationInput[]
    by: ApiKeyManagementScalarFieldEnum[] | ApiKeyManagementScalarFieldEnum
    having?: ApiKeyManagementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyManagementCountAggregateInputType | true
    _avg?: ApiKeyManagementAvgAggregateInputType
    _sum?: ApiKeyManagementSumAggregateInputType
    _min?: ApiKeyManagementMinAggregateInputType
    _max?: ApiKeyManagementMaxAggregateInputType
  }

  export type ApiKeyManagementGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    provider: string
    keyName: string
    encryptedKey: string
    keyHash: string
    isActive: boolean
    lastUsedAt: Date | null
    expiresAt: Date | null
    totalRequests: bigint
    totalTokens: bigint
    totalCost: Decimal
    createdAt: Date
    updatedAt: Date
    _count: ApiKeyManagementCountAggregateOutputType | null
    _avg: ApiKeyManagementAvgAggregateOutputType | null
    _sum: ApiKeyManagementSumAggregateOutputType | null
    _min: ApiKeyManagementMinAggregateOutputType | null
    _max: ApiKeyManagementMaxAggregateOutputType | null
  }

  type GetApiKeyManagementGroupByPayload<T extends ApiKeyManagementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyManagementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyManagementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyManagementGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyManagementGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeyManagementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    provider?: boolean
    keyName?: boolean
    encryptedKey?: boolean
    keyHash?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    totalRequests?: boolean
    totalTokens?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyManagement"]>

  export type ApiKeyManagementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    provider?: boolean
    keyName?: boolean
    encryptedKey?: boolean
    keyHash?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    totalRequests?: boolean
    totalTokens?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyManagement"]>

  export type ApiKeyManagementSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    provider?: boolean
    keyName?: boolean
    encryptedKey?: boolean
    keyHash?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    totalRequests?: boolean
    totalTokens?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApiKeyManagementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyManagementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApiKeyManagementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKeyManagement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      provider: string
      keyName: string
      encryptedKey: string
      keyHash: string
      isActive: boolean
      lastUsedAt: Date | null
      expiresAt: Date | null
      totalRequests: bigint
      totalTokens: bigint
      totalCost: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiKeyManagement"]>
    composites: {}
  }

  type ApiKeyManagementGetPayload<S extends boolean | null | undefined | ApiKeyManagementDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyManagementPayload, S>

  type ApiKeyManagementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyManagementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyManagementCountAggregateInputType | true
    }

  export interface ApiKeyManagementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKeyManagement'], meta: { name: 'ApiKeyManagement' } }
    /**
     * Find zero or one ApiKeyManagement that matches the filter.
     * @param {ApiKeyManagementFindUniqueArgs} args - Arguments to find a ApiKeyManagement
     * @example
     * // Get one ApiKeyManagement
     * const apiKeyManagement = await prisma.apiKeyManagement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyManagementFindUniqueArgs>(args: SelectSubset<T, ApiKeyManagementFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKeyManagement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyManagementFindUniqueOrThrowArgs} args - Arguments to find a ApiKeyManagement
     * @example
     * // Get one ApiKeyManagement
     * const apiKeyManagement = await prisma.apiKeyManagement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyManagementFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyManagementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKeyManagement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementFindFirstArgs} args - Arguments to find a ApiKeyManagement
     * @example
     * // Get one ApiKeyManagement
     * const apiKeyManagement = await prisma.apiKeyManagement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyManagementFindFirstArgs>(args?: SelectSubset<T, ApiKeyManagementFindFirstArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKeyManagement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementFindFirstOrThrowArgs} args - Arguments to find a ApiKeyManagement
     * @example
     * // Get one ApiKeyManagement
     * const apiKeyManagement = await prisma.apiKeyManagement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyManagementFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyManagementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeyManagements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeyManagements
     * const apiKeyManagements = await prisma.apiKeyManagement.findMany()
     * 
     * // Get first 10 ApiKeyManagements
     * const apiKeyManagements = await prisma.apiKeyManagement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyManagementWithIdOnly = await prisma.apiKeyManagement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyManagementFindManyArgs>(args?: SelectSubset<T, ApiKeyManagementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKeyManagement.
     * @param {ApiKeyManagementCreateArgs} args - Arguments to create a ApiKeyManagement.
     * @example
     * // Create one ApiKeyManagement
     * const ApiKeyManagement = await prisma.apiKeyManagement.create({
     *   data: {
     *     // ... data to create a ApiKeyManagement
     *   }
     * })
     * 
     */
    create<T extends ApiKeyManagementCreateArgs>(args: SelectSubset<T, ApiKeyManagementCreateArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeyManagements.
     * @param {ApiKeyManagementCreateManyArgs} args - Arguments to create many ApiKeyManagements.
     * @example
     * // Create many ApiKeyManagements
     * const apiKeyManagement = await prisma.apiKeyManagement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyManagementCreateManyArgs>(args?: SelectSubset<T, ApiKeyManagementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeyManagements and returns the data saved in the database.
     * @param {ApiKeyManagementCreateManyAndReturnArgs} args - Arguments to create many ApiKeyManagements.
     * @example
     * // Create many ApiKeyManagements
     * const apiKeyManagement = await prisma.apiKeyManagement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeyManagements and only return the `id`
     * const apiKeyManagementWithIdOnly = await prisma.apiKeyManagement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyManagementCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyManagementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKeyManagement.
     * @param {ApiKeyManagementDeleteArgs} args - Arguments to delete one ApiKeyManagement.
     * @example
     * // Delete one ApiKeyManagement
     * const ApiKeyManagement = await prisma.apiKeyManagement.delete({
     *   where: {
     *     // ... filter to delete one ApiKeyManagement
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyManagementDeleteArgs>(args: SelectSubset<T, ApiKeyManagementDeleteArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKeyManagement.
     * @param {ApiKeyManagementUpdateArgs} args - Arguments to update one ApiKeyManagement.
     * @example
     * // Update one ApiKeyManagement
     * const apiKeyManagement = await prisma.apiKeyManagement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyManagementUpdateArgs>(args: SelectSubset<T, ApiKeyManagementUpdateArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeyManagements.
     * @param {ApiKeyManagementDeleteManyArgs} args - Arguments to filter ApiKeyManagements to delete.
     * @example
     * // Delete a few ApiKeyManagements
     * const { count } = await prisma.apiKeyManagement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyManagementDeleteManyArgs>(args?: SelectSubset<T, ApiKeyManagementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeyManagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeyManagements
     * const apiKeyManagement = await prisma.apiKeyManagement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyManagementUpdateManyArgs>(args: SelectSubset<T, ApiKeyManagementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKeyManagement.
     * @param {ApiKeyManagementUpsertArgs} args - Arguments to update or create a ApiKeyManagement.
     * @example
     * // Update or create a ApiKeyManagement
     * const apiKeyManagement = await prisma.apiKeyManagement.upsert({
     *   create: {
     *     // ... data to create a ApiKeyManagement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKeyManagement we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyManagementUpsertArgs>(args: SelectSubset<T, ApiKeyManagementUpsertArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeyManagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementCountArgs} args - Arguments to filter ApiKeyManagements to count.
     * @example
     * // Count the number of ApiKeyManagements
     * const count = await prisma.apiKeyManagement.count({
     *   where: {
     *     // ... the filter for the ApiKeyManagements we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyManagementCountArgs>(
      args?: Subset<T, ApiKeyManagementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyManagementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKeyManagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyManagementAggregateArgs>(args: Subset<T, ApiKeyManagementAggregateArgs>): Prisma.PrismaPromise<GetApiKeyManagementAggregateType<T>>

    /**
     * Group by ApiKeyManagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyManagementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyManagementGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyManagementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyManagementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyManagementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKeyManagement model
   */
  readonly fields: ApiKeyManagementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKeyManagement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyManagementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKeyManagement model
   */ 
  interface ApiKeyManagementFieldRefs {
    readonly id: FieldRef<"ApiKeyManagement", 'String'>
    readonly userId: FieldRef<"ApiKeyManagement", 'String'>
    readonly workspaceId: FieldRef<"ApiKeyManagement", 'String'>
    readonly provider: FieldRef<"ApiKeyManagement", 'String'>
    readonly keyName: FieldRef<"ApiKeyManagement", 'String'>
    readonly encryptedKey: FieldRef<"ApiKeyManagement", 'String'>
    readonly keyHash: FieldRef<"ApiKeyManagement", 'String'>
    readonly isActive: FieldRef<"ApiKeyManagement", 'Boolean'>
    readonly lastUsedAt: FieldRef<"ApiKeyManagement", 'DateTime'>
    readonly expiresAt: FieldRef<"ApiKeyManagement", 'DateTime'>
    readonly totalRequests: FieldRef<"ApiKeyManagement", 'BigInt'>
    readonly totalTokens: FieldRef<"ApiKeyManagement", 'BigInt'>
    readonly totalCost: FieldRef<"ApiKeyManagement", 'Decimal'>
    readonly createdAt: FieldRef<"ApiKeyManagement", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKeyManagement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKeyManagement findUnique
   */
  export type ApiKeyManagementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyManagement to fetch.
     */
    where: ApiKeyManagementWhereUniqueInput
  }

  /**
   * ApiKeyManagement findUniqueOrThrow
   */
  export type ApiKeyManagementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyManagement to fetch.
     */
    where: ApiKeyManagementWhereUniqueInput
  }

  /**
   * ApiKeyManagement findFirst
   */
  export type ApiKeyManagementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyManagement to fetch.
     */
    where?: ApiKeyManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyManagements to fetch.
     */
    orderBy?: ApiKeyManagementOrderByWithRelationInput | ApiKeyManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeyManagements.
     */
    cursor?: ApiKeyManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeyManagements.
     */
    distinct?: ApiKeyManagementScalarFieldEnum | ApiKeyManagementScalarFieldEnum[]
  }

  /**
   * ApiKeyManagement findFirstOrThrow
   */
  export type ApiKeyManagementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyManagement to fetch.
     */
    where?: ApiKeyManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyManagements to fetch.
     */
    orderBy?: ApiKeyManagementOrderByWithRelationInput | ApiKeyManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeyManagements.
     */
    cursor?: ApiKeyManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeyManagements.
     */
    distinct?: ApiKeyManagementScalarFieldEnum | ApiKeyManagementScalarFieldEnum[]
  }

  /**
   * ApiKeyManagement findMany
   */
  export type ApiKeyManagementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyManagements to fetch.
     */
    where?: ApiKeyManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyManagements to fetch.
     */
    orderBy?: ApiKeyManagementOrderByWithRelationInput | ApiKeyManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeyManagements.
     */
    cursor?: ApiKeyManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyManagements.
     */
    skip?: number
    distinct?: ApiKeyManagementScalarFieldEnum | ApiKeyManagementScalarFieldEnum[]
  }

  /**
   * ApiKeyManagement create
   */
  export type ApiKeyManagementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKeyManagement.
     */
    data: XOR<ApiKeyManagementCreateInput, ApiKeyManagementUncheckedCreateInput>
  }

  /**
   * ApiKeyManagement createMany
   */
  export type ApiKeyManagementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeyManagements.
     */
    data: ApiKeyManagementCreateManyInput | ApiKeyManagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKeyManagement createManyAndReturn
   */
  export type ApiKeyManagementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeyManagements.
     */
    data: ApiKeyManagementCreateManyInput | ApiKeyManagementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKeyManagement update
   */
  export type ApiKeyManagementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKeyManagement.
     */
    data: XOR<ApiKeyManagementUpdateInput, ApiKeyManagementUncheckedUpdateInput>
    /**
     * Choose, which ApiKeyManagement to update.
     */
    where: ApiKeyManagementWhereUniqueInput
  }

  /**
   * ApiKeyManagement updateMany
   */
  export type ApiKeyManagementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeyManagements.
     */
    data: XOR<ApiKeyManagementUpdateManyMutationInput, ApiKeyManagementUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeyManagements to update
     */
    where?: ApiKeyManagementWhereInput
  }

  /**
   * ApiKeyManagement upsert
   */
  export type ApiKeyManagementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKeyManagement to update in case it exists.
     */
    where: ApiKeyManagementWhereUniqueInput
    /**
     * In case the ApiKeyManagement found by the `where` argument doesn't exist, create a new ApiKeyManagement with this data.
     */
    create: XOR<ApiKeyManagementCreateInput, ApiKeyManagementUncheckedCreateInput>
    /**
     * In case the ApiKeyManagement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyManagementUpdateInput, ApiKeyManagementUncheckedUpdateInput>
  }

  /**
   * ApiKeyManagement delete
   */
  export type ApiKeyManagementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * Filter which ApiKeyManagement to delete.
     */
    where: ApiKeyManagementWhereUniqueInput
  }

  /**
   * ApiKeyManagement deleteMany
   */
  export type ApiKeyManagementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeyManagements to delete
     */
    where?: ApiKeyManagementWhereInput
  }

  /**
   * ApiKeyManagement without action
   */
  export type ApiKeyManagementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
  }


  /**
   * Model AudioUpload
   */

  export type AggregateAudioUpload = {
    _count: AudioUploadCountAggregateOutputType | null
    _avg: AudioUploadAvgAggregateOutputType | null
    _sum: AudioUploadSumAggregateOutputType | null
    _min: AudioUploadMinAggregateOutputType | null
    _max: AudioUploadMaxAggregateOutputType | null
  }

  export type AudioUploadAvgAggregateOutputType = {
    fileSize: number | null
    duration: number | null
    sampleRate: number | null
    channels: number | null
    bitrate: number | null
  }

  export type AudioUploadSumAggregateOutputType = {
    fileSize: bigint | null
    duration: number | null
    sampleRate: number | null
    channels: number | null
    bitrate: number | null
  }

  export type AudioUploadMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    originalFilename: string | null
    fileSize: bigint | null
    fileType: string | null
    mimeType: string | null
    duration: number | null
    sampleRate: number | null
    channels: number | null
    bitrate: number | null
    storageProvider: string | null
    storagePath: string | null
    storageUrl: string | null
    cdnUrl: string | null
    checksumMd5: string | null
    checksumSha256: string | null
    status: string | null
    uploadedAt: Date | null
    processingStartedAt: Date | null
    completedAt: Date | null
  }

  export type AudioUploadMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    originalFilename: string | null
    fileSize: bigint | null
    fileType: string | null
    mimeType: string | null
    duration: number | null
    sampleRate: number | null
    channels: number | null
    bitrate: number | null
    storageProvider: string | null
    storagePath: string | null
    storageUrl: string | null
    cdnUrl: string | null
    checksumMd5: string | null
    checksumSha256: string | null
    status: string | null
    uploadedAt: Date | null
    processingStartedAt: Date | null
    completedAt: Date | null
  }

  export type AudioUploadCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    originalFilename: number
    fileSize: number
    fileType: number
    mimeType: number
    duration: number
    sampleRate: number
    channels: number
    bitrate: number
    storageProvider: number
    storagePath: number
    storageUrl: number
    cdnUrl: number
    checksumMd5: number
    checksumSha256: number
    status: number
    uploadedAt: number
    processingStartedAt: number
    completedAt: number
    _all: number
  }


  export type AudioUploadAvgAggregateInputType = {
    fileSize?: true
    duration?: true
    sampleRate?: true
    channels?: true
    bitrate?: true
  }

  export type AudioUploadSumAggregateInputType = {
    fileSize?: true
    duration?: true
    sampleRate?: true
    channels?: true
    bitrate?: true
  }

  export type AudioUploadMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    originalFilename?: true
    fileSize?: true
    fileType?: true
    mimeType?: true
    duration?: true
    sampleRate?: true
    channels?: true
    bitrate?: true
    storageProvider?: true
    storagePath?: true
    storageUrl?: true
    cdnUrl?: true
    checksumMd5?: true
    checksumSha256?: true
    status?: true
    uploadedAt?: true
    processingStartedAt?: true
    completedAt?: true
  }

  export type AudioUploadMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    originalFilename?: true
    fileSize?: true
    fileType?: true
    mimeType?: true
    duration?: true
    sampleRate?: true
    channels?: true
    bitrate?: true
    storageProvider?: true
    storagePath?: true
    storageUrl?: true
    cdnUrl?: true
    checksumMd5?: true
    checksumSha256?: true
    status?: true
    uploadedAt?: true
    processingStartedAt?: true
    completedAt?: true
  }

  export type AudioUploadCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    originalFilename?: true
    fileSize?: true
    fileType?: true
    mimeType?: true
    duration?: true
    sampleRate?: true
    channels?: true
    bitrate?: true
    storageProvider?: true
    storagePath?: true
    storageUrl?: true
    cdnUrl?: true
    checksumMd5?: true
    checksumSha256?: true
    status?: true
    uploadedAt?: true
    processingStartedAt?: true
    completedAt?: true
    _all?: true
  }

  export type AudioUploadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioUpload to aggregate.
     */
    where?: AudioUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioUploads to fetch.
     */
    orderBy?: AudioUploadOrderByWithRelationInput | AudioUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioUploads
    **/
    _count?: true | AudioUploadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioUploadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioUploadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioUploadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioUploadMaxAggregateInputType
  }

  export type GetAudioUploadAggregateType<T extends AudioUploadAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioUpload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioUpload[P]>
      : GetScalarType<T[P], AggregateAudioUpload[P]>
  }




  export type AudioUploadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioUploadWhereInput
    orderBy?: AudioUploadOrderByWithAggregationInput | AudioUploadOrderByWithAggregationInput[]
    by: AudioUploadScalarFieldEnum[] | AudioUploadScalarFieldEnum
    having?: AudioUploadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioUploadCountAggregateInputType | true
    _avg?: AudioUploadAvgAggregateInputType
    _sum?: AudioUploadSumAggregateInputType
    _min?: AudioUploadMinAggregateInputType
    _max?: AudioUploadMaxAggregateInputType
  }

  export type AudioUploadGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    originalFilename: string
    fileSize: bigint
    fileType: string
    mimeType: string
    duration: number | null
    sampleRate: number | null
    channels: number | null
    bitrate: number | null
    storageProvider: string
    storagePath: string
    storageUrl: string | null
    cdnUrl: string | null
    checksumMd5: string | null
    checksumSha256: string | null
    status: string
    uploadedAt: Date
    processingStartedAt: Date | null
    completedAt: Date | null
    _count: AudioUploadCountAggregateOutputType | null
    _avg: AudioUploadAvgAggregateOutputType | null
    _sum: AudioUploadSumAggregateOutputType | null
    _min: AudioUploadMinAggregateOutputType | null
    _max: AudioUploadMaxAggregateOutputType | null
  }

  type GetAudioUploadGroupByPayload<T extends AudioUploadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioUploadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioUploadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioUploadGroupByOutputType[P]>
            : GetScalarType<T[P], AudioUploadGroupByOutputType[P]>
        }
      >
    >


  export type AudioUploadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    originalFilename?: boolean
    fileSize?: boolean
    fileType?: boolean
    mimeType?: boolean
    duration?: boolean
    sampleRate?: boolean
    channels?: boolean
    bitrate?: boolean
    storageProvider?: boolean
    storagePath?: boolean
    storageUrl?: boolean
    cdnUrl?: boolean
    checksumMd5?: boolean
    checksumSha256?: boolean
    status?: boolean
    uploadedAt?: boolean
    processingStartedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioUpload$workspaceArgs<ExtArgs>
    audioHistory?: boolean | AudioUpload$audioHistoryArgs<ExtArgs>
    processingJobs?: boolean | AudioUpload$processingJobsArgs<ExtArgs>
    audioChunks?: boolean | AudioUpload$audioChunksArgs<ExtArgs>
    _count?: boolean | AudioUploadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioUpload"]>

  export type AudioUploadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    originalFilename?: boolean
    fileSize?: boolean
    fileType?: boolean
    mimeType?: boolean
    duration?: boolean
    sampleRate?: boolean
    channels?: boolean
    bitrate?: boolean
    storageProvider?: boolean
    storagePath?: boolean
    storageUrl?: boolean
    cdnUrl?: boolean
    checksumMd5?: boolean
    checksumSha256?: boolean
    status?: boolean
    uploadedAt?: boolean
    processingStartedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioUpload$workspaceArgs<ExtArgs>
  }, ExtArgs["result"]["audioUpload"]>

  export type AudioUploadSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    originalFilename?: boolean
    fileSize?: boolean
    fileType?: boolean
    mimeType?: boolean
    duration?: boolean
    sampleRate?: boolean
    channels?: boolean
    bitrate?: boolean
    storageProvider?: boolean
    storagePath?: boolean
    storageUrl?: boolean
    cdnUrl?: boolean
    checksumMd5?: boolean
    checksumSha256?: boolean
    status?: boolean
    uploadedAt?: boolean
    processingStartedAt?: boolean
    completedAt?: boolean
  }

  export type AudioUploadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioUpload$workspaceArgs<ExtArgs>
    audioHistory?: boolean | AudioUpload$audioHistoryArgs<ExtArgs>
    processingJobs?: boolean | AudioUpload$processingJobsArgs<ExtArgs>
    audioChunks?: boolean | AudioUpload$audioChunksArgs<ExtArgs>
    _count?: boolean | AudioUploadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AudioUploadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioUpload$workspaceArgs<ExtArgs>
  }

  export type $AudioUploadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioUpload"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs> | null
      audioHistory: Prisma.$AudioHistoryPayload<ExtArgs>[]
      processingJobs: Prisma.$ProcessingJobPayload<ExtArgs>[]
      audioChunks: Prisma.$AudioChunkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      originalFilename: string
      fileSize: bigint
      fileType: string
      mimeType: string
      duration: number | null
      sampleRate: number | null
      channels: number | null
      bitrate: number | null
      storageProvider: string
      storagePath: string
      storageUrl: string | null
      cdnUrl: string | null
      checksumMd5: string | null
      checksumSha256: string | null
      status: string
      uploadedAt: Date
      processingStartedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["audioUpload"]>
    composites: {}
  }

  type AudioUploadGetPayload<S extends boolean | null | undefined | AudioUploadDefaultArgs> = $Result.GetResult<Prisma.$AudioUploadPayload, S>

  type AudioUploadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AudioUploadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AudioUploadCountAggregateInputType | true
    }

  export interface AudioUploadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioUpload'], meta: { name: 'AudioUpload' } }
    /**
     * Find zero or one AudioUpload that matches the filter.
     * @param {AudioUploadFindUniqueArgs} args - Arguments to find a AudioUpload
     * @example
     * // Get one AudioUpload
     * const audioUpload = await prisma.audioUpload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioUploadFindUniqueArgs>(args: SelectSubset<T, AudioUploadFindUniqueArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AudioUpload that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AudioUploadFindUniqueOrThrowArgs} args - Arguments to find a AudioUpload
     * @example
     * // Get one AudioUpload
     * const audioUpload = await prisma.audioUpload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioUploadFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioUploadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AudioUpload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadFindFirstArgs} args - Arguments to find a AudioUpload
     * @example
     * // Get one AudioUpload
     * const audioUpload = await prisma.audioUpload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioUploadFindFirstArgs>(args?: SelectSubset<T, AudioUploadFindFirstArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AudioUpload that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadFindFirstOrThrowArgs} args - Arguments to find a AudioUpload
     * @example
     * // Get one AudioUpload
     * const audioUpload = await prisma.audioUpload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioUploadFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioUploadFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AudioUploads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioUploads
     * const audioUploads = await prisma.audioUpload.findMany()
     * 
     * // Get first 10 AudioUploads
     * const audioUploads = await prisma.audioUpload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioUploadWithIdOnly = await prisma.audioUpload.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioUploadFindManyArgs>(args?: SelectSubset<T, AudioUploadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AudioUpload.
     * @param {AudioUploadCreateArgs} args - Arguments to create a AudioUpload.
     * @example
     * // Create one AudioUpload
     * const AudioUpload = await prisma.audioUpload.create({
     *   data: {
     *     // ... data to create a AudioUpload
     *   }
     * })
     * 
     */
    create<T extends AudioUploadCreateArgs>(args: SelectSubset<T, AudioUploadCreateArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AudioUploads.
     * @param {AudioUploadCreateManyArgs} args - Arguments to create many AudioUploads.
     * @example
     * // Create many AudioUploads
     * const audioUpload = await prisma.audioUpload.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioUploadCreateManyArgs>(args?: SelectSubset<T, AudioUploadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioUploads and returns the data saved in the database.
     * @param {AudioUploadCreateManyAndReturnArgs} args - Arguments to create many AudioUploads.
     * @example
     * // Create many AudioUploads
     * const audioUpload = await prisma.audioUpload.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioUploads and only return the `id`
     * const audioUploadWithIdOnly = await prisma.audioUpload.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioUploadCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioUploadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AudioUpload.
     * @param {AudioUploadDeleteArgs} args - Arguments to delete one AudioUpload.
     * @example
     * // Delete one AudioUpload
     * const AudioUpload = await prisma.audioUpload.delete({
     *   where: {
     *     // ... filter to delete one AudioUpload
     *   }
     * })
     * 
     */
    delete<T extends AudioUploadDeleteArgs>(args: SelectSubset<T, AudioUploadDeleteArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AudioUpload.
     * @param {AudioUploadUpdateArgs} args - Arguments to update one AudioUpload.
     * @example
     * // Update one AudioUpload
     * const audioUpload = await prisma.audioUpload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioUploadUpdateArgs>(args: SelectSubset<T, AudioUploadUpdateArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AudioUploads.
     * @param {AudioUploadDeleteManyArgs} args - Arguments to filter AudioUploads to delete.
     * @example
     * // Delete a few AudioUploads
     * const { count } = await prisma.audioUpload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioUploadDeleteManyArgs>(args?: SelectSubset<T, AudioUploadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioUploads
     * const audioUpload = await prisma.audioUpload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioUploadUpdateManyArgs>(args: SelectSubset<T, AudioUploadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AudioUpload.
     * @param {AudioUploadUpsertArgs} args - Arguments to update or create a AudioUpload.
     * @example
     * // Update or create a AudioUpload
     * const audioUpload = await prisma.audioUpload.upsert({
     *   create: {
     *     // ... data to create a AudioUpload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioUpload we want to update
     *   }
     * })
     */
    upsert<T extends AudioUploadUpsertArgs>(args: SelectSubset<T, AudioUploadUpsertArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AudioUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadCountArgs} args - Arguments to filter AudioUploads to count.
     * @example
     * // Count the number of AudioUploads
     * const count = await prisma.audioUpload.count({
     *   where: {
     *     // ... the filter for the AudioUploads we want to count
     *   }
     * })
    **/
    count<T extends AudioUploadCountArgs>(
      args?: Subset<T, AudioUploadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioUploadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioUploadAggregateArgs>(args: Subset<T, AudioUploadAggregateArgs>): Prisma.PrismaPromise<GetAudioUploadAggregateType<T>>

    /**
     * Group by AudioUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioUploadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioUploadGroupByArgs['orderBy'] }
        : { orderBy?: AudioUploadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioUploadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioUploadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioUpload model
   */
  readonly fields: AudioUploadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioUpload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioUploadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workspace<T extends AudioUpload$workspaceArgs<ExtArgs> = {}>(args?: Subset<T, AudioUpload$workspaceArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    audioHistory<T extends AudioUpload$audioHistoryArgs<ExtArgs> = {}>(args?: Subset<T, AudioUpload$audioHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    processingJobs<T extends AudioUpload$processingJobsArgs<ExtArgs> = {}>(args?: Subset<T, AudioUpload$processingJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findMany"> | Null>
    audioChunks<T extends AudioUpload$audioChunksArgs<ExtArgs> = {}>(args?: Subset<T, AudioUpload$audioChunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioUpload model
   */ 
  interface AudioUploadFieldRefs {
    readonly id: FieldRef<"AudioUpload", 'String'>
    readonly userId: FieldRef<"AudioUpload", 'String'>
    readonly workspaceId: FieldRef<"AudioUpload", 'String'>
    readonly originalFilename: FieldRef<"AudioUpload", 'String'>
    readonly fileSize: FieldRef<"AudioUpload", 'BigInt'>
    readonly fileType: FieldRef<"AudioUpload", 'String'>
    readonly mimeType: FieldRef<"AudioUpload", 'String'>
    readonly duration: FieldRef<"AudioUpload", 'Float'>
    readonly sampleRate: FieldRef<"AudioUpload", 'Int'>
    readonly channels: FieldRef<"AudioUpload", 'Int'>
    readonly bitrate: FieldRef<"AudioUpload", 'Int'>
    readonly storageProvider: FieldRef<"AudioUpload", 'String'>
    readonly storagePath: FieldRef<"AudioUpload", 'String'>
    readonly storageUrl: FieldRef<"AudioUpload", 'String'>
    readonly cdnUrl: FieldRef<"AudioUpload", 'String'>
    readonly checksumMd5: FieldRef<"AudioUpload", 'String'>
    readonly checksumSha256: FieldRef<"AudioUpload", 'String'>
    readonly status: FieldRef<"AudioUpload", 'String'>
    readonly uploadedAt: FieldRef<"AudioUpload", 'DateTime'>
    readonly processingStartedAt: FieldRef<"AudioUpload", 'DateTime'>
    readonly completedAt: FieldRef<"AudioUpload", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioUpload findUnique
   */
  export type AudioUploadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * Filter, which AudioUpload to fetch.
     */
    where: AudioUploadWhereUniqueInput
  }

  /**
   * AudioUpload findUniqueOrThrow
   */
  export type AudioUploadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * Filter, which AudioUpload to fetch.
     */
    where: AudioUploadWhereUniqueInput
  }

  /**
   * AudioUpload findFirst
   */
  export type AudioUploadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * Filter, which AudioUpload to fetch.
     */
    where?: AudioUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioUploads to fetch.
     */
    orderBy?: AudioUploadOrderByWithRelationInput | AudioUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioUploads.
     */
    cursor?: AudioUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioUploads.
     */
    distinct?: AudioUploadScalarFieldEnum | AudioUploadScalarFieldEnum[]
  }

  /**
   * AudioUpload findFirstOrThrow
   */
  export type AudioUploadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * Filter, which AudioUpload to fetch.
     */
    where?: AudioUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioUploads to fetch.
     */
    orderBy?: AudioUploadOrderByWithRelationInput | AudioUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioUploads.
     */
    cursor?: AudioUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioUploads.
     */
    distinct?: AudioUploadScalarFieldEnum | AudioUploadScalarFieldEnum[]
  }

  /**
   * AudioUpload findMany
   */
  export type AudioUploadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * Filter, which AudioUploads to fetch.
     */
    where?: AudioUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioUploads to fetch.
     */
    orderBy?: AudioUploadOrderByWithRelationInput | AudioUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioUploads.
     */
    cursor?: AudioUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioUploads.
     */
    skip?: number
    distinct?: AudioUploadScalarFieldEnum | AudioUploadScalarFieldEnum[]
  }

  /**
   * AudioUpload create
   */
  export type AudioUploadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioUpload.
     */
    data: XOR<AudioUploadCreateInput, AudioUploadUncheckedCreateInput>
  }

  /**
   * AudioUpload createMany
   */
  export type AudioUploadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioUploads.
     */
    data: AudioUploadCreateManyInput | AudioUploadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioUpload createManyAndReturn
   */
  export type AudioUploadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AudioUploads.
     */
    data: AudioUploadCreateManyInput | AudioUploadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioUpload update
   */
  export type AudioUploadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioUpload.
     */
    data: XOR<AudioUploadUpdateInput, AudioUploadUncheckedUpdateInput>
    /**
     * Choose, which AudioUpload to update.
     */
    where: AudioUploadWhereUniqueInput
  }

  /**
   * AudioUpload updateMany
   */
  export type AudioUploadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioUploads.
     */
    data: XOR<AudioUploadUpdateManyMutationInput, AudioUploadUncheckedUpdateManyInput>
    /**
     * Filter which AudioUploads to update
     */
    where?: AudioUploadWhereInput
  }

  /**
   * AudioUpload upsert
   */
  export type AudioUploadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioUpload to update in case it exists.
     */
    where: AudioUploadWhereUniqueInput
    /**
     * In case the AudioUpload found by the `where` argument doesn't exist, create a new AudioUpload with this data.
     */
    create: XOR<AudioUploadCreateInput, AudioUploadUncheckedCreateInput>
    /**
     * In case the AudioUpload was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioUploadUpdateInput, AudioUploadUncheckedUpdateInput>
  }

  /**
   * AudioUpload delete
   */
  export type AudioUploadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * Filter which AudioUpload to delete.
     */
    where: AudioUploadWhereUniqueInput
  }

  /**
   * AudioUpload deleteMany
   */
  export type AudioUploadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioUploads to delete
     */
    where?: AudioUploadWhereInput
  }

  /**
   * AudioUpload.workspace
   */
  export type AudioUpload$workspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
  }

  /**
   * AudioUpload.audioHistory
   */
  export type AudioUpload$audioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    where?: AudioHistoryWhereInput
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    cursor?: AudioHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioHistoryScalarFieldEnum | AudioHistoryScalarFieldEnum[]
  }

  /**
   * AudioUpload.processingJobs
   */
  export type AudioUpload$processingJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    where?: ProcessingJobWhereInput
    orderBy?: ProcessingJobOrderByWithRelationInput | ProcessingJobOrderByWithRelationInput[]
    cursor?: ProcessingJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessingJobScalarFieldEnum | ProcessingJobScalarFieldEnum[]
  }

  /**
   * AudioUpload.audioChunks
   */
  export type AudioUpload$audioChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    where?: AudioChunkWhereInput
    orderBy?: AudioChunkOrderByWithRelationInput | AudioChunkOrderByWithRelationInput[]
    cursor?: AudioChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioChunkScalarFieldEnum | AudioChunkScalarFieldEnum[]
  }

  /**
   * AudioUpload without action
   */
  export type AudioUploadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
  }


  /**
   * Model ProcessingJob
   */

  export type AggregateProcessingJob = {
    _count: ProcessingJobCountAggregateOutputType | null
    _avg: ProcessingJobAvgAggregateOutputType | null
    _sum: ProcessingJobSumAggregateOutputType | null
    _min: ProcessingJobMinAggregateOutputType | null
    _max: ProcessingJobMaxAggregateOutputType | null
  }

  export type ProcessingJobAvgAggregateOutputType = {
    priority: number | null
    progress: number | null
    cpuTimeMs: number | null
    memoryUsageMb: number | null
    retryCount: number | null
    maxRetries: number | null
  }

  export type ProcessingJobSumAggregateOutputType = {
    priority: number | null
    progress: number | null
    cpuTimeMs: bigint | null
    memoryUsageMb: number | null
    retryCount: number | null
    maxRetries: number | null
  }

  export type ProcessingJobMinAggregateOutputType = {
    id: string | null
    userId: string | null
    uploadId: string | null
    jobType: string | null
    priority: number | null
    status: string | null
    progress: number | null
    cpuTimeMs: bigint | null
    memoryUsageMb: number | null
    queuedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    retryCount: number | null
    maxRetries: number | null
  }

  export type ProcessingJobMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    uploadId: string | null
    jobType: string | null
    priority: number | null
    status: string | null
    progress: number | null
    cpuTimeMs: bigint | null
    memoryUsageMb: number | null
    queuedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    retryCount: number | null
    maxRetries: number | null
  }

  export type ProcessingJobCountAggregateOutputType = {
    id: number
    userId: number
    uploadId: number
    jobType: number
    priority: number
    processingOptions: number
    status: number
    progress: number
    cpuTimeMs: number
    memoryUsageMb: number
    queuedAt: number
    startedAt: number
    completedAt: number
    errorMessage: number
    retryCount: number
    maxRetries: number
    _all: number
  }


  export type ProcessingJobAvgAggregateInputType = {
    priority?: true
    progress?: true
    cpuTimeMs?: true
    memoryUsageMb?: true
    retryCount?: true
    maxRetries?: true
  }

  export type ProcessingJobSumAggregateInputType = {
    priority?: true
    progress?: true
    cpuTimeMs?: true
    memoryUsageMb?: true
    retryCount?: true
    maxRetries?: true
  }

  export type ProcessingJobMinAggregateInputType = {
    id?: true
    userId?: true
    uploadId?: true
    jobType?: true
    priority?: true
    status?: true
    progress?: true
    cpuTimeMs?: true
    memoryUsageMb?: true
    queuedAt?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    retryCount?: true
    maxRetries?: true
  }

  export type ProcessingJobMaxAggregateInputType = {
    id?: true
    userId?: true
    uploadId?: true
    jobType?: true
    priority?: true
    status?: true
    progress?: true
    cpuTimeMs?: true
    memoryUsageMb?: true
    queuedAt?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    retryCount?: true
    maxRetries?: true
  }

  export type ProcessingJobCountAggregateInputType = {
    id?: true
    userId?: true
    uploadId?: true
    jobType?: true
    priority?: true
    processingOptions?: true
    status?: true
    progress?: true
    cpuTimeMs?: true
    memoryUsageMb?: true
    queuedAt?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    retryCount?: true
    maxRetries?: true
    _all?: true
  }

  export type ProcessingJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessingJob to aggregate.
     */
    where?: ProcessingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingJobs to fetch.
     */
    orderBy?: ProcessingJobOrderByWithRelationInput | ProcessingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessingJobs
    **/
    _count?: true | ProcessingJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessingJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessingJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessingJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessingJobMaxAggregateInputType
  }

  export type GetProcessingJobAggregateType<T extends ProcessingJobAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessingJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessingJob[P]>
      : GetScalarType<T[P], AggregateProcessingJob[P]>
  }




  export type ProcessingJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessingJobWhereInput
    orderBy?: ProcessingJobOrderByWithAggregationInput | ProcessingJobOrderByWithAggregationInput[]
    by: ProcessingJobScalarFieldEnum[] | ProcessingJobScalarFieldEnum
    having?: ProcessingJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessingJobCountAggregateInputType | true
    _avg?: ProcessingJobAvgAggregateInputType
    _sum?: ProcessingJobSumAggregateInputType
    _min?: ProcessingJobMinAggregateInputType
    _max?: ProcessingJobMaxAggregateInputType
  }

  export type ProcessingJobGroupByOutputType = {
    id: string
    userId: string
    uploadId: string
    jobType: string
    priority: number
    processingOptions: JsonValue
    status: string
    progress: number
    cpuTimeMs: bigint | null
    memoryUsageMb: number | null
    queuedAt: Date
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    retryCount: number
    maxRetries: number
    _count: ProcessingJobCountAggregateOutputType | null
    _avg: ProcessingJobAvgAggregateOutputType | null
    _sum: ProcessingJobSumAggregateOutputType | null
    _min: ProcessingJobMinAggregateOutputType | null
    _max: ProcessingJobMaxAggregateOutputType | null
  }

  type GetProcessingJobGroupByPayload<T extends ProcessingJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessingJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessingJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessingJobGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessingJobGroupByOutputType[P]>
        }
      >
    >


  export type ProcessingJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    uploadId?: boolean
    jobType?: boolean
    priority?: boolean
    processingOptions?: boolean
    status?: boolean
    progress?: boolean
    cpuTimeMs?: boolean
    memoryUsageMb?: boolean
    queuedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processingJob"]>

  export type ProcessingJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    uploadId?: boolean
    jobType?: boolean
    priority?: boolean
    processingOptions?: boolean
    status?: boolean
    progress?: boolean
    cpuTimeMs?: boolean
    memoryUsageMb?: boolean
    queuedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processingJob"]>

  export type ProcessingJobSelectScalar = {
    id?: boolean
    userId?: boolean
    uploadId?: boolean
    jobType?: boolean
    priority?: boolean
    processingOptions?: boolean
    status?: boolean
    progress?: boolean
    cpuTimeMs?: boolean
    memoryUsageMb?: boolean
    queuedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    maxRetries?: boolean
  }

  export type ProcessingJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }
  export type ProcessingJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }

  export type $ProcessingJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessingJob"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      upload: Prisma.$AudioUploadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      uploadId: string
      jobType: string
      priority: number
      processingOptions: Prisma.JsonValue
      status: string
      progress: number
      cpuTimeMs: bigint | null
      memoryUsageMb: number | null
      queuedAt: Date
      startedAt: Date | null
      completedAt: Date | null
      errorMessage: string | null
      retryCount: number
      maxRetries: number
    }, ExtArgs["result"]["processingJob"]>
    composites: {}
  }

  type ProcessingJobGetPayload<S extends boolean | null | undefined | ProcessingJobDefaultArgs> = $Result.GetResult<Prisma.$ProcessingJobPayload, S>

  type ProcessingJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessingJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessingJobCountAggregateInputType | true
    }

  export interface ProcessingJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessingJob'], meta: { name: 'ProcessingJob' } }
    /**
     * Find zero or one ProcessingJob that matches the filter.
     * @param {ProcessingJobFindUniqueArgs} args - Arguments to find a ProcessingJob
     * @example
     * // Get one ProcessingJob
     * const processingJob = await prisma.processingJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessingJobFindUniqueArgs>(args: SelectSubset<T, ProcessingJobFindUniqueArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProcessingJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessingJobFindUniqueOrThrowArgs} args - Arguments to find a ProcessingJob
     * @example
     * // Get one ProcessingJob
     * const processingJob = await prisma.processingJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessingJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessingJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProcessingJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobFindFirstArgs} args - Arguments to find a ProcessingJob
     * @example
     * // Get one ProcessingJob
     * const processingJob = await prisma.processingJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessingJobFindFirstArgs>(args?: SelectSubset<T, ProcessingJobFindFirstArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProcessingJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobFindFirstOrThrowArgs} args - Arguments to find a ProcessingJob
     * @example
     * // Get one ProcessingJob
     * const processingJob = await prisma.processingJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessingJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessingJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProcessingJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessingJobs
     * const processingJobs = await prisma.processingJob.findMany()
     * 
     * // Get first 10 ProcessingJobs
     * const processingJobs = await prisma.processingJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processingJobWithIdOnly = await prisma.processingJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessingJobFindManyArgs>(args?: SelectSubset<T, ProcessingJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProcessingJob.
     * @param {ProcessingJobCreateArgs} args - Arguments to create a ProcessingJob.
     * @example
     * // Create one ProcessingJob
     * const ProcessingJob = await prisma.processingJob.create({
     *   data: {
     *     // ... data to create a ProcessingJob
     *   }
     * })
     * 
     */
    create<T extends ProcessingJobCreateArgs>(args: SelectSubset<T, ProcessingJobCreateArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProcessingJobs.
     * @param {ProcessingJobCreateManyArgs} args - Arguments to create many ProcessingJobs.
     * @example
     * // Create many ProcessingJobs
     * const processingJob = await prisma.processingJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessingJobCreateManyArgs>(args?: SelectSubset<T, ProcessingJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessingJobs and returns the data saved in the database.
     * @param {ProcessingJobCreateManyAndReturnArgs} args - Arguments to create many ProcessingJobs.
     * @example
     * // Create many ProcessingJobs
     * const processingJob = await prisma.processingJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessingJobs and only return the `id`
     * const processingJobWithIdOnly = await prisma.processingJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessingJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessingJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProcessingJob.
     * @param {ProcessingJobDeleteArgs} args - Arguments to delete one ProcessingJob.
     * @example
     * // Delete one ProcessingJob
     * const ProcessingJob = await prisma.processingJob.delete({
     *   where: {
     *     // ... filter to delete one ProcessingJob
     *   }
     * })
     * 
     */
    delete<T extends ProcessingJobDeleteArgs>(args: SelectSubset<T, ProcessingJobDeleteArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProcessingJob.
     * @param {ProcessingJobUpdateArgs} args - Arguments to update one ProcessingJob.
     * @example
     * // Update one ProcessingJob
     * const processingJob = await prisma.processingJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessingJobUpdateArgs>(args: SelectSubset<T, ProcessingJobUpdateArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProcessingJobs.
     * @param {ProcessingJobDeleteManyArgs} args - Arguments to filter ProcessingJobs to delete.
     * @example
     * // Delete a few ProcessingJobs
     * const { count } = await prisma.processingJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessingJobDeleteManyArgs>(args?: SelectSubset<T, ProcessingJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessingJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessingJobs
     * const processingJob = await prisma.processingJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessingJobUpdateManyArgs>(args: SelectSubset<T, ProcessingJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessingJob.
     * @param {ProcessingJobUpsertArgs} args - Arguments to update or create a ProcessingJob.
     * @example
     * // Update or create a ProcessingJob
     * const processingJob = await prisma.processingJob.upsert({
     *   create: {
     *     // ... data to create a ProcessingJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessingJob we want to update
     *   }
     * })
     */
    upsert<T extends ProcessingJobUpsertArgs>(args: SelectSubset<T, ProcessingJobUpsertArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProcessingJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobCountArgs} args - Arguments to filter ProcessingJobs to count.
     * @example
     * // Count the number of ProcessingJobs
     * const count = await prisma.processingJob.count({
     *   where: {
     *     // ... the filter for the ProcessingJobs we want to count
     *   }
     * })
    **/
    count<T extends ProcessingJobCountArgs>(
      args?: Subset<T, ProcessingJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessingJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessingJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessingJobAggregateArgs>(args: Subset<T, ProcessingJobAggregateArgs>): Prisma.PrismaPromise<GetProcessingJobAggregateType<T>>

    /**
     * Group by ProcessingJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessingJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessingJobGroupByArgs['orderBy'] }
        : { orderBy?: ProcessingJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessingJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessingJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessingJob model
   */
  readonly fields: ProcessingJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessingJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessingJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    upload<T extends AudioUploadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AudioUploadDefaultArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessingJob model
   */ 
  interface ProcessingJobFieldRefs {
    readonly id: FieldRef<"ProcessingJob", 'String'>
    readonly userId: FieldRef<"ProcessingJob", 'String'>
    readonly uploadId: FieldRef<"ProcessingJob", 'String'>
    readonly jobType: FieldRef<"ProcessingJob", 'String'>
    readonly priority: FieldRef<"ProcessingJob", 'Int'>
    readonly processingOptions: FieldRef<"ProcessingJob", 'Json'>
    readonly status: FieldRef<"ProcessingJob", 'String'>
    readonly progress: FieldRef<"ProcessingJob", 'Float'>
    readonly cpuTimeMs: FieldRef<"ProcessingJob", 'BigInt'>
    readonly memoryUsageMb: FieldRef<"ProcessingJob", 'Int'>
    readonly queuedAt: FieldRef<"ProcessingJob", 'DateTime'>
    readonly startedAt: FieldRef<"ProcessingJob", 'DateTime'>
    readonly completedAt: FieldRef<"ProcessingJob", 'DateTime'>
    readonly errorMessage: FieldRef<"ProcessingJob", 'String'>
    readonly retryCount: FieldRef<"ProcessingJob", 'Int'>
    readonly maxRetries: FieldRef<"ProcessingJob", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProcessingJob findUnique
   */
  export type ProcessingJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingJob to fetch.
     */
    where: ProcessingJobWhereUniqueInput
  }

  /**
   * ProcessingJob findUniqueOrThrow
   */
  export type ProcessingJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingJob to fetch.
     */
    where: ProcessingJobWhereUniqueInput
  }

  /**
   * ProcessingJob findFirst
   */
  export type ProcessingJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingJob to fetch.
     */
    where?: ProcessingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingJobs to fetch.
     */
    orderBy?: ProcessingJobOrderByWithRelationInput | ProcessingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessingJobs.
     */
    cursor?: ProcessingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessingJobs.
     */
    distinct?: ProcessingJobScalarFieldEnum | ProcessingJobScalarFieldEnum[]
  }

  /**
   * ProcessingJob findFirstOrThrow
   */
  export type ProcessingJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingJob to fetch.
     */
    where?: ProcessingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingJobs to fetch.
     */
    orderBy?: ProcessingJobOrderByWithRelationInput | ProcessingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessingJobs.
     */
    cursor?: ProcessingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessingJobs.
     */
    distinct?: ProcessingJobScalarFieldEnum | ProcessingJobScalarFieldEnum[]
  }

  /**
   * ProcessingJob findMany
   */
  export type ProcessingJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingJobs to fetch.
     */
    where?: ProcessingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingJobs to fetch.
     */
    orderBy?: ProcessingJobOrderByWithRelationInput | ProcessingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessingJobs.
     */
    cursor?: ProcessingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingJobs.
     */
    skip?: number
    distinct?: ProcessingJobScalarFieldEnum | ProcessingJobScalarFieldEnum[]
  }

  /**
   * ProcessingJob create
   */
  export type ProcessingJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessingJob.
     */
    data: XOR<ProcessingJobCreateInput, ProcessingJobUncheckedCreateInput>
  }

  /**
   * ProcessingJob createMany
   */
  export type ProcessingJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessingJobs.
     */
    data: ProcessingJobCreateManyInput | ProcessingJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessingJob createManyAndReturn
   */
  export type ProcessingJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProcessingJobs.
     */
    data: ProcessingJobCreateManyInput | ProcessingJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessingJob update
   */
  export type ProcessingJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessingJob.
     */
    data: XOR<ProcessingJobUpdateInput, ProcessingJobUncheckedUpdateInput>
    /**
     * Choose, which ProcessingJob to update.
     */
    where: ProcessingJobWhereUniqueInput
  }

  /**
   * ProcessingJob updateMany
   */
  export type ProcessingJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessingJobs.
     */
    data: XOR<ProcessingJobUpdateManyMutationInput, ProcessingJobUncheckedUpdateManyInput>
    /**
     * Filter which ProcessingJobs to update
     */
    where?: ProcessingJobWhereInput
  }

  /**
   * ProcessingJob upsert
   */
  export type ProcessingJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessingJob to update in case it exists.
     */
    where: ProcessingJobWhereUniqueInput
    /**
     * In case the ProcessingJob found by the `where` argument doesn't exist, create a new ProcessingJob with this data.
     */
    create: XOR<ProcessingJobCreateInput, ProcessingJobUncheckedCreateInput>
    /**
     * In case the ProcessingJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessingJobUpdateInput, ProcessingJobUncheckedUpdateInput>
  }

  /**
   * ProcessingJob delete
   */
  export type ProcessingJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * Filter which ProcessingJob to delete.
     */
    where: ProcessingJobWhereUniqueInput
  }

  /**
   * ProcessingJob deleteMany
   */
  export type ProcessingJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessingJobs to delete
     */
    where?: ProcessingJobWhereInput
  }

  /**
   * ProcessingJob without action
   */
  export type ProcessingJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
  }


  /**
   * Model AudioHistory
   */

  export type AggregateAudioHistory = {
    _count: AudioHistoryCountAggregateOutputType | null
    _avg: AudioHistoryAvgAggregateOutputType | null
    _sum: AudioHistorySumAggregateOutputType | null
    _min: AudioHistoryMinAggregateOutputType | null
    _max: AudioHistoryMaxAggregateOutputType | null
  }

  export type AudioHistoryAvgAggregateOutputType = {
    fileSizeBytes: number | null
    durationSeconds: number | null
    confidence: number | null
    wordCount: number | null
    speakerCount: number | null
    processingTime: number | null
    transcriptionCost: Decimal | null
    summarizationCost: Decimal | null
    totalCost: Decimal | null
  }

  export type AudioHistorySumAggregateOutputType = {
    fileSizeBytes: bigint | null
    durationSeconds: number | null
    confidence: number | null
    wordCount: number | null
    speakerCount: number | null
    processingTime: number | null
    transcriptionCost: Decimal | null
    summarizationCost: Decimal | null
    totalCost: Decimal | null
  }

  export type AudioHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    uploadId: string | null
    title: string | null
    audioUrl: string | null
    cdnUrl: string | null
    fileSizeBytes: bigint | null
    durationSeconds: number | null
    transcript: string | null
    summary: string | null
    language: string | null
    confidence: number | null
    wordCount: number | null
    speakerCount: number | null
    processingTime: number | null
    apiProvider: string | null
    modelVersion: string | null
    transcriptionCost: Decimal | null
    summarizationCost: Decimal | null
    totalCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AudioHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    uploadId: string | null
    title: string | null
    audioUrl: string | null
    cdnUrl: string | null
    fileSizeBytes: bigint | null
    durationSeconds: number | null
    transcript: string | null
    summary: string | null
    language: string | null
    confidence: number | null
    wordCount: number | null
    speakerCount: number | null
    processingTime: number | null
    apiProvider: string | null
    modelVersion: string | null
    transcriptionCost: Decimal | null
    summarizationCost: Decimal | null
    totalCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AudioHistoryCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    uploadId: number
    title: number
    audioUrl: number
    cdnUrl: number
    fileSizeBytes: number
    durationSeconds: number
    transcript: number
    summary: number
    keyMoments: number
    language: number
    confidence: number
    wordCount: number
    speakerCount: number
    processingOptions: number
    processingTime: number
    apiProvider: number
    modelVersion: number
    transcriptionCost: number
    summarizationCost: number
    totalCost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AudioHistoryAvgAggregateInputType = {
    fileSizeBytes?: true
    durationSeconds?: true
    confidence?: true
    wordCount?: true
    speakerCount?: true
    processingTime?: true
    transcriptionCost?: true
    summarizationCost?: true
    totalCost?: true
  }

  export type AudioHistorySumAggregateInputType = {
    fileSizeBytes?: true
    durationSeconds?: true
    confidence?: true
    wordCount?: true
    speakerCount?: true
    processingTime?: true
    transcriptionCost?: true
    summarizationCost?: true
    totalCost?: true
  }

  export type AudioHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    uploadId?: true
    title?: true
    audioUrl?: true
    cdnUrl?: true
    fileSizeBytes?: true
    durationSeconds?: true
    transcript?: true
    summary?: true
    language?: true
    confidence?: true
    wordCount?: true
    speakerCount?: true
    processingTime?: true
    apiProvider?: true
    modelVersion?: true
    transcriptionCost?: true
    summarizationCost?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AudioHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    uploadId?: true
    title?: true
    audioUrl?: true
    cdnUrl?: true
    fileSizeBytes?: true
    durationSeconds?: true
    transcript?: true
    summary?: true
    language?: true
    confidence?: true
    wordCount?: true
    speakerCount?: true
    processingTime?: true
    apiProvider?: true
    modelVersion?: true
    transcriptionCost?: true
    summarizationCost?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AudioHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    uploadId?: true
    title?: true
    audioUrl?: true
    cdnUrl?: true
    fileSizeBytes?: true
    durationSeconds?: true
    transcript?: true
    summary?: true
    keyMoments?: true
    language?: true
    confidence?: true
    wordCount?: true
    speakerCount?: true
    processingOptions?: true
    processingTime?: true
    apiProvider?: true
    modelVersion?: true
    transcriptionCost?: true
    summarizationCost?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AudioHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioHistory to aggregate.
     */
    where?: AudioHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioHistories to fetch.
     */
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioHistories
    **/
    _count?: true | AudioHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioHistoryMaxAggregateInputType
  }

  export type GetAudioHistoryAggregateType<T extends AudioHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioHistory[P]>
      : GetScalarType<T[P], AggregateAudioHistory[P]>
  }




  export type AudioHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioHistoryWhereInput
    orderBy?: AudioHistoryOrderByWithAggregationInput | AudioHistoryOrderByWithAggregationInput[]
    by: AudioHistoryScalarFieldEnum[] | AudioHistoryScalarFieldEnum
    having?: AudioHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioHistoryCountAggregateInputType | true
    _avg?: AudioHistoryAvgAggregateInputType
    _sum?: AudioHistorySumAggregateInputType
    _min?: AudioHistoryMinAggregateInputType
    _max?: AudioHistoryMaxAggregateInputType
  }

  export type AudioHistoryGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    uploadId: string | null
    title: string | null
    audioUrl: string | null
    cdnUrl: string | null
    fileSizeBytes: bigint | null
    durationSeconds: number | null
    transcript: string | null
    summary: string | null
    keyMoments: JsonValue | null
    language: string | null
    confidence: number | null
    wordCount: number | null
    speakerCount: number | null
    processingOptions: JsonValue | null
    processingTime: number | null
    apiProvider: string | null
    modelVersion: string | null
    transcriptionCost: Decimal | null
    summarizationCost: Decimal | null
    totalCost: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: AudioHistoryCountAggregateOutputType | null
    _avg: AudioHistoryAvgAggregateOutputType | null
    _sum: AudioHistorySumAggregateOutputType | null
    _min: AudioHistoryMinAggregateOutputType | null
    _max: AudioHistoryMaxAggregateOutputType | null
  }

  type GetAudioHistoryGroupByPayload<T extends AudioHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AudioHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AudioHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    uploadId?: boolean
    title?: boolean
    audioUrl?: boolean
    cdnUrl?: boolean
    fileSizeBytes?: boolean
    durationSeconds?: boolean
    transcript?: boolean
    summary?: boolean
    keyMoments?: boolean
    language?: boolean
    confidence?: boolean
    wordCount?: boolean
    speakerCount?: boolean
    processingOptions?: boolean
    processingTime?: boolean
    apiProvider?: boolean
    modelVersion?: boolean
    transcriptionCost?: boolean
    summarizationCost?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioHistory$workspaceArgs<ExtArgs>
    upload?: boolean | AudioHistory$uploadArgs<ExtArgs>
    segments?: boolean | AudioHistory$segmentsArgs<ExtArgs>
    _count?: boolean | AudioHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioHistory"]>

  export type AudioHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    uploadId?: boolean
    title?: boolean
    audioUrl?: boolean
    cdnUrl?: boolean
    fileSizeBytes?: boolean
    durationSeconds?: boolean
    transcript?: boolean
    summary?: boolean
    keyMoments?: boolean
    language?: boolean
    confidence?: boolean
    wordCount?: boolean
    speakerCount?: boolean
    processingOptions?: boolean
    processingTime?: boolean
    apiProvider?: boolean
    modelVersion?: boolean
    transcriptionCost?: boolean
    summarizationCost?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioHistory$workspaceArgs<ExtArgs>
    upload?: boolean | AudioHistory$uploadArgs<ExtArgs>
  }, ExtArgs["result"]["audioHistory"]>

  export type AudioHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    uploadId?: boolean
    title?: boolean
    audioUrl?: boolean
    cdnUrl?: boolean
    fileSizeBytes?: boolean
    durationSeconds?: boolean
    transcript?: boolean
    summary?: boolean
    keyMoments?: boolean
    language?: boolean
    confidence?: boolean
    wordCount?: boolean
    speakerCount?: boolean
    processingOptions?: boolean
    processingTime?: boolean
    apiProvider?: boolean
    modelVersion?: boolean
    transcriptionCost?: boolean
    summarizationCost?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AudioHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioHistory$workspaceArgs<ExtArgs>
    upload?: boolean | AudioHistory$uploadArgs<ExtArgs>
    segments?: boolean | AudioHistory$segmentsArgs<ExtArgs>
    _count?: boolean | AudioHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AudioHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioHistory$workspaceArgs<ExtArgs>
    upload?: boolean | AudioHistory$uploadArgs<ExtArgs>
  }

  export type $AudioHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs> | null
      upload: Prisma.$AudioUploadPayload<ExtArgs> | null
      segments: Prisma.$AudioSegmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      uploadId: string | null
      title: string | null
      audioUrl: string | null
      cdnUrl: string | null
      fileSizeBytes: bigint | null
      durationSeconds: number | null
      transcript: string | null
      summary: string | null
      keyMoments: Prisma.JsonValue | null
      language: string | null
      confidence: number | null
      wordCount: number | null
      speakerCount: number | null
      processingOptions: Prisma.JsonValue | null
      processingTime: number | null
      apiProvider: string | null
      modelVersion: string | null
      transcriptionCost: Prisma.Decimal | null
      summarizationCost: Prisma.Decimal | null
      totalCost: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["audioHistory"]>
    composites: {}
  }

  type AudioHistoryGetPayload<S extends boolean | null | undefined | AudioHistoryDefaultArgs> = $Result.GetResult<Prisma.$AudioHistoryPayload, S>

  type AudioHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AudioHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AudioHistoryCountAggregateInputType | true
    }

  export interface AudioHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioHistory'], meta: { name: 'AudioHistory' } }
    /**
     * Find zero or one AudioHistory that matches the filter.
     * @param {AudioHistoryFindUniqueArgs} args - Arguments to find a AudioHistory
     * @example
     * // Get one AudioHistory
     * const audioHistory = await prisma.audioHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioHistoryFindUniqueArgs>(args: SelectSubset<T, AudioHistoryFindUniqueArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AudioHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AudioHistoryFindUniqueOrThrowArgs} args - Arguments to find a AudioHistory
     * @example
     * // Get one AudioHistory
     * const audioHistory = await prisma.audioHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AudioHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryFindFirstArgs} args - Arguments to find a AudioHistory
     * @example
     * // Get one AudioHistory
     * const audioHistory = await prisma.audioHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioHistoryFindFirstArgs>(args?: SelectSubset<T, AudioHistoryFindFirstArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AudioHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryFindFirstOrThrowArgs} args - Arguments to find a AudioHistory
     * @example
     * // Get one AudioHistory
     * const audioHistory = await prisma.audioHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AudioHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioHistories
     * const audioHistories = await prisma.audioHistory.findMany()
     * 
     * // Get first 10 AudioHistories
     * const audioHistories = await prisma.audioHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioHistoryWithIdOnly = await prisma.audioHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioHistoryFindManyArgs>(args?: SelectSubset<T, AudioHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AudioHistory.
     * @param {AudioHistoryCreateArgs} args - Arguments to create a AudioHistory.
     * @example
     * // Create one AudioHistory
     * const AudioHistory = await prisma.audioHistory.create({
     *   data: {
     *     // ... data to create a AudioHistory
     *   }
     * })
     * 
     */
    create<T extends AudioHistoryCreateArgs>(args: SelectSubset<T, AudioHistoryCreateArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AudioHistories.
     * @param {AudioHistoryCreateManyArgs} args - Arguments to create many AudioHistories.
     * @example
     * // Create many AudioHistories
     * const audioHistory = await prisma.audioHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioHistoryCreateManyArgs>(args?: SelectSubset<T, AudioHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioHistories and returns the data saved in the database.
     * @param {AudioHistoryCreateManyAndReturnArgs} args - Arguments to create many AudioHistories.
     * @example
     * // Create many AudioHistories
     * const audioHistory = await prisma.audioHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioHistories and only return the `id`
     * const audioHistoryWithIdOnly = await prisma.audioHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AudioHistory.
     * @param {AudioHistoryDeleteArgs} args - Arguments to delete one AudioHistory.
     * @example
     * // Delete one AudioHistory
     * const AudioHistory = await prisma.audioHistory.delete({
     *   where: {
     *     // ... filter to delete one AudioHistory
     *   }
     * })
     * 
     */
    delete<T extends AudioHistoryDeleteArgs>(args: SelectSubset<T, AudioHistoryDeleteArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AudioHistory.
     * @param {AudioHistoryUpdateArgs} args - Arguments to update one AudioHistory.
     * @example
     * // Update one AudioHistory
     * const audioHistory = await prisma.audioHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioHistoryUpdateArgs>(args: SelectSubset<T, AudioHistoryUpdateArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AudioHistories.
     * @param {AudioHistoryDeleteManyArgs} args - Arguments to filter AudioHistories to delete.
     * @example
     * // Delete a few AudioHistories
     * const { count } = await prisma.audioHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioHistoryDeleteManyArgs>(args?: SelectSubset<T, AudioHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioHistories
     * const audioHistory = await prisma.audioHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioHistoryUpdateManyArgs>(args: SelectSubset<T, AudioHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AudioHistory.
     * @param {AudioHistoryUpsertArgs} args - Arguments to update or create a AudioHistory.
     * @example
     * // Update or create a AudioHistory
     * const audioHistory = await prisma.audioHistory.upsert({
     *   create: {
     *     // ... data to create a AudioHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioHistory we want to update
     *   }
     * })
     */
    upsert<T extends AudioHistoryUpsertArgs>(args: SelectSubset<T, AudioHistoryUpsertArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AudioHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryCountArgs} args - Arguments to filter AudioHistories to count.
     * @example
     * // Count the number of AudioHistories
     * const count = await prisma.audioHistory.count({
     *   where: {
     *     // ... the filter for the AudioHistories we want to count
     *   }
     * })
    **/
    count<T extends AudioHistoryCountArgs>(
      args?: Subset<T, AudioHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioHistoryAggregateArgs>(args: Subset<T, AudioHistoryAggregateArgs>): Prisma.PrismaPromise<GetAudioHistoryAggregateType<T>>

    /**
     * Group by AudioHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AudioHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioHistory model
   */
  readonly fields: AudioHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workspace<T extends AudioHistory$workspaceArgs<ExtArgs> = {}>(args?: Subset<T, AudioHistory$workspaceArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    upload<T extends AudioHistory$uploadArgs<ExtArgs> = {}>(args?: Subset<T, AudioHistory$uploadArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    segments<T extends AudioHistory$segmentsArgs<ExtArgs> = {}>(args?: Subset<T, AudioHistory$segmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioHistory model
   */ 
  interface AudioHistoryFieldRefs {
    readonly id: FieldRef<"AudioHistory", 'String'>
    readonly userId: FieldRef<"AudioHistory", 'String'>
    readonly workspaceId: FieldRef<"AudioHistory", 'String'>
    readonly uploadId: FieldRef<"AudioHistory", 'String'>
    readonly title: FieldRef<"AudioHistory", 'String'>
    readonly audioUrl: FieldRef<"AudioHistory", 'String'>
    readonly cdnUrl: FieldRef<"AudioHistory", 'String'>
    readonly fileSizeBytes: FieldRef<"AudioHistory", 'BigInt'>
    readonly durationSeconds: FieldRef<"AudioHistory", 'Int'>
    readonly transcript: FieldRef<"AudioHistory", 'String'>
    readonly summary: FieldRef<"AudioHistory", 'String'>
    readonly keyMoments: FieldRef<"AudioHistory", 'Json'>
    readonly language: FieldRef<"AudioHistory", 'String'>
    readonly confidence: FieldRef<"AudioHistory", 'Float'>
    readonly wordCount: FieldRef<"AudioHistory", 'Int'>
    readonly speakerCount: FieldRef<"AudioHistory", 'Int'>
    readonly processingOptions: FieldRef<"AudioHistory", 'Json'>
    readonly processingTime: FieldRef<"AudioHistory", 'Float'>
    readonly apiProvider: FieldRef<"AudioHistory", 'String'>
    readonly modelVersion: FieldRef<"AudioHistory", 'String'>
    readonly transcriptionCost: FieldRef<"AudioHistory", 'Decimal'>
    readonly summarizationCost: FieldRef<"AudioHistory", 'Decimal'>
    readonly totalCost: FieldRef<"AudioHistory", 'Decimal'>
    readonly createdAt: FieldRef<"AudioHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"AudioHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioHistory findUnique
   */
  export type AudioHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AudioHistory to fetch.
     */
    where: AudioHistoryWhereUniqueInput
  }

  /**
   * AudioHistory findUniqueOrThrow
   */
  export type AudioHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AudioHistory to fetch.
     */
    where: AudioHistoryWhereUniqueInput
  }

  /**
   * AudioHistory findFirst
   */
  export type AudioHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AudioHistory to fetch.
     */
    where?: AudioHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioHistories to fetch.
     */
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioHistories.
     */
    cursor?: AudioHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioHistories.
     */
    distinct?: AudioHistoryScalarFieldEnum | AudioHistoryScalarFieldEnum[]
  }

  /**
   * AudioHistory findFirstOrThrow
   */
  export type AudioHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AudioHistory to fetch.
     */
    where?: AudioHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioHistories to fetch.
     */
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioHistories.
     */
    cursor?: AudioHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioHistories.
     */
    distinct?: AudioHistoryScalarFieldEnum | AudioHistoryScalarFieldEnum[]
  }

  /**
   * AudioHistory findMany
   */
  export type AudioHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AudioHistories to fetch.
     */
    where?: AudioHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioHistories to fetch.
     */
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioHistories.
     */
    cursor?: AudioHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioHistories.
     */
    skip?: number
    distinct?: AudioHistoryScalarFieldEnum | AudioHistoryScalarFieldEnum[]
  }

  /**
   * AudioHistory create
   */
  export type AudioHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioHistory.
     */
    data: XOR<AudioHistoryCreateInput, AudioHistoryUncheckedCreateInput>
  }

  /**
   * AudioHistory createMany
   */
  export type AudioHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioHistories.
     */
    data: AudioHistoryCreateManyInput | AudioHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioHistory createManyAndReturn
   */
  export type AudioHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AudioHistories.
     */
    data: AudioHistoryCreateManyInput | AudioHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioHistory update
   */
  export type AudioHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioHistory.
     */
    data: XOR<AudioHistoryUpdateInput, AudioHistoryUncheckedUpdateInput>
    /**
     * Choose, which AudioHistory to update.
     */
    where: AudioHistoryWhereUniqueInput
  }

  /**
   * AudioHistory updateMany
   */
  export type AudioHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioHistories.
     */
    data: XOR<AudioHistoryUpdateManyMutationInput, AudioHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AudioHistories to update
     */
    where?: AudioHistoryWhereInput
  }

  /**
   * AudioHistory upsert
   */
  export type AudioHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioHistory to update in case it exists.
     */
    where: AudioHistoryWhereUniqueInput
    /**
     * In case the AudioHistory found by the `where` argument doesn't exist, create a new AudioHistory with this data.
     */
    create: XOR<AudioHistoryCreateInput, AudioHistoryUncheckedCreateInput>
    /**
     * In case the AudioHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioHistoryUpdateInput, AudioHistoryUncheckedUpdateInput>
  }

  /**
   * AudioHistory delete
   */
  export type AudioHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * Filter which AudioHistory to delete.
     */
    where: AudioHistoryWhereUniqueInput
  }

  /**
   * AudioHistory deleteMany
   */
  export type AudioHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioHistories to delete
     */
    where?: AudioHistoryWhereInput
  }

  /**
   * AudioHistory.workspace
   */
  export type AudioHistory$workspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
  }

  /**
   * AudioHistory.upload
   */
  export type AudioHistory$uploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    where?: AudioUploadWhereInput
  }

  /**
   * AudioHistory.segments
   */
  export type AudioHistory$segmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    where?: AudioSegmentWhereInput
    orderBy?: AudioSegmentOrderByWithRelationInput | AudioSegmentOrderByWithRelationInput[]
    cursor?: AudioSegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioSegmentScalarFieldEnum | AudioSegmentScalarFieldEnum[]
  }

  /**
   * AudioHistory without action
   */
  export type AudioHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AudioSegment
   */

  export type AggregateAudioSegment = {
    _count: AudioSegmentCountAggregateOutputType | null
    _avg: AudioSegmentAvgAggregateOutputType | null
    _sum: AudioSegmentSumAggregateOutputType | null
    _min: AudioSegmentMinAggregateOutputType | null
    _max: AudioSegmentMaxAggregateOutputType | null
  }

  export type AudioSegmentAvgAggregateOutputType = {
    segmentIndex: number | null
    startTime: number | null
    endTime: number | null
    confidence: number | null
    tokens: number | null
    logprobs: number | null
    temperature: number | null
    avgLogprob: number | null
    compressionRatio: number | null
    noSpeechProb: number | null
  }

  export type AudioSegmentSumAggregateOutputType = {
    segmentIndex: number | null
    startTime: number | null
    endTime: number | null
    confidence: number | null
    tokens: number[]
    logprobs: number[]
    temperature: number | null
    avgLogprob: number | null
    compressionRatio: number | null
    noSpeechProb: number | null
  }

  export type AudioSegmentMinAggregateOutputType = {
    id: string | null
    historyId: string | null
    segmentIndex: number | null
    startTime: number | null
    endTime: number | null
    text: string | null
    confidence: number | null
    language: string | null
    speakerId: string | null
    emotion: string | null
    sentiment: string | null
    temperature: number | null
    avgLogprob: number | null
    compressionRatio: number | null
    noSpeechProb: number | null
  }

  export type AudioSegmentMaxAggregateOutputType = {
    id: string | null
    historyId: string | null
    segmentIndex: number | null
    startTime: number | null
    endTime: number | null
    text: string | null
    confidence: number | null
    language: string | null
    speakerId: string | null
    emotion: string | null
    sentiment: string | null
    temperature: number | null
    avgLogprob: number | null
    compressionRatio: number | null
    noSpeechProb: number | null
  }

  export type AudioSegmentCountAggregateOutputType = {
    id: number
    historyId: number
    segmentIndex: number
    startTime: number
    endTime: number
    text: number
    confidence: number
    language: number
    speakerId: number
    emotion: number
    sentiment: number
    tokens: number
    logprobs: number
    temperature: number
    avgLogprob: number
    compressionRatio: number
    noSpeechProb: number
    _all: number
  }


  export type AudioSegmentAvgAggregateInputType = {
    segmentIndex?: true
    startTime?: true
    endTime?: true
    confidence?: true
    tokens?: true
    logprobs?: true
    temperature?: true
    avgLogprob?: true
    compressionRatio?: true
    noSpeechProb?: true
  }

  export type AudioSegmentSumAggregateInputType = {
    segmentIndex?: true
    startTime?: true
    endTime?: true
    confidence?: true
    tokens?: true
    logprobs?: true
    temperature?: true
    avgLogprob?: true
    compressionRatio?: true
    noSpeechProb?: true
  }

  export type AudioSegmentMinAggregateInputType = {
    id?: true
    historyId?: true
    segmentIndex?: true
    startTime?: true
    endTime?: true
    text?: true
    confidence?: true
    language?: true
    speakerId?: true
    emotion?: true
    sentiment?: true
    temperature?: true
    avgLogprob?: true
    compressionRatio?: true
    noSpeechProb?: true
  }

  export type AudioSegmentMaxAggregateInputType = {
    id?: true
    historyId?: true
    segmentIndex?: true
    startTime?: true
    endTime?: true
    text?: true
    confidence?: true
    language?: true
    speakerId?: true
    emotion?: true
    sentiment?: true
    temperature?: true
    avgLogprob?: true
    compressionRatio?: true
    noSpeechProb?: true
  }

  export type AudioSegmentCountAggregateInputType = {
    id?: true
    historyId?: true
    segmentIndex?: true
    startTime?: true
    endTime?: true
    text?: true
    confidence?: true
    language?: true
    speakerId?: true
    emotion?: true
    sentiment?: true
    tokens?: true
    logprobs?: true
    temperature?: true
    avgLogprob?: true
    compressionRatio?: true
    noSpeechProb?: true
    _all?: true
  }

  export type AudioSegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioSegment to aggregate.
     */
    where?: AudioSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioSegments to fetch.
     */
    orderBy?: AudioSegmentOrderByWithRelationInput | AudioSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioSegments
    **/
    _count?: true | AudioSegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioSegmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioSegmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioSegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioSegmentMaxAggregateInputType
  }

  export type GetAudioSegmentAggregateType<T extends AudioSegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioSegment[P]>
      : GetScalarType<T[P], AggregateAudioSegment[P]>
  }




  export type AudioSegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioSegmentWhereInput
    orderBy?: AudioSegmentOrderByWithAggregationInput | AudioSegmentOrderByWithAggregationInput[]
    by: AudioSegmentScalarFieldEnum[] | AudioSegmentScalarFieldEnum
    having?: AudioSegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioSegmentCountAggregateInputType | true
    _avg?: AudioSegmentAvgAggregateInputType
    _sum?: AudioSegmentSumAggregateInputType
    _min?: AudioSegmentMinAggregateInputType
    _max?: AudioSegmentMaxAggregateInputType
  }

  export type AudioSegmentGroupByOutputType = {
    id: string
    historyId: string
    segmentIndex: number
    startTime: number
    endTime: number
    text: string
    confidence: number | null
    language: string | null
    speakerId: string | null
    emotion: string | null
    sentiment: string | null
    tokens: number[]
    logprobs: number[]
    temperature: number | null
    avgLogprob: number | null
    compressionRatio: number | null
    noSpeechProb: number | null
    _count: AudioSegmentCountAggregateOutputType | null
    _avg: AudioSegmentAvgAggregateOutputType | null
    _sum: AudioSegmentSumAggregateOutputType | null
    _min: AudioSegmentMinAggregateOutputType | null
    _max: AudioSegmentMaxAggregateOutputType | null
  }

  type GetAudioSegmentGroupByPayload<T extends AudioSegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioSegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioSegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioSegmentGroupByOutputType[P]>
            : GetScalarType<T[P], AudioSegmentGroupByOutputType[P]>
        }
      >
    >


  export type AudioSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    historyId?: boolean
    segmentIndex?: boolean
    startTime?: boolean
    endTime?: boolean
    text?: boolean
    confidence?: boolean
    language?: boolean
    speakerId?: boolean
    emotion?: boolean
    sentiment?: boolean
    tokens?: boolean
    logprobs?: boolean
    temperature?: boolean
    avgLogprob?: boolean
    compressionRatio?: boolean
    noSpeechProb?: boolean
    history?: boolean | AudioHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioSegment"]>

  export type AudioSegmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    historyId?: boolean
    segmentIndex?: boolean
    startTime?: boolean
    endTime?: boolean
    text?: boolean
    confidence?: boolean
    language?: boolean
    speakerId?: boolean
    emotion?: boolean
    sentiment?: boolean
    tokens?: boolean
    logprobs?: boolean
    temperature?: boolean
    avgLogprob?: boolean
    compressionRatio?: boolean
    noSpeechProb?: boolean
    history?: boolean | AudioHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioSegment"]>

  export type AudioSegmentSelectScalar = {
    id?: boolean
    historyId?: boolean
    segmentIndex?: boolean
    startTime?: boolean
    endTime?: boolean
    text?: boolean
    confidence?: boolean
    language?: boolean
    speakerId?: boolean
    emotion?: boolean
    sentiment?: boolean
    tokens?: boolean
    logprobs?: boolean
    temperature?: boolean
    avgLogprob?: boolean
    compressionRatio?: boolean
    noSpeechProb?: boolean
  }

  export type AudioSegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | AudioHistoryDefaultArgs<ExtArgs>
  }
  export type AudioSegmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | AudioHistoryDefaultArgs<ExtArgs>
  }

  export type $AudioSegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioSegment"
    objects: {
      history: Prisma.$AudioHistoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      historyId: string
      segmentIndex: number
      startTime: number
      endTime: number
      text: string
      confidence: number | null
      language: string | null
      speakerId: string | null
      emotion: string | null
      sentiment: string | null
      tokens: number[]
      logprobs: number[]
      temperature: number | null
      avgLogprob: number | null
      compressionRatio: number | null
      noSpeechProb: number | null
    }, ExtArgs["result"]["audioSegment"]>
    composites: {}
  }

  type AudioSegmentGetPayload<S extends boolean | null | undefined | AudioSegmentDefaultArgs> = $Result.GetResult<Prisma.$AudioSegmentPayload, S>

  type AudioSegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AudioSegmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AudioSegmentCountAggregateInputType | true
    }

  export interface AudioSegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioSegment'], meta: { name: 'AudioSegment' } }
    /**
     * Find zero or one AudioSegment that matches the filter.
     * @param {AudioSegmentFindUniqueArgs} args - Arguments to find a AudioSegment
     * @example
     * // Get one AudioSegment
     * const audioSegment = await prisma.audioSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioSegmentFindUniqueArgs>(args: SelectSubset<T, AudioSegmentFindUniqueArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AudioSegment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AudioSegmentFindUniqueOrThrowArgs} args - Arguments to find a AudioSegment
     * @example
     * // Get one AudioSegment
     * const audioSegment = await prisma.audioSegment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioSegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioSegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AudioSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentFindFirstArgs} args - Arguments to find a AudioSegment
     * @example
     * // Get one AudioSegment
     * const audioSegment = await prisma.audioSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioSegmentFindFirstArgs>(args?: SelectSubset<T, AudioSegmentFindFirstArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AudioSegment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentFindFirstOrThrowArgs} args - Arguments to find a AudioSegment
     * @example
     * // Get one AudioSegment
     * const audioSegment = await prisma.audioSegment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioSegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioSegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AudioSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioSegments
     * const audioSegments = await prisma.audioSegment.findMany()
     * 
     * // Get first 10 AudioSegments
     * const audioSegments = await prisma.audioSegment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioSegmentWithIdOnly = await prisma.audioSegment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioSegmentFindManyArgs>(args?: SelectSubset<T, AudioSegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AudioSegment.
     * @param {AudioSegmentCreateArgs} args - Arguments to create a AudioSegment.
     * @example
     * // Create one AudioSegment
     * const AudioSegment = await prisma.audioSegment.create({
     *   data: {
     *     // ... data to create a AudioSegment
     *   }
     * })
     * 
     */
    create<T extends AudioSegmentCreateArgs>(args: SelectSubset<T, AudioSegmentCreateArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AudioSegments.
     * @param {AudioSegmentCreateManyArgs} args - Arguments to create many AudioSegments.
     * @example
     * // Create many AudioSegments
     * const audioSegment = await prisma.audioSegment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioSegmentCreateManyArgs>(args?: SelectSubset<T, AudioSegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioSegments and returns the data saved in the database.
     * @param {AudioSegmentCreateManyAndReturnArgs} args - Arguments to create many AudioSegments.
     * @example
     * // Create many AudioSegments
     * const audioSegment = await prisma.audioSegment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioSegments and only return the `id`
     * const audioSegmentWithIdOnly = await prisma.audioSegment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioSegmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioSegmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AudioSegment.
     * @param {AudioSegmentDeleteArgs} args - Arguments to delete one AudioSegment.
     * @example
     * // Delete one AudioSegment
     * const AudioSegment = await prisma.audioSegment.delete({
     *   where: {
     *     // ... filter to delete one AudioSegment
     *   }
     * })
     * 
     */
    delete<T extends AudioSegmentDeleteArgs>(args: SelectSubset<T, AudioSegmentDeleteArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AudioSegment.
     * @param {AudioSegmentUpdateArgs} args - Arguments to update one AudioSegment.
     * @example
     * // Update one AudioSegment
     * const audioSegment = await prisma.audioSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioSegmentUpdateArgs>(args: SelectSubset<T, AudioSegmentUpdateArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AudioSegments.
     * @param {AudioSegmentDeleteManyArgs} args - Arguments to filter AudioSegments to delete.
     * @example
     * // Delete a few AudioSegments
     * const { count } = await prisma.audioSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioSegmentDeleteManyArgs>(args?: SelectSubset<T, AudioSegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioSegments
     * const audioSegment = await prisma.audioSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioSegmentUpdateManyArgs>(args: SelectSubset<T, AudioSegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AudioSegment.
     * @param {AudioSegmentUpsertArgs} args - Arguments to update or create a AudioSegment.
     * @example
     * // Update or create a AudioSegment
     * const audioSegment = await prisma.audioSegment.upsert({
     *   create: {
     *     // ... data to create a AudioSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioSegment we want to update
     *   }
     * })
     */
    upsert<T extends AudioSegmentUpsertArgs>(args: SelectSubset<T, AudioSegmentUpsertArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AudioSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentCountArgs} args - Arguments to filter AudioSegments to count.
     * @example
     * // Count the number of AudioSegments
     * const count = await prisma.audioSegment.count({
     *   where: {
     *     // ... the filter for the AudioSegments we want to count
     *   }
     * })
    **/
    count<T extends AudioSegmentCountArgs>(
      args?: Subset<T, AudioSegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioSegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioSegmentAggregateArgs>(args: Subset<T, AudioSegmentAggregateArgs>): Prisma.PrismaPromise<GetAudioSegmentAggregateType<T>>

    /**
     * Group by AudioSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioSegmentGroupByArgs['orderBy'] }
        : { orderBy?: AudioSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioSegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioSegment model
   */
  readonly fields: AudioSegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioSegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    history<T extends AudioHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AudioHistoryDefaultArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioSegment model
   */ 
  interface AudioSegmentFieldRefs {
    readonly id: FieldRef<"AudioSegment", 'String'>
    readonly historyId: FieldRef<"AudioSegment", 'String'>
    readonly segmentIndex: FieldRef<"AudioSegment", 'Int'>
    readonly startTime: FieldRef<"AudioSegment", 'Float'>
    readonly endTime: FieldRef<"AudioSegment", 'Float'>
    readonly text: FieldRef<"AudioSegment", 'String'>
    readonly confidence: FieldRef<"AudioSegment", 'Float'>
    readonly language: FieldRef<"AudioSegment", 'String'>
    readonly speakerId: FieldRef<"AudioSegment", 'String'>
    readonly emotion: FieldRef<"AudioSegment", 'String'>
    readonly sentiment: FieldRef<"AudioSegment", 'String'>
    readonly tokens: FieldRef<"AudioSegment", 'Int[]'>
    readonly logprobs: FieldRef<"AudioSegment", 'Float[]'>
    readonly temperature: FieldRef<"AudioSegment", 'Float'>
    readonly avgLogprob: FieldRef<"AudioSegment", 'Float'>
    readonly compressionRatio: FieldRef<"AudioSegment", 'Float'>
    readonly noSpeechProb: FieldRef<"AudioSegment", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * AudioSegment findUnique
   */
  export type AudioSegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudioSegment to fetch.
     */
    where: AudioSegmentWhereUniqueInput
  }

  /**
   * AudioSegment findUniqueOrThrow
   */
  export type AudioSegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudioSegment to fetch.
     */
    where: AudioSegmentWhereUniqueInput
  }

  /**
   * AudioSegment findFirst
   */
  export type AudioSegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudioSegment to fetch.
     */
    where?: AudioSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioSegments to fetch.
     */
    orderBy?: AudioSegmentOrderByWithRelationInput | AudioSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioSegments.
     */
    cursor?: AudioSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioSegments.
     */
    distinct?: AudioSegmentScalarFieldEnum | AudioSegmentScalarFieldEnum[]
  }

  /**
   * AudioSegment findFirstOrThrow
   */
  export type AudioSegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudioSegment to fetch.
     */
    where?: AudioSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioSegments to fetch.
     */
    orderBy?: AudioSegmentOrderByWithRelationInput | AudioSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioSegments.
     */
    cursor?: AudioSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioSegments.
     */
    distinct?: AudioSegmentScalarFieldEnum | AudioSegmentScalarFieldEnum[]
  }

  /**
   * AudioSegment findMany
   */
  export type AudioSegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudioSegments to fetch.
     */
    where?: AudioSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioSegments to fetch.
     */
    orderBy?: AudioSegmentOrderByWithRelationInput | AudioSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioSegments.
     */
    cursor?: AudioSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioSegments.
     */
    skip?: number
    distinct?: AudioSegmentScalarFieldEnum | AudioSegmentScalarFieldEnum[]
  }

  /**
   * AudioSegment create
   */
  export type AudioSegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioSegment.
     */
    data: XOR<AudioSegmentCreateInput, AudioSegmentUncheckedCreateInput>
  }

  /**
   * AudioSegment createMany
   */
  export type AudioSegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioSegments.
     */
    data: AudioSegmentCreateManyInput | AudioSegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioSegment createManyAndReturn
   */
  export type AudioSegmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AudioSegments.
     */
    data: AudioSegmentCreateManyInput | AudioSegmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioSegment update
   */
  export type AudioSegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioSegment.
     */
    data: XOR<AudioSegmentUpdateInput, AudioSegmentUncheckedUpdateInput>
    /**
     * Choose, which AudioSegment to update.
     */
    where: AudioSegmentWhereUniqueInput
  }

  /**
   * AudioSegment updateMany
   */
  export type AudioSegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioSegments.
     */
    data: XOR<AudioSegmentUpdateManyMutationInput, AudioSegmentUncheckedUpdateManyInput>
    /**
     * Filter which AudioSegments to update
     */
    where?: AudioSegmentWhereInput
  }

  /**
   * AudioSegment upsert
   */
  export type AudioSegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioSegment to update in case it exists.
     */
    where: AudioSegmentWhereUniqueInput
    /**
     * In case the AudioSegment found by the `where` argument doesn't exist, create a new AudioSegment with this data.
     */
    create: XOR<AudioSegmentCreateInput, AudioSegmentUncheckedCreateInput>
    /**
     * In case the AudioSegment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioSegmentUpdateInput, AudioSegmentUncheckedUpdateInput>
  }

  /**
   * AudioSegment delete
   */
  export type AudioSegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * Filter which AudioSegment to delete.
     */
    where: AudioSegmentWhereUniqueInput
  }

  /**
   * AudioSegment deleteMany
   */
  export type AudioSegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioSegments to delete
     */
    where?: AudioSegmentWhereInput
  }

  /**
   * AudioSegment without action
   */
  export type AudioSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
  }


  /**
   * Model AudioChunk
   */

  export type AggregateAudioChunk = {
    _count: AudioChunkCountAggregateOutputType | null
    _avg: AudioChunkAvgAggregateOutputType | null
    _sum: AudioChunkSumAggregateOutputType | null
    _min: AudioChunkMinAggregateOutputType | null
    _max: AudioChunkMaxAggregateOutputType | null
  }

  export type AudioChunkAvgAggregateOutputType = {
    chunkIndex: number | null
    startTime: number | null
    endTime: number | null
    fileSize: number | null
  }

  export type AudioChunkSumAggregateOutputType = {
    chunkIndex: number | null
    startTime: number | null
    endTime: number | null
    fileSize: bigint | null
  }

  export type AudioChunkMinAggregateOutputType = {
    id: string | null
    uploadId: string | null
    chunkIndex: number | null
    startTime: number | null
    endTime: number | null
    fileSize: bigint | null
    storagePath: string | null
    checksumMd5: string | null
    status: string | null
    processedAt: Date | null
  }

  export type AudioChunkMaxAggregateOutputType = {
    id: string | null
    uploadId: string | null
    chunkIndex: number | null
    startTime: number | null
    endTime: number | null
    fileSize: bigint | null
    storagePath: string | null
    checksumMd5: string | null
    status: string | null
    processedAt: Date | null
  }

  export type AudioChunkCountAggregateOutputType = {
    id: number
    uploadId: number
    chunkIndex: number
    startTime: number
    endTime: number
    fileSize: number
    storagePath: number
    checksumMd5: number
    status: number
    processedAt: number
    _all: number
  }


  export type AudioChunkAvgAggregateInputType = {
    chunkIndex?: true
    startTime?: true
    endTime?: true
    fileSize?: true
  }

  export type AudioChunkSumAggregateInputType = {
    chunkIndex?: true
    startTime?: true
    endTime?: true
    fileSize?: true
  }

  export type AudioChunkMinAggregateInputType = {
    id?: true
    uploadId?: true
    chunkIndex?: true
    startTime?: true
    endTime?: true
    fileSize?: true
    storagePath?: true
    checksumMd5?: true
    status?: true
    processedAt?: true
  }

  export type AudioChunkMaxAggregateInputType = {
    id?: true
    uploadId?: true
    chunkIndex?: true
    startTime?: true
    endTime?: true
    fileSize?: true
    storagePath?: true
    checksumMd5?: true
    status?: true
    processedAt?: true
  }

  export type AudioChunkCountAggregateInputType = {
    id?: true
    uploadId?: true
    chunkIndex?: true
    startTime?: true
    endTime?: true
    fileSize?: true
    storagePath?: true
    checksumMd5?: true
    status?: true
    processedAt?: true
    _all?: true
  }

  export type AudioChunkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioChunk to aggregate.
     */
    where?: AudioChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioChunks to fetch.
     */
    orderBy?: AudioChunkOrderByWithRelationInput | AudioChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioChunks
    **/
    _count?: true | AudioChunkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioChunkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioChunkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioChunkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioChunkMaxAggregateInputType
  }

  export type GetAudioChunkAggregateType<T extends AudioChunkAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioChunk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioChunk[P]>
      : GetScalarType<T[P], AggregateAudioChunk[P]>
  }




  export type AudioChunkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioChunkWhereInput
    orderBy?: AudioChunkOrderByWithAggregationInput | AudioChunkOrderByWithAggregationInput[]
    by: AudioChunkScalarFieldEnum[] | AudioChunkScalarFieldEnum
    having?: AudioChunkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioChunkCountAggregateInputType | true
    _avg?: AudioChunkAvgAggregateInputType
    _sum?: AudioChunkSumAggregateInputType
    _min?: AudioChunkMinAggregateInputType
    _max?: AudioChunkMaxAggregateInputType
  }

  export type AudioChunkGroupByOutputType = {
    id: string
    uploadId: string
    chunkIndex: number
    startTime: number
    endTime: number
    fileSize: bigint
    storagePath: string
    checksumMd5: string | null
    status: string
    processedAt: Date | null
    _count: AudioChunkCountAggregateOutputType | null
    _avg: AudioChunkAvgAggregateOutputType | null
    _sum: AudioChunkSumAggregateOutputType | null
    _min: AudioChunkMinAggregateOutputType | null
    _max: AudioChunkMaxAggregateOutputType | null
  }

  type GetAudioChunkGroupByPayload<T extends AudioChunkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioChunkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioChunkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioChunkGroupByOutputType[P]>
            : GetScalarType<T[P], AudioChunkGroupByOutputType[P]>
        }
      >
    >


  export type AudioChunkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploadId?: boolean
    chunkIndex?: boolean
    startTime?: boolean
    endTime?: boolean
    fileSize?: boolean
    storagePath?: boolean
    checksumMd5?: boolean
    status?: boolean
    processedAt?: boolean
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioChunk"]>

  export type AudioChunkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploadId?: boolean
    chunkIndex?: boolean
    startTime?: boolean
    endTime?: boolean
    fileSize?: boolean
    storagePath?: boolean
    checksumMd5?: boolean
    status?: boolean
    processedAt?: boolean
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioChunk"]>

  export type AudioChunkSelectScalar = {
    id?: boolean
    uploadId?: boolean
    chunkIndex?: boolean
    startTime?: boolean
    endTime?: boolean
    fileSize?: boolean
    storagePath?: boolean
    checksumMd5?: boolean
    status?: boolean
    processedAt?: boolean
  }

  export type AudioChunkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }
  export type AudioChunkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }

  export type $AudioChunkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioChunk"
    objects: {
      upload: Prisma.$AudioUploadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uploadId: string
      chunkIndex: number
      startTime: number
      endTime: number
      fileSize: bigint
      storagePath: string
      checksumMd5: string | null
      status: string
      processedAt: Date | null
    }, ExtArgs["result"]["audioChunk"]>
    composites: {}
  }

  type AudioChunkGetPayload<S extends boolean | null | undefined | AudioChunkDefaultArgs> = $Result.GetResult<Prisma.$AudioChunkPayload, S>

  type AudioChunkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AudioChunkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AudioChunkCountAggregateInputType | true
    }

  export interface AudioChunkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioChunk'], meta: { name: 'AudioChunk' } }
    /**
     * Find zero or one AudioChunk that matches the filter.
     * @param {AudioChunkFindUniqueArgs} args - Arguments to find a AudioChunk
     * @example
     * // Get one AudioChunk
     * const audioChunk = await prisma.audioChunk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioChunkFindUniqueArgs>(args: SelectSubset<T, AudioChunkFindUniqueArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AudioChunk that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AudioChunkFindUniqueOrThrowArgs} args - Arguments to find a AudioChunk
     * @example
     * // Get one AudioChunk
     * const audioChunk = await prisma.audioChunk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioChunkFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioChunkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AudioChunk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkFindFirstArgs} args - Arguments to find a AudioChunk
     * @example
     * // Get one AudioChunk
     * const audioChunk = await prisma.audioChunk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioChunkFindFirstArgs>(args?: SelectSubset<T, AudioChunkFindFirstArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AudioChunk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkFindFirstOrThrowArgs} args - Arguments to find a AudioChunk
     * @example
     * // Get one AudioChunk
     * const audioChunk = await prisma.audioChunk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioChunkFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioChunkFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AudioChunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioChunks
     * const audioChunks = await prisma.audioChunk.findMany()
     * 
     * // Get first 10 AudioChunks
     * const audioChunks = await prisma.audioChunk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioChunkWithIdOnly = await prisma.audioChunk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioChunkFindManyArgs>(args?: SelectSubset<T, AudioChunkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AudioChunk.
     * @param {AudioChunkCreateArgs} args - Arguments to create a AudioChunk.
     * @example
     * // Create one AudioChunk
     * const AudioChunk = await prisma.audioChunk.create({
     *   data: {
     *     // ... data to create a AudioChunk
     *   }
     * })
     * 
     */
    create<T extends AudioChunkCreateArgs>(args: SelectSubset<T, AudioChunkCreateArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AudioChunks.
     * @param {AudioChunkCreateManyArgs} args - Arguments to create many AudioChunks.
     * @example
     * // Create many AudioChunks
     * const audioChunk = await prisma.audioChunk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioChunkCreateManyArgs>(args?: SelectSubset<T, AudioChunkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioChunks and returns the data saved in the database.
     * @param {AudioChunkCreateManyAndReturnArgs} args - Arguments to create many AudioChunks.
     * @example
     * // Create many AudioChunks
     * const audioChunk = await prisma.audioChunk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioChunks and only return the `id`
     * const audioChunkWithIdOnly = await prisma.audioChunk.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioChunkCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioChunkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AudioChunk.
     * @param {AudioChunkDeleteArgs} args - Arguments to delete one AudioChunk.
     * @example
     * // Delete one AudioChunk
     * const AudioChunk = await prisma.audioChunk.delete({
     *   where: {
     *     // ... filter to delete one AudioChunk
     *   }
     * })
     * 
     */
    delete<T extends AudioChunkDeleteArgs>(args: SelectSubset<T, AudioChunkDeleteArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AudioChunk.
     * @param {AudioChunkUpdateArgs} args - Arguments to update one AudioChunk.
     * @example
     * // Update one AudioChunk
     * const audioChunk = await prisma.audioChunk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioChunkUpdateArgs>(args: SelectSubset<T, AudioChunkUpdateArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AudioChunks.
     * @param {AudioChunkDeleteManyArgs} args - Arguments to filter AudioChunks to delete.
     * @example
     * // Delete a few AudioChunks
     * const { count } = await prisma.audioChunk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioChunkDeleteManyArgs>(args?: SelectSubset<T, AudioChunkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioChunks
     * const audioChunk = await prisma.audioChunk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioChunkUpdateManyArgs>(args: SelectSubset<T, AudioChunkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AudioChunk.
     * @param {AudioChunkUpsertArgs} args - Arguments to update or create a AudioChunk.
     * @example
     * // Update or create a AudioChunk
     * const audioChunk = await prisma.audioChunk.upsert({
     *   create: {
     *     // ... data to create a AudioChunk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioChunk we want to update
     *   }
     * })
     */
    upsert<T extends AudioChunkUpsertArgs>(args: SelectSubset<T, AudioChunkUpsertArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AudioChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkCountArgs} args - Arguments to filter AudioChunks to count.
     * @example
     * // Count the number of AudioChunks
     * const count = await prisma.audioChunk.count({
     *   where: {
     *     // ... the filter for the AudioChunks we want to count
     *   }
     * })
    **/
    count<T extends AudioChunkCountArgs>(
      args?: Subset<T, AudioChunkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioChunkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioChunkAggregateArgs>(args: Subset<T, AudioChunkAggregateArgs>): Prisma.PrismaPromise<GetAudioChunkAggregateType<T>>

    /**
     * Group by AudioChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioChunkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioChunkGroupByArgs['orderBy'] }
        : { orderBy?: AudioChunkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioChunkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioChunkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioChunk model
   */
  readonly fields: AudioChunkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioChunk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioChunkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    upload<T extends AudioUploadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AudioUploadDefaultArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioChunk model
   */ 
  interface AudioChunkFieldRefs {
    readonly id: FieldRef<"AudioChunk", 'String'>
    readonly uploadId: FieldRef<"AudioChunk", 'String'>
    readonly chunkIndex: FieldRef<"AudioChunk", 'Int'>
    readonly startTime: FieldRef<"AudioChunk", 'Float'>
    readonly endTime: FieldRef<"AudioChunk", 'Float'>
    readonly fileSize: FieldRef<"AudioChunk", 'BigInt'>
    readonly storagePath: FieldRef<"AudioChunk", 'String'>
    readonly checksumMd5: FieldRef<"AudioChunk", 'String'>
    readonly status: FieldRef<"AudioChunk", 'String'>
    readonly processedAt: FieldRef<"AudioChunk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioChunk findUnique
   */
  export type AudioChunkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * Filter, which AudioChunk to fetch.
     */
    where: AudioChunkWhereUniqueInput
  }

  /**
   * AudioChunk findUniqueOrThrow
   */
  export type AudioChunkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * Filter, which AudioChunk to fetch.
     */
    where: AudioChunkWhereUniqueInput
  }

  /**
   * AudioChunk findFirst
   */
  export type AudioChunkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * Filter, which AudioChunk to fetch.
     */
    where?: AudioChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioChunks to fetch.
     */
    orderBy?: AudioChunkOrderByWithRelationInput | AudioChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioChunks.
     */
    cursor?: AudioChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioChunks.
     */
    distinct?: AudioChunkScalarFieldEnum | AudioChunkScalarFieldEnum[]
  }

  /**
   * AudioChunk findFirstOrThrow
   */
  export type AudioChunkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * Filter, which AudioChunk to fetch.
     */
    where?: AudioChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioChunks to fetch.
     */
    orderBy?: AudioChunkOrderByWithRelationInput | AudioChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioChunks.
     */
    cursor?: AudioChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioChunks.
     */
    distinct?: AudioChunkScalarFieldEnum | AudioChunkScalarFieldEnum[]
  }

  /**
   * AudioChunk findMany
   */
  export type AudioChunkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * Filter, which AudioChunks to fetch.
     */
    where?: AudioChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioChunks to fetch.
     */
    orderBy?: AudioChunkOrderByWithRelationInput | AudioChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioChunks.
     */
    cursor?: AudioChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioChunks.
     */
    skip?: number
    distinct?: AudioChunkScalarFieldEnum | AudioChunkScalarFieldEnum[]
  }

  /**
   * AudioChunk create
   */
  export type AudioChunkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioChunk.
     */
    data: XOR<AudioChunkCreateInput, AudioChunkUncheckedCreateInput>
  }

  /**
   * AudioChunk createMany
   */
  export type AudioChunkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioChunks.
     */
    data: AudioChunkCreateManyInput | AudioChunkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioChunk createManyAndReturn
   */
  export type AudioChunkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AudioChunks.
     */
    data: AudioChunkCreateManyInput | AudioChunkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioChunk update
   */
  export type AudioChunkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioChunk.
     */
    data: XOR<AudioChunkUpdateInput, AudioChunkUncheckedUpdateInput>
    /**
     * Choose, which AudioChunk to update.
     */
    where: AudioChunkWhereUniqueInput
  }

  /**
   * AudioChunk updateMany
   */
  export type AudioChunkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioChunks.
     */
    data: XOR<AudioChunkUpdateManyMutationInput, AudioChunkUncheckedUpdateManyInput>
    /**
     * Filter which AudioChunks to update
     */
    where?: AudioChunkWhereInput
  }

  /**
   * AudioChunk upsert
   */
  export type AudioChunkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioChunk to update in case it exists.
     */
    where: AudioChunkWhereUniqueInput
    /**
     * In case the AudioChunk found by the `where` argument doesn't exist, create a new AudioChunk with this data.
     */
    create: XOR<AudioChunkCreateInput, AudioChunkUncheckedCreateInput>
    /**
     * In case the AudioChunk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioChunkUpdateInput, AudioChunkUncheckedUpdateInput>
  }

  /**
   * AudioChunk delete
   */
  export type AudioChunkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * Filter which AudioChunk to delete.
     */
    where: AudioChunkWhereUniqueInput
  }

  /**
   * AudioChunk deleteMany
   */
  export type AudioChunkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioChunks to delete
     */
    where?: AudioChunkWhereInput
  }

  /**
   * AudioChunk without action
   */
  export type AudioChunkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
  }


  /**
   * Model AudioProject
   */

  export type AggregateAudioProject = {
    _count: AudioProjectCountAggregateOutputType | null
    _min: AudioProjectMinAggregateOutputType | null
    _max: AudioProjectMaxAggregateOutputType | null
  }

  export type AudioProjectMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    color: string | null
    status: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AudioProjectMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    color: string | null
    status: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AudioProjectCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    name: number
    description: number
    color: number
    status: number
    isPublic: number
    tags: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AudioProjectMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    name?: true
    description?: true
    color?: true
    status?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AudioProjectMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    name?: true
    description?: true
    color?: true
    status?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AudioProjectCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    name?: true
    description?: true
    color?: true
    status?: true
    isPublic?: true
    tags?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AudioProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioProject to aggregate.
     */
    where?: AudioProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioProjects to fetch.
     */
    orderBy?: AudioProjectOrderByWithRelationInput | AudioProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioProjects
    **/
    _count?: true | AudioProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioProjectMaxAggregateInputType
  }

  export type GetAudioProjectAggregateType<T extends AudioProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioProject[P]>
      : GetScalarType<T[P], AggregateAudioProject[P]>
  }




  export type AudioProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioProjectWhereInput
    orderBy?: AudioProjectOrderByWithAggregationInput | AudioProjectOrderByWithAggregationInput[]
    by: AudioProjectScalarFieldEnum[] | AudioProjectScalarFieldEnum
    having?: AudioProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioProjectCountAggregateInputType | true
    _min?: AudioProjectMinAggregateInputType
    _max?: AudioProjectMaxAggregateInputType
  }

  export type AudioProjectGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    name: string
    description: string | null
    color: string | null
    status: string
    isPublic: boolean
    tags: string[]
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AudioProjectCountAggregateOutputType | null
    _min: AudioProjectMinAggregateOutputType | null
    _max: AudioProjectMaxAggregateOutputType | null
  }

  type GetAudioProjectGroupByPayload<T extends AudioProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioProjectGroupByOutputType[P]>
            : GetScalarType<T[P], AudioProjectGroupByOutputType[P]>
        }
      >
    >


  export type AudioProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    status?: boolean
    isPublic?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioProject$workspaceArgs<ExtArgs>
  }, ExtArgs["result"]["audioProject"]>

  export type AudioProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    status?: boolean
    isPublic?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioProject$workspaceArgs<ExtArgs>
  }, ExtArgs["result"]["audioProject"]>

  export type AudioProjectSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    status?: boolean
    isPublic?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AudioProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioProject$workspaceArgs<ExtArgs>
  }
  export type AudioProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioProject$workspaceArgs<ExtArgs>
  }

  export type $AudioProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioProject"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      name: string
      description: string | null
      color: string | null
      status: string
      isPublic: boolean
      tags: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["audioProject"]>
    composites: {}
  }

  type AudioProjectGetPayload<S extends boolean | null | undefined | AudioProjectDefaultArgs> = $Result.GetResult<Prisma.$AudioProjectPayload, S>

  type AudioProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AudioProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AudioProjectCountAggregateInputType | true
    }

  export interface AudioProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioProject'], meta: { name: 'AudioProject' } }
    /**
     * Find zero or one AudioProject that matches the filter.
     * @param {AudioProjectFindUniqueArgs} args - Arguments to find a AudioProject
     * @example
     * // Get one AudioProject
     * const audioProject = await prisma.audioProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioProjectFindUniqueArgs>(args: SelectSubset<T, AudioProjectFindUniqueArgs<ExtArgs>>): Prisma__AudioProjectClient<$Result.GetResult<Prisma.$AudioProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AudioProject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AudioProjectFindUniqueOrThrowArgs} args - Arguments to find a AudioProject
     * @example
     * // Get one AudioProject
     * const audioProject = await prisma.audioProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioProjectClient<$Result.GetResult<Prisma.$AudioProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AudioProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioProjectFindFirstArgs} args - Arguments to find a AudioProject
     * @example
     * // Get one AudioProject
     * const audioProject = await prisma.audioProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioProjectFindFirstArgs>(args?: SelectSubset<T, AudioProjectFindFirstArgs<ExtArgs>>): Prisma__AudioProjectClient<$Result.GetResult<Prisma.$AudioProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AudioProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioProjectFindFirstOrThrowArgs} args - Arguments to find a AudioProject
     * @example
     * // Get one AudioProject
     * const audioProject = await prisma.audioProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioProjectClient<$Result.GetResult<Prisma.$AudioProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AudioProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioProjects
     * const audioProjects = await prisma.audioProject.findMany()
     * 
     * // Get first 10 AudioProjects
     * const audioProjects = await prisma.audioProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioProjectWithIdOnly = await prisma.audioProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioProjectFindManyArgs>(args?: SelectSubset<T, AudioProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AudioProject.
     * @param {AudioProjectCreateArgs} args - Arguments to create a AudioProject.
     * @example
     * // Create one AudioProject
     * const AudioProject = await prisma.audioProject.create({
     *   data: {
     *     // ... data to create a AudioProject
     *   }
     * })
     * 
     */
    create<T extends AudioProjectCreateArgs>(args: SelectSubset<T, AudioProjectCreateArgs<ExtArgs>>): Prisma__AudioProjectClient<$Result.GetResult<Prisma.$AudioProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AudioProjects.
     * @param {AudioProjectCreateManyArgs} args - Arguments to create many AudioProjects.
     * @example
     * // Create many AudioProjects
     * const audioProject = await prisma.audioProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioProjectCreateManyArgs>(args?: SelectSubset<T, AudioProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioProjects and returns the data saved in the database.
     * @param {AudioProjectCreateManyAndReturnArgs} args - Arguments to create many AudioProjects.
     * @example
     * // Create many AudioProjects
     * const audioProject = await prisma.audioProject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioProjects and only return the `id`
     * const audioProjectWithIdOnly = await prisma.audioProject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AudioProject.
     * @param {AudioProjectDeleteArgs} args - Arguments to delete one AudioProject.
     * @example
     * // Delete one AudioProject
     * const AudioProject = await prisma.audioProject.delete({
     *   where: {
     *     // ... filter to delete one AudioProject
     *   }
     * })
     * 
     */
    delete<T extends AudioProjectDeleteArgs>(args: SelectSubset<T, AudioProjectDeleteArgs<ExtArgs>>): Prisma__AudioProjectClient<$Result.GetResult<Prisma.$AudioProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AudioProject.
     * @param {AudioProjectUpdateArgs} args - Arguments to update one AudioProject.
     * @example
     * // Update one AudioProject
     * const audioProject = await prisma.audioProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioProjectUpdateArgs>(args: SelectSubset<T, AudioProjectUpdateArgs<ExtArgs>>): Prisma__AudioProjectClient<$Result.GetResult<Prisma.$AudioProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AudioProjects.
     * @param {AudioProjectDeleteManyArgs} args - Arguments to filter AudioProjects to delete.
     * @example
     * // Delete a few AudioProjects
     * const { count } = await prisma.audioProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioProjectDeleteManyArgs>(args?: SelectSubset<T, AudioProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioProjects
     * const audioProject = await prisma.audioProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioProjectUpdateManyArgs>(args: SelectSubset<T, AudioProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AudioProject.
     * @param {AudioProjectUpsertArgs} args - Arguments to update or create a AudioProject.
     * @example
     * // Update or create a AudioProject
     * const audioProject = await prisma.audioProject.upsert({
     *   create: {
     *     // ... data to create a AudioProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioProject we want to update
     *   }
     * })
     */
    upsert<T extends AudioProjectUpsertArgs>(args: SelectSubset<T, AudioProjectUpsertArgs<ExtArgs>>): Prisma__AudioProjectClient<$Result.GetResult<Prisma.$AudioProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AudioProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioProjectCountArgs} args - Arguments to filter AudioProjects to count.
     * @example
     * // Count the number of AudioProjects
     * const count = await prisma.audioProject.count({
     *   where: {
     *     // ... the filter for the AudioProjects we want to count
     *   }
     * })
    **/
    count<T extends AudioProjectCountArgs>(
      args?: Subset<T, AudioProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioProjectAggregateArgs>(args: Subset<T, AudioProjectAggregateArgs>): Prisma.PrismaPromise<GetAudioProjectAggregateType<T>>

    /**
     * Group by AudioProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioProjectGroupByArgs['orderBy'] }
        : { orderBy?: AudioProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioProject model
   */
  readonly fields: AudioProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workspace<T extends AudioProject$workspaceArgs<ExtArgs> = {}>(args?: Subset<T, AudioProject$workspaceArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioProject model
   */ 
  interface AudioProjectFieldRefs {
    readonly id: FieldRef<"AudioProject", 'String'>
    readonly userId: FieldRef<"AudioProject", 'String'>
    readonly workspaceId: FieldRef<"AudioProject", 'String'>
    readonly name: FieldRef<"AudioProject", 'String'>
    readonly description: FieldRef<"AudioProject", 'String'>
    readonly color: FieldRef<"AudioProject", 'String'>
    readonly status: FieldRef<"AudioProject", 'String'>
    readonly isPublic: FieldRef<"AudioProject", 'Boolean'>
    readonly tags: FieldRef<"AudioProject", 'String[]'>
    readonly metadata: FieldRef<"AudioProject", 'Json'>
    readonly createdAt: FieldRef<"AudioProject", 'DateTime'>
    readonly updatedAt: FieldRef<"AudioProject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioProject findUnique
   */
  export type AudioProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectInclude<ExtArgs> | null
    /**
     * Filter, which AudioProject to fetch.
     */
    where: AudioProjectWhereUniqueInput
  }

  /**
   * AudioProject findUniqueOrThrow
   */
  export type AudioProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectInclude<ExtArgs> | null
    /**
     * Filter, which AudioProject to fetch.
     */
    where: AudioProjectWhereUniqueInput
  }

  /**
   * AudioProject findFirst
   */
  export type AudioProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectInclude<ExtArgs> | null
    /**
     * Filter, which AudioProject to fetch.
     */
    where?: AudioProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioProjects to fetch.
     */
    orderBy?: AudioProjectOrderByWithRelationInput | AudioProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioProjects.
     */
    cursor?: AudioProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioProjects.
     */
    distinct?: AudioProjectScalarFieldEnum | AudioProjectScalarFieldEnum[]
  }

  /**
   * AudioProject findFirstOrThrow
   */
  export type AudioProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectInclude<ExtArgs> | null
    /**
     * Filter, which AudioProject to fetch.
     */
    where?: AudioProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioProjects to fetch.
     */
    orderBy?: AudioProjectOrderByWithRelationInput | AudioProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioProjects.
     */
    cursor?: AudioProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioProjects.
     */
    distinct?: AudioProjectScalarFieldEnum | AudioProjectScalarFieldEnum[]
  }

  /**
   * AudioProject findMany
   */
  export type AudioProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectInclude<ExtArgs> | null
    /**
     * Filter, which AudioProjects to fetch.
     */
    where?: AudioProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioProjects to fetch.
     */
    orderBy?: AudioProjectOrderByWithRelationInput | AudioProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioProjects.
     */
    cursor?: AudioProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioProjects.
     */
    skip?: number
    distinct?: AudioProjectScalarFieldEnum | AudioProjectScalarFieldEnum[]
  }

  /**
   * AudioProject create
   */
  export type AudioProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioProject.
     */
    data: XOR<AudioProjectCreateInput, AudioProjectUncheckedCreateInput>
  }

  /**
   * AudioProject createMany
   */
  export type AudioProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioProjects.
     */
    data: AudioProjectCreateManyInput | AudioProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioProject createManyAndReturn
   */
  export type AudioProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AudioProjects.
     */
    data: AudioProjectCreateManyInput | AudioProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioProject update
   */
  export type AudioProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioProject.
     */
    data: XOR<AudioProjectUpdateInput, AudioProjectUncheckedUpdateInput>
    /**
     * Choose, which AudioProject to update.
     */
    where: AudioProjectWhereUniqueInput
  }

  /**
   * AudioProject updateMany
   */
  export type AudioProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioProjects.
     */
    data: XOR<AudioProjectUpdateManyMutationInput, AudioProjectUncheckedUpdateManyInput>
    /**
     * Filter which AudioProjects to update
     */
    where?: AudioProjectWhereInput
  }

  /**
   * AudioProject upsert
   */
  export type AudioProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioProject to update in case it exists.
     */
    where: AudioProjectWhereUniqueInput
    /**
     * In case the AudioProject found by the `where` argument doesn't exist, create a new AudioProject with this data.
     */
    create: XOR<AudioProjectCreateInput, AudioProjectUncheckedCreateInput>
    /**
     * In case the AudioProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioProjectUpdateInput, AudioProjectUncheckedUpdateInput>
  }

  /**
   * AudioProject delete
   */
  export type AudioProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectInclude<ExtArgs> | null
    /**
     * Filter which AudioProject to delete.
     */
    where: AudioProjectWhereUniqueInput
  }

  /**
   * AudioProject deleteMany
   */
  export type AudioProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioProjects to delete
     */
    where?: AudioProjectWhereInput
  }

  /**
   * AudioProject.workspace
   */
  export type AudioProject$workspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
  }

  /**
   * AudioProject without action
   */
  export type AudioProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioProject
     */
    select?: AudioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioProjectInclude<ExtArgs> | null
  }


  /**
   * Model UsageMetric
   */

  export type AggregateUsageMetric = {
    _count: UsageMetricCountAggregateOutputType | null
    _avg: UsageMetricAvgAggregateOutputType | null
    _sum: UsageMetricSumAggregateOutputType | null
    _min: UsageMetricMinAggregateOutputType | null
    _max: UsageMetricMaxAggregateOutputType | null
  }

  export type UsageMetricAvgAggregateOutputType = {
    quantity: number | null
    cost: Decimal | null
  }

  export type UsageMetricSumAggregateOutputType = {
    quantity: bigint | null
    cost: Decimal | null
  }

  export type UsageMetricMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    metricType: string | null
    provider: string | null
    quantity: bigint | null
    cost: Decimal | null
    currency: string | null
    periodStart: Date | null
    periodEnd: Date | null
    recordedAt: Date | null
  }

  export type UsageMetricMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    metricType: string | null
    provider: string | null
    quantity: bigint | null
    cost: Decimal | null
    currency: string | null
    periodStart: Date | null
    periodEnd: Date | null
    recordedAt: Date | null
  }

  export type UsageMetricCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    metricType: number
    provider: number
    quantity: number
    cost: number
    currency: number
    metadata: number
    periodStart: number
    periodEnd: number
    recordedAt: number
    _all: number
  }


  export type UsageMetricAvgAggregateInputType = {
    quantity?: true
    cost?: true
  }

  export type UsageMetricSumAggregateInputType = {
    quantity?: true
    cost?: true
  }

  export type UsageMetricMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    metricType?: true
    provider?: true
    quantity?: true
    cost?: true
    currency?: true
    periodStart?: true
    periodEnd?: true
    recordedAt?: true
  }

  export type UsageMetricMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    metricType?: true
    provider?: true
    quantity?: true
    cost?: true
    currency?: true
    periodStart?: true
    periodEnd?: true
    recordedAt?: true
  }

  export type UsageMetricCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    metricType?: true
    provider?: true
    quantity?: true
    cost?: true
    currency?: true
    metadata?: true
    periodStart?: true
    periodEnd?: true
    recordedAt?: true
    _all?: true
  }

  export type UsageMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageMetric to aggregate.
     */
    where?: UsageMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageMetrics
    **/
    _count?: true | UsageMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageMetricMaxAggregateInputType
  }

  export type GetUsageMetricAggregateType<T extends UsageMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageMetric[P]>
      : GetScalarType<T[P], AggregateUsageMetric[P]>
  }




  export type UsageMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageMetricWhereInput
    orderBy?: UsageMetricOrderByWithAggregationInput | UsageMetricOrderByWithAggregationInput[]
    by: UsageMetricScalarFieldEnum[] | UsageMetricScalarFieldEnum
    having?: UsageMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageMetricCountAggregateInputType | true
    _avg?: UsageMetricAvgAggregateInputType
    _sum?: UsageMetricSumAggregateInputType
    _min?: UsageMetricMinAggregateInputType
    _max?: UsageMetricMaxAggregateInputType
  }

  export type UsageMetricGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    metricType: string
    provider: string | null
    quantity: bigint
    cost: Decimal
    currency: string
    metadata: JsonValue | null
    periodStart: Date
    periodEnd: Date
    recordedAt: Date
    _count: UsageMetricCountAggregateOutputType | null
    _avg: UsageMetricAvgAggregateOutputType | null
    _sum: UsageMetricSumAggregateOutputType | null
    _min: UsageMetricMinAggregateOutputType | null
    _max: UsageMetricMaxAggregateOutputType | null
  }

  type GetUsageMetricGroupByPayload<T extends UsageMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageMetricGroupByOutputType[P]>
            : GetScalarType<T[P], UsageMetricGroupByOutputType[P]>
        }
      >
    >


  export type UsageMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    metricType?: boolean
    provider?: boolean
    quantity?: boolean
    cost?: boolean
    currency?: boolean
    metadata?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    recordedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | UsageMetric$workspaceArgs<ExtArgs>
  }, ExtArgs["result"]["usageMetric"]>

  export type UsageMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    metricType?: boolean
    provider?: boolean
    quantity?: boolean
    cost?: boolean
    currency?: boolean
    metadata?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    recordedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | UsageMetric$workspaceArgs<ExtArgs>
  }, ExtArgs["result"]["usageMetric"]>

  export type UsageMetricSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    metricType?: boolean
    provider?: boolean
    quantity?: boolean
    cost?: boolean
    currency?: boolean
    metadata?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    recordedAt?: boolean
  }

  export type UsageMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | UsageMetric$workspaceArgs<ExtArgs>
  }
  export type UsageMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | UsageMetric$workspaceArgs<ExtArgs>
  }

  export type $UsageMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageMetric"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      metricType: string
      provider: string | null
      quantity: bigint
      cost: Prisma.Decimal
      currency: string
      metadata: Prisma.JsonValue | null
      periodStart: Date
      periodEnd: Date
      recordedAt: Date
    }, ExtArgs["result"]["usageMetric"]>
    composites: {}
  }

  type UsageMetricGetPayload<S extends boolean | null | undefined | UsageMetricDefaultArgs> = $Result.GetResult<Prisma.$UsageMetricPayload, S>

  type UsageMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsageMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsageMetricCountAggregateInputType | true
    }

  export interface UsageMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageMetric'], meta: { name: 'UsageMetric' } }
    /**
     * Find zero or one UsageMetric that matches the filter.
     * @param {UsageMetricFindUniqueArgs} args - Arguments to find a UsageMetric
     * @example
     * // Get one UsageMetric
     * const usageMetric = await prisma.usageMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageMetricFindUniqueArgs>(args: SelectSubset<T, UsageMetricFindUniqueArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsageMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsageMetricFindUniqueOrThrowArgs} args - Arguments to find a UsageMetric
     * @example
     * // Get one UsageMetric
     * const usageMetric = await prisma.usageMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsageMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricFindFirstArgs} args - Arguments to find a UsageMetric
     * @example
     * // Get one UsageMetric
     * const usageMetric = await prisma.usageMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageMetricFindFirstArgs>(args?: SelectSubset<T, UsageMetricFindFirstArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsageMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricFindFirstOrThrowArgs} args - Arguments to find a UsageMetric
     * @example
     * // Get one UsageMetric
     * const usageMetric = await prisma.usageMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsageMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageMetrics
     * const usageMetrics = await prisma.usageMetric.findMany()
     * 
     * // Get first 10 UsageMetrics
     * const usageMetrics = await prisma.usageMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageMetricWithIdOnly = await prisma.usageMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageMetricFindManyArgs>(args?: SelectSubset<T, UsageMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsageMetric.
     * @param {UsageMetricCreateArgs} args - Arguments to create a UsageMetric.
     * @example
     * // Create one UsageMetric
     * const UsageMetric = await prisma.usageMetric.create({
     *   data: {
     *     // ... data to create a UsageMetric
     *   }
     * })
     * 
     */
    create<T extends UsageMetricCreateArgs>(args: SelectSubset<T, UsageMetricCreateArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsageMetrics.
     * @param {UsageMetricCreateManyArgs} args - Arguments to create many UsageMetrics.
     * @example
     * // Create many UsageMetrics
     * const usageMetric = await prisma.usageMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageMetricCreateManyArgs>(args?: SelectSubset<T, UsageMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageMetrics and returns the data saved in the database.
     * @param {UsageMetricCreateManyAndReturnArgs} args - Arguments to create many UsageMetrics.
     * @example
     * // Create many UsageMetrics
     * const usageMetric = await prisma.usageMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageMetrics and only return the `id`
     * const usageMetricWithIdOnly = await prisma.usageMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsageMetric.
     * @param {UsageMetricDeleteArgs} args - Arguments to delete one UsageMetric.
     * @example
     * // Delete one UsageMetric
     * const UsageMetric = await prisma.usageMetric.delete({
     *   where: {
     *     // ... filter to delete one UsageMetric
     *   }
     * })
     * 
     */
    delete<T extends UsageMetricDeleteArgs>(args: SelectSubset<T, UsageMetricDeleteArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsageMetric.
     * @param {UsageMetricUpdateArgs} args - Arguments to update one UsageMetric.
     * @example
     * // Update one UsageMetric
     * const usageMetric = await prisma.usageMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageMetricUpdateArgs>(args: SelectSubset<T, UsageMetricUpdateArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsageMetrics.
     * @param {UsageMetricDeleteManyArgs} args - Arguments to filter UsageMetrics to delete.
     * @example
     * // Delete a few UsageMetrics
     * const { count } = await prisma.usageMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageMetricDeleteManyArgs>(args?: SelectSubset<T, UsageMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageMetrics
     * const usageMetric = await prisma.usageMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageMetricUpdateManyArgs>(args: SelectSubset<T, UsageMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageMetric.
     * @param {UsageMetricUpsertArgs} args - Arguments to update or create a UsageMetric.
     * @example
     * // Update or create a UsageMetric
     * const usageMetric = await prisma.usageMetric.upsert({
     *   create: {
     *     // ... data to create a UsageMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageMetric we want to update
     *   }
     * })
     */
    upsert<T extends UsageMetricUpsertArgs>(args: SelectSubset<T, UsageMetricUpsertArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricCountArgs} args - Arguments to filter UsageMetrics to count.
     * @example
     * // Count the number of UsageMetrics
     * const count = await prisma.usageMetric.count({
     *   where: {
     *     // ... the filter for the UsageMetrics we want to count
     *   }
     * })
    **/
    count<T extends UsageMetricCountArgs>(
      args?: Subset<T, UsageMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageMetricAggregateArgs>(args: Subset<T, UsageMetricAggregateArgs>): Prisma.PrismaPromise<GetUsageMetricAggregateType<T>>

    /**
     * Group by UsageMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageMetricGroupByArgs['orderBy'] }
        : { orderBy?: UsageMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageMetric model
   */
  readonly fields: UsageMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workspace<T extends UsageMetric$workspaceArgs<ExtArgs> = {}>(args?: Subset<T, UsageMetric$workspaceArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageMetric model
   */ 
  interface UsageMetricFieldRefs {
    readonly id: FieldRef<"UsageMetric", 'String'>
    readonly userId: FieldRef<"UsageMetric", 'String'>
    readonly workspaceId: FieldRef<"UsageMetric", 'String'>
    readonly metricType: FieldRef<"UsageMetric", 'String'>
    readonly provider: FieldRef<"UsageMetric", 'String'>
    readonly quantity: FieldRef<"UsageMetric", 'BigInt'>
    readonly cost: FieldRef<"UsageMetric", 'Decimal'>
    readonly currency: FieldRef<"UsageMetric", 'String'>
    readonly metadata: FieldRef<"UsageMetric", 'Json'>
    readonly periodStart: FieldRef<"UsageMetric", 'DateTime'>
    readonly periodEnd: FieldRef<"UsageMetric", 'DateTime'>
    readonly recordedAt: FieldRef<"UsageMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageMetric findUnique
   */
  export type UsageMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null
    /**
     * Filter, which UsageMetric to fetch.
     */
    where: UsageMetricWhereUniqueInput
  }

  /**
   * UsageMetric findUniqueOrThrow
   */
  export type UsageMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null
    /**
     * Filter, which UsageMetric to fetch.
     */
    where: UsageMetricWhereUniqueInput
  }

  /**
   * UsageMetric findFirst
   */
  export type UsageMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null
    /**
     * Filter, which UsageMetric to fetch.
     */
    where?: UsageMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageMetrics.
     */
    cursor?: UsageMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageMetrics.
     */
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[]
  }

  /**
   * UsageMetric findFirstOrThrow
   */
  export type UsageMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null
    /**
     * Filter, which UsageMetric to fetch.
     */
    where?: UsageMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageMetrics.
     */
    cursor?: UsageMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageMetrics.
     */
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[]
  }

  /**
   * UsageMetric findMany
   */
  export type UsageMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null
    /**
     * Filter, which UsageMetrics to fetch.
     */
    where?: UsageMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageMetrics.
     */
    cursor?: UsageMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMetrics.
     */
    skip?: number
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[]
  }

  /**
   * UsageMetric create
   */
  export type UsageMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageMetric.
     */
    data: XOR<UsageMetricCreateInput, UsageMetricUncheckedCreateInput>
  }

  /**
   * UsageMetric createMany
   */
  export type UsageMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageMetrics.
     */
    data: UsageMetricCreateManyInput | UsageMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageMetric createManyAndReturn
   */
  export type UsageMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsageMetrics.
     */
    data: UsageMetricCreateManyInput | UsageMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageMetric update
   */
  export type UsageMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageMetric.
     */
    data: XOR<UsageMetricUpdateInput, UsageMetricUncheckedUpdateInput>
    /**
     * Choose, which UsageMetric to update.
     */
    where: UsageMetricWhereUniqueInput
  }

  /**
   * UsageMetric updateMany
   */
  export type UsageMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageMetrics.
     */
    data: XOR<UsageMetricUpdateManyMutationInput, UsageMetricUncheckedUpdateManyInput>
    /**
     * Filter which UsageMetrics to update
     */
    where?: UsageMetricWhereInput
  }

  /**
   * UsageMetric upsert
   */
  export type UsageMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageMetric to update in case it exists.
     */
    where: UsageMetricWhereUniqueInput
    /**
     * In case the UsageMetric found by the `where` argument doesn't exist, create a new UsageMetric with this data.
     */
    create: XOR<UsageMetricCreateInput, UsageMetricUncheckedCreateInput>
    /**
     * In case the UsageMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageMetricUpdateInput, UsageMetricUncheckedUpdateInput>
  }

  /**
   * UsageMetric delete
   */
  export type UsageMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null
    /**
     * Filter which UsageMetric to delete.
     */
    where: UsageMetricWhereUniqueInput
  }

  /**
   * UsageMetric deleteMany
   */
  export type UsageMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageMetrics to delete
     */
    where?: UsageMetricWhereInput
  }

  /**
   * UsageMetric.workspace
   */
  export type UsageMetric$workspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
  }

  /**
   * UsageMetric without action
   */
  export type UsageMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null
  }


  /**
   * Model UserQuota
   */

  export type AggregateUserQuota = {
    _count: UserQuotaCountAggregateOutputType | null
    _avg: UserQuotaAvgAggregateOutputType | null
    _sum: UserQuotaSumAggregateOutputType | null
    _min: UserQuotaMinAggregateOutputType | null
    _max: UserQuotaMaxAggregateOutputType | null
  }

  export type UserQuotaAvgAggregateOutputType = {
    monthlyApiCalls: number | null
    monthlyTokens: number | null
    monthlyStorageMb: number | null
    monthlyProcessingMin: number | null
    currentApiCalls: number | null
    currentTokens: number | null
    currentStorageMb: number | null
    currentProcessingMin: number | null
    overageCostPerToken: Decimal | null
  }

  export type UserQuotaSumAggregateOutputType = {
    monthlyApiCalls: bigint | null
    monthlyTokens: bigint | null
    monthlyStorageMb: bigint | null
    monthlyProcessingMin: bigint | null
    currentApiCalls: bigint | null
    currentTokens: bigint | null
    currentStorageMb: bigint | null
    currentProcessingMin: bigint | null
    overageCostPerToken: Decimal | null
  }

  export type UserQuotaMinAggregateOutputType = {
    userId: string | null
    monthlyApiCalls: bigint | null
    monthlyTokens: bigint | null
    monthlyStorageMb: bigint | null
    monthlyProcessingMin: bigint | null
    currentApiCalls: bigint | null
    currentTokens: bigint | null
    currentStorageMb: bigint | null
    currentProcessingMin: bigint | null
    periodStart: Date | null
    periodEnd: Date | null
    lastResetAt: Date | null
    allowOverages: boolean | null
    overageCostPerToken: Decimal | null
  }

  export type UserQuotaMaxAggregateOutputType = {
    userId: string | null
    monthlyApiCalls: bigint | null
    monthlyTokens: bigint | null
    monthlyStorageMb: bigint | null
    monthlyProcessingMin: bigint | null
    currentApiCalls: bigint | null
    currentTokens: bigint | null
    currentStorageMb: bigint | null
    currentProcessingMin: bigint | null
    periodStart: Date | null
    periodEnd: Date | null
    lastResetAt: Date | null
    allowOverages: boolean | null
    overageCostPerToken: Decimal | null
  }

  export type UserQuotaCountAggregateOutputType = {
    userId: number
    monthlyApiCalls: number
    monthlyTokens: number
    monthlyStorageMb: number
    monthlyProcessingMin: number
    currentApiCalls: number
    currentTokens: number
    currentStorageMb: number
    currentProcessingMin: number
    periodStart: number
    periodEnd: number
    lastResetAt: number
    allowOverages: number
    overageCostPerToken: number
    _all: number
  }


  export type UserQuotaAvgAggregateInputType = {
    monthlyApiCalls?: true
    monthlyTokens?: true
    monthlyStorageMb?: true
    monthlyProcessingMin?: true
    currentApiCalls?: true
    currentTokens?: true
    currentStorageMb?: true
    currentProcessingMin?: true
    overageCostPerToken?: true
  }

  export type UserQuotaSumAggregateInputType = {
    monthlyApiCalls?: true
    monthlyTokens?: true
    monthlyStorageMb?: true
    monthlyProcessingMin?: true
    currentApiCalls?: true
    currentTokens?: true
    currentStorageMb?: true
    currentProcessingMin?: true
    overageCostPerToken?: true
  }

  export type UserQuotaMinAggregateInputType = {
    userId?: true
    monthlyApiCalls?: true
    monthlyTokens?: true
    monthlyStorageMb?: true
    monthlyProcessingMin?: true
    currentApiCalls?: true
    currentTokens?: true
    currentStorageMb?: true
    currentProcessingMin?: true
    periodStart?: true
    periodEnd?: true
    lastResetAt?: true
    allowOverages?: true
    overageCostPerToken?: true
  }

  export type UserQuotaMaxAggregateInputType = {
    userId?: true
    monthlyApiCalls?: true
    monthlyTokens?: true
    monthlyStorageMb?: true
    monthlyProcessingMin?: true
    currentApiCalls?: true
    currentTokens?: true
    currentStorageMb?: true
    currentProcessingMin?: true
    periodStart?: true
    periodEnd?: true
    lastResetAt?: true
    allowOverages?: true
    overageCostPerToken?: true
  }

  export type UserQuotaCountAggregateInputType = {
    userId?: true
    monthlyApiCalls?: true
    monthlyTokens?: true
    monthlyStorageMb?: true
    monthlyProcessingMin?: true
    currentApiCalls?: true
    currentTokens?: true
    currentStorageMb?: true
    currentProcessingMin?: true
    periodStart?: true
    periodEnd?: true
    lastResetAt?: true
    allowOverages?: true
    overageCostPerToken?: true
    _all?: true
  }

  export type UserQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuota to aggregate.
     */
    where?: UserQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuotas to fetch.
     */
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserQuotas
    **/
    _count?: true | UserQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserQuotaMaxAggregateInputType
  }

  export type GetUserQuotaAggregateType<T extends UserQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateUserQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserQuota[P]>
      : GetScalarType<T[P], AggregateUserQuota[P]>
  }




  export type UserQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuotaWhereInput
    orderBy?: UserQuotaOrderByWithAggregationInput | UserQuotaOrderByWithAggregationInput[]
    by: UserQuotaScalarFieldEnum[] | UserQuotaScalarFieldEnum
    having?: UserQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserQuotaCountAggregateInputType | true
    _avg?: UserQuotaAvgAggregateInputType
    _sum?: UserQuotaSumAggregateInputType
    _min?: UserQuotaMinAggregateInputType
    _max?: UserQuotaMaxAggregateInputType
  }

  export type UserQuotaGroupByOutputType = {
    userId: string
    monthlyApiCalls: bigint
    monthlyTokens: bigint
    monthlyStorageMb: bigint
    monthlyProcessingMin: bigint
    currentApiCalls: bigint
    currentTokens: bigint
    currentStorageMb: bigint
    currentProcessingMin: bigint
    periodStart: Date
    periodEnd: Date
    lastResetAt: Date
    allowOverages: boolean
    overageCostPerToken: Decimal
    _count: UserQuotaCountAggregateOutputType | null
    _avg: UserQuotaAvgAggregateOutputType | null
    _sum: UserQuotaSumAggregateOutputType | null
    _min: UserQuotaMinAggregateOutputType | null
    _max: UserQuotaMaxAggregateOutputType | null
  }

  type GetUserQuotaGroupByPayload<T extends UserQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], UserQuotaGroupByOutputType[P]>
        }
      >
    >


  export type UserQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    monthlyApiCalls?: boolean
    monthlyTokens?: boolean
    monthlyStorageMb?: boolean
    monthlyProcessingMin?: boolean
    currentApiCalls?: boolean
    currentTokens?: boolean
    currentStorageMb?: boolean
    currentProcessingMin?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    lastResetAt?: boolean
    allowOverages?: boolean
    overageCostPerToken?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuota"]>

  export type UserQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    monthlyApiCalls?: boolean
    monthlyTokens?: boolean
    monthlyStorageMb?: boolean
    monthlyProcessingMin?: boolean
    currentApiCalls?: boolean
    currentTokens?: boolean
    currentStorageMb?: boolean
    currentProcessingMin?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    lastResetAt?: boolean
    allowOverages?: boolean
    overageCostPerToken?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuota"]>

  export type UserQuotaSelectScalar = {
    userId?: boolean
    monthlyApiCalls?: boolean
    monthlyTokens?: boolean
    monthlyStorageMb?: boolean
    monthlyProcessingMin?: boolean
    currentApiCalls?: boolean
    currentTokens?: boolean
    currentStorageMb?: boolean
    currentProcessingMin?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    lastResetAt?: boolean
    allowOverages?: boolean
    overageCostPerToken?: boolean
  }

  export type UserQuotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserQuotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserQuota"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      monthlyApiCalls: bigint
      monthlyTokens: bigint
      monthlyStorageMb: bigint
      monthlyProcessingMin: bigint
      currentApiCalls: bigint
      currentTokens: bigint
      currentStorageMb: bigint
      currentProcessingMin: bigint
      periodStart: Date
      periodEnd: Date
      lastResetAt: Date
      allowOverages: boolean
      overageCostPerToken: Prisma.Decimal
    }, ExtArgs["result"]["userQuota"]>
    composites: {}
  }

  type UserQuotaGetPayload<S extends boolean | null | undefined | UserQuotaDefaultArgs> = $Result.GetResult<Prisma.$UserQuotaPayload, S>

  type UserQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserQuotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserQuotaCountAggregateInputType | true
    }

  export interface UserQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserQuota'], meta: { name: 'UserQuota' } }
    /**
     * Find zero or one UserQuota that matches the filter.
     * @param {UserQuotaFindUniqueArgs} args - Arguments to find a UserQuota
     * @example
     * // Get one UserQuota
     * const userQuota = await prisma.userQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserQuotaFindUniqueArgs>(args: SelectSubset<T, UserQuotaFindUniqueArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserQuota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserQuotaFindUniqueOrThrowArgs} args - Arguments to find a UserQuota
     * @example
     * // Get one UserQuota
     * const userQuota = await prisma.userQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, UserQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaFindFirstArgs} args - Arguments to find a UserQuota
     * @example
     * // Get one UserQuota
     * const userQuota = await prisma.userQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserQuotaFindFirstArgs>(args?: SelectSubset<T, UserQuotaFindFirstArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaFindFirstOrThrowArgs} args - Arguments to find a UserQuota
     * @example
     * // Get one UserQuota
     * const userQuota = await prisma.userQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, UserQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserQuotas
     * const userQuotas = await prisma.userQuota.findMany()
     * 
     * // Get first 10 UserQuotas
     * const userQuotas = await prisma.userQuota.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userQuotaWithUserIdOnly = await prisma.userQuota.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserQuotaFindManyArgs>(args?: SelectSubset<T, UserQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserQuota.
     * @param {UserQuotaCreateArgs} args - Arguments to create a UserQuota.
     * @example
     * // Create one UserQuota
     * const UserQuota = await prisma.userQuota.create({
     *   data: {
     *     // ... data to create a UserQuota
     *   }
     * })
     * 
     */
    create<T extends UserQuotaCreateArgs>(args: SelectSubset<T, UserQuotaCreateArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserQuotas.
     * @param {UserQuotaCreateManyArgs} args - Arguments to create many UserQuotas.
     * @example
     * // Create many UserQuotas
     * const userQuota = await prisma.userQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserQuotaCreateManyArgs>(args?: SelectSubset<T, UserQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserQuotas and returns the data saved in the database.
     * @param {UserQuotaCreateManyAndReturnArgs} args - Arguments to create many UserQuotas.
     * @example
     * // Create many UserQuotas
     * const userQuota = await prisma.userQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserQuotas and only return the `userId`
     * const userQuotaWithUserIdOnly = await prisma.userQuota.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, UserQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserQuota.
     * @param {UserQuotaDeleteArgs} args - Arguments to delete one UserQuota.
     * @example
     * // Delete one UserQuota
     * const UserQuota = await prisma.userQuota.delete({
     *   where: {
     *     // ... filter to delete one UserQuota
     *   }
     * })
     * 
     */
    delete<T extends UserQuotaDeleteArgs>(args: SelectSubset<T, UserQuotaDeleteArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserQuota.
     * @param {UserQuotaUpdateArgs} args - Arguments to update one UserQuota.
     * @example
     * // Update one UserQuota
     * const userQuota = await prisma.userQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserQuotaUpdateArgs>(args: SelectSubset<T, UserQuotaUpdateArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserQuotas.
     * @param {UserQuotaDeleteManyArgs} args - Arguments to filter UserQuotas to delete.
     * @example
     * // Delete a few UserQuotas
     * const { count } = await prisma.userQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserQuotaDeleteManyArgs>(args?: SelectSubset<T, UserQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserQuotas
     * const userQuota = await prisma.userQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserQuotaUpdateManyArgs>(args: SelectSubset<T, UserQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserQuota.
     * @param {UserQuotaUpsertArgs} args - Arguments to update or create a UserQuota.
     * @example
     * // Update or create a UserQuota
     * const userQuota = await prisma.userQuota.upsert({
     *   create: {
     *     // ... data to create a UserQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserQuota we want to update
     *   }
     * })
     */
    upsert<T extends UserQuotaUpsertArgs>(args: SelectSubset<T, UserQuotaUpsertArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaCountArgs} args - Arguments to filter UserQuotas to count.
     * @example
     * // Count the number of UserQuotas
     * const count = await prisma.userQuota.count({
     *   where: {
     *     // ... the filter for the UserQuotas we want to count
     *   }
     * })
    **/
    count<T extends UserQuotaCountArgs>(
      args?: Subset<T, UserQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserQuotaAggregateArgs>(args: Subset<T, UserQuotaAggregateArgs>): Prisma.PrismaPromise<GetUserQuotaAggregateType<T>>

    /**
     * Group by UserQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserQuotaGroupByArgs['orderBy'] }
        : { orderBy?: UserQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserQuota model
   */
  readonly fields: UserQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserQuota model
   */ 
  interface UserQuotaFieldRefs {
    readonly userId: FieldRef<"UserQuota", 'String'>
    readonly monthlyApiCalls: FieldRef<"UserQuota", 'BigInt'>
    readonly monthlyTokens: FieldRef<"UserQuota", 'BigInt'>
    readonly monthlyStorageMb: FieldRef<"UserQuota", 'BigInt'>
    readonly monthlyProcessingMin: FieldRef<"UserQuota", 'BigInt'>
    readonly currentApiCalls: FieldRef<"UserQuota", 'BigInt'>
    readonly currentTokens: FieldRef<"UserQuota", 'BigInt'>
    readonly currentStorageMb: FieldRef<"UserQuota", 'BigInt'>
    readonly currentProcessingMin: FieldRef<"UserQuota", 'BigInt'>
    readonly periodStart: FieldRef<"UserQuota", 'DateTime'>
    readonly periodEnd: FieldRef<"UserQuota", 'DateTime'>
    readonly lastResetAt: FieldRef<"UserQuota", 'DateTime'>
    readonly allowOverages: FieldRef<"UserQuota", 'Boolean'>
    readonly overageCostPerToken: FieldRef<"UserQuota", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * UserQuota findUnique
   */
  export type UserQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UserQuota to fetch.
     */
    where: UserQuotaWhereUniqueInput
  }

  /**
   * UserQuota findUniqueOrThrow
   */
  export type UserQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UserQuota to fetch.
     */
    where: UserQuotaWhereUniqueInput
  }

  /**
   * UserQuota findFirst
   */
  export type UserQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UserQuota to fetch.
     */
    where?: UserQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuotas to fetch.
     */
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuotas.
     */
    cursor?: UserQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuotas.
     */
    distinct?: UserQuotaScalarFieldEnum | UserQuotaScalarFieldEnum[]
  }

  /**
   * UserQuota findFirstOrThrow
   */
  export type UserQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UserQuota to fetch.
     */
    where?: UserQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuotas to fetch.
     */
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuotas.
     */
    cursor?: UserQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuotas.
     */
    distinct?: UserQuotaScalarFieldEnum | UserQuotaScalarFieldEnum[]
  }

  /**
   * UserQuota findMany
   */
  export type UserQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UserQuotas to fetch.
     */
    where?: UserQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuotas to fetch.
     */
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserQuotas.
     */
    cursor?: UserQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuotas.
     */
    skip?: number
    distinct?: UserQuotaScalarFieldEnum | UserQuotaScalarFieldEnum[]
  }

  /**
   * UserQuota create
   */
  export type UserQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a UserQuota.
     */
    data: XOR<UserQuotaCreateInput, UserQuotaUncheckedCreateInput>
  }

  /**
   * UserQuota createMany
   */
  export type UserQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserQuotas.
     */
    data: UserQuotaCreateManyInput | UserQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserQuota createManyAndReturn
   */
  export type UserQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserQuotas.
     */
    data: UserQuotaCreateManyInput | UserQuotaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserQuota update
   */
  export type UserQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a UserQuota.
     */
    data: XOR<UserQuotaUpdateInput, UserQuotaUncheckedUpdateInput>
    /**
     * Choose, which UserQuota to update.
     */
    where: UserQuotaWhereUniqueInput
  }

  /**
   * UserQuota updateMany
   */
  export type UserQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserQuotas.
     */
    data: XOR<UserQuotaUpdateManyMutationInput, UserQuotaUncheckedUpdateManyInput>
    /**
     * Filter which UserQuotas to update
     */
    where?: UserQuotaWhereInput
  }

  /**
   * UserQuota upsert
   */
  export type UserQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the UserQuota to update in case it exists.
     */
    where: UserQuotaWhereUniqueInput
    /**
     * In case the UserQuota found by the `where` argument doesn't exist, create a new UserQuota with this data.
     */
    create: XOR<UserQuotaCreateInput, UserQuotaUncheckedCreateInput>
    /**
     * In case the UserQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserQuotaUpdateInput, UserQuotaUncheckedUpdateInput>
  }

  /**
   * UserQuota delete
   */
  export type UserQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * Filter which UserQuota to delete.
     */
    where: UserQuotaWhereUniqueInput
  }

  /**
   * UserQuota deleteMany
   */
  export type UserQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuotas to delete
     */
    where?: UserQuotaWhereInput
  }

  /**
   * UserQuota without action
   */
  export type UserQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
  }


  /**
   * Model StorageQuota
   */

  export type AggregateStorageQuota = {
    _count: StorageQuotaCountAggregateOutputType | null
    _avg: StorageQuotaAvgAggregateOutputType | null
    _sum: StorageQuotaSumAggregateOutputType | null
    _min: StorageQuotaMinAggregateOutputType | null
    _max: StorageQuotaMaxAggregateOutputType | null
  }

  export type StorageQuotaAvgAggregateOutputType = {
    maxStorageBytes: number | null
    maxFileCount: number | null
    maxFileSize: number | null
    currentStorageBytes: number | null
    currentFileCount: number | null
    retentionDays: number | null
  }

  export type StorageQuotaSumAggregateOutputType = {
    maxStorageBytes: bigint | null
    maxFileCount: number | null
    maxFileSize: bigint | null
    currentStorageBytes: bigint | null
    currentFileCount: number | null
    retentionDays: number | null
  }

  export type StorageQuotaMinAggregateOutputType = {
    workspaceId: string | null
    maxStorageBytes: bigint | null
    maxFileCount: number | null
    maxFileSize: bigint | null
    currentStorageBytes: bigint | null
    currentFileCount: number | null
    retentionDays: number | null
    autoCleanup: boolean | null
    updatedAt: Date | null
  }

  export type StorageQuotaMaxAggregateOutputType = {
    workspaceId: string | null
    maxStorageBytes: bigint | null
    maxFileCount: number | null
    maxFileSize: bigint | null
    currentStorageBytes: bigint | null
    currentFileCount: number | null
    retentionDays: number | null
    autoCleanup: boolean | null
    updatedAt: Date | null
  }

  export type StorageQuotaCountAggregateOutputType = {
    workspaceId: number
    maxStorageBytes: number
    maxFileCount: number
    maxFileSize: number
    currentStorageBytes: number
    currentFileCount: number
    retentionDays: number
    autoCleanup: number
    updatedAt: number
    _all: number
  }


  export type StorageQuotaAvgAggregateInputType = {
    maxStorageBytes?: true
    maxFileCount?: true
    maxFileSize?: true
    currentStorageBytes?: true
    currentFileCount?: true
    retentionDays?: true
  }

  export type StorageQuotaSumAggregateInputType = {
    maxStorageBytes?: true
    maxFileCount?: true
    maxFileSize?: true
    currentStorageBytes?: true
    currentFileCount?: true
    retentionDays?: true
  }

  export type StorageQuotaMinAggregateInputType = {
    workspaceId?: true
    maxStorageBytes?: true
    maxFileCount?: true
    maxFileSize?: true
    currentStorageBytes?: true
    currentFileCount?: true
    retentionDays?: true
    autoCleanup?: true
    updatedAt?: true
  }

  export type StorageQuotaMaxAggregateInputType = {
    workspaceId?: true
    maxStorageBytes?: true
    maxFileCount?: true
    maxFileSize?: true
    currentStorageBytes?: true
    currentFileCount?: true
    retentionDays?: true
    autoCleanup?: true
    updatedAt?: true
  }

  export type StorageQuotaCountAggregateInputType = {
    workspaceId?: true
    maxStorageBytes?: true
    maxFileCount?: true
    maxFileSize?: true
    currentStorageBytes?: true
    currentFileCount?: true
    retentionDays?: true
    autoCleanup?: true
    updatedAt?: true
    _all?: true
  }

  export type StorageQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageQuota to aggregate.
     */
    where?: StorageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageQuotas to fetch.
     */
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorageQuotas
    **/
    _count?: true | StorageQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorageQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorageQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageQuotaMaxAggregateInputType
  }

  export type GetStorageQuotaAggregateType<T extends StorageQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateStorageQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorageQuota[P]>
      : GetScalarType<T[P], AggregateStorageQuota[P]>
  }




  export type StorageQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageQuotaWhereInput
    orderBy?: StorageQuotaOrderByWithAggregationInput | StorageQuotaOrderByWithAggregationInput[]
    by: StorageQuotaScalarFieldEnum[] | StorageQuotaScalarFieldEnum
    having?: StorageQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageQuotaCountAggregateInputType | true
    _avg?: StorageQuotaAvgAggregateInputType
    _sum?: StorageQuotaSumAggregateInputType
    _min?: StorageQuotaMinAggregateInputType
    _max?: StorageQuotaMaxAggregateInputType
  }

  export type StorageQuotaGroupByOutputType = {
    workspaceId: string
    maxStorageBytes: bigint
    maxFileCount: number
    maxFileSize: bigint
    currentStorageBytes: bigint
    currentFileCount: number
    retentionDays: number | null
    autoCleanup: boolean
    updatedAt: Date
    _count: StorageQuotaCountAggregateOutputType | null
    _avg: StorageQuotaAvgAggregateOutputType | null
    _sum: StorageQuotaSumAggregateOutputType | null
    _min: StorageQuotaMinAggregateOutputType | null
    _max: StorageQuotaMaxAggregateOutputType | null
  }

  type GetStorageQuotaGroupByPayload<T extends StorageQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorageQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], StorageQuotaGroupByOutputType[P]>
        }
      >
    >


  export type StorageQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    maxStorageBytes?: boolean
    maxFileCount?: boolean
    maxFileSize?: boolean
    currentStorageBytes?: boolean
    currentFileCount?: boolean
    retentionDays?: boolean
    autoCleanup?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storageQuota"]>

  export type StorageQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    maxStorageBytes?: boolean
    maxFileCount?: boolean
    maxFileSize?: boolean
    currentStorageBytes?: boolean
    currentFileCount?: boolean
    retentionDays?: boolean
    autoCleanup?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storageQuota"]>

  export type StorageQuotaSelectScalar = {
    workspaceId?: boolean
    maxStorageBytes?: boolean
    maxFileCount?: boolean
    maxFileSize?: boolean
    currentStorageBytes?: boolean
    currentFileCount?: boolean
    retentionDays?: boolean
    autoCleanup?: boolean
    updatedAt?: boolean
  }

  export type StorageQuotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type StorageQuotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $StorageQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorageQuota"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      maxStorageBytes: bigint
      maxFileCount: number
      maxFileSize: bigint
      currentStorageBytes: bigint
      currentFileCount: number
      retentionDays: number | null
      autoCleanup: boolean
      updatedAt: Date
    }, ExtArgs["result"]["storageQuota"]>
    composites: {}
  }

  type StorageQuotaGetPayload<S extends boolean | null | undefined | StorageQuotaDefaultArgs> = $Result.GetResult<Prisma.$StorageQuotaPayload, S>

  type StorageQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorageQuotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StorageQuotaCountAggregateInputType | true
    }

  export interface StorageQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorageQuota'], meta: { name: 'StorageQuota' } }
    /**
     * Find zero or one StorageQuota that matches the filter.
     * @param {StorageQuotaFindUniqueArgs} args - Arguments to find a StorageQuota
     * @example
     * // Get one StorageQuota
     * const storageQuota = await prisma.storageQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorageQuotaFindUniqueArgs>(args: SelectSubset<T, StorageQuotaFindUniqueArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StorageQuota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StorageQuotaFindUniqueOrThrowArgs} args - Arguments to find a StorageQuota
     * @example
     * // Get one StorageQuota
     * const storageQuota = await prisma.storageQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorageQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, StorageQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StorageQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaFindFirstArgs} args - Arguments to find a StorageQuota
     * @example
     * // Get one StorageQuota
     * const storageQuota = await prisma.storageQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorageQuotaFindFirstArgs>(args?: SelectSubset<T, StorageQuotaFindFirstArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StorageQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaFindFirstOrThrowArgs} args - Arguments to find a StorageQuota
     * @example
     * // Get one StorageQuota
     * const storageQuota = await prisma.storageQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorageQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, StorageQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StorageQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorageQuotas
     * const storageQuotas = await prisma.storageQuota.findMany()
     * 
     * // Get first 10 StorageQuotas
     * const storageQuotas = await prisma.storageQuota.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const storageQuotaWithWorkspaceIdOnly = await prisma.storageQuota.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends StorageQuotaFindManyArgs>(args?: SelectSubset<T, StorageQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StorageQuota.
     * @param {StorageQuotaCreateArgs} args - Arguments to create a StorageQuota.
     * @example
     * // Create one StorageQuota
     * const StorageQuota = await prisma.storageQuota.create({
     *   data: {
     *     // ... data to create a StorageQuota
     *   }
     * })
     * 
     */
    create<T extends StorageQuotaCreateArgs>(args: SelectSubset<T, StorageQuotaCreateArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StorageQuotas.
     * @param {StorageQuotaCreateManyArgs} args - Arguments to create many StorageQuotas.
     * @example
     * // Create many StorageQuotas
     * const storageQuota = await prisma.storageQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorageQuotaCreateManyArgs>(args?: SelectSubset<T, StorageQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StorageQuotas and returns the data saved in the database.
     * @param {StorageQuotaCreateManyAndReturnArgs} args - Arguments to create many StorageQuotas.
     * @example
     * // Create many StorageQuotas
     * const storageQuota = await prisma.storageQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StorageQuotas and only return the `workspaceId`
     * const storageQuotaWithWorkspaceIdOnly = await prisma.storageQuota.createManyAndReturn({ 
     *   select: { workspaceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StorageQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, StorageQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StorageQuota.
     * @param {StorageQuotaDeleteArgs} args - Arguments to delete one StorageQuota.
     * @example
     * // Delete one StorageQuota
     * const StorageQuota = await prisma.storageQuota.delete({
     *   where: {
     *     // ... filter to delete one StorageQuota
     *   }
     * })
     * 
     */
    delete<T extends StorageQuotaDeleteArgs>(args: SelectSubset<T, StorageQuotaDeleteArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StorageQuota.
     * @param {StorageQuotaUpdateArgs} args - Arguments to update one StorageQuota.
     * @example
     * // Update one StorageQuota
     * const storageQuota = await prisma.storageQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorageQuotaUpdateArgs>(args: SelectSubset<T, StorageQuotaUpdateArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StorageQuotas.
     * @param {StorageQuotaDeleteManyArgs} args - Arguments to filter StorageQuotas to delete.
     * @example
     * // Delete a few StorageQuotas
     * const { count } = await prisma.storageQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorageQuotaDeleteManyArgs>(args?: SelectSubset<T, StorageQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorageQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorageQuotas
     * const storageQuota = await prisma.storageQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorageQuotaUpdateManyArgs>(args: SelectSubset<T, StorageQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StorageQuota.
     * @param {StorageQuotaUpsertArgs} args - Arguments to update or create a StorageQuota.
     * @example
     * // Update or create a StorageQuota
     * const storageQuota = await prisma.storageQuota.upsert({
     *   create: {
     *     // ... data to create a StorageQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorageQuota we want to update
     *   }
     * })
     */
    upsert<T extends StorageQuotaUpsertArgs>(args: SelectSubset<T, StorageQuotaUpsertArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StorageQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaCountArgs} args - Arguments to filter StorageQuotas to count.
     * @example
     * // Count the number of StorageQuotas
     * const count = await prisma.storageQuota.count({
     *   where: {
     *     // ... the filter for the StorageQuotas we want to count
     *   }
     * })
    **/
    count<T extends StorageQuotaCountArgs>(
      args?: Subset<T, StorageQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorageQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageQuotaAggregateArgs>(args: Subset<T, StorageQuotaAggregateArgs>): Prisma.PrismaPromise<GetStorageQuotaAggregateType<T>>

    /**
     * Group by StorageQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageQuotaGroupByArgs['orderBy'] }
        : { orderBy?: StorageQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorageQuota model
   */
  readonly fields: StorageQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorageQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorageQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorageQuota model
   */ 
  interface StorageQuotaFieldRefs {
    readonly workspaceId: FieldRef<"StorageQuota", 'String'>
    readonly maxStorageBytes: FieldRef<"StorageQuota", 'BigInt'>
    readonly maxFileCount: FieldRef<"StorageQuota", 'Int'>
    readonly maxFileSize: FieldRef<"StorageQuota", 'BigInt'>
    readonly currentStorageBytes: FieldRef<"StorageQuota", 'BigInt'>
    readonly currentFileCount: FieldRef<"StorageQuota", 'Int'>
    readonly retentionDays: FieldRef<"StorageQuota", 'Int'>
    readonly autoCleanup: FieldRef<"StorageQuota", 'Boolean'>
    readonly updatedAt: FieldRef<"StorageQuota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StorageQuota findUnique
   */
  export type StorageQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuota to fetch.
     */
    where: StorageQuotaWhereUniqueInput
  }

  /**
   * StorageQuota findUniqueOrThrow
   */
  export type StorageQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuota to fetch.
     */
    where: StorageQuotaWhereUniqueInput
  }

  /**
   * StorageQuota findFirst
   */
  export type StorageQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuota to fetch.
     */
    where?: StorageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageQuotas to fetch.
     */
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageQuotas.
     */
    cursor?: StorageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageQuotas.
     */
    distinct?: StorageQuotaScalarFieldEnum | StorageQuotaScalarFieldEnum[]
  }

  /**
   * StorageQuota findFirstOrThrow
   */
  export type StorageQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuota to fetch.
     */
    where?: StorageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageQuotas to fetch.
     */
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageQuotas.
     */
    cursor?: StorageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageQuotas.
     */
    distinct?: StorageQuotaScalarFieldEnum | StorageQuotaScalarFieldEnum[]
  }

  /**
   * StorageQuota findMany
   */
  export type StorageQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuotas to fetch.
     */
    where?: StorageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageQuotas to fetch.
     */
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorageQuotas.
     */
    cursor?: StorageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageQuotas.
     */
    skip?: number
    distinct?: StorageQuotaScalarFieldEnum | StorageQuotaScalarFieldEnum[]
  }

  /**
   * StorageQuota create
   */
  export type StorageQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a StorageQuota.
     */
    data: XOR<StorageQuotaCreateInput, StorageQuotaUncheckedCreateInput>
  }

  /**
   * StorageQuota createMany
   */
  export type StorageQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorageQuotas.
     */
    data: StorageQuotaCreateManyInput | StorageQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorageQuota createManyAndReturn
   */
  export type StorageQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StorageQuotas.
     */
    data: StorageQuotaCreateManyInput | StorageQuotaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StorageQuota update
   */
  export type StorageQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a StorageQuota.
     */
    data: XOR<StorageQuotaUpdateInput, StorageQuotaUncheckedUpdateInput>
    /**
     * Choose, which StorageQuota to update.
     */
    where: StorageQuotaWhereUniqueInput
  }

  /**
   * StorageQuota updateMany
   */
  export type StorageQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorageQuotas.
     */
    data: XOR<StorageQuotaUpdateManyMutationInput, StorageQuotaUncheckedUpdateManyInput>
    /**
     * Filter which StorageQuotas to update
     */
    where?: StorageQuotaWhereInput
  }

  /**
   * StorageQuota upsert
   */
  export type StorageQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the StorageQuota to update in case it exists.
     */
    where: StorageQuotaWhereUniqueInput
    /**
     * In case the StorageQuota found by the `where` argument doesn't exist, create a new StorageQuota with this data.
     */
    create: XOR<StorageQuotaCreateInput, StorageQuotaUncheckedCreateInput>
    /**
     * In case the StorageQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorageQuotaUpdateInput, StorageQuotaUncheckedUpdateInput>
  }

  /**
   * StorageQuota delete
   */
  export type StorageQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter which StorageQuota to delete.
     */
    where: StorageQuotaWhereUniqueInput
  }

  /**
   * StorageQuota deleteMany
   */
  export type StorageQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageQuotas to delete
     */
    where?: StorageQuotaWhereInput
  }

  /**
   * StorageQuota without action
   */
  export type StorageQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  export type SubscriptionPlanAvgAggregateOutputType = {
    price: Decimal | null
    sortOrder: number | null
    maxApiCalls: number | null
    maxTokens: number | null
    maxStorageMb: number | null
    maxProcessingMin: number | null
    maxWorkspaces: number | null
    maxUsers: number | null
    maxFileSize: number | null
    maxTranscriptionsMonthly: number | null
    maxFilesDaily: number | null
    maxFilesMonthly: number | null
    maxConcurrentJobs: number | null
    maxVoiceSynthesisMonthly: number | null
    maxExportOperationsMonthly: number | null
    maxAudioDurationMinutes: number | null
    priorityLevel: number | null
    trialDays: number | null
  }

  export type SubscriptionPlanSumAggregateOutputType = {
    price: Decimal | null
    sortOrder: number | null
    maxApiCalls: bigint | null
    maxTokens: bigint | null
    maxStorageMb: bigint | null
    maxProcessingMin: bigint | null
    maxWorkspaces: number | null
    maxUsers: number | null
    maxFileSize: bigint | null
    maxTranscriptionsMonthly: bigint | null
    maxFilesDaily: number | null
    maxFilesMonthly: number | null
    maxConcurrentJobs: number | null
    maxVoiceSynthesisMonthly: bigint | null
    maxExportOperationsMonthly: number | null
    maxAudioDurationMinutes: number | null
    priorityLevel: number | null
    trialDays: number | null
  }

  export type SubscriptionPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    planCode: string | null
    price: Decimal | null
    currency: string | null
    billingInterval: string | null
    tier: string | null
    sortOrder: number | null
    maxApiCalls: bigint | null
    maxTokens: bigint | null
    maxStorageMb: bigint | null
    maxProcessingMin: bigint | null
    maxWorkspaces: number | null
    maxUsers: number | null
    maxFileSize: bigint | null
    maxTranscriptionsMonthly: bigint | null
    maxFilesDaily: number | null
    maxFilesMonthly: number | null
    maxConcurrentJobs: number | null
    maxVoiceSynthesisMonthly: bigint | null
    maxExportOperationsMonthly: number | null
    maxAudioDurationMinutes: number | null
    priorityLevel: number | null
    planCategory: string | null
    trialDays: number | null
    isCustom: boolean | null
    isEnterprise: boolean | null
    isActive: boolean | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    planCode: string | null
    price: Decimal | null
    currency: string | null
    billingInterval: string | null
    tier: string | null
    sortOrder: number | null
    maxApiCalls: bigint | null
    maxTokens: bigint | null
    maxStorageMb: bigint | null
    maxProcessingMin: bigint | null
    maxWorkspaces: number | null
    maxUsers: number | null
    maxFileSize: bigint | null
    maxTranscriptionsMonthly: bigint | null
    maxFilesDaily: number | null
    maxFilesMonthly: number | null
    maxConcurrentJobs: number | null
    maxVoiceSynthesisMonthly: bigint | null
    maxExportOperationsMonthly: number | null
    maxAudioDurationMinutes: number | null
    priorityLevel: number | null
    planCategory: string | null
    trialDays: number | null
    isCustom: boolean | null
    isEnterprise: boolean | null
    isActive: boolean | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    planCode: number
    price: number
    currency: number
    billingInterval: number
    tier: number
    sortOrder: number
    maxApiCalls: number
    maxTokens: number
    maxStorageMb: number
    maxProcessingMin: number
    maxWorkspaces: number
    maxUsers: number
    maxFileSize: number
    maxTranscriptionsMonthly: number
    maxFilesDaily: number
    maxFilesMonthly: number
    maxConcurrentJobs: number
    maxVoiceSynthesisMonthly: number
    maxExportOperationsMonthly: number
    maxAudioDurationMinutes: number
    priorityLevel: number
    planCategory: number
    trialDays: number
    isCustom: number
    isEnterprise: number
    features: number
    recommendedFor: number
    allowedFileTypes: number
    analysisFeatures: number
    collaborationFeatures: number
    integrationFeatures: number
    isActive: number
    isPublic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionPlanAvgAggregateInputType = {
    price?: true
    sortOrder?: true
    maxApiCalls?: true
    maxTokens?: true
    maxStorageMb?: true
    maxProcessingMin?: true
    maxWorkspaces?: true
    maxUsers?: true
    maxFileSize?: true
    maxTranscriptionsMonthly?: true
    maxFilesDaily?: true
    maxFilesMonthly?: true
    maxConcurrentJobs?: true
    maxVoiceSynthesisMonthly?: true
    maxExportOperationsMonthly?: true
    maxAudioDurationMinutes?: true
    priorityLevel?: true
    trialDays?: true
  }

  export type SubscriptionPlanSumAggregateInputType = {
    price?: true
    sortOrder?: true
    maxApiCalls?: true
    maxTokens?: true
    maxStorageMb?: true
    maxProcessingMin?: true
    maxWorkspaces?: true
    maxUsers?: true
    maxFileSize?: true
    maxTranscriptionsMonthly?: true
    maxFilesDaily?: true
    maxFilesMonthly?: true
    maxConcurrentJobs?: true
    maxVoiceSynthesisMonthly?: true
    maxExportOperationsMonthly?: true
    maxAudioDurationMinutes?: true
    priorityLevel?: true
    trialDays?: true
  }

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    planCode?: true
    price?: true
    currency?: true
    billingInterval?: true
    tier?: true
    sortOrder?: true
    maxApiCalls?: true
    maxTokens?: true
    maxStorageMb?: true
    maxProcessingMin?: true
    maxWorkspaces?: true
    maxUsers?: true
    maxFileSize?: true
    maxTranscriptionsMonthly?: true
    maxFilesDaily?: true
    maxFilesMonthly?: true
    maxConcurrentJobs?: true
    maxVoiceSynthesisMonthly?: true
    maxExportOperationsMonthly?: true
    maxAudioDurationMinutes?: true
    priorityLevel?: true
    planCategory?: true
    trialDays?: true
    isCustom?: true
    isEnterprise?: true
    isActive?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    planCode?: true
    price?: true
    currency?: true
    billingInterval?: true
    tier?: true
    sortOrder?: true
    maxApiCalls?: true
    maxTokens?: true
    maxStorageMb?: true
    maxProcessingMin?: true
    maxWorkspaces?: true
    maxUsers?: true
    maxFileSize?: true
    maxTranscriptionsMonthly?: true
    maxFilesDaily?: true
    maxFilesMonthly?: true
    maxConcurrentJobs?: true
    maxVoiceSynthesisMonthly?: true
    maxExportOperationsMonthly?: true
    maxAudioDurationMinutes?: true
    priorityLevel?: true
    planCategory?: true
    trialDays?: true
    isCustom?: true
    isEnterprise?: true
    isActive?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    planCode?: true
    price?: true
    currency?: true
    billingInterval?: true
    tier?: true
    sortOrder?: true
    maxApiCalls?: true
    maxTokens?: true
    maxStorageMb?: true
    maxProcessingMin?: true
    maxWorkspaces?: true
    maxUsers?: true
    maxFileSize?: true
    maxTranscriptionsMonthly?: true
    maxFilesDaily?: true
    maxFilesMonthly?: true
    maxConcurrentJobs?: true
    maxVoiceSynthesisMonthly?: true
    maxExportOperationsMonthly?: true
    maxAudioDurationMinutes?: true
    priorityLevel?: true
    planCategory?: true
    trialDays?: true
    isCustom?: true
    isEnterprise?: true
    features?: true
    recommendedFor?: true
    allowedFileTypes?: true
    analysisFeatures?: true
    collaborationFeatures?: true
    integrationFeatures?: true
    isActive?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type GetSubscriptionPlanAggregateType<T extends SubscriptionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
  }




  export type SubscriptionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithAggregationInput | SubscriptionPlanOrderByWithAggregationInput[]
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum
    having?: SubscriptionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlanCountAggregateInputType | true
    _avg?: SubscriptionPlanAvgAggregateInputType
    _sum?: SubscriptionPlanSumAggregateInputType
    _min?: SubscriptionPlanMinAggregateInputType
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type SubscriptionPlanGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    planCode: string
    price: Decimal
    currency: string
    billingInterval: string
    tier: string
    sortOrder: number
    maxApiCalls: bigint
    maxTokens: bigint
    maxStorageMb: bigint
    maxProcessingMin: bigint
    maxWorkspaces: number
    maxUsers: number
    maxFileSize: bigint
    maxTranscriptionsMonthly: bigint
    maxFilesDaily: number
    maxFilesMonthly: number
    maxConcurrentJobs: number
    maxVoiceSynthesisMonthly: bigint
    maxExportOperationsMonthly: number
    maxAudioDurationMinutes: number
    priorityLevel: number
    planCategory: string
    trialDays: number
    isCustom: boolean
    isEnterprise: boolean
    features: JsonValue
    recommendedFor: string[]
    allowedFileTypes: string[]
    analysisFeatures: string[]
    collaborationFeatures: string[]
    integrationFeatures: string[]
    isActive: boolean
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  type GetSubscriptionPlanGroupByPayload<T extends SubscriptionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    planCode?: boolean
    price?: boolean
    currency?: boolean
    billingInterval?: boolean
    tier?: boolean
    sortOrder?: boolean
    maxApiCalls?: boolean
    maxTokens?: boolean
    maxStorageMb?: boolean
    maxProcessingMin?: boolean
    maxWorkspaces?: boolean
    maxUsers?: boolean
    maxFileSize?: boolean
    maxTranscriptionsMonthly?: boolean
    maxFilesDaily?: boolean
    maxFilesMonthly?: boolean
    maxConcurrentJobs?: boolean
    maxVoiceSynthesisMonthly?: boolean
    maxExportOperationsMonthly?: boolean
    maxAudioDurationMinutes?: boolean
    priorityLevel?: boolean
    planCategory?: boolean
    trialDays?: boolean
    isCustom?: boolean
    isEnterprise?: boolean
    features?: boolean
    recommendedFor?: boolean
    allowedFileTypes?: boolean
    analysisFeatures?: boolean
    collaborationFeatures?: boolean
    integrationFeatures?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    planPricing?: boolean | SubscriptionPlan$planPricingArgs<ExtArgs>
    planFeatures?: boolean | SubscriptionPlan$planFeaturesArgs<ExtArgs>
    currentPlanRecommendations?: boolean | SubscriptionPlan$currentPlanRecommendationsArgs<ExtArgs>
    recommendedPlanRecommendations?: boolean | SubscriptionPlan$recommendedPlanRecommendationsArgs<ExtArgs>
    customPlans?: boolean | SubscriptionPlan$customPlansArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    planCode?: boolean
    price?: boolean
    currency?: boolean
    billingInterval?: boolean
    tier?: boolean
    sortOrder?: boolean
    maxApiCalls?: boolean
    maxTokens?: boolean
    maxStorageMb?: boolean
    maxProcessingMin?: boolean
    maxWorkspaces?: boolean
    maxUsers?: boolean
    maxFileSize?: boolean
    maxTranscriptionsMonthly?: boolean
    maxFilesDaily?: boolean
    maxFilesMonthly?: boolean
    maxConcurrentJobs?: boolean
    maxVoiceSynthesisMonthly?: boolean
    maxExportOperationsMonthly?: boolean
    maxAudioDurationMinutes?: boolean
    priorityLevel?: boolean
    planCategory?: boolean
    trialDays?: boolean
    isCustom?: boolean
    isEnterprise?: boolean
    features?: boolean
    recommendedFor?: boolean
    allowedFileTypes?: boolean
    analysisFeatures?: boolean
    collaborationFeatures?: boolean
    integrationFeatures?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    planCode?: boolean
    price?: boolean
    currency?: boolean
    billingInterval?: boolean
    tier?: boolean
    sortOrder?: boolean
    maxApiCalls?: boolean
    maxTokens?: boolean
    maxStorageMb?: boolean
    maxProcessingMin?: boolean
    maxWorkspaces?: boolean
    maxUsers?: boolean
    maxFileSize?: boolean
    maxTranscriptionsMonthly?: boolean
    maxFilesDaily?: boolean
    maxFilesMonthly?: boolean
    maxConcurrentJobs?: boolean
    maxVoiceSynthesisMonthly?: boolean
    maxExportOperationsMonthly?: boolean
    maxAudioDurationMinutes?: boolean
    priorityLevel?: boolean
    planCategory?: boolean
    trialDays?: boolean
    isCustom?: boolean
    isEnterprise?: boolean
    features?: boolean
    recommendedFor?: boolean
    allowedFileTypes?: boolean
    analysisFeatures?: boolean
    collaborationFeatures?: boolean
    integrationFeatures?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    planPricing?: boolean | SubscriptionPlan$planPricingArgs<ExtArgs>
    planFeatures?: boolean | SubscriptionPlan$planFeaturesArgs<ExtArgs>
    currentPlanRecommendations?: boolean | SubscriptionPlan$currentPlanRecommendationsArgs<ExtArgs>
    recommendedPlanRecommendations?: boolean | SubscriptionPlan$recommendedPlanRecommendationsArgs<ExtArgs>
    customPlans?: boolean | SubscriptionPlan$customPlansArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubscriptionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlan"
    objects: {
      subscriptions: Prisma.$WorkspaceSubscriptionPayload<ExtArgs>[]
      planPricing: Prisma.$PlanPricingPayload<ExtArgs>[]
      planFeatures: Prisma.$PlanFeatureMatrixPayload<ExtArgs>[]
      currentPlanRecommendations: Prisma.$PlanRecommendationPayload<ExtArgs>[]
      recommendedPlanRecommendations: Prisma.$PlanRecommendationPayload<ExtArgs>[]
      customPlans: Prisma.$CustomPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      planCode: string
      price: Prisma.Decimal
      currency: string
      billingInterval: string
      tier: string
      sortOrder: number
      maxApiCalls: bigint
      maxTokens: bigint
      maxStorageMb: bigint
      maxProcessingMin: bigint
      maxWorkspaces: number
      maxUsers: number
      maxFileSize: bigint
      maxTranscriptionsMonthly: bigint
      maxFilesDaily: number
      maxFilesMonthly: number
      maxConcurrentJobs: number
      maxVoiceSynthesisMonthly: bigint
      maxExportOperationsMonthly: number
      maxAudioDurationMinutes: number
      priorityLevel: number
      planCategory: string
      trialDays: number
      isCustom: boolean
      isEnterprise: boolean
      features: Prisma.JsonValue
      recommendedFor: string[]
      allowedFileTypes: string[]
      analysisFeatures: string[]
      collaborationFeatures: string[]
      integrationFeatures: string[]
      isActive: boolean
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionPlan"]>
    composites: {}
  }

  type SubscriptionPlanGetPayload<S extends boolean | null | undefined | SubscriptionPlanDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>

  type SubscriptionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionPlanCountAggregateInputType | true
    }

  export interface SubscriptionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'], meta: { name: 'SubscriptionPlan' } }
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPlanCreateArgs>(args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPlanDeleteArgs>(args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPlanUpdateArgs>(args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(args: Subset<T, SubscriptionPlanAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlan model
   */
  readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends SubscriptionPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    planPricing<T extends SubscriptionPlan$planPricingArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$planPricingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "findMany"> | Null>
    planFeatures<T extends SubscriptionPlan$planFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$planFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanFeatureMatrixPayload<ExtArgs>, T, "findMany"> | Null>
    currentPlanRecommendations<T extends SubscriptionPlan$currentPlanRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$currentPlanRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "findMany"> | Null>
    recommendedPlanRecommendations<T extends SubscriptionPlan$recommendedPlanRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$recommendedPlanRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "findMany"> | Null>
    customPlans<T extends SubscriptionPlan$customPlansArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$customPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPlanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPlan model
   */ 
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<"SubscriptionPlan", 'String'>
    readonly name: FieldRef<"SubscriptionPlan", 'String'>
    readonly displayName: FieldRef<"SubscriptionPlan", 'String'>
    readonly description: FieldRef<"SubscriptionPlan", 'String'>
    readonly planCode: FieldRef<"SubscriptionPlan", 'String'>
    readonly price: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly currency: FieldRef<"SubscriptionPlan", 'String'>
    readonly billingInterval: FieldRef<"SubscriptionPlan", 'String'>
    readonly tier: FieldRef<"SubscriptionPlan", 'String'>
    readonly sortOrder: FieldRef<"SubscriptionPlan", 'Float'>
    readonly maxApiCalls: FieldRef<"SubscriptionPlan", 'BigInt'>
    readonly maxTokens: FieldRef<"SubscriptionPlan", 'BigInt'>
    readonly maxStorageMb: FieldRef<"SubscriptionPlan", 'BigInt'>
    readonly maxProcessingMin: FieldRef<"SubscriptionPlan", 'BigInt'>
    readonly maxWorkspaces: FieldRef<"SubscriptionPlan", 'Int'>
    readonly maxUsers: FieldRef<"SubscriptionPlan", 'Int'>
    readonly maxFileSize: FieldRef<"SubscriptionPlan", 'BigInt'>
    readonly maxTranscriptionsMonthly: FieldRef<"SubscriptionPlan", 'BigInt'>
    readonly maxFilesDaily: FieldRef<"SubscriptionPlan", 'Int'>
    readonly maxFilesMonthly: FieldRef<"SubscriptionPlan", 'Int'>
    readonly maxConcurrentJobs: FieldRef<"SubscriptionPlan", 'Int'>
    readonly maxVoiceSynthesisMonthly: FieldRef<"SubscriptionPlan", 'BigInt'>
    readonly maxExportOperationsMonthly: FieldRef<"SubscriptionPlan", 'Int'>
    readonly maxAudioDurationMinutes: FieldRef<"SubscriptionPlan", 'Int'>
    readonly priorityLevel: FieldRef<"SubscriptionPlan", 'Int'>
    readonly planCategory: FieldRef<"SubscriptionPlan", 'String'>
    readonly trialDays: FieldRef<"SubscriptionPlan", 'Int'>
    readonly isCustom: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly isEnterprise: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly features: FieldRef<"SubscriptionPlan", 'Json'>
    readonly recommendedFor: FieldRef<"SubscriptionPlan", 'String[]'>
    readonly allowedFileTypes: FieldRef<"SubscriptionPlan", 'String[]'>
    readonly analysisFeatures: FieldRef<"SubscriptionPlan", 'String[]'>
    readonly collaborationFeatures: FieldRef<"SubscriptionPlan", 'String[]'>
    readonly integrationFeatures: FieldRef<"SubscriptionPlan", 'String[]'>
    readonly isActive: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly isPublic: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly createdAt: FieldRef<"SubscriptionPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
  }

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
  }

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput
  }

  /**
   * SubscriptionPlan.subscriptions
   */
  export type SubscriptionPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    where?: WorkspaceSubscriptionWhereInput
    orderBy?: WorkspaceSubscriptionOrderByWithRelationInput | WorkspaceSubscriptionOrderByWithRelationInput[]
    cursor?: WorkspaceSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceSubscriptionScalarFieldEnum | WorkspaceSubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan.planPricing
   */
  export type SubscriptionPlan$planPricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    where?: PlanPricingWhereInput
    orderBy?: PlanPricingOrderByWithRelationInput | PlanPricingOrderByWithRelationInput[]
    cursor?: PlanPricingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanPricingScalarFieldEnum | PlanPricingScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan.planFeatures
   */
  export type SubscriptionPlan$planFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixInclude<ExtArgs> | null
    where?: PlanFeatureMatrixWhereInput
    orderBy?: PlanFeatureMatrixOrderByWithRelationInput | PlanFeatureMatrixOrderByWithRelationInput[]
    cursor?: PlanFeatureMatrixWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanFeatureMatrixScalarFieldEnum | PlanFeatureMatrixScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan.currentPlanRecommendations
   */
  export type SubscriptionPlan$currentPlanRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
    where?: PlanRecommendationWhereInput
    orderBy?: PlanRecommendationOrderByWithRelationInput | PlanRecommendationOrderByWithRelationInput[]
    cursor?: PlanRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanRecommendationScalarFieldEnum | PlanRecommendationScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan.recommendedPlanRecommendations
   */
  export type SubscriptionPlan$recommendedPlanRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
    where?: PlanRecommendationWhereInput
    orderBy?: PlanRecommendationOrderByWithRelationInput | PlanRecommendationOrderByWithRelationInput[]
    cursor?: PlanRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanRecommendationScalarFieldEnum | PlanRecommendationScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan.customPlans
   */
  export type SubscriptionPlan$customPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanInclude<ExtArgs> | null
    where?: CustomPlanWhereInput
    orderBy?: CustomPlanOrderByWithRelationInput | CustomPlanOrderByWithRelationInput[]
    cursor?: CustomPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomPlanScalarFieldEnum | CustomPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
  }


  /**
   * Model PlanPricing
   */

  export type AggregatePlanPricing = {
    _count: PlanPricingCountAggregateOutputType | null
    _avg: PlanPricingAvgAggregateOutputType | null
    _sum: PlanPricingSumAggregateOutputType | null
    _min: PlanPricingMinAggregateOutputType | null
    _max: PlanPricingMaxAggregateOutputType | null
  }

  export type PlanPricingAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type PlanPricingSumAggregateOutputType = {
    price: Decimal | null
  }

  export type PlanPricingMinAggregateOutputType = {
    id: string | null
    planId: string | null
    currency: string | null
    price: Decimal | null
    billingPeriod: string | null
    region: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanPricingMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    currency: string | null
    price: Decimal | null
    billingPeriod: string | null
    region: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanPricingCountAggregateOutputType = {
    id: number
    planId: number
    currency: number
    price: number
    billingPeriod: number
    region: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanPricingAvgAggregateInputType = {
    price?: true
  }

  export type PlanPricingSumAggregateInputType = {
    price?: true
  }

  export type PlanPricingMinAggregateInputType = {
    id?: true
    planId?: true
    currency?: true
    price?: true
    billingPeriod?: true
    region?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanPricingMaxAggregateInputType = {
    id?: true
    planId?: true
    currency?: true
    price?: true
    billingPeriod?: true
    region?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanPricingCountAggregateInputType = {
    id?: true
    planId?: true
    currency?: true
    price?: true
    billingPeriod?: true
    region?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanPricingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanPricing to aggregate.
     */
    where?: PlanPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPricings to fetch.
     */
    orderBy?: PlanPricingOrderByWithRelationInput | PlanPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanPricings
    **/
    _count?: true | PlanPricingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanPricingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanPricingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanPricingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanPricingMaxAggregateInputType
  }

  export type GetPlanPricingAggregateType<T extends PlanPricingAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanPricing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanPricing[P]>
      : GetScalarType<T[P], AggregatePlanPricing[P]>
  }




  export type PlanPricingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanPricingWhereInput
    orderBy?: PlanPricingOrderByWithAggregationInput | PlanPricingOrderByWithAggregationInput[]
    by: PlanPricingScalarFieldEnum[] | PlanPricingScalarFieldEnum
    having?: PlanPricingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanPricingCountAggregateInputType | true
    _avg?: PlanPricingAvgAggregateInputType
    _sum?: PlanPricingSumAggregateInputType
    _min?: PlanPricingMinAggregateInputType
    _max?: PlanPricingMaxAggregateInputType
  }

  export type PlanPricingGroupByOutputType = {
    id: string
    planId: string
    currency: string
    price: Decimal
    billingPeriod: string
    region: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlanPricingCountAggregateOutputType | null
    _avg: PlanPricingAvgAggregateOutputType | null
    _sum: PlanPricingSumAggregateOutputType | null
    _min: PlanPricingMinAggregateOutputType | null
    _max: PlanPricingMaxAggregateOutputType | null
  }

  type GetPlanPricingGroupByPayload<T extends PlanPricingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanPricingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanPricingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanPricingGroupByOutputType[P]>
            : GetScalarType<T[P], PlanPricingGroupByOutputType[P]>
        }
      >
    >


  export type PlanPricingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    currency?: boolean
    price?: boolean
    billingPeriod?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planPricing"]>

  export type PlanPricingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    currency?: boolean
    price?: boolean
    billingPeriod?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planPricing"]>

  export type PlanPricingSelectScalar = {
    id?: boolean
    planId?: boolean
    currency?: boolean
    price?: boolean
    billingPeriod?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanPricingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }
  export type PlanPricingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $PlanPricingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanPricing"
    objects: {
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      currency: string
      price: Prisma.Decimal
      billingPeriod: string
      region: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planPricing"]>
    composites: {}
  }

  type PlanPricingGetPayload<S extends boolean | null | undefined | PlanPricingDefaultArgs> = $Result.GetResult<Prisma.$PlanPricingPayload, S>

  type PlanPricingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanPricingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanPricingCountAggregateInputType | true
    }

  export interface PlanPricingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanPricing'], meta: { name: 'PlanPricing' } }
    /**
     * Find zero or one PlanPricing that matches the filter.
     * @param {PlanPricingFindUniqueArgs} args - Arguments to find a PlanPricing
     * @example
     * // Get one PlanPricing
     * const planPricing = await prisma.planPricing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanPricingFindUniqueArgs>(args: SelectSubset<T, PlanPricingFindUniqueArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlanPricing that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanPricingFindUniqueOrThrowArgs} args - Arguments to find a PlanPricing
     * @example
     * // Get one PlanPricing
     * const planPricing = await prisma.planPricing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanPricingFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanPricingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlanPricing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingFindFirstArgs} args - Arguments to find a PlanPricing
     * @example
     * // Get one PlanPricing
     * const planPricing = await prisma.planPricing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanPricingFindFirstArgs>(args?: SelectSubset<T, PlanPricingFindFirstArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlanPricing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingFindFirstOrThrowArgs} args - Arguments to find a PlanPricing
     * @example
     * // Get one PlanPricing
     * const planPricing = await prisma.planPricing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanPricingFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanPricingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlanPricings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanPricings
     * const planPricings = await prisma.planPricing.findMany()
     * 
     * // Get first 10 PlanPricings
     * const planPricings = await prisma.planPricing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planPricingWithIdOnly = await prisma.planPricing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanPricingFindManyArgs>(args?: SelectSubset<T, PlanPricingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlanPricing.
     * @param {PlanPricingCreateArgs} args - Arguments to create a PlanPricing.
     * @example
     * // Create one PlanPricing
     * const PlanPricing = await prisma.planPricing.create({
     *   data: {
     *     // ... data to create a PlanPricing
     *   }
     * })
     * 
     */
    create<T extends PlanPricingCreateArgs>(args: SelectSubset<T, PlanPricingCreateArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlanPricings.
     * @param {PlanPricingCreateManyArgs} args - Arguments to create many PlanPricings.
     * @example
     * // Create many PlanPricings
     * const planPricing = await prisma.planPricing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanPricingCreateManyArgs>(args?: SelectSubset<T, PlanPricingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanPricings and returns the data saved in the database.
     * @param {PlanPricingCreateManyAndReturnArgs} args - Arguments to create many PlanPricings.
     * @example
     * // Create many PlanPricings
     * const planPricing = await prisma.planPricing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanPricings and only return the `id`
     * const planPricingWithIdOnly = await prisma.planPricing.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanPricingCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanPricingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlanPricing.
     * @param {PlanPricingDeleteArgs} args - Arguments to delete one PlanPricing.
     * @example
     * // Delete one PlanPricing
     * const PlanPricing = await prisma.planPricing.delete({
     *   where: {
     *     // ... filter to delete one PlanPricing
     *   }
     * })
     * 
     */
    delete<T extends PlanPricingDeleteArgs>(args: SelectSubset<T, PlanPricingDeleteArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlanPricing.
     * @param {PlanPricingUpdateArgs} args - Arguments to update one PlanPricing.
     * @example
     * // Update one PlanPricing
     * const planPricing = await prisma.planPricing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanPricingUpdateArgs>(args: SelectSubset<T, PlanPricingUpdateArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlanPricings.
     * @param {PlanPricingDeleteManyArgs} args - Arguments to filter PlanPricings to delete.
     * @example
     * // Delete a few PlanPricings
     * const { count } = await prisma.planPricing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanPricingDeleteManyArgs>(args?: SelectSubset<T, PlanPricingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanPricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanPricings
     * const planPricing = await prisma.planPricing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanPricingUpdateManyArgs>(args: SelectSubset<T, PlanPricingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanPricing.
     * @param {PlanPricingUpsertArgs} args - Arguments to update or create a PlanPricing.
     * @example
     * // Update or create a PlanPricing
     * const planPricing = await prisma.planPricing.upsert({
     *   create: {
     *     // ... data to create a PlanPricing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanPricing we want to update
     *   }
     * })
     */
    upsert<T extends PlanPricingUpsertArgs>(args: SelectSubset<T, PlanPricingUpsertArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlanPricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingCountArgs} args - Arguments to filter PlanPricings to count.
     * @example
     * // Count the number of PlanPricings
     * const count = await prisma.planPricing.count({
     *   where: {
     *     // ... the filter for the PlanPricings we want to count
     *   }
     * })
    **/
    count<T extends PlanPricingCountArgs>(
      args?: Subset<T, PlanPricingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanPricingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanPricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanPricingAggregateArgs>(args: Subset<T, PlanPricingAggregateArgs>): Prisma.PrismaPromise<GetPlanPricingAggregateType<T>>

    /**
     * Group by PlanPricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanPricingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanPricingGroupByArgs['orderBy'] }
        : { orderBy?: PlanPricingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanPricingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanPricingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanPricing model
   */
  readonly fields: PlanPricingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanPricing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanPricingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanPricing model
   */ 
  interface PlanPricingFieldRefs {
    readonly id: FieldRef<"PlanPricing", 'String'>
    readonly planId: FieldRef<"PlanPricing", 'String'>
    readonly currency: FieldRef<"PlanPricing", 'String'>
    readonly price: FieldRef<"PlanPricing", 'Decimal'>
    readonly billingPeriod: FieldRef<"PlanPricing", 'String'>
    readonly region: FieldRef<"PlanPricing", 'String'>
    readonly isActive: FieldRef<"PlanPricing", 'Boolean'>
    readonly createdAt: FieldRef<"PlanPricing", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanPricing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanPricing findUnique
   */
  export type PlanPricingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * Filter, which PlanPricing to fetch.
     */
    where: PlanPricingWhereUniqueInput
  }

  /**
   * PlanPricing findUniqueOrThrow
   */
  export type PlanPricingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * Filter, which PlanPricing to fetch.
     */
    where: PlanPricingWhereUniqueInput
  }

  /**
   * PlanPricing findFirst
   */
  export type PlanPricingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * Filter, which PlanPricing to fetch.
     */
    where?: PlanPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPricings to fetch.
     */
    orderBy?: PlanPricingOrderByWithRelationInput | PlanPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanPricings.
     */
    cursor?: PlanPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanPricings.
     */
    distinct?: PlanPricingScalarFieldEnum | PlanPricingScalarFieldEnum[]
  }

  /**
   * PlanPricing findFirstOrThrow
   */
  export type PlanPricingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * Filter, which PlanPricing to fetch.
     */
    where?: PlanPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPricings to fetch.
     */
    orderBy?: PlanPricingOrderByWithRelationInput | PlanPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanPricings.
     */
    cursor?: PlanPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanPricings.
     */
    distinct?: PlanPricingScalarFieldEnum | PlanPricingScalarFieldEnum[]
  }

  /**
   * PlanPricing findMany
   */
  export type PlanPricingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * Filter, which PlanPricings to fetch.
     */
    where?: PlanPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPricings to fetch.
     */
    orderBy?: PlanPricingOrderByWithRelationInput | PlanPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanPricings.
     */
    cursor?: PlanPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPricings.
     */
    skip?: number
    distinct?: PlanPricingScalarFieldEnum | PlanPricingScalarFieldEnum[]
  }

  /**
   * PlanPricing create
   */
  export type PlanPricingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanPricing.
     */
    data: XOR<PlanPricingCreateInput, PlanPricingUncheckedCreateInput>
  }

  /**
   * PlanPricing createMany
   */
  export type PlanPricingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanPricings.
     */
    data: PlanPricingCreateManyInput | PlanPricingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanPricing createManyAndReturn
   */
  export type PlanPricingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlanPricings.
     */
    data: PlanPricingCreateManyInput | PlanPricingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanPricing update
   */
  export type PlanPricingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanPricing.
     */
    data: XOR<PlanPricingUpdateInput, PlanPricingUncheckedUpdateInput>
    /**
     * Choose, which PlanPricing to update.
     */
    where: PlanPricingWhereUniqueInput
  }

  /**
   * PlanPricing updateMany
   */
  export type PlanPricingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanPricings.
     */
    data: XOR<PlanPricingUpdateManyMutationInput, PlanPricingUncheckedUpdateManyInput>
    /**
     * Filter which PlanPricings to update
     */
    where?: PlanPricingWhereInput
  }

  /**
   * PlanPricing upsert
   */
  export type PlanPricingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanPricing to update in case it exists.
     */
    where: PlanPricingWhereUniqueInput
    /**
     * In case the PlanPricing found by the `where` argument doesn't exist, create a new PlanPricing with this data.
     */
    create: XOR<PlanPricingCreateInput, PlanPricingUncheckedCreateInput>
    /**
     * In case the PlanPricing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanPricingUpdateInput, PlanPricingUncheckedUpdateInput>
  }

  /**
   * PlanPricing delete
   */
  export type PlanPricingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * Filter which PlanPricing to delete.
     */
    where: PlanPricingWhereUniqueInput
  }

  /**
   * PlanPricing deleteMany
   */
  export type PlanPricingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanPricings to delete
     */
    where?: PlanPricingWhereInput
  }

  /**
   * PlanPricing without action
   */
  export type PlanPricingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
  }


  /**
   * Model Currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyAvgAggregateOutputType = {
    exchangeRate: Decimal | null
  }

  export type CurrencySumAggregateOutputType = {
    exchangeRate: Decimal | null
  }

  export type CurrencyMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    symbol: string | null
    exchangeRate: Decimal | null
    lastUpdated: Date | null
    isActive: boolean | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    symbol: string | null
    exchangeRate: Decimal | null
    lastUpdated: Date | null
    isActive: boolean | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyCountAggregateOutputType = {
    id: number
    code: number
    name: number
    symbol: number
    exchangeRate: number
    lastUpdated: number
    isActive: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CurrencyAvgAggregateInputType = {
    exchangeRate?: true
  }

  export type CurrencySumAggregateInputType = {
    exchangeRate?: true
  }

  export type CurrencyMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    symbol?: true
    exchangeRate?: true
    lastUpdated?: true
    isActive?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    symbol?: true
    exchangeRate?: true
    lastUpdated?: true
    isActive?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    symbol?: true
    exchangeRate?: true
    lastUpdated?: true
    isActive?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currency to aggregate.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithAggregationInput | CurrencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _avg?: CurrencyAvgAggregateInputType
    _sum?: CurrencySumAggregateInputType
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    id: string
    code: string
    name: string
    symbol: string
    exchangeRate: Decimal
    lastUpdated: Date
    isActive: boolean
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    exchangeRate?: boolean
    lastUpdated?: boolean
    isActive?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    exchangeRate?: boolean
    lastUpdated?: boolean
    isActive?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    exchangeRate?: boolean
    lastUpdated?: boolean
    isActive?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Currency"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      symbol: string
      exchangeRate: Prisma.Decimal
      lastUpdated: Date
      isActive: boolean
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }

  type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyDefaultArgs> = $Result.GetResult<Prisma.$CurrencyPayload, S>

  type CurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CurrencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface CurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Currency'], meta: { name: 'Currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyFindUniqueArgs>(args: SelectSubset<T, CurrencyFindUniqueArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Currency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CurrencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyFindFirstArgs>(args?: SelectSubset<T, CurrencyFindFirstArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyWithIdOnly = await prisma.currency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrencyFindManyArgs>(args?: SelectSubset<T, CurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
     */
    create<T extends CurrencyCreateArgs>(args: SelectSubset<T, CurrencyCreateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Currencies.
     * @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyCreateManyArgs>(args?: SelectSubset<T, CurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Currencies and returns the data saved in the database.
     * @param {CurrencyCreateManyAndReturnArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
     */
    delete<T extends CurrencyDeleteArgs>(args: SelectSubset<T, CurrencyDeleteArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyUpdateArgs>(args: SelectSubset<T, CurrencyUpdateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyDeleteManyArgs>(args?: SelectSubset<T, CurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyUpdateManyArgs>(args: SelectSubset<T, CurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyUpsertArgs>(args: SelectSubset<T, CurrencyUpsertArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Currency model
   */
  readonly fields: CurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Currency model
   */ 
  interface CurrencyFieldRefs {
    readonly id: FieldRef<"Currency", 'String'>
    readonly code: FieldRef<"Currency", 'String'>
    readonly name: FieldRef<"Currency", 'String'>
    readonly symbol: FieldRef<"Currency", 'String'>
    readonly exchangeRate: FieldRef<"Currency", 'Decimal'>
    readonly lastUpdated: FieldRef<"Currency", 'DateTime'>
    readonly isActive: FieldRef<"Currency", 'Boolean'>
    readonly isPrimary: FieldRef<"Currency", 'Boolean'>
    readonly createdAt: FieldRef<"Currency", 'DateTime'>
    readonly updatedAt: FieldRef<"Currency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findUniqueOrThrow
   */
  export type CurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findFirstOrThrow
   */
  export type CurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Filter, which Currencies to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency create
   */
  export type CurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * The data needed to create a Currency.
     */
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }

  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency createManyAndReturn
   */
  export type CurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency update
   */
  export type CurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * The data needed to update a Currency.
     */
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
  }

  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * The filter to search for the Currency to update in case it exists.
     */
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
     */
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }

  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Filter which Currency to delete.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currencies to delete
     */
    where?: CurrencyWhereInput
  }

  /**
   * Currency without action
   */
  export type CurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
  }


  /**
   * Model WorkspaceSubscription
   */

  export type AggregateWorkspaceSubscription = {
    _count: WorkspaceSubscriptionCountAggregateOutputType | null
    _avg: WorkspaceSubscriptionAvgAggregateOutputType | null
    _sum: WorkspaceSubscriptionSumAggregateOutputType | null
    _min: WorkspaceSubscriptionMinAggregateOutputType | null
    _max: WorkspaceSubscriptionMaxAggregateOutputType | null
  }

  export type WorkspaceSubscriptionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type WorkspaceSubscriptionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type WorkspaceSubscriptionMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    planId: string | null
    status: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    nextBillingDate: Date | null
    trialEnd: Date | null
    paymentGateway: string | null
    paymentMethodId: string | null
    currency: string | null
    amount: Decimal | null
    ewayCustomerId: string | null
    stripeSubscriptionId: string | null
    stripeCustomerId: string | null
    cancelledAt: Date | null
    cancelReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceSubscriptionMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    planId: string | null
    status: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    nextBillingDate: Date | null
    trialEnd: Date | null
    paymentGateway: string | null
    paymentMethodId: string | null
    currency: string | null
    amount: Decimal | null
    ewayCustomerId: string | null
    stripeSubscriptionId: string | null
    stripeCustomerId: string | null
    cancelledAt: Date | null
    cancelReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceSubscriptionCountAggregateOutputType = {
    id: number
    workspaceId: number
    planId: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    nextBillingDate: number
    trialEnd: number
    paymentGateway: number
    paymentMethodId: number
    currency: number
    amount: number
    ewayCustomerId: number
    stripeSubscriptionId: number
    stripeCustomerId: number
    cancelledAt: number
    cancelReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceSubscriptionAvgAggregateInputType = {
    amount?: true
  }

  export type WorkspaceSubscriptionSumAggregateInputType = {
    amount?: true
  }

  export type WorkspaceSubscriptionMinAggregateInputType = {
    id?: true
    workspaceId?: true
    planId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    nextBillingDate?: true
    trialEnd?: true
    paymentGateway?: true
    paymentMethodId?: true
    currency?: true
    amount?: true
    ewayCustomerId?: true
    stripeSubscriptionId?: true
    stripeCustomerId?: true
    cancelledAt?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceSubscriptionMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    planId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    nextBillingDate?: true
    trialEnd?: true
    paymentGateway?: true
    paymentMethodId?: true
    currency?: true
    amount?: true
    ewayCustomerId?: true
    stripeSubscriptionId?: true
    stripeCustomerId?: true
    cancelledAt?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceSubscriptionCountAggregateInputType = {
    id?: true
    workspaceId?: true
    planId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    nextBillingDate?: true
    trialEnd?: true
    paymentGateway?: true
    paymentMethodId?: true
    currency?: true
    amount?: true
    ewayCustomerId?: true
    stripeSubscriptionId?: true
    stripeCustomerId?: true
    cancelledAt?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceSubscription to aggregate.
     */
    where?: WorkspaceSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceSubscriptions to fetch.
     */
    orderBy?: WorkspaceSubscriptionOrderByWithRelationInput | WorkspaceSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceSubscriptions
    **/
    _count?: true | WorkspaceSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkspaceSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkspaceSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceSubscriptionMaxAggregateInputType
  }

  export type GetWorkspaceSubscriptionAggregateType<T extends WorkspaceSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceSubscription[P]>
      : GetScalarType<T[P], AggregateWorkspaceSubscription[P]>
  }




  export type WorkspaceSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceSubscriptionWhereInput
    orderBy?: WorkspaceSubscriptionOrderByWithAggregationInput | WorkspaceSubscriptionOrderByWithAggregationInput[]
    by: WorkspaceSubscriptionScalarFieldEnum[] | WorkspaceSubscriptionScalarFieldEnum
    having?: WorkspaceSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceSubscriptionCountAggregateInputType | true
    _avg?: WorkspaceSubscriptionAvgAggregateInputType
    _sum?: WorkspaceSubscriptionSumAggregateInputType
    _min?: WorkspaceSubscriptionMinAggregateInputType
    _max?: WorkspaceSubscriptionMaxAggregateInputType
  }

  export type WorkspaceSubscriptionGroupByOutputType = {
    id: string
    workspaceId: string
    planId: string
    status: string
    currentPeriodStart: Date
    currentPeriodEnd: Date
    nextBillingDate: Date | null
    trialEnd: Date | null
    paymentGateway: string
    paymentMethodId: string | null
    currency: string
    amount: Decimal
    ewayCustomerId: string | null
    stripeSubscriptionId: string | null
    stripeCustomerId: string | null
    cancelledAt: Date | null
    cancelReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceSubscriptionCountAggregateOutputType | null
    _avg: WorkspaceSubscriptionAvgAggregateOutputType | null
    _sum: WorkspaceSubscriptionSumAggregateOutputType | null
    _min: WorkspaceSubscriptionMinAggregateOutputType | null
    _max: WorkspaceSubscriptionMaxAggregateOutputType | null
  }

  type GetWorkspaceSubscriptionGroupByPayload<T extends WorkspaceSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    nextBillingDate?: boolean
    trialEnd?: boolean
    paymentGateway?: boolean
    paymentMethodId?: boolean
    currency?: boolean
    amount?: boolean
    ewayCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    billingRecords?: boolean | WorkspaceSubscription$billingRecordsArgs<ExtArgs>
    usageRecords?: boolean | WorkspaceSubscription$usageRecordsArgs<ExtArgs>
    _count?: boolean | WorkspaceSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceSubscription"]>

  export type WorkspaceSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    nextBillingDate?: boolean
    trialEnd?: boolean
    paymentGateway?: boolean
    paymentMethodId?: boolean
    currency?: boolean
    amount?: boolean
    ewayCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceSubscription"]>

  export type WorkspaceSubscriptionSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    nextBillingDate?: boolean
    trialEnd?: boolean
    paymentGateway?: boolean
    paymentMethodId?: boolean
    currency?: boolean
    amount?: boolean
    ewayCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    billingRecords?: boolean | WorkspaceSubscription$billingRecordsArgs<ExtArgs>
    usageRecords?: boolean | WorkspaceSubscription$usageRecordsArgs<ExtArgs>
    _count?: boolean | WorkspaceSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $WorkspaceSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceSubscription"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
      billingRecords: Prisma.$BillingRecordPayload<ExtArgs>[]
      usageRecords: Prisma.$UsageRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      planId: string
      status: string
      currentPeriodStart: Date
      currentPeriodEnd: Date
      nextBillingDate: Date | null
      trialEnd: Date | null
      paymentGateway: string
      paymentMethodId: string | null
      currency: string
      amount: Prisma.Decimal
      ewayCustomerId: string | null
      stripeSubscriptionId: string | null
      stripeCustomerId: string | null
      cancelledAt: Date | null
      cancelReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspaceSubscription"]>
    composites: {}
  }

  type WorkspaceSubscriptionGetPayload<S extends boolean | null | undefined | WorkspaceSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceSubscriptionPayload, S>

  type WorkspaceSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceSubscriptionCountAggregateInputType | true
    }

  export interface WorkspaceSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceSubscription'], meta: { name: 'WorkspaceSubscription' } }
    /**
     * Find zero or one WorkspaceSubscription that matches the filter.
     * @param {WorkspaceSubscriptionFindUniqueArgs} args - Arguments to find a WorkspaceSubscription
     * @example
     * // Get one WorkspaceSubscription
     * const workspaceSubscription = await prisma.workspaceSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceSubscriptionFindUniqueArgs>(args: SelectSubset<T, WorkspaceSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkspaceSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceSubscription
     * @example
     * // Get one WorkspaceSubscription
     * const workspaceSubscription = await prisma.workspaceSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkspaceSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionFindFirstArgs} args - Arguments to find a WorkspaceSubscription
     * @example
     * // Get one WorkspaceSubscription
     * const workspaceSubscription = await prisma.workspaceSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceSubscriptionFindFirstArgs>(args?: SelectSubset<T, WorkspaceSubscriptionFindFirstArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkspaceSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionFindFirstOrThrowArgs} args - Arguments to find a WorkspaceSubscription
     * @example
     * // Get one WorkspaceSubscription
     * const workspaceSubscription = await prisma.workspaceSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkspaceSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceSubscriptions
     * const workspaceSubscriptions = await prisma.workspaceSubscription.findMany()
     * 
     * // Get first 10 WorkspaceSubscriptions
     * const workspaceSubscriptions = await prisma.workspaceSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceSubscriptionWithIdOnly = await prisma.workspaceSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceSubscriptionFindManyArgs>(args?: SelectSubset<T, WorkspaceSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkspaceSubscription.
     * @param {WorkspaceSubscriptionCreateArgs} args - Arguments to create a WorkspaceSubscription.
     * @example
     * // Create one WorkspaceSubscription
     * const WorkspaceSubscription = await prisma.workspaceSubscription.create({
     *   data: {
     *     // ... data to create a WorkspaceSubscription
     *   }
     * })
     * 
     */
    create<T extends WorkspaceSubscriptionCreateArgs>(args: SelectSubset<T, WorkspaceSubscriptionCreateArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkspaceSubscriptions.
     * @param {WorkspaceSubscriptionCreateManyArgs} args - Arguments to create many WorkspaceSubscriptions.
     * @example
     * // Create many WorkspaceSubscriptions
     * const workspaceSubscription = await prisma.workspaceSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceSubscriptionCreateManyArgs>(args?: SelectSubset<T, WorkspaceSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceSubscriptions and returns the data saved in the database.
     * @param {WorkspaceSubscriptionCreateManyAndReturnArgs} args - Arguments to create many WorkspaceSubscriptions.
     * @example
     * // Create many WorkspaceSubscriptions
     * const workspaceSubscription = await prisma.workspaceSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceSubscriptions and only return the `id`
     * const workspaceSubscriptionWithIdOnly = await prisma.workspaceSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkspaceSubscription.
     * @param {WorkspaceSubscriptionDeleteArgs} args - Arguments to delete one WorkspaceSubscription.
     * @example
     * // Delete one WorkspaceSubscription
     * const WorkspaceSubscription = await prisma.workspaceSubscription.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceSubscription
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceSubscriptionDeleteArgs>(args: SelectSubset<T, WorkspaceSubscriptionDeleteArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkspaceSubscription.
     * @param {WorkspaceSubscriptionUpdateArgs} args - Arguments to update one WorkspaceSubscription.
     * @example
     * // Update one WorkspaceSubscription
     * const workspaceSubscription = await prisma.workspaceSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceSubscriptionUpdateArgs>(args: SelectSubset<T, WorkspaceSubscriptionUpdateArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkspaceSubscriptions.
     * @param {WorkspaceSubscriptionDeleteManyArgs} args - Arguments to filter WorkspaceSubscriptions to delete.
     * @example
     * // Delete a few WorkspaceSubscriptions
     * const { count } = await prisma.workspaceSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceSubscriptionDeleteManyArgs>(args?: SelectSubset<T, WorkspaceSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceSubscriptions
     * const workspaceSubscription = await prisma.workspaceSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceSubscriptionUpdateManyArgs>(args: SelectSubset<T, WorkspaceSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkspaceSubscription.
     * @param {WorkspaceSubscriptionUpsertArgs} args - Arguments to update or create a WorkspaceSubscription.
     * @example
     * // Update or create a WorkspaceSubscription
     * const workspaceSubscription = await prisma.workspaceSubscription.upsert({
     *   create: {
     *     // ... data to create a WorkspaceSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceSubscription we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceSubscriptionUpsertArgs>(args: SelectSubset<T, WorkspaceSubscriptionUpsertArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkspaceSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionCountArgs} args - Arguments to filter WorkspaceSubscriptions to count.
     * @example
     * // Count the number of WorkspaceSubscriptions
     * const count = await prisma.workspaceSubscription.count({
     *   where: {
     *     // ... the filter for the WorkspaceSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceSubscriptionCountArgs>(
      args?: Subset<T, WorkspaceSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceSubscriptionAggregateArgs>(args: Subset<T, WorkspaceSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceSubscriptionAggregateType<T>>

    /**
     * Group by WorkspaceSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceSubscription model
   */
  readonly fields: WorkspaceSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    billingRecords<T extends WorkspaceSubscription$billingRecordsArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceSubscription$billingRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "findMany"> | Null>
    usageRecords<T extends WorkspaceSubscription$usageRecordsArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceSubscription$usageRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceSubscription model
   */ 
  interface WorkspaceSubscriptionFieldRefs {
    readonly id: FieldRef<"WorkspaceSubscription", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceSubscription", 'String'>
    readonly planId: FieldRef<"WorkspaceSubscription", 'String'>
    readonly status: FieldRef<"WorkspaceSubscription", 'String'>
    readonly currentPeriodStart: FieldRef<"WorkspaceSubscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"WorkspaceSubscription", 'DateTime'>
    readonly nextBillingDate: FieldRef<"WorkspaceSubscription", 'DateTime'>
    readonly trialEnd: FieldRef<"WorkspaceSubscription", 'DateTime'>
    readonly paymentGateway: FieldRef<"WorkspaceSubscription", 'String'>
    readonly paymentMethodId: FieldRef<"WorkspaceSubscription", 'String'>
    readonly currency: FieldRef<"WorkspaceSubscription", 'String'>
    readonly amount: FieldRef<"WorkspaceSubscription", 'Decimal'>
    readonly ewayCustomerId: FieldRef<"WorkspaceSubscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"WorkspaceSubscription", 'String'>
    readonly stripeCustomerId: FieldRef<"WorkspaceSubscription", 'String'>
    readonly cancelledAt: FieldRef<"WorkspaceSubscription", 'DateTime'>
    readonly cancelReason: FieldRef<"WorkspaceSubscription", 'String'>
    readonly createdAt: FieldRef<"WorkspaceSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkspaceSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceSubscription findUnique
   */
  export type WorkspaceSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSubscription to fetch.
     */
    where: WorkspaceSubscriptionWhereUniqueInput
  }

  /**
   * WorkspaceSubscription findUniqueOrThrow
   */
  export type WorkspaceSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSubscription to fetch.
     */
    where: WorkspaceSubscriptionWhereUniqueInput
  }

  /**
   * WorkspaceSubscription findFirst
   */
  export type WorkspaceSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSubscription to fetch.
     */
    where?: WorkspaceSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceSubscriptions to fetch.
     */
    orderBy?: WorkspaceSubscriptionOrderByWithRelationInput | WorkspaceSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceSubscriptions.
     */
    cursor?: WorkspaceSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceSubscriptions.
     */
    distinct?: WorkspaceSubscriptionScalarFieldEnum | WorkspaceSubscriptionScalarFieldEnum[]
  }

  /**
   * WorkspaceSubscription findFirstOrThrow
   */
  export type WorkspaceSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSubscription to fetch.
     */
    where?: WorkspaceSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceSubscriptions to fetch.
     */
    orderBy?: WorkspaceSubscriptionOrderByWithRelationInput | WorkspaceSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceSubscriptions.
     */
    cursor?: WorkspaceSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceSubscriptions.
     */
    distinct?: WorkspaceSubscriptionScalarFieldEnum | WorkspaceSubscriptionScalarFieldEnum[]
  }

  /**
   * WorkspaceSubscription findMany
   */
  export type WorkspaceSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSubscriptions to fetch.
     */
    where?: WorkspaceSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceSubscriptions to fetch.
     */
    orderBy?: WorkspaceSubscriptionOrderByWithRelationInput | WorkspaceSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceSubscriptions.
     */
    cursor?: WorkspaceSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceSubscriptions.
     */
    skip?: number
    distinct?: WorkspaceSubscriptionScalarFieldEnum | WorkspaceSubscriptionScalarFieldEnum[]
  }

  /**
   * WorkspaceSubscription create
   */
  export type WorkspaceSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceSubscription.
     */
    data: XOR<WorkspaceSubscriptionCreateInput, WorkspaceSubscriptionUncheckedCreateInput>
  }

  /**
   * WorkspaceSubscription createMany
   */
  export type WorkspaceSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceSubscriptions.
     */
    data: WorkspaceSubscriptionCreateManyInput | WorkspaceSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceSubscription createManyAndReturn
   */
  export type WorkspaceSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkspaceSubscriptions.
     */
    data: WorkspaceSubscriptionCreateManyInput | WorkspaceSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceSubscription update
   */
  export type WorkspaceSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceSubscription.
     */
    data: XOR<WorkspaceSubscriptionUpdateInput, WorkspaceSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceSubscription to update.
     */
    where: WorkspaceSubscriptionWhereUniqueInput
  }

  /**
   * WorkspaceSubscription updateMany
   */
  export type WorkspaceSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceSubscriptions.
     */
    data: XOR<WorkspaceSubscriptionUpdateManyMutationInput, WorkspaceSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceSubscriptions to update
     */
    where?: WorkspaceSubscriptionWhereInput
  }

  /**
   * WorkspaceSubscription upsert
   */
  export type WorkspaceSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceSubscription to update in case it exists.
     */
    where: WorkspaceSubscriptionWhereUniqueInput
    /**
     * In case the WorkspaceSubscription found by the `where` argument doesn't exist, create a new WorkspaceSubscription with this data.
     */
    create: XOR<WorkspaceSubscriptionCreateInput, WorkspaceSubscriptionUncheckedCreateInput>
    /**
     * In case the WorkspaceSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceSubscriptionUpdateInput, WorkspaceSubscriptionUncheckedUpdateInput>
  }

  /**
   * WorkspaceSubscription delete
   */
  export type WorkspaceSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceSubscription to delete.
     */
    where: WorkspaceSubscriptionWhereUniqueInput
  }

  /**
   * WorkspaceSubscription deleteMany
   */
  export type WorkspaceSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceSubscriptions to delete
     */
    where?: WorkspaceSubscriptionWhereInput
  }

  /**
   * WorkspaceSubscription.billingRecords
   */
  export type WorkspaceSubscription$billingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    where?: BillingRecordWhereInput
    orderBy?: BillingRecordOrderByWithRelationInput | BillingRecordOrderByWithRelationInput[]
    cursor?: BillingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingRecordScalarFieldEnum | BillingRecordScalarFieldEnum[]
  }

  /**
   * WorkspaceSubscription.usageRecords
   */
  export type WorkspaceSubscription$usageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    where?: UsageRecordWhereInput
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    cursor?: UsageRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * WorkspaceSubscription without action
   */
  export type WorkspaceSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model BillingRecord
   */

  export type AggregateBillingRecord = {
    _count: BillingRecordCountAggregateOutputType | null
    _avg: BillingRecordAvgAggregateOutputType | null
    _sum: BillingRecordSumAggregateOutputType | null
    _min: BillingRecordMinAggregateOutputType | null
    _max: BillingRecordMaxAggregateOutputType | null
  }

  export type BillingRecordAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type BillingRecordSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type BillingRecordMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    invoiceNumber: string | null
    amount: Decimal | null
    currency: string | null
    status: string | null
    paymentMethod: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    paidAt: Date | null
    stripeInvoiceId: string | null
    ewayTransactionId: string | null
    invoiceUrl: string | null
    failureReason: string | null
    createdAt: Date | null
  }

  export type BillingRecordMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    invoiceNumber: string | null
    amount: Decimal | null
    currency: string | null
    status: string | null
    paymentMethod: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    paidAt: Date | null
    stripeInvoiceId: string | null
    ewayTransactionId: string | null
    invoiceUrl: string | null
    failureReason: string | null
    createdAt: Date | null
  }

  export type BillingRecordCountAggregateOutputType = {
    id: number
    subscriptionId: number
    invoiceNumber: number
    amount: number
    currency: number
    status: number
    paymentMethod: number
    invoiceDate: number
    dueDate: number
    paidAt: number
    stripeInvoiceId: number
    ewayTransactionId: number
    invoiceUrl: number
    failureReason: number
    usageDetails: number
    createdAt: number
    _all: number
  }


  export type BillingRecordAvgAggregateInputType = {
    amount?: true
  }

  export type BillingRecordSumAggregateInputType = {
    amount?: true
  }

  export type BillingRecordMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    invoiceNumber?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    invoiceDate?: true
    dueDate?: true
    paidAt?: true
    stripeInvoiceId?: true
    ewayTransactionId?: true
    invoiceUrl?: true
    failureReason?: true
    createdAt?: true
  }

  export type BillingRecordMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    invoiceNumber?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    invoiceDate?: true
    dueDate?: true
    paidAt?: true
    stripeInvoiceId?: true
    ewayTransactionId?: true
    invoiceUrl?: true
    failureReason?: true
    createdAt?: true
  }

  export type BillingRecordCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    invoiceNumber?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    invoiceDate?: true
    dueDate?: true
    paidAt?: true
    stripeInvoiceId?: true
    ewayTransactionId?: true
    invoiceUrl?: true
    failureReason?: true
    usageDetails?: true
    createdAt?: true
    _all?: true
  }

  export type BillingRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingRecord to aggregate.
     */
    where?: BillingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRecords to fetch.
     */
    orderBy?: BillingRecordOrderByWithRelationInput | BillingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingRecords
    **/
    _count?: true | BillingRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingRecordMaxAggregateInputType
  }

  export type GetBillingRecordAggregateType<T extends BillingRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingRecord[P]>
      : GetScalarType<T[P], AggregateBillingRecord[P]>
  }




  export type BillingRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingRecordWhereInput
    orderBy?: BillingRecordOrderByWithAggregationInput | BillingRecordOrderByWithAggregationInput[]
    by: BillingRecordScalarFieldEnum[] | BillingRecordScalarFieldEnum
    having?: BillingRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingRecordCountAggregateInputType | true
    _avg?: BillingRecordAvgAggregateInputType
    _sum?: BillingRecordSumAggregateInputType
    _min?: BillingRecordMinAggregateInputType
    _max?: BillingRecordMaxAggregateInputType
  }

  export type BillingRecordGroupByOutputType = {
    id: string
    subscriptionId: string
    invoiceNumber: string
    amount: Decimal
    currency: string
    status: string
    paymentMethod: string | null
    invoiceDate: Date
    dueDate: Date
    paidAt: Date | null
    stripeInvoiceId: string | null
    ewayTransactionId: string | null
    invoiceUrl: string | null
    failureReason: string | null
    usageDetails: JsonValue | null
    createdAt: Date
    _count: BillingRecordCountAggregateOutputType | null
    _avg: BillingRecordAvgAggregateOutputType | null
    _sum: BillingRecordSumAggregateOutputType | null
    _min: BillingRecordMinAggregateOutputType | null
    _max: BillingRecordMaxAggregateOutputType | null
  }

  type GetBillingRecordGroupByPayload<T extends BillingRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingRecordGroupByOutputType[P]>
            : GetScalarType<T[P], BillingRecordGroupByOutputType[P]>
        }
      >
    >


  export type BillingRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    stripeInvoiceId?: boolean
    ewayTransactionId?: boolean
    invoiceUrl?: boolean
    failureReason?: boolean
    usageDetails?: boolean
    createdAt?: boolean
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingRecord"]>

  export type BillingRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    stripeInvoiceId?: boolean
    ewayTransactionId?: boolean
    invoiceUrl?: boolean
    failureReason?: boolean
    usageDetails?: boolean
    createdAt?: boolean
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingRecord"]>

  export type BillingRecordSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    stripeInvoiceId?: boolean
    ewayTransactionId?: boolean
    invoiceUrl?: boolean
    failureReason?: boolean
    usageDetails?: boolean
    createdAt?: boolean
  }

  export type BillingRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }
  export type BillingRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }

  export type $BillingRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingRecord"
    objects: {
      subscription: Prisma.$WorkspaceSubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      invoiceNumber: string
      amount: Prisma.Decimal
      currency: string
      status: string
      paymentMethod: string | null
      invoiceDate: Date
      dueDate: Date
      paidAt: Date | null
      stripeInvoiceId: string | null
      ewayTransactionId: string | null
      invoiceUrl: string | null
      failureReason: string | null
      usageDetails: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["billingRecord"]>
    composites: {}
  }

  type BillingRecordGetPayload<S extends boolean | null | undefined | BillingRecordDefaultArgs> = $Result.GetResult<Prisma.$BillingRecordPayload, S>

  type BillingRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BillingRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillingRecordCountAggregateInputType | true
    }

  export interface BillingRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingRecord'], meta: { name: 'BillingRecord' } }
    /**
     * Find zero or one BillingRecord that matches the filter.
     * @param {BillingRecordFindUniqueArgs} args - Arguments to find a BillingRecord
     * @example
     * // Get one BillingRecord
     * const billingRecord = await prisma.billingRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingRecordFindUniqueArgs>(args: SelectSubset<T, BillingRecordFindUniqueArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BillingRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BillingRecordFindUniqueOrThrowArgs} args - Arguments to find a BillingRecord
     * @example
     * // Get one BillingRecord
     * const billingRecord = await prisma.billingRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BillingRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordFindFirstArgs} args - Arguments to find a BillingRecord
     * @example
     * // Get one BillingRecord
     * const billingRecord = await prisma.billingRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingRecordFindFirstArgs>(args?: SelectSubset<T, BillingRecordFindFirstArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BillingRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordFindFirstOrThrowArgs} args - Arguments to find a BillingRecord
     * @example
     * // Get one BillingRecord
     * const billingRecord = await prisma.billingRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BillingRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingRecords
     * const billingRecords = await prisma.billingRecord.findMany()
     * 
     * // Get first 10 BillingRecords
     * const billingRecords = await prisma.billingRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingRecordWithIdOnly = await prisma.billingRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingRecordFindManyArgs>(args?: SelectSubset<T, BillingRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BillingRecord.
     * @param {BillingRecordCreateArgs} args - Arguments to create a BillingRecord.
     * @example
     * // Create one BillingRecord
     * const BillingRecord = await prisma.billingRecord.create({
     *   data: {
     *     // ... data to create a BillingRecord
     *   }
     * })
     * 
     */
    create<T extends BillingRecordCreateArgs>(args: SelectSubset<T, BillingRecordCreateArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BillingRecords.
     * @param {BillingRecordCreateManyArgs} args - Arguments to create many BillingRecords.
     * @example
     * // Create many BillingRecords
     * const billingRecord = await prisma.billingRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingRecordCreateManyArgs>(args?: SelectSubset<T, BillingRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingRecords and returns the data saved in the database.
     * @param {BillingRecordCreateManyAndReturnArgs} args - Arguments to create many BillingRecords.
     * @example
     * // Create many BillingRecords
     * const billingRecord = await prisma.billingRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingRecords and only return the `id`
     * const billingRecordWithIdOnly = await prisma.billingRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BillingRecord.
     * @param {BillingRecordDeleteArgs} args - Arguments to delete one BillingRecord.
     * @example
     * // Delete one BillingRecord
     * const BillingRecord = await prisma.billingRecord.delete({
     *   where: {
     *     // ... filter to delete one BillingRecord
     *   }
     * })
     * 
     */
    delete<T extends BillingRecordDeleteArgs>(args: SelectSubset<T, BillingRecordDeleteArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BillingRecord.
     * @param {BillingRecordUpdateArgs} args - Arguments to update one BillingRecord.
     * @example
     * // Update one BillingRecord
     * const billingRecord = await prisma.billingRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingRecordUpdateArgs>(args: SelectSubset<T, BillingRecordUpdateArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BillingRecords.
     * @param {BillingRecordDeleteManyArgs} args - Arguments to filter BillingRecords to delete.
     * @example
     * // Delete a few BillingRecords
     * const { count } = await prisma.billingRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingRecordDeleteManyArgs>(args?: SelectSubset<T, BillingRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingRecords
     * const billingRecord = await prisma.billingRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingRecordUpdateManyArgs>(args: SelectSubset<T, BillingRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BillingRecord.
     * @param {BillingRecordUpsertArgs} args - Arguments to update or create a BillingRecord.
     * @example
     * // Update or create a BillingRecord
     * const billingRecord = await prisma.billingRecord.upsert({
     *   create: {
     *     // ... data to create a BillingRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingRecord we want to update
     *   }
     * })
     */
    upsert<T extends BillingRecordUpsertArgs>(args: SelectSubset<T, BillingRecordUpsertArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BillingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordCountArgs} args - Arguments to filter BillingRecords to count.
     * @example
     * // Count the number of BillingRecords
     * const count = await prisma.billingRecord.count({
     *   where: {
     *     // ... the filter for the BillingRecords we want to count
     *   }
     * })
    **/
    count<T extends BillingRecordCountArgs>(
      args?: Subset<T, BillingRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingRecordAggregateArgs>(args: Subset<T, BillingRecordAggregateArgs>): Prisma.PrismaPromise<GetBillingRecordAggregateType<T>>

    /**
     * Group by BillingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingRecordGroupByArgs['orderBy'] }
        : { orderBy?: BillingRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingRecord model
   */
  readonly fields: BillingRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends WorkspaceSubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceSubscriptionDefaultArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingRecord model
   */ 
  interface BillingRecordFieldRefs {
    readonly id: FieldRef<"BillingRecord", 'String'>
    readonly subscriptionId: FieldRef<"BillingRecord", 'String'>
    readonly invoiceNumber: FieldRef<"BillingRecord", 'String'>
    readonly amount: FieldRef<"BillingRecord", 'Decimal'>
    readonly currency: FieldRef<"BillingRecord", 'String'>
    readonly status: FieldRef<"BillingRecord", 'String'>
    readonly paymentMethod: FieldRef<"BillingRecord", 'String'>
    readonly invoiceDate: FieldRef<"BillingRecord", 'DateTime'>
    readonly dueDate: FieldRef<"BillingRecord", 'DateTime'>
    readonly paidAt: FieldRef<"BillingRecord", 'DateTime'>
    readonly stripeInvoiceId: FieldRef<"BillingRecord", 'String'>
    readonly ewayTransactionId: FieldRef<"BillingRecord", 'String'>
    readonly invoiceUrl: FieldRef<"BillingRecord", 'String'>
    readonly failureReason: FieldRef<"BillingRecord", 'String'>
    readonly usageDetails: FieldRef<"BillingRecord", 'Json'>
    readonly createdAt: FieldRef<"BillingRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingRecord findUnique
   */
  export type BillingRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * Filter, which BillingRecord to fetch.
     */
    where: BillingRecordWhereUniqueInput
  }

  /**
   * BillingRecord findUniqueOrThrow
   */
  export type BillingRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * Filter, which BillingRecord to fetch.
     */
    where: BillingRecordWhereUniqueInput
  }

  /**
   * BillingRecord findFirst
   */
  export type BillingRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * Filter, which BillingRecord to fetch.
     */
    where?: BillingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRecords to fetch.
     */
    orderBy?: BillingRecordOrderByWithRelationInput | BillingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingRecords.
     */
    cursor?: BillingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingRecords.
     */
    distinct?: BillingRecordScalarFieldEnum | BillingRecordScalarFieldEnum[]
  }

  /**
   * BillingRecord findFirstOrThrow
   */
  export type BillingRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * Filter, which BillingRecord to fetch.
     */
    where?: BillingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRecords to fetch.
     */
    orderBy?: BillingRecordOrderByWithRelationInput | BillingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingRecords.
     */
    cursor?: BillingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingRecords.
     */
    distinct?: BillingRecordScalarFieldEnum | BillingRecordScalarFieldEnum[]
  }

  /**
   * BillingRecord findMany
   */
  export type BillingRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * Filter, which BillingRecords to fetch.
     */
    where?: BillingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRecords to fetch.
     */
    orderBy?: BillingRecordOrderByWithRelationInput | BillingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingRecords.
     */
    cursor?: BillingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRecords.
     */
    skip?: number
    distinct?: BillingRecordScalarFieldEnum | BillingRecordScalarFieldEnum[]
  }

  /**
   * BillingRecord create
   */
  export type BillingRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingRecord.
     */
    data: XOR<BillingRecordCreateInput, BillingRecordUncheckedCreateInput>
  }

  /**
   * BillingRecord createMany
   */
  export type BillingRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingRecords.
     */
    data: BillingRecordCreateManyInput | BillingRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingRecord createManyAndReturn
   */
  export type BillingRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BillingRecords.
     */
    data: BillingRecordCreateManyInput | BillingRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingRecord update
   */
  export type BillingRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingRecord.
     */
    data: XOR<BillingRecordUpdateInput, BillingRecordUncheckedUpdateInput>
    /**
     * Choose, which BillingRecord to update.
     */
    where: BillingRecordWhereUniqueInput
  }

  /**
   * BillingRecord updateMany
   */
  export type BillingRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingRecords.
     */
    data: XOR<BillingRecordUpdateManyMutationInput, BillingRecordUncheckedUpdateManyInput>
    /**
     * Filter which BillingRecords to update
     */
    where?: BillingRecordWhereInput
  }

  /**
   * BillingRecord upsert
   */
  export type BillingRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingRecord to update in case it exists.
     */
    where: BillingRecordWhereUniqueInput
    /**
     * In case the BillingRecord found by the `where` argument doesn't exist, create a new BillingRecord with this data.
     */
    create: XOR<BillingRecordCreateInput, BillingRecordUncheckedCreateInput>
    /**
     * In case the BillingRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingRecordUpdateInput, BillingRecordUncheckedUpdateInput>
  }

  /**
   * BillingRecord delete
   */
  export type BillingRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * Filter which BillingRecord to delete.
     */
    where: BillingRecordWhereUniqueInput
  }

  /**
   * BillingRecord deleteMany
   */
  export type BillingRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingRecords to delete
     */
    where?: BillingRecordWhereInput
  }

  /**
   * BillingRecord without action
   */
  export type BillingRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
  }


  /**
   * Model UsageRecord
   */

  export type AggregateUsageRecord = {
    _count: UsageRecordCountAggregateOutputType | null
    _avg: UsageRecordAvgAggregateOutputType | null
    _sum: UsageRecordSumAggregateOutputType | null
    _min: UsageRecordMinAggregateOutputType | null
    _max: UsageRecordMaxAggregateOutputType | null
  }

  export type UsageRecordAvgAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalCost: Decimal | null
  }

  export type UsageRecordSumAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalCost: Decimal | null
  }

  export type UsageRecordMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    recordType: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalCost: Decimal | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
  }

  export type UsageRecordMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    recordType: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalCost: Decimal | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
  }

  export type UsageRecordCountAggregateOutputType = {
    id: number
    subscriptionId: number
    recordType: number
    quantity: number
    unitPrice: number
    totalCost: number
    periodStart: number
    periodEnd: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type UsageRecordAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalCost?: true
  }

  export type UsageRecordSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalCost?: true
  }

  export type UsageRecordMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    recordType?: true
    quantity?: true
    unitPrice?: true
    totalCost?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
  }

  export type UsageRecordMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    recordType?: true
    quantity?: true
    unitPrice?: true
    totalCost?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
  }

  export type UsageRecordCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    recordType?: true
    quantity?: true
    unitPrice?: true
    totalCost?: true
    periodStart?: true
    periodEnd?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type UsageRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageRecord to aggregate.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageRecords
    **/
    _count?: true | UsageRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageRecordMaxAggregateInputType
  }

  export type GetUsageRecordAggregateType<T extends UsageRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageRecord[P]>
      : GetScalarType<T[P], AggregateUsageRecord[P]>
  }




  export type UsageRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageRecordWhereInput
    orderBy?: UsageRecordOrderByWithAggregationInput | UsageRecordOrderByWithAggregationInput[]
    by: UsageRecordScalarFieldEnum[] | UsageRecordScalarFieldEnum
    having?: UsageRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageRecordCountAggregateInputType | true
    _avg?: UsageRecordAvgAggregateInputType
    _sum?: UsageRecordSumAggregateInputType
    _min?: UsageRecordMinAggregateInputType
    _max?: UsageRecordMaxAggregateInputType
  }

  export type UsageRecordGroupByOutputType = {
    id: string
    subscriptionId: string
    recordType: string
    quantity: Decimal
    unitPrice: Decimal | null
    totalCost: Decimal | null
    periodStart: Date
    periodEnd: Date
    metadata: JsonValue | null
    createdAt: Date
    _count: UsageRecordCountAggregateOutputType | null
    _avg: UsageRecordAvgAggregateOutputType | null
    _sum: UsageRecordSumAggregateOutputType | null
    _min: UsageRecordMinAggregateOutputType | null
    _max: UsageRecordMaxAggregateOutputType | null
  }

  type GetUsageRecordGroupByPayload<T extends UsageRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageRecordGroupByOutputType[P]>
            : GetScalarType<T[P], UsageRecordGroupByOutputType[P]>
        }
      >
    >


  export type UsageRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    recordType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalCost?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageRecord"]>

  export type UsageRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    recordType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalCost?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageRecord"]>

  export type UsageRecordSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    recordType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalCost?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type UsageRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }
  export type UsageRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }

  export type $UsageRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageRecord"
    objects: {
      subscription: Prisma.$WorkspaceSubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      recordType: string
      quantity: Prisma.Decimal
      unitPrice: Prisma.Decimal | null
      totalCost: Prisma.Decimal | null
      periodStart: Date
      periodEnd: Date
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["usageRecord"]>
    composites: {}
  }

  type UsageRecordGetPayload<S extends boolean | null | undefined | UsageRecordDefaultArgs> = $Result.GetResult<Prisma.$UsageRecordPayload, S>

  type UsageRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsageRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsageRecordCountAggregateInputType | true
    }

  export interface UsageRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageRecord'], meta: { name: 'UsageRecord' } }
    /**
     * Find zero or one UsageRecord that matches the filter.
     * @param {UsageRecordFindUniqueArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageRecordFindUniqueArgs>(args: SelectSubset<T, UsageRecordFindUniqueArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsageRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsageRecordFindUniqueOrThrowArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsageRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindFirstArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageRecordFindFirstArgs>(args?: SelectSubset<T, UsageRecordFindFirstArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsageRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindFirstOrThrowArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsageRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageRecords
     * const usageRecords = await prisma.usageRecord.findMany()
     * 
     * // Get first 10 UsageRecords
     * const usageRecords = await prisma.usageRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageRecordWithIdOnly = await prisma.usageRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageRecordFindManyArgs>(args?: SelectSubset<T, UsageRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsageRecord.
     * @param {UsageRecordCreateArgs} args - Arguments to create a UsageRecord.
     * @example
     * // Create one UsageRecord
     * const UsageRecord = await prisma.usageRecord.create({
     *   data: {
     *     // ... data to create a UsageRecord
     *   }
     * })
     * 
     */
    create<T extends UsageRecordCreateArgs>(args: SelectSubset<T, UsageRecordCreateArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsageRecords.
     * @param {UsageRecordCreateManyArgs} args - Arguments to create many UsageRecords.
     * @example
     * // Create many UsageRecords
     * const usageRecord = await prisma.usageRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageRecordCreateManyArgs>(args?: SelectSubset<T, UsageRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageRecords and returns the data saved in the database.
     * @param {UsageRecordCreateManyAndReturnArgs} args - Arguments to create many UsageRecords.
     * @example
     * // Create many UsageRecords
     * const usageRecord = await prisma.usageRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageRecords and only return the `id`
     * const usageRecordWithIdOnly = await prisma.usageRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsageRecord.
     * @param {UsageRecordDeleteArgs} args - Arguments to delete one UsageRecord.
     * @example
     * // Delete one UsageRecord
     * const UsageRecord = await prisma.usageRecord.delete({
     *   where: {
     *     // ... filter to delete one UsageRecord
     *   }
     * })
     * 
     */
    delete<T extends UsageRecordDeleteArgs>(args: SelectSubset<T, UsageRecordDeleteArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsageRecord.
     * @param {UsageRecordUpdateArgs} args - Arguments to update one UsageRecord.
     * @example
     * // Update one UsageRecord
     * const usageRecord = await prisma.usageRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageRecordUpdateArgs>(args: SelectSubset<T, UsageRecordUpdateArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsageRecords.
     * @param {UsageRecordDeleteManyArgs} args - Arguments to filter UsageRecords to delete.
     * @example
     * // Delete a few UsageRecords
     * const { count } = await prisma.usageRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageRecordDeleteManyArgs>(args?: SelectSubset<T, UsageRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageRecords
     * const usageRecord = await prisma.usageRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageRecordUpdateManyArgs>(args: SelectSubset<T, UsageRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageRecord.
     * @param {UsageRecordUpsertArgs} args - Arguments to update or create a UsageRecord.
     * @example
     * // Update or create a UsageRecord
     * const usageRecord = await prisma.usageRecord.upsert({
     *   create: {
     *     // ... data to create a UsageRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageRecord we want to update
     *   }
     * })
     */
    upsert<T extends UsageRecordUpsertArgs>(args: SelectSubset<T, UsageRecordUpsertArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsageRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordCountArgs} args - Arguments to filter UsageRecords to count.
     * @example
     * // Count the number of UsageRecords
     * const count = await prisma.usageRecord.count({
     *   where: {
     *     // ... the filter for the UsageRecords we want to count
     *   }
     * })
    **/
    count<T extends UsageRecordCountArgs>(
      args?: Subset<T, UsageRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageRecordAggregateArgs>(args: Subset<T, UsageRecordAggregateArgs>): Prisma.PrismaPromise<GetUsageRecordAggregateType<T>>

    /**
     * Group by UsageRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageRecordGroupByArgs['orderBy'] }
        : { orderBy?: UsageRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageRecord model
   */
  readonly fields: UsageRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends WorkspaceSubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceSubscriptionDefaultArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageRecord model
   */ 
  interface UsageRecordFieldRefs {
    readonly id: FieldRef<"UsageRecord", 'String'>
    readonly subscriptionId: FieldRef<"UsageRecord", 'String'>
    readonly recordType: FieldRef<"UsageRecord", 'String'>
    readonly quantity: FieldRef<"UsageRecord", 'Decimal'>
    readonly unitPrice: FieldRef<"UsageRecord", 'Decimal'>
    readonly totalCost: FieldRef<"UsageRecord", 'Decimal'>
    readonly periodStart: FieldRef<"UsageRecord", 'DateTime'>
    readonly periodEnd: FieldRef<"UsageRecord", 'DateTime'>
    readonly metadata: FieldRef<"UsageRecord", 'Json'>
    readonly createdAt: FieldRef<"UsageRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageRecord findUnique
   */
  export type UsageRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord findUniqueOrThrow
   */
  export type UsageRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord findFirst
   */
  export type UsageRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageRecords.
     */
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * UsageRecord findFirstOrThrow
   */
  export type UsageRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageRecords.
     */
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * UsageRecord findMany
   */
  export type UsageRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecords to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * UsageRecord create
   */
  export type UsageRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageRecord.
     */
    data: XOR<UsageRecordCreateInput, UsageRecordUncheckedCreateInput>
  }

  /**
   * UsageRecord createMany
   */
  export type UsageRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageRecords.
     */
    data: UsageRecordCreateManyInput | UsageRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageRecord createManyAndReturn
   */
  export type UsageRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsageRecords.
     */
    data: UsageRecordCreateManyInput | UsageRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageRecord update
   */
  export type UsageRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageRecord.
     */
    data: XOR<UsageRecordUpdateInput, UsageRecordUncheckedUpdateInput>
    /**
     * Choose, which UsageRecord to update.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord updateMany
   */
  export type UsageRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageRecords.
     */
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyInput>
    /**
     * Filter which UsageRecords to update
     */
    where?: UsageRecordWhereInput
  }

  /**
   * UsageRecord upsert
   */
  export type UsageRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageRecord to update in case it exists.
     */
    where: UsageRecordWhereUniqueInput
    /**
     * In case the UsageRecord found by the `where` argument doesn't exist, create a new UsageRecord with this data.
     */
    create: XOR<UsageRecordCreateInput, UsageRecordUncheckedCreateInput>
    /**
     * In case the UsageRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageRecordUpdateInput, UsageRecordUncheckedUpdateInput>
  }

  /**
   * UsageRecord delete
   */
  export type UsageRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter which UsageRecord to delete.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord deleteMany
   */
  export type UsageRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageRecords to delete
     */
    where?: UsageRecordWhereInput
  }

  /**
   * UsageRecord without action
   */
  export type UsageRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
  }


  /**
   * Model UsageCounter
   */

  export type AggregateUsageCounter = {
    _count: UsageCounterCountAggregateOutputType | null
    _avg: UsageCounterAvgAggregateOutputType | null
    _sum: UsageCounterSumAggregateOutputType | null
    _min: UsageCounterMinAggregateOutputType | null
    _max: UsageCounterMaxAggregateOutputType | null
  }

  export type UsageCounterAvgAggregateOutputType = {
    transcriptionsUsed: number | null
    filesUploaded: number | null
    voiceSynthesisUsed: number | null
    exportOperationsUsed: number | null
    totalProcessingMinutes: Decimal | null
    concurrentJobsPeak: number | null
  }

  export type UsageCounterSumAggregateOutputType = {
    transcriptionsUsed: number | null
    filesUploaded: number | null
    voiceSynthesisUsed: number | null
    exportOperationsUsed: number | null
    totalProcessingMinutes: Decimal | null
    concurrentJobsPeak: number | null
  }

  export type UsageCounterMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    periodType: string | null
    periodStart: Date | null
    periodEnd: Date | null
    transcriptionsUsed: number | null
    filesUploaded: number | null
    voiceSynthesisUsed: number | null
    exportOperationsUsed: number | null
    totalProcessingMinutes: Decimal | null
    concurrentJobsPeak: number | null
    lastResetAt: Date | null
    autoReset: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsageCounterMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    periodType: string | null
    periodStart: Date | null
    periodEnd: Date | null
    transcriptionsUsed: number | null
    filesUploaded: number | null
    voiceSynthesisUsed: number | null
    exportOperationsUsed: number | null
    totalProcessingMinutes: Decimal | null
    concurrentJobsPeak: number | null
    lastResetAt: Date | null
    autoReset: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsageCounterCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    periodType: number
    periodStart: number
    periodEnd: number
    transcriptionsUsed: number
    filesUploaded: number
    voiceSynthesisUsed: number
    exportOperationsUsed: number
    totalProcessingMinutes: number
    concurrentJobsPeak: number
    featureUsage: number
    lastResetAt: number
    autoReset: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsageCounterAvgAggregateInputType = {
    transcriptionsUsed?: true
    filesUploaded?: true
    voiceSynthesisUsed?: true
    exportOperationsUsed?: true
    totalProcessingMinutes?: true
    concurrentJobsPeak?: true
  }

  export type UsageCounterSumAggregateInputType = {
    transcriptionsUsed?: true
    filesUploaded?: true
    voiceSynthesisUsed?: true
    exportOperationsUsed?: true
    totalProcessingMinutes?: true
    concurrentJobsPeak?: true
  }

  export type UsageCounterMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    periodType?: true
    periodStart?: true
    periodEnd?: true
    transcriptionsUsed?: true
    filesUploaded?: true
    voiceSynthesisUsed?: true
    exportOperationsUsed?: true
    totalProcessingMinutes?: true
    concurrentJobsPeak?: true
    lastResetAt?: true
    autoReset?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsageCounterMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    periodType?: true
    periodStart?: true
    periodEnd?: true
    transcriptionsUsed?: true
    filesUploaded?: true
    voiceSynthesisUsed?: true
    exportOperationsUsed?: true
    totalProcessingMinutes?: true
    concurrentJobsPeak?: true
    lastResetAt?: true
    autoReset?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsageCounterCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    periodType?: true
    periodStart?: true
    periodEnd?: true
    transcriptionsUsed?: true
    filesUploaded?: true
    voiceSynthesisUsed?: true
    exportOperationsUsed?: true
    totalProcessingMinutes?: true
    concurrentJobsPeak?: true
    featureUsage?: true
    lastResetAt?: true
    autoReset?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsageCounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageCounter to aggregate.
     */
    where?: UsageCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageCounters to fetch.
     */
    orderBy?: UsageCounterOrderByWithRelationInput | UsageCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageCounters
    **/
    _count?: true | UsageCounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageCounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageCounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageCounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageCounterMaxAggregateInputType
  }

  export type GetUsageCounterAggregateType<T extends UsageCounterAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageCounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageCounter[P]>
      : GetScalarType<T[P], AggregateUsageCounter[P]>
  }




  export type UsageCounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageCounterWhereInput
    orderBy?: UsageCounterOrderByWithAggregationInput | UsageCounterOrderByWithAggregationInput[]
    by: UsageCounterScalarFieldEnum[] | UsageCounterScalarFieldEnum
    having?: UsageCounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageCounterCountAggregateInputType | true
    _avg?: UsageCounterAvgAggregateInputType
    _sum?: UsageCounterSumAggregateInputType
    _min?: UsageCounterMinAggregateInputType
    _max?: UsageCounterMaxAggregateInputType
  }

  export type UsageCounterGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    periodType: string
    periodStart: Date
    periodEnd: Date
    transcriptionsUsed: number
    filesUploaded: number
    voiceSynthesisUsed: number
    exportOperationsUsed: number
    totalProcessingMinutes: Decimal
    concurrentJobsPeak: number
    featureUsage: JsonValue
    lastResetAt: Date
    autoReset: boolean
    createdAt: Date
    updatedAt: Date
    _count: UsageCounterCountAggregateOutputType | null
    _avg: UsageCounterAvgAggregateOutputType | null
    _sum: UsageCounterSumAggregateOutputType | null
    _min: UsageCounterMinAggregateOutputType | null
    _max: UsageCounterMaxAggregateOutputType | null
  }

  type GetUsageCounterGroupByPayload<T extends UsageCounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageCounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageCounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageCounterGroupByOutputType[P]>
            : GetScalarType<T[P], UsageCounterGroupByOutputType[P]>
        }
      >
    >


  export type UsageCounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    periodType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    transcriptionsUsed?: boolean
    filesUploaded?: boolean
    voiceSynthesisUsed?: boolean
    exportOperationsUsed?: boolean
    totalProcessingMinutes?: boolean
    concurrentJobsPeak?: boolean
    featureUsage?: boolean
    lastResetAt?: boolean
    autoReset?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageCounter"]>

  export type UsageCounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    periodType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    transcriptionsUsed?: boolean
    filesUploaded?: boolean
    voiceSynthesisUsed?: boolean
    exportOperationsUsed?: boolean
    totalProcessingMinutes?: boolean
    concurrentJobsPeak?: boolean
    featureUsage?: boolean
    lastResetAt?: boolean
    autoReset?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageCounter"]>

  export type UsageCounterSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    periodType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    transcriptionsUsed?: boolean
    filesUploaded?: boolean
    voiceSynthesisUsed?: boolean
    exportOperationsUsed?: boolean
    totalProcessingMinutes?: boolean
    concurrentJobsPeak?: boolean
    featureUsage?: boolean
    lastResetAt?: boolean
    autoReset?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsageCounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UsageCounterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UsageCounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageCounter"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      periodType: string
      periodStart: Date
      periodEnd: Date
      transcriptionsUsed: number
      filesUploaded: number
      voiceSynthesisUsed: number
      exportOperationsUsed: number
      totalProcessingMinutes: Prisma.Decimal
      concurrentJobsPeak: number
      featureUsage: Prisma.JsonValue
      lastResetAt: Date
      autoReset: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usageCounter"]>
    composites: {}
  }

  type UsageCounterGetPayload<S extends boolean | null | undefined | UsageCounterDefaultArgs> = $Result.GetResult<Prisma.$UsageCounterPayload, S>

  type UsageCounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsageCounterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsageCounterCountAggregateInputType | true
    }

  export interface UsageCounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageCounter'], meta: { name: 'UsageCounter' } }
    /**
     * Find zero or one UsageCounter that matches the filter.
     * @param {UsageCounterFindUniqueArgs} args - Arguments to find a UsageCounter
     * @example
     * // Get one UsageCounter
     * const usageCounter = await prisma.usageCounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageCounterFindUniqueArgs>(args: SelectSubset<T, UsageCounterFindUniqueArgs<ExtArgs>>): Prisma__UsageCounterClient<$Result.GetResult<Prisma.$UsageCounterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsageCounter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsageCounterFindUniqueOrThrowArgs} args - Arguments to find a UsageCounter
     * @example
     * // Get one UsageCounter
     * const usageCounter = await prisma.usageCounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageCounterFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageCounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageCounterClient<$Result.GetResult<Prisma.$UsageCounterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsageCounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageCounterFindFirstArgs} args - Arguments to find a UsageCounter
     * @example
     * // Get one UsageCounter
     * const usageCounter = await prisma.usageCounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageCounterFindFirstArgs>(args?: SelectSubset<T, UsageCounterFindFirstArgs<ExtArgs>>): Prisma__UsageCounterClient<$Result.GetResult<Prisma.$UsageCounterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsageCounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageCounterFindFirstOrThrowArgs} args - Arguments to find a UsageCounter
     * @example
     * // Get one UsageCounter
     * const usageCounter = await prisma.usageCounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageCounterFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageCounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageCounterClient<$Result.GetResult<Prisma.$UsageCounterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsageCounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageCounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageCounters
     * const usageCounters = await prisma.usageCounter.findMany()
     * 
     * // Get first 10 UsageCounters
     * const usageCounters = await prisma.usageCounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageCounterWithIdOnly = await prisma.usageCounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageCounterFindManyArgs>(args?: SelectSubset<T, UsageCounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageCounterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsageCounter.
     * @param {UsageCounterCreateArgs} args - Arguments to create a UsageCounter.
     * @example
     * // Create one UsageCounter
     * const UsageCounter = await prisma.usageCounter.create({
     *   data: {
     *     // ... data to create a UsageCounter
     *   }
     * })
     * 
     */
    create<T extends UsageCounterCreateArgs>(args: SelectSubset<T, UsageCounterCreateArgs<ExtArgs>>): Prisma__UsageCounterClient<$Result.GetResult<Prisma.$UsageCounterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsageCounters.
     * @param {UsageCounterCreateManyArgs} args - Arguments to create many UsageCounters.
     * @example
     * // Create many UsageCounters
     * const usageCounter = await prisma.usageCounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageCounterCreateManyArgs>(args?: SelectSubset<T, UsageCounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageCounters and returns the data saved in the database.
     * @param {UsageCounterCreateManyAndReturnArgs} args - Arguments to create many UsageCounters.
     * @example
     * // Create many UsageCounters
     * const usageCounter = await prisma.usageCounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageCounters and only return the `id`
     * const usageCounterWithIdOnly = await prisma.usageCounter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageCounterCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageCounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageCounterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsageCounter.
     * @param {UsageCounterDeleteArgs} args - Arguments to delete one UsageCounter.
     * @example
     * // Delete one UsageCounter
     * const UsageCounter = await prisma.usageCounter.delete({
     *   where: {
     *     // ... filter to delete one UsageCounter
     *   }
     * })
     * 
     */
    delete<T extends UsageCounterDeleteArgs>(args: SelectSubset<T, UsageCounterDeleteArgs<ExtArgs>>): Prisma__UsageCounterClient<$Result.GetResult<Prisma.$UsageCounterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsageCounter.
     * @param {UsageCounterUpdateArgs} args - Arguments to update one UsageCounter.
     * @example
     * // Update one UsageCounter
     * const usageCounter = await prisma.usageCounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageCounterUpdateArgs>(args: SelectSubset<T, UsageCounterUpdateArgs<ExtArgs>>): Prisma__UsageCounterClient<$Result.GetResult<Prisma.$UsageCounterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsageCounters.
     * @param {UsageCounterDeleteManyArgs} args - Arguments to filter UsageCounters to delete.
     * @example
     * // Delete a few UsageCounters
     * const { count } = await prisma.usageCounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageCounterDeleteManyArgs>(args?: SelectSubset<T, UsageCounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageCounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageCounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageCounters
     * const usageCounter = await prisma.usageCounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageCounterUpdateManyArgs>(args: SelectSubset<T, UsageCounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageCounter.
     * @param {UsageCounterUpsertArgs} args - Arguments to update or create a UsageCounter.
     * @example
     * // Update or create a UsageCounter
     * const usageCounter = await prisma.usageCounter.upsert({
     *   create: {
     *     // ... data to create a UsageCounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageCounter we want to update
     *   }
     * })
     */
    upsert<T extends UsageCounterUpsertArgs>(args: SelectSubset<T, UsageCounterUpsertArgs<ExtArgs>>): Prisma__UsageCounterClient<$Result.GetResult<Prisma.$UsageCounterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsageCounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageCounterCountArgs} args - Arguments to filter UsageCounters to count.
     * @example
     * // Count the number of UsageCounters
     * const count = await prisma.usageCounter.count({
     *   where: {
     *     // ... the filter for the UsageCounters we want to count
     *   }
     * })
    **/
    count<T extends UsageCounterCountArgs>(
      args?: Subset<T, UsageCounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageCounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageCounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageCounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageCounterAggregateArgs>(args: Subset<T, UsageCounterAggregateArgs>): Prisma.PrismaPromise<GetUsageCounterAggregateType<T>>

    /**
     * Group by UsageCounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageCounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageCounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageCounterGroupByArgs['orderBy'] }
        : { orderBy?: UsageCounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageCounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageCounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageCounter model
   */
  readonly fields: UsageCounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageCounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageCounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageCounter model
   */ 
  interface UsageCounterFieldRefs {
    readonly id: FieldRef<"UsageCounter", 'String'>
    readonly userId: FieldRef<"UsageCounter", 'String'>
    readonly workspaceId: FieldRef<"UsageCounter", 'String'>
    readonly periodType: FieldRef<"UsageCounter", 'String'>
    readonly periodStart: FieldRef<"UsageCounter", 'DateTime'>
    readonly periodEnd: FieldRef<"UsageCounter", 'DateTime'>
    readonly transcriptionsUsed: FieldRef<"UsageCounter", 'Int'>
    readonly filesUploaded: FieldRef<"UsageCounter", 'Int'>
    readonly voiceSynthesisUsed: FieldRef<"UsageCounter", 'Int'>
    readonly exportOperationsUsed: FieldRef<"UsageCounter", 'Int'>
    readonly totalProcessingMinutes: FieldRef<"UsageCounter", 'Decimal'>
    readonly concurrentJobsPeak: FieldRef<"UsageCounter", 'Int'>
    readonly featureUsage: FieldRef<"UsageCounter", 'Json'>
    readonly lastResetAt: FieldRef<"UsageCounter", 'DateTime'>
    readonly autoReset: FieldRef<"UsageCounter", 'Boolean'>
    readonly createdAt: FieldRef<"UsageCounter", 'DateTime'>
    readonly updatedAt: FieldRef<"UsageCounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageCounter findUnique
   */
  export type UsageCounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageCounter
     */
    select?: UsageCounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageCounterInclude<ExtArgs> | null
    /**
     * Filter, which UsageCounter to fetch.
     */
    where: UsageCounterWhereUniqueInput
  }

  /**
   * UsageCounter findUniqueOrThrow
   */
  export type UsageCounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageCounter
     */
    select?: UsageCounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageCounterInclude<ExtArgs> | null
    /**
     * Filter, which UsageCounter to fetch.
     */
    where: UsageCounterWhereUniqueInput
  }

  /**
   * UsageCounter findFirst
   */
  export type UsageCounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageCounter
     */
    select?: UsageCounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageCounterInclude<ExtArgs> | null
    /**
     * Filter, which UsageCounter to fetch.
     */
    where?: UsageCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageCounters to fetch.
     */
    orderBy?: UsageCounterOrderByWithRelationInput | UsageCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageCounters.
     */
    cursor?: UsageCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageCounters.
     */
    distinct?: UsageCounterScalarFieldEnum | UsageCounterScalarFieldEnum[]
  }

  /**
   * UsageCounter findFirstOrThrow
   */
  export type UsageCounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageCounter
     */
    select?: UsageCounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageCounterInclude<ExtArgs> | null
    /**
     * Filter, which UsageCounter to fetch.
     */
    where?: UsageCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageCounters to fetch.
     */
    orderBy?: UsageCounterOrderByWithRelationInput | UsageCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageCounters.
     */
    cursor?: UsageCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageCounters.
     */
    distinct?: UsageCounterScalarFieldEnum | UsageCounterScalarFieldEnum[]
  }

  /**
   * UsageCounter findMany
   */
  export type UsageCounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageCounter
     */
    select?: UsageCounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageCounterInclude<ExtArgs> | null
    /**
     * Filter, which UsageCounters to fetch.
     */
    where?: UsageCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageCounters to fetch.
     */
    orderBy?: UsageCounterOrderByWithRelationInput | UsageCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageCounters.
     */
    cursor?: UsageCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageCounters.
     */
    skip?: number
    distinct?: UsageCounterScalarFieldEnum | UsageCounterScalarFieldEnum[]
  }

  /**
   * UsageCounter create
   */
  export type UsageCounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageCounter
     */
    select?: UsageCounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageCounterInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageCounter.
     */
    data: XOR<UsageCounterCreateInput, UsageCounterUncheckedCreateInput>
  }

  /**
   * UsageCounter createMany
   */
  export type UsageCounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageCounters.
     */
    data: UsageCounterCreateManyInput | UsageCounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageCounter createManyAndReturn
   */
  export type UsageCounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageCounter
     */
    select?: UsageCounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsageCounters.
     */
    data: UsageCounterCreateManyInput | UsageCounterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageCounterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageCounter update
   */
  export type UsageCounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageCounter
     */
    select?: UsageCounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageCounterInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageCounter.
     */
    data: XOR<UsageCounterUpdateInput, UsageCounterUncheckedUpdateInput>
    /**
     * Choose, which UsageCounter to update.
     */
    where: UsageCounterWhereUniqueInput
  }

  /**
   * UsageCounter updateMany
   */
  export type UsageCounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageCounters.
     */
    data: XOR<UsageCounterUpdateManyMutationInput, UsageCounterUncheckedUpdateManyInput>
    /**
     * Filter which UsageCounters to update
     */
    where?: UsageCounterWhereInput
  }

  /**
   * UsageCounter upsert
   */
  export type UsageCounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageCounter
     */
    select?: UsageCounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageCounterInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageCounter to update in case it exists.
     */
    where: UsageCounterWhereUniqueInput
    /**
     * In case the UsageCounter found by the `where` argument doesn't exist, create a new UsageCounter with this data.
     */
    create: XOR<UsageCounterCreateInput, UsageCounterUncheckedCreateInput>
    /**
     * In case the UsageCounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageCounterUpdateInput, UsageCounterUncheckedUpdateInput>
  }

  /**
   * UsageCounter delete
   */
  export type UsageCounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageCounter
     */
    select?: UsageCounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageCounterInclude<ExtArgs> | null
    /**
     * Filter which UsageCounter to delete.
     */
    where: UsageCounterWhereUniqueInput
  }

  /**
   * UsageCounter deleteMany
   */
  export type UsageCounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageCounters to delete
     */
    where?: UsageCounterWhereInput
  }

  /**
   * UsageCounter without action
   */
  export type UsageCounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageCounter
     */
    select?: UsageCounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageCounterInclude<ExtArgs> | null
  }


  /**
   * Model PlanRecommendation
   */

  export type AggregatePlanRecommendation = {
    _count: PlanRecommendationCountAggregateOutputType | null
    _avg: PlanRecommendationAvgAggregateOutputType | null
    _sum: PlanRecommendationSumAggregateOutputType | null
    _min: PlanRecommendationMinAggregateOutputType | null
    _max: PlanRecommendationMaxAggregateOutputType | null
  }

  export type PlanRecommendationAvgAggregateOutputType = {
    confidenceScore: Decimal | null
    projectedSavings: Decimal | null
    roiMonths: number | null
  }

  export type PlanRecommendationSumAggregateOutputType = {
    confidenceScore: Decimal | null
    projectedSavings: Decimal | null
    roiMonths: number | null
  }

  export type PlanRecommendationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    currentPlanId: string | null
    recommendedPlanId: string | null
    recommendationReason: string | null
    confidenceScore: Decimal | null
    projectedSavings: Decimal | null
    roiMonths: number | null
    triggeredBy: string | null
    status: string | null
    viewedAt: Date | null
    dismissedAt: Date | null
    acceptedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanRecommendationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    currentPlanId: string | null
    recommendedPlanId: string | null
    recommendationReason: string | null
    confidenceScore: Decimal | null
    projectedSavings: Decimal | null
    roiMonths: number | null
    triggeredBy: string | null
    status: string | null
    viewedAt: Date | null
    dismissedAt: Date | null
    acceptedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanRecommendationCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    currentPlanId: number
    recommendedPlanId: number
    recommendationReason: number
    confidenceScore: number
    usagePattern: number
    projectedSavings: number
    roiMonths: number
    triggeredBy: number
    benefits: number
    limitationsRemoved: number
    status: number
    viewedAt: number
    dismissedAt: number
    acceptedAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanRecommendationAvgAggregateInputType = {
    confidenceScore?: true
    projectedSavings?: true
    roiMonths?: true
  }

  export type PlanRecommendationSumAggregateInputType = {
    confidenceScore?: true
    projectedSavings?: true
    roiMonths?: true
  }

  export type PlanRecommendationMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    currentPlanId?: true
    recommendedPlanId?: true
    recommendationReason?: true
    confidenceScore?: true
    projectedSavings?: true
    roiMonths?: true
    triggeredBy?: true
    status?: true
    viewedAt?: true
    dismissedAt?: true
    acceptedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanRecommendationMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    currentPlanId?: true
    recommendedPlanId?: true
    recommendationReason?: true
    confidenceScore?: true
    projectedSavings?: true
    roiMonths?: true
    triggeredBy?: true
    status?: true
    viewedAt?: true
    dismissedAt?: true
    acceptedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanRecommendationCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    currentPlanId?: true
    recommendedPlanId?: true
    recommendationReason?: true
    confidenceScore?: true
    usagePattern?: true
    projectedSavings?: true
    roiMonths?: true
    triggeredBy?: true
    benefits?: true
    limitationsRemoved?: true
    status?: true
    viewedAt?: true
    dismissedAt?: true
    acceptedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanRecommendation to aggregate.
     */
    where?: PlanRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanRecommendations to fetch.
     */
    orderBy?: PlanRecommendationOrderByWithRelationInput | PlanRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanRecommendations
    **/
    _count?: true | PlanRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanRecommendationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanRecommendationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanRecommendationMaxAggregateInputType
  }

  export type GetPlanRecommendationAggregateType<T extends PlanRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanRecommendation[P]>
      : GetScalarType<T[P], AggregatePlanRecommendation[P]>
  }




  export type PlanRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanRecommendationWhereInput
    orderBy?: PlanRecommendationOrderByWithAggregationInput | PlanRecommendationOrderByWithAggregationInput[]
    by: PlanRecommendationScalarFieldEnum[] | PlanRecommendationScalarFieldEnum
    having?: PlanRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanRecommendationCountAggregateInputType | true
    _avg?: PlanRecommendationAvgAggregateInputType
    _sum?: PlanRecommendationSumAggregateInputType
    _min?: PlanRecommendationMinAggregateInputType
    _max?: PlanRecommendationMaxAggregateInputType
  }

  export type PlanRecommendationGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    currentPlanId: string
    recommendedPlanId: string
    recommendationReason: string
    confidenceScore: Decimal | null
    usagePattern: JsonValue | null
    projectedSavings: Decimal | null
    roiMonths: number | null
    triggeredBy: string | null
    benefits: string[]
    limitationsRemoved: string[]
    status: string
    viewedAt: Date | null
    dismissedAt: Date | null
    acceptedAt: Date | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PlanRecommendationCountAggregateOutputType | null
    _avg: PlanRecommendationAvgAggregateOutputType | null
    _sum: PlanRecommendationSumAggregateOutputType | null
    _min: PlanRecommendationMinAggregateOutputType | null
    _max: PlanRecommendationMaxAggregateOutputType | null
  }

  type GetPlanRecommendationGroupByPayload<T extends PlanRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], PlanRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type PlanRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    currentPlanId?: boolean
    recommendedPlanId?: boolean
    recommendationReason?: boolean
    confidenceScore?: boolean
    usagePattern?: boolean
    projectedSavings?: boolean
    roiMonths?: boolean
    triggeredBy?: boolean
    benefits?: boolean
    limitationsRemoved?: boolean
    status?: boolean
    viewedAt?: boolean
    dismissedAt?: boolean
    acceptedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentPlan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    recommendedPlan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planRecommendation"]>

  export type PlanRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    currentPlanId?: boolean
    recommendedPlanId?: boolean
    recommendationReason?: boolean
    confidenceScore?: boolean
    usagePattern?: boolean
    projectedSavings?: boolean
    roiMonths?: boolean
    triggeredBy?: boolean
    benefits?: boolean
    limitationsRemoved?: boolean
    status?: boolean
    viewedAt?: boolean
    dismissedAt?: boolean
    acceptedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentPlan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    recommendedPlan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planRecommendation"]>

  export type PlanRecommendationSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    currentPlanId?: boolean
    recommendedPlanId?: boolean
    recommendationReason?: boolean
    confidenceScore?: boolean
    usagePattern?: boolean
    projectedSavings?: boolean
    roiMonths?: boolean
    triggeredBy?: boolean
    benefits?: boolean
    limitationsRemoved?: boolean
    status?: boolean
    viewedAt?: boolean
    dismissedAt?: boolean
    acceptedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentPlan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    recommendedPlan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }
  export type PlanRecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentPlan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    recommendedPlan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $PlanRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanRecommendation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      currentPlan: Prisma.$SubscriptionPlanPayload<ExtArgs>
      recommendedPlan: Prisma.$SubscriptionPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      currentPlanId: string
      recommendedPlanId: string
      recommendationReason: string
      confidenceScore: Prisma.Decimal | null
      usagePattern: Prisma.JsonValue | null
      projectedSavings: Prisma.Decimal | null
      roiMonths: number | null
      triggeredBy: string | null
      benefits: string[]
      limitationsRemoved: string[]
      status: string
      viewedAt: Date | null
      dismissedAt: Date | null
      acceptedAt: Date | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planRecommendation"]>
    composites: {}
  }

  type PlanRecommendationGetPayload<S extends boolean | null | undefined | PlanRecommendationDefaultArgs> = $Result.GetResult<Prisma.$PlanRecommendationPayload, S>

  type PlanRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanRecommendationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanRecommendationCountAggregateInputType | true
    }

  export interface PlanRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanRecommendation'], meta: { name: 'PlanRecommendation' } }
    /**
     * Find zero or one PlanRecommendation that matches the filter.
     * @param {PlanRecommendationFindUniqueArgs} args - Arguments to find a PlanRecommendation
     * @example
     * // Get one PlanRecommendation
     * const planRecommendation = await prisma.planRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanRecommendationFindUniqueArgs>(args: SelectSubset<T, PlanRecommendationFindUniqueArgs<ExtArgs>>): Prisma__PlanRecommendationClient<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlanRecommendation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanRecommendationFindUniqueOrThrowArgs} args - Arguments to find a PlanRecommendation
     * @example
     * // Get one PlanRecommendation
     * const planRecommendation = await prisma.planRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanRecommendationClient<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlanRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanRecommendationFindFirstArgs} args - Arguments to find a PlanRecommendation
     * @example
     * // Get one PlanRecommendation
     * const planRecommendation = await prisma.planRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanRecommendationFindFirstArgs>(args?: SelectSubset<T, PlanRecommendationFindFirstArgs<ExtArgs>>): Prisma__PlanRecommendationClient<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlanRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanRecommendationFindFirstOrThrowArgs} args - Arguments to find a PlanRecommendation
     * @example
     * // Get one PlanRecommendation
     * const planRecommendation = await prisma.planRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanRecommendationClient<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlanRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanRecommendations
     * const planRecommendations = await prisma.planRecommendation.findMany()
     * 
     * // Get first 10 PlanRecommendations
     * const planRecommendations = await prisma.planRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planRecommendationWithIdOnly = await prisma.planRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanRecommendationFindManyArgs>(args?: SelectSubset<T, PlanRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlanRecommendation.
     * @param {PlanRecommendationCreateArgs} args - Arguments to create a PlanRecommendation.
     * @example
     * // Create one PlanRecommendation
     * const PlanRecommendation = await prisma.planRecommendation.create({
     *   data: {
     *     // ... data to create a PlanRecommendation
     *   }
     * })
     * 
     */
    create<T extends PlanRecommendationCreateArgs>(args: SelectSubset<T, PlanRecommendationCreateArgs<ExtArgs>>): Prisma__PlanRecommendationClient<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlanRecommendations.
     * @param {PlanRecommendationCreateManyArgs} args - Arguments to create many PlanRecommendations.
     * @example
     * // Create many PlanRecommendations
     * const planRecommendation = await prisma.planRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanRecommendationCreateManyArgs>(args?: SelectSubset<T, PlanRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanRecommendations and returns the data saved in the database.
     * @param {PlanRecommendationCreateManyAndReturnArgs} args - Arguments to create many PlanRecommendations.
     * @example
     * // Create many PlanRecommendations
     * const planRecommendation = await prisma.planRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanRecommendations and only return the `id`
     * const planRecommendationWithIdOnly = await prisma.planRecommendation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlanRecommendation.
     * @param {PlanRecommendationDeleteArgs} args - Arguments to delete one PlanRecommendation.
     * @example
     * // Delete one PlanRecommendation
     * const PlanRecommendation = await prisma.planRecommendation.delete({
     *   where: {
     *     // ... filter to delete one PlanRecommendation
     *   }
     * })
     * 
     */
    delete<T extends PlanRecommendationDeleteArgs>(args: SelectSubset<T, PlanRecommendationDeleteArgs<ExtArgs>>): Prisma__PlanRecommendationClient<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlanRecommendation.
     * @param {PlanRecommendationUpdateArgs} args - Arguments to update one PlanRecommendation.
     * @example
     * // Update one PlanRecommendation
     * const planRecommendation = await prisma.planRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanRecommendationUpdateArgs>(args: SelectSubset<T, PlanRecommendationUpdateArgs<ExtArgs>>): Prisma__PlanRecommendationClient<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlanRecommendations.
     * @param {PlanRecommendationDeleteManyArgs} args - Arguments to filter PlanRecommendations to delete.
     * @example
     * // Delete a few PlanRecommendations
     * const { count } = await prisma.planRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanRecommendationDeleteManyArgs>(args?: SelectSubset<T, PlanRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanRecommendations
     * const planRecommendation = await prisma.planRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanRecommendationUpdateManyArgs>(args: SelectSubset<T, PlanRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanRecommendation.
     * @param {PlanRecommendationUpsertArgs} args - Arguments to update or create a PlanRecommendation.
     * @example
     * // Update or create a PlanRecommendation
     * const planRecommendation = await prisma.planRecommendation.upsert({
     *   create: {
     *     // ... data to create a PlanRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends PlanRecommendationUpsertArgs>(args: SelectSubset<T, PlanRecommendationUpsertArgs<ExtArgs>>): Prisma__PlanRecommendationClient<$Result.GetResult<Prisma.$PlanRecommendationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlanRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanRecommendationCountArgs} args - Arguments to filter PlanRecommendations to count.
     * @example
     * // Count the number of PlanRecommendations
     * const count = await prisma.planRecommendation.count({
     *   where: {
     *     // ... the filter for the PlanRecommendations we want to count
     *   }
     * })
    **/
    count<T extends PlanRecommendationCountArgs>(
      args?: Subset<T, PlanRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanRecommendationAggregateArgs>(args: Subset<T, PlanRecommendationAggregateArgs>): Prisma.PrismaPromise<GetPlanRecommendationAggregateType<T>>

    /**
     * Group by PlanRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: PlanRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanRecommendation model
   */
  readonly fields: PlanRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    currentPlan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    recommendedPlan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanRecommendation model
   */ 
  interface PlanRecommendationFieldRefs {
    readonly id: FieldRef<"PlanRecommendation", 'String'>
    readonly userId: FieldRef<"PlanRecommendation", 'String'>
    readonly workspaceId: FieldRef<"PlanRecommendation", 'String'>
    readonly currentPlanId: FieldRef<"PlanRecommendation", 'String'>
    readonly recommendedPlanId: FieldRef<"PlanRecommendation", 'String'>
    readonly recommendationReason: FieldRef<"PlanRecommendation", 'String'>
    readonly confidenceScore: FieldRef<"PlanRecommendation", 'Decimal'>
    readonly usagePattern: FieldRef<"PlanRecommendation", 'Json'>
    readonly projectedSavings: FieldRef<"PlanRecommendation", 'Decimal'>
    readonly roiMonths: FieldRef<"PlanRecommendation", 'Int'>
    readonly triggeredBy: FieldRef<"PlanRecommendation", 'String'>
    readonly benefits: FieldRef<"PlanRecommendation", 'String[]'>
    readonly limitationsRemoved: FieldRef<"PlanRecommendation", 'String[]'>
    readonly status: FieldRef<"PlanRecommendation", 'String'>
    readonly viewedAt: FieldRef<"PlanRecommendation", 'DateTime'>
    readonly dismissedAt: FieldRef<"PlanRecommendation", 'DateTime'>
    readonly acceptedAt: FieldRef<"PlanRecommendation", 'DateTime'>
    readonly expiresAt: FieldRef<"PlanRecommendation", 'DateTime'>
    readonly createdAt: FieldRef<"PlanRecommendation", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanRecommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanRecommendation findUnique
   */
  export type PlanRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which PlanRecommendation to fetch.
     */
    where: PlanRecommendationWhereUniqueInput
  }

  /**
   * PlanRecommendation findUniqueOrThrow
   */
  export type PlanRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which PlanRecommendation to fetch.
     */
    where: PlanRecommendationWhereUniqueInput
  }

  /**
   * PlanRecommendation findFirst
   */
  export type PlanRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which PlanRecommendation to fetch.
     */
    where?: PlanRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanRecommendations to fetch.
     */
    orderBy?: PlanRecommendationOrderByWithRelationInput | PlanRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanRecommendations.
     */
    cursor?: PlanRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanRecommendations.
     */
    distinct?: PlanRecommendationScalarFieldEnum | PlanRecommendationScalarFieldEnum[]
  }

  /**
   * PlanRecommendation findFirstOrThrow
   */
  export type PlanRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which PlanRecommendation to fetch.
     */
    where?: PlanRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanRecommendations to fetch.
     */
    orderBy?: PlanRecommendationOrderByWithRelationInput | PlanRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanRecommendations.
     */
    cursor?: PlanRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanRecommendations.
     */
    distinct?: PlanRecommendationScalarFieldEnum | PlanRecommendationScalarFieldEnum[]
  }

  /**
   * PlanRecommendation findMany
   */
  export type PlanRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which PlanRecommendations to fetch.
     */
    where?: PlanRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanRecommendations to fetch.
     */
    orderBy?: PlanRecommendationOrderByWithRelationInput | PlanRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanRecommendations.
     */
    cursor?: PlanRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanRecommendations.
     */
    skip?: number
    distinct?: PlanRecommendationScalarFieldEnum | PlanRecommendationScalarFieldEnum[]
  }

  /**
   * PlanRecommendation create
   */
  export type PlanRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanRecommendation.
     */
    data: XOR<PlanRecommendationCreateInput, PlanRecommendationUncheckedCreateInput>
  }

  /**
   * PlanRecommendation createMany
   */
  export type PlanRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanRecommendations.
     */
    data: PlanRecommendationCreateManyInput | PlanRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanRecommendation createManyAndReturn
   */
  export type PlanRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlanRecommendations.
     */
    data: PlanRecommendationCreateManyInput | PlanRecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanRecommendation update
   */
  export type PlanRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanRecommendation.
     */
    data: XOR<PlanRecommendationUpdateInput, PlanRecommendationUncheckedUpdateInput>
    /**
     * Choose, which PlanRecommendation to update.
     */
    where: PlanRecommendationWhereUniqueInput
  }

  /**
   * PlanRecommendation updateMany
   */
  export type PlanRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanRecommendations.
     */
    data: XOR<PlanRecommendationUpdateManyMutationInput, PlanRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which PlanRecommendations to update
     */
    where?: PlanRecommendationWhereInput
  }

  /**
   * PlanRecommendation upsert
   */
  export type PlanRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanRecommendation to update in case it exists.
     */
    where: PlanRecommendationWhereUniqueInput
    /**
     * In case the PlanRecommendation found by the `where` argument doesn't exist, create a new PlanRecommendation with this data.
     */
    create: XOR<PlanRecommendationCreateInput, PlanRecommendationUncheckedCreateInput>
    /**
     * In case the PlanRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanRecommendationUpdateInput, PlanRecommendationUncheckedUpdateInput>
  }

  /**
   * PlanRecommendation delete
   */
  export type PlanRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
    /**
     * Filter which PlanRecommendation to delete.
     */
    where: PlanRecommendationWhereUniqueInput
  }

  /**
   * PlanRecommendation deleteMany
   */
  export type PlanRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanRecommendations to delete
     */
    where?: PlanRecommendationWhereInput
  }

  /**
   * PlanRecommendation without action
   */
  export type PlanRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanRecommendation
     */
    select?: PlanRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanRecommendationInclude<ExtArgs> | null
  }


  /**
   * Model CustomPlan
   */

  export type AggregateCustomPlan = {
    _count: CustomPlanCountAggregateOutputType | null
    _avg: CustomPlanAvgAggregateOutputType | null
    _sum: CustomPlanSumAggregateOutputType | null
    _min: CustomPlanMinAggregateOutputType | null
    _max: CustomPlanMaxAggregateOutputType | null
  }

  export type CustomPlanAvgAggregateOutputType = {
    customMaxTranscriptionsMonthly: number | null
    customMaxFilesDaily: number | null
    customMaxFilesMonthly: number | null
    customMaxConcurrentJobs: number | null
    customMaxVoiceSynthesisMonthly: number | null
    customMaxExportOperationsMonthly: number | null
    customMaxAudioDurationMinutes: number | null
    customPriorityLevel: number | null
    customPrice: Decimal | null
    noticePeriodDays: number | null
  }

  export type CustomPlanSumAggregateOutputType = {
    customMaxTranscriptionsMonthly: bigint | null
    customMaxFilesDaily: number | null
    customMaxFilesMonthly: number | null
    customMaxConcurrentJobs: number | null
    customMaxVoiceSynthesisMonthly: bigint | null
    customMaxExportOperationsMonthly: number | null
    customMaxAudioDurationMinutes: number | null
    customPriorityLevel: number | null
    customPrice: Decimal | null
    noticePeriodDays: number | null
  }

  export type CustomPlanMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    basePlanId: string | null
    planName: string | null
    description: string | null
    customMaxTranscriptionsMonthly: bigint | null
    customMaxFilesDaily: number | null
    customMaxFilesMonthly: number | null
    customMaxConcurrentJobs: number | null
    customMaxVoiceSynthesisMonthly: bigint | null
    customMaxExportOperationsMonthly: number | null
    customMaxAudioDurationMinutes: number | null
    customPriorityLevel: number | null
    customPrice: Decimal | null
    pricingModel: string | null
    billingInterval: string | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    autoRenew: boolean | null
    noticePeriodDays: number | null
    requestedBy: string | null
    approvedBy: string | null
    approvalStatus: string | null
    approvalNotes: string | null
    isActive: boolean | null
    activatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomPlanMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    basePlanId: string | null
    planName: string | null
    description: string | null
    customMaxTranscriptionsMonthly: bigint | null
    customMaxFilesDaily: number | null
    customMaxFilesMonthly: number | null
    customMaxConcurrentJobs: number | null
    customMaxVoiceSynthesisMonthly: bigint | null
    customMaxExportOperationsMonthly: number | null
    customMaxAudioDurationMinutes: number | null
    customPriorityLevel: number | null
    customPrice: Decimal | null
    pricingModel: string | null
    billingInterval: string | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    autoRenew: boolean | null
    noticePeriodDays: number | null
    requestedBy: string | null
    approvedBy: string | null
    approvalStatus: string | null
    approvalNotes: string | null
    isActive: boolean | null
    activatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomPlanCountAggregateOutputType = {
    id: number
    workspaceId: number
    basePlanId: number
    planName: number
    description: number
    customMaxTranscriptionsMonthly: number
    customMaxFilesDaily: number
    customMaxFilesMonthly: number
    customMaxConcurrentJobs: number
    customMaxVoiceSynthesisMonthly: number
    customMaxExportOperationsMonthly: number
    customMaxAudioDurationMinutes: number
    customPriorityLevel: number
    customFeatures: number
    excludedFeatures: number
    additionalFeatures: number
    customPrice: number
    pricingModel: number
    billingInterval: number
    contractStartDate: number
    contractEndDate: number
    autoRenew: number
    noticePeriodDays: number
    requestedBy: number
    approvedBy: number
    approvalStatus: number
    approvalNotes: number
    isActive: number
    activatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomPlanAvgAggregateInputType = {
    customMaxTranscriptionsMonthly?: true
    customMaxFilesDaily?: true
    customMaxFilesMonthly?: true
    customMaxConcurrentJobs?: true
    customMaxVoiceSynthesisMonthly?: true
    customMaxExportOperationsMonthly?: true
    customMaxAudioDurationMinutes?: true
    customPriorityLevel?: true
    customPrice?: true
    noticePeriodDays?: true
  }

  export type CustomPlanSumAggregateInputType = {
    customMaxTranscriptionsMonthly?: true
    customMaxFilesDaily?: true
    customMaxFilesMonthly?: true
    customMaxConcurrentJobs?: true
    customMaxVoiceSynthesisMonthly?: true
    customMaxExportOperationsMonthly?: true
    customMaxAudioDurationMinutes?: true
    customPriorityLevel?: true
    customPrice?: true
    noticePeriodDays?: true
  }

  export type CustomPlanMinAggregateInputType = {
    id?: true
    workspaceId?: true
    basePlanId?: true
    planName?: true
    description?: true
    customMaxTranscriptionsMonthly?: true
    customMaxFilesDaily?: true
    customMaxFilesMonthly?: true
    customMaxConcurrentJobs?: true
    customMaxVoiceSynthesisMonthly?: true
    customMaxExportOperationsMonthly?: true
    customMaxAudioDurationMinutes?: true
    customPriorityLevel?: true
    customPrice?: true
    pricingModel?: true
    billingInterval?: true
    contractStartDate?: true
    contractEndDate?: true
    autoRenew?: true
    noticePeriodDays?: true
    requestedBy?: true
    approvedBy?: true
    approvalStatus?: true
    approvalNotes?: true
    isActive?: true
    activatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomPlanMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    basePlanId?: true
    planName?: true
    description?: true
    customMaxTranscriptionsMonthly?: true
    customMaxFilesDaily?: true
    customMaxFilesMonthly?: true
    customMaxConcurrentJobs?: true
    customMaxVoiceSynthesisMonthly?: true
    customMaxExportOperationsMonthly?: true
    customMaxAudioDurationMinutes?: true
    customPriorityLevel?: true
    customPrice?: true
    pricingModel?: true
    billingInterval?: true
    contractStartDate?: true
    contractEndDate?: true
    autoRenew?: true
    noticePeriodDays?: true
    requestedBy?: true
    approvedBy?: true
    approvalStatus?: true
    approvalNotes?: true
    isActive?: true
    activatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomPlanCountAggregateInputType = {
    id?: true
    workspaceId?: true
    basePlanId?: true
    planName?: true
    description?: true
    customMaxTranscriptionsMonthly?: true
    customMaxFilesDaily?: true
    customMaxFilesMonthly?: true
    customMaxConcurrentJobs?: true
    customMaxVoiceSynthesisMonthly?: true
    customMaxExportOperationsMonthly?: true
    customMaxAudioDurationMinutes?: true
    customPriorityLevel?: true
    customFeatures?: true
    excludedFeatures?: true
    additionalFeatures?: true
    customPrice?: true
    pricingModel?: true
    billingInterval?: true
    contractStartDate?: true
    contractEndDate?: true
    autoRenew?: true
    noticePeriodDays?: true
    requestedBy?: true
    approvedBy?: true
    approvalStatus?: true
    approvalNotes?: true
    isActive?: true
    activatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomPlan to aggregate.
     */
    where?: CustomPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPlans to fetch.
     */
    orderBy?: CustomPlanOrderByWithRelationInput | CustomPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomPlans
    **/
    _count?: true | CustomPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomPlanMaxAggregateInputType
  }

  export type GetCustomPlanAggregateType<T extends CustomPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomPlan[P]>
      : GetScalarType<T[P], AggregateCustomPlan[P]>
  }




  export type CustomPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomPlanWhereInput
    orderBy?: CustomPlanOrderByWithAggregationInput | CustomPlanOrderByWithAggregationInput[]
    by: CustomPlanScalarFieldEnum[] | CustomPlanScalarFieldEnum
    having?: CustomPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomPlanCountAggregateInputType | true
    _avg?: CustomPlanAvgAggregateInputType
    _sum?: CustomPlanSumAggregateInputType
    _min?: CustomPlanMinAggregateInputType
    _max?: CustomPlanMaxAggregateInputType
  }

  export type CustomPlanGroupByOutputType = {
    id: string
    workspaceId: string
    basePlanId: string | null
    planName: string
    description: string | null
    customMaxTranscriptionsMonthly: bigint | null
    customMaxFilesDaily: number | null
    customMaxFilesMonthly: number | null
    customMaxConcurrentJobs: number | null
    customMaxVoiceSynthesisMonthly: bigint | null
    customMaxExportOperationsMonthly: number | null
    customMaxAudioDurationMinutes: number | null
    customPriorityLevel: number | null
    customFeatures: string[]
    excludedFeatures: string[]
    additionalFeatures: string[]
    customPrice: Decimal | null
    pricingModel: string
    billingInterval: string
    contractStartDate: Date | null
    contractEndDate: Date | null
    autoRenew: boolean
    noticePeriodDays: number
    requestedBy: string | null
    approvedBy: string | null
    approvalStatus: string
    approvalNotes: string | null
    isActive: boolean
    activatedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CustomPlanCountAggregateOutputType | null
    _avg: CustomPlanAvgAggregateOutputType | null
    _sum: CustomPlanSumAggregateOutputType | null
    _min: CustomPlanMinAggregateOutputType | null
    _max: CustomPlanMaxAggregateOutputType | null
  }

  type GetCustomPlanGroupByPayload<T extends CustomPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomPlanGroupByOutputType[P]>
            : GetScalarType<T[P], CustomPlanGroupByOutputType[P]>
        }
      >
    >


  export type CustomPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    basePlanId?: boolean
    planName?: boolean
    description?: boolean
    customMaxTranscriptionsMonthly?: boolean
    customMaxFilesDaily?: boolean
    customMaxFilesMonthly?: boolean
    customMaxConcurrentJobs?: boolean
    customMaxVoiceSynthesisMonthly?: boolean
    customMaxExportOperationsMonthly?: boolean
    customMaxAudioDurationMinutes?: boolean
    customPriorityLevel?: boolean
    customFeatures?: boolean
    excludedFeatures?: boolean
    additionalFeatures?: boolean
    customPrice?: boolean
    pricingModel?: boolean
    billingInterval?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    autoRenew?: boolean
    noticePeriodDays?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    approvalStatus?: boolean
    approvalNotes?: boolean
    isActive?: boolean
    activatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requestedByUser?: boolean | CustomPlan$requestedByUserArgs<ExtArgs>
    basePlan?: boolean | CustomPlan$basePlanArgs<ExtArgs>
  }, ExtArgs["result"]["customPlan"]>

  export type CustomPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    basePlanId?: boolean
    planName?: boolean
    description?: boolean
    customMaxTranscriptionsMonthly?: boolean
    customMaxFilesDaily?: boolean
    customMaxFilesMonthly?: boolean
    customMaxConcurrentJobs?: boolean
    customMaxVoiceSynthesisMonthly?: boolean
    customMaxExportOperationsMonthly?: boolean
    customMaxAudioDurationMinutes?: boolean
    customPriorityLevel?: boolean
    customFeatures?: boolean
    excludedFeatures?: boolean
    additionalFeatures?: boolean
    customPrice?: boolean
    pricingModel?: boolean
    billingInterval?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    autoRenew?: boolean
    noticePeriodDays?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    approvalStatus?: boolean
    approvalNotes?: boolean
    isActive?: boolean
    activatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requestedByUser?: boolean | CustomPlan$requestedByUserArgs<ExtArgs>
    basePlan?: boolean | CustomPlan$basePlanArgs<ExtArgs>
  }, ExtArgs["result"]["customPlan"]>

  export type CustomPlanSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    basePlanId?: boolean
    planName?: boolean
    description?: boolean
    customMaxTranscriptionsMonthly?: boolean
    customMaxFilesDaily?: boolean
    customMaxFilesMonthly?: boolean
    customMaxConcurrentJobs?: boolean
    customMaxVoiceSynthesisMonthly?: boolean
    customMaxExportOperationsMonthly?: boolean
    customMaxAudioDurationMinutes?: boolean
    customPriorityLevel?: boolean
    customFeatures?: boolean
    excludedFeatures?: boolean
    additionalFeatures?: boolean
    customPrice?: boolean
    pricingModel?: boolean
    billingInterval?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    autoRenew?: boolean
    noticePeriodDays?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    approvalStatus?: boolean
    approvalNotes?: boolean
    isActive?: boolean
    activatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestedByUser?: boolean | CustomPlan$requestedByUserArgs<ExtArgs>
    basePlan?: boolean | CustomPlan$basePlanArgs<ExtArgs>
  }
  export type CustomPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestedByUser?: boolean | CustomPlan$requestedByUserArgs<ExtArgs>
    basePlan?: boolean | CustomPlan$basePlanArgs<ExtArgs>
  }

  export type $CustomPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomPlan"
    objects: {
      requestedByUser: Prisma.$UserPayload<ExtArgs> | null
      basePlan: Prisma.$SubscriptionPlanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      basePlanId: string | null
      planName: string
      description: string | null
      customMaxTranscriptionsMonthly: bigint | null
      customMaxFilesDaily: number | null
      customMaxFilesMonthly: number | null
      customMaxConcurrentJobs: number | null
      customMaxVoiceSynthesisMonthly: bigint | null
      customMaxExportOperationsMonthly: number | null
      customMaxAudioDurationMinutes: number | null
      customPriorityLevel: number | null
      customFeatures: string[]
      excludedFeatures: string[]
      additionalFeatures: string[]
      customPrice: Prisma.Decimal | null
      pricingModel: string
      billingInterval: string
      contractStartDate: Date | null
      contractEndDate: Date | null
      autoRenew: boolean
      noticePeriodDays: number
      requestedBy: string | null
      approvedBy: string | null
      approvalStatus: string
      approvalNotes: string | null
      isActive: boolean
      activatedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customPlan"]>
    composites: {}
  }

  type CustomPlanGetPayload<S extends boolean | null | undefined | CustomPlanDefaultArgs> = $Result.GetResult<Prisma.$CustomPlanPayload, S>

  type CustomPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomPlanCountAggregateInputType | true
    }

  export interface CustomPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomPlan'], meta: { name: 'CustomPlan' } }
    /**
     * Find zero or one CustomPlan that matches the filter.
     * @param {CustomPlanFindUniqueArgs} args - Arguments to find a CustomPlan
     * @example
     * // Get one CustomPlan
     * const customPlan = await prisma.customPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomPlanFindUniqueArgs>(args: SelectSubset<T, CustomPlanFindUniqueArgs<ExtArgs>>): Prisma__CustomPlanClient<$Result.GetResult<Prisma.$CustomPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomPlanFindUniqueOrThrowArgs} args - Arguments to find a CustomPlan
     * @example
     * // Get one CustomPlan
     * const customPlan = await prisma.customPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomPlanClient<$Result.GetResult<Prisma.$CustomPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPlanFindFirstArgs} args - Arguments to find a CustomPlan
     * @example
     * // Get one CustomPlan
     * const customPlan = await prisma.customPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomPlanFindFirstArgs>(args?: SelectSubset<T, CustomPlanFindFirstArgs<ExtArgs>>): Prisma__CustomPlanClient<$Result.GetResult<Prisma.$CustomPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPlanFindFirstOrThrowArgs} args - Arguments to find a CustomPlan
     * @example
     * // Get one CustomPlan
     * const customPlan = await prisma.customPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomPlanClient<$Result.GetResult<Prisma.$CustomPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomPlans
     * const customPlans = await prisma.customPlan.findMany()
     * 
     * // Get first 10 CustomPlans
     * const customPlans = await prisma.customPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customPlanWithIdOnly = await prisma.customPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomPlanFindManyArgs>(args?: SelectSubset<T, CustomPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomPlan.
     * @param {CustomPlanCreateArgs} args - Arguments to create a CustomPlan.
     * @example
     * // Create one CustomPlan
     * const CustomPlan = await prisma.customPlan.create({
     *   data: {
     *     // ... data to create a CustomPlan
     *   }
     * })
     * 
     */
    create<T extends CustomPlanCreateArgs>(args: SelectSubset<T, CustomPlanCreateArgs<ExtArgs>>): Prisma__CustomPlanClient<$Result.GetResult<Prisma.$CustomPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomPlans.
     * @param {CustomPlanCreateManyArgs} args - Arguments to create many CustomPlans.
     * @example
     * // Create many CustomPlans
     * const customPlan = await prisma.customPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomPlanCreateManyArgs>(args?: SelectSubset<T, CustomPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomPlans and returns the data saved in the database.
     * @param {CustomPlanCreateManyAndReturnArgs} args - Arguments to create many CustomPlans.
     * @example
     * // Create many CustomPlans
     * const customPlan = await prisma.customPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomPlans and only return the `id`
     * const customPlanWithIdOnly = await prisma.customPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomPlan.
     * @param {CustomPlanDeleteArgs} args - Arguments to delete one CustomPlan.
     * @example
     * // Delete one CustomPlan
     * const CustomPlan = await prisma.customPlan.delete({
     *   where: {
     *     // ... filter to delete one CustomPlan
     *   }
     * })
     * 
     */
    delete<T extends CustomPlanDeleteArgs>(args: SelectSubset<T, CustomPlanDeleteArgs<ExtArgs>>): Prisma__CustomPlanClient<$Result.GetResult<Prisma.$CustomPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomPlan.
     * @param {CustomPlanUpdateArgs} args - Arguments to update one CustomPlan.
     * @example
     * // Update one CustomPlan
     * const customPlan = await prisma.customPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomPlanUpdateArgs>(args: SelectSubset<T, CustomPlanUpdateArgs<ExtArgs>>): Prisma__CustomPlanClient<$Result.GetResult<Prisma.$CustomPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomPlans.
     * @param {CustomPlanDeleteManyArgs} args - Arguments to filter CustomPlans to delete.
     * @example
     * // Delete a few CustomPlans
     * const { count } = await prisma.customPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomPlanDeleteManyArgs>(args?: SelectSubset<T, CustomPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomPlans
     * const customPlan = await prisma.customPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomPlanUpdateManyArgs>(args: SelectSubset<T, CustomPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomPlan.
     * @param {CustomPlanUpsertArgs} args - Arguments to update or create a CustomPlan.
     * @example
     * // Update or create a CustomPlan
     * const customPlan = await prisma.customPlan.upsert({
     *   create: {
     *     // ... data to create a CustomPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomPlan we want to update
     *   }
     * })
     */
    upsert<T extends CustomPlanUpsertArgs>(args: SelectSubset<T, CustomPlanUpsertArgs<ExtArgs>>): Prisma__CustomPlanClient<$Result.GetResult<Prisma.$CustomPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPlanCountArgs} args - Arguments to filter CustomPlans to count.
     * @example
     * // Count the number of CustomPlans
     * const count = await prisma.customPlan.count({
     *   where: {
     *     // ... the filter for the CustomPlans we want to count
     *   }
     * })
    **/
    count<T extends CustomPlanCountArgs>(
      args?: Subset<T, CustomPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomPlanAggregateArgs>(args: Subset<T, CustomPlanAggregateArgs>): Prisma.PrismaPromise<GetCustomPlanAggregateType<T>>

    /**
     * Group by CustomPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomPlanGroupByArgs['orderBy'] }
        : { orderBy?: CustomPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomPlan model
   */
  readonly fields: CustomPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requestedByUser<T extends CustomPlan$requestedByUserArgs<ExtArgs> = {}>(args?: Subset<T, CustomPlan$requestedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    basePlan<T extends CustomPlan$basePlanArgs<ExtArgs> = {}>(args?: Subset<T, CustomPlan$basePlanArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomPlan model
   */ 
  interface CustomPlanFieldRefs {
    readonly id: FieldRef<"CustomPlan", 'String'>
    readonly workspaceId: FieldRef<"CustomPlan", 'String'>
    readonly basePlanId: FieldRef<"CustomPlan", 'String'>
    readonly planName: FieldRef<"CustomPlan", 'String'>
    readonly description: FieldRef<"CustomPlan", 'String'>
    readonly customMaxTranscriptionsMonthly: FieldRef<"CustomPlan", 'BigInt'>
    readonly customMaxFilesDaily: FieldRef<"CustomPlan", 'Int'>
    readonly customMaxFilesMonthly: FieldRef<"CustomPlan", 'Int'>
    readonly customMaxConcurrentJobs: FieldRef<"CustomPlan", 'Int'>
    readonly customMaxVoiceSynthesisMonthly: FieldRef<"CustomPlan", 'BigInt'>
    readonly customMaxExportOperationsMonthly: FieldRef<"CustomPlan", 'Int'>
    readonly customMaxAudioDurationMinutes: FieldRef<"CustomPlan", 'Int'>
    readonly customPriorityLevel: FieldRef<"CustomPlan", 'Int'>
    readonly customFeatures: FieldRef<"CustomPlan", 'String[]'>
    readonly excludedFeatures: FieldRef<"CustomPlan", 'String[]'>
    readonly additionalFeatures: FieldRef<"CustomPlan", 'String[]'>
    readonly customPrice: FieldRef<"CustomPlan", 'Decimal'>
    readonly pricingModel: FieldRef<"CustomPlan", 'String'>
    readonly billingInterval: FieldRef<"CustomPlan", 'String'>
    readonly contractStartDate: FieldRef<"CustomPlan", 'DateTime'>
    readonly contractEndDate: FieldRef<"CustomPlan", 'DateTime'>
    readonly autoRenew: FieldRef<"CustomPlan", 'Boolean'>
    readonly noticePeriodDays: FieldRef<"CustomPlan", 'Int'>
    readonly requestedBy: FieldRef<"CustomPlan", 'String'>
    readonly approvedBy: FieldRef<"CustomPlan", 'String'>
    readonly approvalStatus: FieldRef<"CustomPlan", 'String'>
    readonly approvalNotes: FieldRef<"CustomPlan", 'String'>
    readonly isActive: FieldRef<"CustomPlan", 'Boolean'>
    readonly activatedAt: FieldRef<"CustomPlan", 'DateTime'>
    readonly createdAt: FieldRef<"CustomPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomPlan findUnique
   */
  export type CustomPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanInclude<ExtArgs> | null
    /**
     * Filter, which CustomPlan to fetch.
     */
    where: CustomPlanWhereUniqueInput
  }

  /**
   * CustomPlan findUniqueOrThrow
   */
  export type CustomPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanInclude<ExtArgs> | null
    /**
     * Filter, which CustomPlan to fetch.
     */
    where: CustomPlanWhereUniqueInput
  }

  /**
   * CustomPlan findFirst
   */
  export type CustomPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanInclude<ExtArgs> | null
    /**
     * Filter, which CustomPlan to fetch.
     */
    where?: CustomPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPlans to fetch.
     */
    orderBy?: CustomPlanOrderByWithRelationInput | CustomPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomPlans.
     */
    cursor?: CustomPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomPlans.
     */
    distinct?: CustomPlanScalarFieldEnum | CustomPlanScalarFieldEnum[]
  }

  /**
   * CustomPlan findFirstOrThrow
   */
  export type CustomPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanInclude<ExtArgs> | null
    /**
     * Filter, which CustomPlan to fetch.
     */
    where?: CustomPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPlans to fetch.
     */
    orderBy?: CustomPlanOrderByWithRelationInput | CustomPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomPlans.
     */
    cursor?: CustomPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomPlans.
     */
    distinct?: CustomPlanScalarFieldEnum | CustomPlanScalarFieldEnum[]
  }

  /**
   * CustomPlan findMany
   */
  export type CustomPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanInclude<ExtArgs> | null
    /**
     * Filter, which CustomPlans to fetch.
     */
    where?: CustomPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPlans to fetch.
     */
    orderBy?: CustomPlanOrderByWithRelationInput | CustomPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomPlans.
     */
    cursor?: CustomPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPlans.
     */
    skip?: number
    distinct?: CustomPlanScalarFieldEnum | CustomPlanScalarFieldEnum[]
  }

  /**
   * CustomPlan create
   */
  export type CustomPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomPlan.
     */
    data: XOR<CustomPlanCreateInput, CustomPlanUncheckedCreateInput>
  }

  /**
   * CustomPlan createMany
   */
  export type CustomPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomPlans.
     */
    data: CustomPlanCreateManyInput | CustomPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomPlan createManyAndReturn
   */
  export type CustomPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomPlans.
     */
    data: CustomPlanCreateManyInput | CustomPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomPlan update
   */
  export type CustomPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomPlan.
     */
    data: XOR<CustomPlanUpdateInput, CustomPlanUncheckedUpdateInput>
    /**
     * Choose, which CustomPlan to update.
     */
    where: CustomPlanWhereUniqueInput
  }

  /**
   * CustomPlan updateMany
   */
  export type CustomPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomPlans.
     */
    data: XOR<CustomPlanUpdateManyMutationInput, CustomPlanUncheckedUpdateManyInput>
    /**
     * Filter which CustomPlans to update
     */
    where?: CustomPlanWhereInput
  }

  /**
   * CustomPlan upsert
   */
  export type CustomPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomPlan to update in case it exists.
     */
    where: CustomPlanWhereUniqueInput
    /**
     * In case the CustomPlan found by the `where` argument doesn't exist, create a new CustomPlan with this data.
     */
    create: XOR<CustomPlanCreateInput, CustomPlanUncheckedCreateInput>
    /**
     * In case the CustomPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomPlanUpdateInput, CustomPlanUncheckedUpdateInput>
  }

  /**
   * CustomPlan delete
   */
  export type CustomPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanInclude<ExtArgs> | null
    /**
     * Filter which CustomPlan to delete.
     */
    where: CustomPlanWhereUniqueInput
  }

  /**
   * CustomPlan deleteMany
   */
  export type CustomPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomPlans to delete
     */
    where?: CustomPlanWhereInput
  }

  /**
   * CustomPlan.requestedByUser
   */
  export type CustomPlan$requestedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CustomPlan.basePlan
   */
  export type CustomPlan$basePlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    where?: SubscriptionPlanWhereInput
  }

  /**
   * CustomPlan without action
   */
  export type CustomPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPlan
     */
    select?: CustomPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPlanInclude<ExtArgs> | null
  }


  /**
   * Model FeatureFlag
   */

  export type AggregateFeatureFlag = {
    _count: FeatureFlagCountAggregateOutputType | null
    _avg: FeatureFlagAvgAggregateOutputType | null
    _sum: FeatureFlagSumAggregateOutputType | null
    _min: FeatureFlagMinAggregateOutputType | null
    _max: FeatureFlagMaxAggregateOutputType | null
  }

  export type FeatureFlagAvgAggregateOutputType = {
    minPlanLevel: number | null
    usageCount: number | null
  }

  export type FeatureFlagSumAggregateOutputType = {
    minPlanLevel: number | null
    usageCount: bigint | null
  }

  export type FeatureFlagMinAggregateOutputType = {
    id: string | null
    featureName: string | null
    displayName: string | null
    description: string | null
    category: string | null
    featureType: string | null
    minPlanLevel: number | null
    isEnabled: boolean | null
    isBeta: boolean | null
    isDeprecated: boolean | null
    usageCount: bigint | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureFlagMaxAggregateOutputType = {
    id: string | null
    featureName: string | null
    displayName: string | null
    description: string | null
    category: string | null
    featureType: string | null
    minPlanLevel: number | null
    isEnabled: boolean | null
    isBeta: boolean | null
    isDeprecated: boolean | null
    usageCount: bigint | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureFlagCountAggregateOutputType = {
    id: number
    featureName: number
    displayName: number
    description: number
    category: number
    featureType: number
    minPlanLevel: number
    requiredPlans: number
    excludedPlans: number
    isEnabled: number
    isBeta: number
    isDeprecated: number
    usageCount: number
    lastUsedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureFlagAvgAggregateInputType = {
    minPlanLevel?: true
    usageCount?: true
  }

  export type FeatureFlagSumAggregateInputType = {
    minPlanLevel?: true
    usageCount?: true
  }

  export type FeatureFlagMinAggregateInputType = {
    id?: true
    featureName?: true
    displayName?: true
    description?: true
    category?: true
    featureType?: true
    minPlanLevel?: true
    isEnabled?: true
    isBeta?: true
    isDeprecated?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureFlagMaxAggregateInputType = {
    id?: true
    featureName?: true
    displayName?: true
    description?: true
    category?: true
    featureType?: true
    minPlanLevel?: true
    isEnabled?: true
    isBeta?: true
    isDeprecated?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureFlagCountAggregateInputType = {
    id?: true
    featureName?: true
    displayName?: true
    description?: true
    category?: true
    featureType?: true
    minPlanLevel?: true
    requiredPlans?: true
    excludedPlans?: true
    isEnabled?: true
    isBeta?: true
    isDeprecated?: true
    usageCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureFlagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureFlag to aggregate.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureFlags
    **/
    _count?: true | FeatureFlagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureFlagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureFlagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureFlagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureFlagMaxAggregateInputType
  }

  export type GetFeatureFlagAggregateType<T extends FeatureFlagAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureFlag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureFlag[P]>
      : GetScalarType<T[P], AggregateFeatureFlag[P]>
  }




  export type FeatureFlagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureFlagWhereInput
    orderBy?: FeatureFlagOrderByWithAggregationInput | FeatureFlagOrderByWithAggregationInput[]
    by: FeatureFlagScalarFieldEnum[] | FeatureFlagScalarFieldEnum
    having?: FeatureFlagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureFlagCountAggregateInputType | true
    _avg?: FeatureFlagAvgAggregateInputType
    _sum?: FeatureFlagSumAggregateInputType
    _min?: FeatureFlagMinAggregateInputType
    _max?: FeatureFlagMaxAggregateInputType
  }

  export type FeatureFlagGroupByOutputType = {
    id: string
    featureName: string
    displayName: string
    description: string | null
    category: string | null
    featureType: string | null
    minPlanLevel: number
    requiredPlans: string[]
    excludedPlans: string[]
    isEnabled: boolean
    isBeta: boolean
    isDeprecated: boolean
    usageCount: bigint
    lastUsedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FeatureFlagCountAggregateOutputType | null
    _avg: FeatureFlagAvgAggregateOutputType | null
    _sum: FeatureFlagSumAggregateOutputType | null
    _min: FeatureFlagMinAggregateOutputType | null
    _max: FeatureFlagMaxAggregateOutputType | null
  }

  type GetFeatureFlagGroupByPayload<T extends FeatureFlagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureFlagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureFlagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureFlagGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureFlagGroupByOutputType[P]>
        }
      >
    >


  export type FeatureFlagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureName?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    featureType?: boolean
    minPlanLevel?: boolean
    requiredPlans?: boolean
    excludedPlans?: boolean
    isEnabled?: boolean
    isBeta?: boolean
    isDeprecated?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planFeatures?: boolean | FeatureFlag$planFeaturesArgs<ExtArgs>
    _count?: boolean | FeatureFlagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureFlag"]>

  export type FeatureFlagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureName?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    featureType?: boolean
    minPlanLevel?: boolean
    requiredPlans?: boolean
    excludedPlans?: boolean
    isEnabled?: boolean
    isBeta?: boolean
    isDeprecated?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featureFlag"]>

  export type FeatureFlagSelectScalar = {
    id?: boolean
    featureName?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    featureType?: boolean
    minPlanLevel?: boolean
    requiredPlans?: boolean
    excludedPlans?: boolean
    isEnabled?: boolean
    isBeta?: boolean
    isDeprecated?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeatureFlagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planFeatures?: boolean | FeatureFlag$planFeaturesArgs<ExtArgs>
    _count?: boolean | FeatureFlagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeatureFlagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FeatureFlagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatureFlag"
    objects: {
      planFeatures: Prisma.$PlanFeatureMatrixPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      featureName: string
      displayName: string
      description: string | null
      category: string | null
      featureType: string | null
      minPlanLevel: number
      requiredPlans: string[]
      excludedPlans: string[]
      isEnabled: boolean
      isBeta: boolean
      isDeprecated: boolean
      usageCount: bigint
      lastUsedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featureFlag"]>
    composites: {}
  }

  type FeatureFlagGetPayload<S extends boolean | null | undefined | FeatureFlagDefaultArgs> = $Result.GetResult<Prisma.$FeatureFlagPayload, S>

  type FeatureFlagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeatureFlagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeatureFlagCountAggregateInputType | true
    }

  export interface FeatureFlagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatureFlag'], meta: { name: 'FeatureFlag' } }
    /**
     * Find zero or one FeatureFlag that matches the filter.
     * @param {FeatureFlagFindUniqueArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureFlagFindUniqueArgs>(args: SelectSubset<T, FeatureFlagFindUniqueArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeatureFlag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeatureFlagFindUniqueOrThrowArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureFlagFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureFlagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeatureFlag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagFindFirstArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureFlagFindFirstArgs>(args?: SelectSubset<T, FeatureFlagFindFirstArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeatureFlag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagFindFirstOrThrowArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureFlagFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureFlagFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeatureFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureFlags
     * const featureFlags = await prisma.featureFlag.findMany()
     * 
     * // Get first 10 FeatureFlags
     * const featureFlags = await prisma.featureFlag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureFlagWithIdOnly = await prisma.featureFlag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureFlagFindManyArgs>(args?: SelectSubset<T, FeatureFlagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeatureFlag.
     * @param {FeatureFlagCreateArgs} args - Arguments to create a FeatureFlag.
     * @example
     * // Create one FeatureFlag
     * const FeatureFlag = await prisma.featureFlag.create({
     *   data: {
     *     // ... data to create a FeatureFlag
     *   }
     * })
     * 
     */
    create<T extends FeatureFlagCreateArgs>(args: SelectSubset<T, FeatureFlagCreateArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeatureFlags.
     * @param {FeatureFlagCreateManyArgs} args - Arguments to create many FeatureFlags.
     * @example
     * // Create many FeatureFlags
     * const featureFlag = await prisma.featureFlag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureFlagCreateManyArgs>(args?: SelectSubset<T, FeatureFlagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatureFlags and returns the data saved in the database.
     * @param {FeatureFlagCreateManyAndReturnArgs} args - Arguments to create many FeatureFlags.
     * @example
     * // Create many FeatureFlags
     * const featureFlag = await prisma.featureFlag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatureFlags and only return the `id`
     * const featureFlagWithIdOnly = await prisma.featureFlag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureFlagCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureFlagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeatureFlag.
     * @param {FeatureFlagDeleteArgs} args - Arguments to delete one FeatureFlag.
     * @example
     * // Delete one FeatureFlag
     * const FeatureFlag = await prisma.featureFlag.delete({
     *   where: {
     *     // ... filter to delete one FeatureFlag
     *   }
     * })
     * 
     */
    delete<T extends FeatureFlagDeleteArgs>(args: SelectSubset<T, FeatureFlagDeleteArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeatureFlag.
     * @param {FeatureFlagUpdateArgs} args - Arguments to update one FeatureFlag.
     * @example
     * // Update one FeatureFlag
     * const featureFlag = await prisma.featureFlag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureFlagUpdateArgs>(args: SelectSubset<T, FeatureFlagUpdateArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeatureFlags.
     * @param {FeatureFlagDeleteManyArgs} args - Arguments to filter FeatureFlags to delete.
     * @example
     * // Delete a few FeatureFlags
     * const { count } = await prisma.featureFlag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureFlagDeleteManyArgs>(args?: SelectSubset<T, FeatureFlagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureFlags
     * const featureFlag = await prisma.featureFlag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureFlagUpdateManyArgs>(args: SelectSubset<T, FeatureFlagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeatureFlag.
     * @param {FeatureFlagUpsertArgs} args - Arguments to update or create a FeatureFlag.
     * @example
     * // Update or create a FeatureFlag
     * const featureFlag = await prisma.featureFlag.upsert({
     *   create: {
     *     // ... data to create a FeatureFlag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureFlag we want to update
     *   }
     * })
     */
    upsert<T extends FeatureFlagUpsertArgs>(args: SelectSubset<T, FeatureFlagUpsertArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagCountArgs} args - Arguments to filter FeatureFlags to count.
     * @example
     * // Count the number of FeatureFlags
     * const count = await prisma.featureFlag.count({
     *   where: {
     *     // ... the filter for the FeatureFlags we want to count
     *   }
     * })
    **/
    count<T extends FeatureFlagCountArgs>(
      args?: Subset<T, FeatureFlagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureFlagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureFlagAggregateArgs>(args: Subset<T, FeatureFlagAggregateArgs>): Prisma.PrismaPromise<GetFeatureFlagAggregateType<T>>

    /**
     * Group by FeatureFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureFlagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureFlagGroupByArgs['orderBy'] }
        : { orderBy?: FeatureFlagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureFlagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureFlagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatureFlag model
   */
  readonly fields: FeatureFlagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureFlag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureFlagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planFeatures<T extends FeatureFlag$planFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, FeatureFlag$planFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanFeatureMatrixPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatureFlag model
   */ 
  interface FeatureFlagFieldRefs {
    readonly id: FieldRef<"FeatureFlag", 'String'>
    readonly featureName: FieldRef<"FeatureFlag", 'String'>
    readonly displayName: FieldRef<"FeatureFlag", 'String'>
    readonly description: FieldRef<"FeatureFlag", 'String'>
    readonly category: FieldRef<"FeatureFlag", 'String'>
    readonly featureType: FieldRef<"FeatureFlag", 'String'>
    readonly minPlanLevel: FieldRef<"FeatureFlag", 'Int'>
    readonly requiredPlans: FieldRef<"FeatureFlag", 'String[]'>
    readonly excludedPlans: FieldRef<"FeatureFlag", 'String[]'>
    readonly isEnabled: FieldRef<"FeatureFlag", 'Boolean'>
    readonly isBeta: FieldRef<"FeatureFlag", 'Boolean'>
    readonly isDeprecated: FieldRef<"FeatureFlag", 'Boolean'>
    readonly usageCount: FieldRef<"FeatureFlag", 'BigInt'>
    readonly lastUsedAt: FieldRef<"FeatureFlag", 'DateTime'>
    readonly createdAt: FieldRef<"FeatureFlag", 'DateTime'>
    readonly updatedAt: FieldRef<"FeatureFlag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeatureFlag findUnique
   */
  export type FeatureFlagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagInclude<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag findUniqueOrThrow
   */
  export type FeatureFlagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagInclude<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag findFirst
   */
  export type FeatureFlagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagInclude<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureFlags.
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureFlags.
     */
    distinct?: FeatureFlagScalarFieldEnum | FeatureFlagScalarFieldEnum[]
  }

  /**
   * FeatureFlag findFirstOrThrow
   */
  export type FeatureFlagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagInclude<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureFlags.
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureFlags.
     */
    distinct?: FeatureFlagScalarFieldEnum | FeatureFlagScalarFieldEnum[]
  }

  /**
   * FeatureFlag findMany
   */
  export type FeatureFlagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagInclude<ExtArgs> | null
    /**
     * Filter, which FeatureFlags to fetch.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureFlags.
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    distinct?: FeatureFlagScalarFieldEnum | FeatureFlagScalarFieldEnum[]
  }

  /**
   * FeatureFlag create
   */
  export type FeatureFlagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagInclude<ExtArgs> | null
    /**
     * The data needed to create a FeatureFlag.
     */
    data: XOR<FeatureFlagCreateInput, FeatureFlagUncheckedCreateInput>
  }

  /**
   * FeatureFlag createMany
   */
  export type FeatureFlagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatureFlags.
     */
    data: FeatureFlagCreateManyInput | FeatureFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureFlag createManyAndReturn
   */
  export type FeatureFlagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeatureFlags.
     */
    data: FeatureFlagCreateManyInput | FeatureFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureFlag update
   */
  export type FeatureFlagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagInclude<ExtArgs> | null
    /**
     * The data needed to update a FeatureFlag.
     */
    data: XOR<FeatureFlagUpdateInput, FeatureFlagUncheckedUpdateInput>
    /**
     * Choose, which FeatureFlag to update.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag updateMany
   */
  export type FeatureFlagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatureFlags.
     */
    data: XOR<FeatureFlagUpdateManyMutationInput, FeatureFlagUncheckedUpdateManyInput>
    /**
     * Filter which FeatureFlags to update
     */
    where?: FeatureFlagWhereInput
  }

  /**
   * FeatureFlag upsert
   */
  export type FeatureFlagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagInclude<ExtArgs> | null
    /**
     * The filter to search for the FeatureFlag to update in case it exists.
     */
    where: FeatureFlagWhereUniqueInput
    /**
     * In case the FeatureFlag found by the `where` argument doesn't exist, create a new FeatureFlag with this data.
     */
    create: XOR<FeatureFlagCreateInput, FeatureFlagUncheckedCreateInput>
    /**
     * In case the FeatureFlag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureFlagUpdateInput, FeatureFlagUncheckedUpdateInput>
  }

  /**
   * FeatureFlag delete
   */
  export type FeatureFlagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagInclude<ExtArgs> | null
    /**
     * Filter which FeatureFlag to delete.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag deleteMany
   */
  export type FeatureFlagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureFlags to delete
     */
    where?: FeatureFlagWhereInput
  }

  /**
   * FeatureFlag.planFeatures
   */
  export type FeatureFlag$planFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixInclude<ExtArgs> | null
    where?: PlanFeatureMatrixWhereInput
    orderBy?: PlanFeatureMatrixOrderByWithRelationInput | PlanFeatureMatrixOrderByWithRelationInput[]
    cursor?: PlanFeatureMatrixWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanFeatureMatrixScalarFieldEnum | PlanFeatureMatrixScalarFieldEnum[]
  }

  /**
   * FeatureFlag without action
   */
  export type FeatureFlagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagInclude<ExtArgs> | null
  }


  /**
   * Model PlanFeatureMatrix
   */

  export type AggregatePlanFeatureMatrix = {
    _count: PlanFeatureMatrixCountAggregateOutputType | null
    _avg: PlanFeatureMatrixAvgAggregateOutputType | null
    _sum: PlanFeatureMatrixSumAggregateOutputType | null
    _min: PlanFeatureMatrixMinAggregateOutputType | null
    _max: PlanFeatureMatrixMaxAggregateOutputType | null
  }

  export type PlanFeatureMatrixAvgAggregateOutputType = {
    usageLimit: number | null
    includedUsage: number | null
    overageRate: Decimal | null
  }

  export type PlanFeatureMatrixSumAggregateOutputType = {
    usageLimit: number | null
    includedUsage: number | null
    overageRate: Decimal | null
  }

  export type PlanFeatureMatrixMinAggregateOutputType = {
    id: string | null
    planId: string | null
    featureFlagId: string | null
    isEnabled: boolean | null
    usageLimit: number | null
    includedUsage: number | null
    overageRate: Decimal | null
    createdAt: Date | null
  }

  export type PlanFeatureMatrixMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    featureFlagId: string | null
    isEnabled: boolean | null
    usageLimit: number | null
    includedUsage: number | null
    overageRate: Decimal | null
    createdAt: Date | null
  }

  export type PlanFeatureMatrixCountAggregateOutputType = {
    id: number
    planId: number
    featureFlagId: number
    isEnabled: number
    usageLimit: number
    includedUsage: number
    overageRate: number
    createdAt: number
    _all: number
  }


  export type PlanFeatureMatrixAvgAggregateInputType = {
    usageLimit?: true
    includedUsage?: true
    overageRate?: true
  }

  export type PlanFeatureMatrixSumAggregateInputType = {
    usageLimit?: true
    includedUsage?: true
    overageRate?: true
  }

  export type PlanFeatureMatrixMinAggregateInputType = {
    id?: true
    planId?: true
    featureFlagId?: true
    isEnabled?: true
    usageLimit?: true
    includedUsage?: true
    overageRate?: true
    createdAt?: true
  }

  export type PlanFeatureMatrixMaxAggregateInputType = {
    id?: true
    planId?: true
    featureFlagId?: true
    isEnabled?: true
    usageLimit?: true
    includedUsage?: true
    overageRate?: true
    createdAt?: true
  }

  export type PlanFeatureMatrixCountAggregateInputType = {
    id?: true
    planId?: true
    featureFlagId?: true
    isEnabled?: true
    usageLimit?: true
    includedUsage?: true
    overageRate?: true
    createdAt?: true
    _all?: true
  }

  export type PlanFeatureMatrixAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanFeatureMatrix to aggregate.
     */
    where?: PlanFeatureMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanFeatureMatrices to fetch.
     */
    orderBy?: PlanFeatureMatrixOrderByWithRelationInput | PlanFeatureMatrixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanFeatureMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanFeatureMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanFeatureMatrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanFeatureMatrices
    **/
    _count?: true | PlanFeatureMatrixCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanFeatureMatrixAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanFeatureMatrixSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanFeatureMatrixMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanFeatureMatrixMaxAggregateInputType
  }

  export type GetPlanFeatureMatrixAggregateType<T extends PlanFeatureMatrixAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanFeatureMatrix]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanFeatureMatrix[P]>
      : GetScalarType<T[P], AggregatePlanFeatureMatrix[P]>
  }




  export type PlanFeatureMatrixGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanFeatureMatrixWhereInput
    orderBy?: PlanFeatureMatrixOrderByWithAggregationInput | PlanFeatureMatrixOrderByWithAggregationInput[]
    by: PlanFeatureMatrixScalarFieldEnum[] | PlanFeatureMatrixScalarFieldEnum
    having?: PlanFeatureMatrixScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanFeatureMatrixCountAggregateInputType | true
    _avg?: PlanFeatureMatrixAvgAggregateInputType
    _sum?: PlanFeatureMatrixSumAggregateInputType
    _min?: PlanFeatureMatrixMinAggregateInputType
    _max?: PlanFeatureMatrixMaxAggregateInputType
  }

  export type PlanFeatureMatrixGroupByOutputType = {
    id: string
    planId: string
    featureFlagId: string
    isEnabled: boolean
    usageLimit: number | null
    includedUsage: number
    overageRate: Decimal | null
    createdAt: Date
    _count: PlanFeatureMatrixCountAggregateOutputType | null
    _avg: PlanFeatureMatrixAvgAggregateOutputType | null
    _sum: PlanFeatureMatrixSumAggregateOutputType | null
    _min: PlanFeatureMatrixMinAggregateOutputType | null
    _max: PlanFeatureMatrixMaxAggregateOutputType | null
  }

  type GetPlanFeatureMatrixGroupByPayload<T extends PlanFeatureMatrixGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanFeatureMatrixGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanFeatureMatrixGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanFeatureMatrixGroupByOutputType[P]>
            : GetScalarType<T[P], PlanFeatureMatrixGroupByOutputType[P]>
        }
      >
    >


  export type PlanFeatureMatrixSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    featureFlagId?: boolean
    isEnabled?: boolean
    usageLimit?: boolean
    includedUsage?: boolean
    overageRate?: boolean
    createdAt?: boolean
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    featureFlag?: boolean | FeatureFlagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planFeatureMatrix"]>

  export type PlanFeatureMatrixSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    featureFlagId?: boolean
    isEnabled?: boolean
    usageLimit?: boolean
    includedUsage?: boolean
    overageRate?: boolean
    createdAt?: boolean
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    featureFlag?: boolean | FeatureFlagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planFeatureMatrix"]>

  export type PlanFeatureMatrixSelectScalar = {
    id?: boolean
    planId?: boolean
    featureFlagId?: boolean
    isEnabled?: boolean
    usageLimit?: boolean
    includedUsage?: boolean
    overageRate?: boolean
    createdAt?: boolean
  }

  export type PlanFeatureMatrixInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    featureFlag?: boolean | FeatureFlagDefaultArgs<ExtArgs>
  }
  export type PlanFeatureMatrixIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    featureFlag?: boolean | FeatureFlagDefaultArgs<ExtArgs>
  }

  export type $PlanFeatureMatrixPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanFeatureMatrix"
    objects: {
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
      featureFlag: Prisma.$FeatureFlagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      featureFlagId: string
      isEnabled: boolean
      usageLimit: number | null
      includedUsage: number
      overageRate: Prisma.Decimal | null
      createdAt: Date
    }, ExtArgs["result"]["planFeatureMatrix"]>
    composites: {}
  }

  type PlanFeatureMatrixGetPayload<S extends boolean | null | undefined | PlanFeatureMatrixDefaultArgs> = $Result.GetResult<Prisma.$PlanFeatureMatrixPayload, S>

  type PlanFeatureMatrixCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanFeatureMatrixFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanFeatureMatrixCountAggregateInputType | true
    }

  export interface PlanFeatureMatrixDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanFeatureMatrix'], meta: { name: 'PlanFeatureMatrix' } }
    /**
     * Find zero or one PlanFeatureMatrix that matches the filter.
     * @param {PlanFeatureMatrixFindUniqueArgs} args - Arguments to find a PlanFeatureMatrix
     * @example
     * // Get one PlanFeatureMatrix
     * const planFeatureMatrix = await prisma.planFeatureMatrix.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFeatureMatrixFindUniqueArgs>(args: SelectSubset<T, PlanFeatureMatrixFindUniqueArgs<ExtArgs>>): Prisma__PlanFeatureMatrixClient<$Result.GetResult<Prisma.$PlanFeatureMatrixPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlanFeatureMatrix that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanFeatureMatrixFindUniqueOrThrowArgs} args - Arguments to find a PlanFeatureMatrix
     * @example
     * // Get one PlanFeatureMatrix
     * const planFeatureMatrix = await prisma.planFeatureMatrix.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFeatureMatrixFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFeatureMatrixFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanFeatureMatrixClient<$Result.GetResult<Prisma.$PlanFeatureMatrixPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlanFeatureMatrix that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureMatrixFindFirstArgs} args - Arguments to find a PlanFeatureMatrix
     * @example
     * // Get one PlanFeatureMatrix
     * const planFeatureMatrix = await prisma.planFeatureMatrix.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFeatureMatrixFindFirstArgs>(args?: SelectSubset<T, PlanFeatureMatrixFindFirstArgs<ExtArgs>>): Prisma__PlanFeatureMatrixClient<$Result.GetResult<Prisma.$PlanFeatureMatrixPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlanFeatureMatrix that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureMatrixFindFirstOrThrowArgs} args - Arguments to find a PlanFeatureMatrix
     * @example
     * // Get one PlanFeatureMatrix
     * const planFeatureMatrix = await prisma.planFeatureMatrix.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFeatureMatrixFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFeatureMatrixFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanFeatureMatrixClient<$Result.GetResult<Prisma.$PlanFeatureMatrixPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlanFeatureMatrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureMatrixFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanFeatureMatrices
     * const planFeatureMatrices = await prisma.planFeatureMatrix.findMany()
     * 
     * // Get first 10 PlanFeatureMatrices
     * const planFeatureMatrices = await prisma.planFeatureMatrix.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planFeatureMatrixWithIdOnly = await prisma.planFeatureMatrix.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFeatureMatrixFindManyArgs>(args?: SelectSubset<T, PlanFeatureMatrixFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanFeatureMatrixPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlanFeatureMatrix.
     * @param {PlanFeatureMatrixCreateArgs} args - Arguments to create a PlanFeatureMatrix.
     * @example
     * // Create one PlanFeatureMatrix
     * const PlanFeatureMatrix = await prisma.planFeatureMatrix.create({
     *   data: {
     *     // ... data to create a PlanFeatureMatrix
     *   }
     * })
     * 
     */
    create<T extends PlanFeatureMatrixCreateArgs>(args: SelectSubset<T, PlanFeatureMatrixCreateArgs<ExtArgs>>): Prisma__PlanFeatureMatrixClient<$Result.GetResult<Prisma.$PlanFeatureMatrixPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlanFeatureMatrices.
     * @param {PlanFeatureMatrixCreateManyArgs} args - Arguments to create many PlanFeatureMatrices.
     * @example
     * // Create many PlanFeatureMatrices
     * const planFeatureMatrix = await prisma.planFeatureMatrix.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanFeatureMatrixCreateManyArgs>(args?: SelectSubset<T, PlanFeatureMatrixCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanFeatureMatrices and returns the data saved in the database.
     * @param {PlanFeatureMatrixCreateManyAndReturnArgs} args - Arguments to create many PlanFeatureMatrices.
     * @example
     * // Create many PlanFeatureMatrices
     * const planFeatureMatrix = await prisma.planFeatureMatrix.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanFeatureMatrices and only return the `id`
     * const planFeatureMatrixWithIdOnly = await prisma.planFeatureMatrix.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanFeatureMatrixCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanFeatureMatrixCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanFeatureMatrixPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlanFeatureMatrix.
     * @param {PlanFeatureMatrixDeleteArgs} args - Arguments to delete one PlanFeatureMatrix.
     * @example
     * // Delete one PlanFeatureMatrix
     * const PlanFeatureMatrix = await prisma.planFeatureMatrix.delete({
     *   where: {
     *     // ... filter to delete one PlanFeatureMatrix
     *   }
     * })
     * 
     */
    delete<T extends PlanFeatureMatrixDeleteArgs>(args: SelectSubset<T, PlanFeatureMatrixDeleteArgs<ExtArgs>>): Prisma__PlanFeatureMatrixClient<$Result.GetResult<Prisma.$PlanFeatureMatrixPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlanFeatureMatrix.
     * @param {PlanFeatureMatrixUpdateArgs} args - Arguments to update one PlanFeatureMatrix.
     * @example
     * // Update one PlanFeatureMatrix
     * const planFeatureMatrix = await prisma.planFeatureMatrix.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanFeatureMatrixUpdateArgs>(args: SelectSubset<T, PlanFeatureMatrixUpdateArgs<ExtArgs>>): Prisma__PlanFeatureMatrixClient<$Result.GetResult<Prisma.$PlanFeatureMatrixPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlanFeatureMatrices.
     * @param {PlanFeatureMatrixDeleteManyArgs} args - Arguments to filter PlanFeatureMatrices to delete.
     * @example
     * // Delete a few PlanFeatureMatrices
     * const { count } = await prisma.planFeatureMatrix.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanFeatureMatrixDeleteManyArgs>(args?: SelectSubset<T, PlanFeatureMatrixDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanFeatureMatrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureMatrixUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanFeatureMatrices
     * const planFeatureMatrix = await prisma.planFeatureMatrix.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanFeatureMatrixUpdateManyArgs>(args: SelectSubset<T, PlanFeatureMatrixUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanFeatureMatrix.
     * @param {PlanFeatureMatrixUpsertArgs} args - Arguments to update or create a PlanFeatureMatrix.
     * @example
     * // Update or create a PlanFeatureMatrix
     * const planFeatureMatrix = await prisma.planFeatureMatrix.upsert({
     *   create: {
     *     // ... data to create a PlanFeatureMatrix
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanFeatureMatrix we want to update
     *   }
     * })
     */
    upsert<T extends PlanFeatureMatrixUpsertArgs>(args: SelectSubset<T, PlanFeatureMatrixUpsertArgs<ExtArgs>>): Prisma__PlanFeatureMatrixClient<$Result.GetResult<Prisma.$PlanFeatureMatrixPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlanFeatureMatrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureMatrixCountArgs} args - Arguments to filter PlanFeatureMatrices to count.
     * @example
     * // Count the number of PlanFeatureMatrices
     * const count = await prisma.planFeatureMatrix.count({
     *   where: {
     *     // ... the filter for the PlanFeatureMatrices we want to count
     *   }
     * })
    **/
    count<T extends PlanFeatureMatrixCountArgs>(
      args?: Subset<T, PlanFeatureMatrixCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanFeatureMatrixCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanFeatureMatrix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureMatrixAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanFeatureMatrixAggregateArgs>(args: Subset<T, PlanFeatureMatrixAggregateArgs>): Prisma.PrismaPromise<GetPlanFeatureMatrixAggregateType<T>>

    /**
     * Group by PlanFeatureMatrix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureMatrixGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanFeatureMatrixGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanFeatureMatrixGroupByArgs['orderBy'] }
        : { orderBy?: PlanFeatureMatrixGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanFeatureMatrixGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanFeatureMatrixGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanFeatureMatrix model
   */
  readonly fields: PlanFeatureMatrixFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanFeatureMatrix.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanFeatureMatrixClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    featureFlag<T extends FeatureFlagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureFlagDefaultArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanFeatureMatrix model
   */ 
  interface PlanFeatureMatrixFieldRefs {
    readonly id: FieldRef<"PlanFeatureMatrix", 'String'>
    readonly planId: FieldRef<"PlanFeatureMatrix", 'String'>
    readonly featureFlagId: FieldRef<"PlanFeatureMatrix", 'String'>
    readonly isEnabled: FieldRef<"PlanFeatureMatrix", 'Boolean'>
    readonly usageLimit: FieldRef<"PlanFeatureMatrix", 'Int'>
    readonly includedUsage: FieldRef<"PlanFeatureMatrix", 'Int'>
    readonly overageRate: FieldRef<"PlanFeatureMatrix", 'Decimal'>
    readonly createdAt: FieldRef<"PlanFeatureMatrix", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanFeatureMatrix findUnique
   */
  export type PlanFeatureMatrixFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeatureMatrix to fetch.
     */
    where: PlanFeatureMatrixWhereUniqueInput
  }

  /**
   * PlanFeatureMatrix findUniqueOrThrow
   */
  export type PlanFeatureMatrixFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeatureMatrix to fetch.
     */
    where: PlanFeatureMatrixWhereUniqueInput
  }

  /**
   * PlanFeatureMatrix findFirst
   */
  export type PlanFeatureMatrixFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeatureMatrix to fetch.
     */
    where?: PlanFeatureMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanFeatureMatrices to fetch.
     */
    orderBy?: PlanFeatureMatrixOrderByWithRelationInput | PlanFeatureMatrixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanFeatureMatrices.
     */
    cursor?: PlanFeatureMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanFeatureMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanFeatureMatrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanFeatureMatrices.
     */
    distinct?: PlanFeatureMatrixScalarFieldEnum | PlanFeatureMatrixScalarFieldEnum[]
  }

  /**
   * PlanFeatureMatrix findFirstOrThrow
   */
  export type PlanFeatureMatrixFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeatureMatrix to fetch.
     */
    where?: PlanFeatureMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanFeatureMatrices to fetch.
     */
    orderBy?: PlanFeatureMatrixOrderByWithRelationInput | PlanFeatureMatrixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanFeatureMatrices.
     */
    cursor?: PlanFeatureMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanFeatureMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanFeatureMatrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanFeatureMatrices.
     */
    distinct?: PlanFeatureMatrixScalarFieldEnum | PlanFeatureMatrixScalarFieldEnum[]
  }

  /**
   * PlanFeatureMatrix findMany
   */
  export type PlanFeatureMatrixFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeatureMatrices to fetch.
     */
    where?: PlanFeatureMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanFeatureMatrices to fetch.
     */
    orderBy?: PlanFeatureMatrixOrderByWithRelationInput | PlanFeatureMatrixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanFeatureMatrices.
     */
    cursor?: PlanFeatureMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanFeatureMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanFeatureMatrices.
     */
    skip?: number
    distinct?: PlanFeatureMatrixScalarFieldEnum | PlanFeatureMatrixScalarFieldEnum[]
  }

  /**
   * PlanFeatureMatrix create
   */
  export type PlanFeatureMatrixCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanFeatureMatrix.
     */
    data: XOR<PlanFeatureMatrixCreateInput, PlanFeatureMatrixUncheckedCreateInput>
  }

  /**
   * PlanFeatureMatrix createMany
   */
  export type PlanFeatureMatrixCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanFeatureMatrices.
     */
    data: PlanFeatureMatrixCreateManyInput | PlanFeatureMatrixCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanFeatureMatrix createManyAndReturn
   */
  export type PlanFeatureMatrixCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlanFeatureMatrices.
     */
    data: PlanFeatureMatrixCreateManyInput | PlanFeatureMatrixCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanFeatureMatrix update
   */
  export type PlanFeatureMatrixUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanFeatureMatrix.
     */
    data: XOR<PlanFeatureMatrixUpdateInput, PlanFeatureMatrixUncheckedUpdateInput>
    /**
     * Choose, which PlanFeatureMatrix to update.
     */
    where: PlanFeatureMatrixWhereUniqueInput
  }

  /**
   * PlanFeatureMatrix updateMany
   */
  export type PlanFeatureMatrixUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanFeatureMatrices.
     */
    data: XOR<PlanFeatureMatrixUpdateManyMutationInput, PlanFeatureMatrixUncheckedUpdateManyInput>
    /**
     * Filter which PlanFeatureMatrices to update
     */
    where?: PlanFeatureMatrixWhereInput
  }

  /**
   * PlanFeatureMatrix upsert
   */
  export type PlanFeatureMatrixUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanFeatureMatrix to update in case it exists.
     */
    where: PlanFeatureMatrixWhereUniqueInput
    /**
     * In case the PlanFeatureMatrix found by the `where` argument doesn't exist, create a new PlanFeatureMatrix with this data.
     */
    create: XOR<PlanFeatureMatrixCreateInput, PlanFeatureMatrixUncheckedCreateInput>
    /**
     * In case the PlanFeatureMatrix was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanFeatureMatrixUpdateInput, PlanFeatureMatrixUncheckedUpdateInput>
  }

  /**
   * PlanFeatureMatrix delete
   */
  export type PlanFeatureMatrixDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixInclude<ExtArgs> | null
    /**
     * Filter which PlanFeatureMatrix to delete.
     */
    where: PlanFeatureMatrixWhereUniqueInput
  }

  /**
   * PlanFeatureMatrix deleteMany
   */
  export type PlanFeatureMatrixDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanFeatureMatrices to delete
     */
    where?: PlanFeatureMatrixWhereInput
  }

  /**
   * PlanFeatureMatrix without action
   */
  export type PlanFeatureMatrixDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeatureMatrix
     */
    select?: PlanFeatureMatrixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureMatrixInclude<ExtArgs> | null
  }


  /**
   * Model EwayCustomer
   */

  export type AggregateEwayCustomer = {
    _count: EwayCustomerCountAggregateOutputType | null
    _avg: EwayCustomerAvgAggregateOutputType | null
    _sum: EwayCustomerSumAggregateOutputType | null
    _min: EwayCustomerMinAggregateOutputType | null
    _max: EwayCustomerMaxAggregateOutputType | null
  }

  export type EwayCustomerAvgAggregateOutputType = {
    cardExpiryMonth: number | null
    cardExpiryYear: number | null
  }

  export type EwayCustomerSumAggregateOutputType = {
    cardExpiryMonth: number | null
    cardExpiryYear: number | null
  }

  export type EwayCustomerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    ewayCustomerToken: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    companyName: string | null
    country: string | null
    streetAddress: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    phoneNumber: string | null
    cardLastFour: string | null
    cardType: string | null
    cardExpiryMonth: number | null
    cardExpiryYear: number | null
    ewayReference: string | null
    isActive: boolean | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EwayCustomerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    ewayCustomerToken: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    companyName: string | null
    country: string | null
    streetAddress: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    phoneNumber: string | null
    cardLastFour: string | null
    cardType: string | null
    cardExpiryMonth: number | null
    cardExpiryYear: number | null
    ewayReference: string | null
    isActive: boolean | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EwayCustomerCountAggregateOutputType = {
    id: number
    userId: number
    ewayCustomerToken: number
    firstName: number
    lastName: number
    email: number
    companyName: number
    country: number
    streetAddress: number
    city: number
    state: number
    postalCode: number
    phoneNumber: number
    cardLastFour: number
    cardType: number
    cardExpiryMonth: number
    cardExpiryYear: number
    ewayReference: number
    isActive: number
    lastUsedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EwayCustomerAvgAggregateInputType = {
    cardExpiryMonth?: true
    cardExpiryYear?: true
  }

  export type EwayCustomerSumAggregateInputType = {
    cardExpiryMonth?: true
    cardExpiryYear?: true
  }

  export type EwayCustomerMinAggregateInputType = {
    id?: true
    userId?: true
    ewayCustomerToken?: true
    firstName?: true
    lastName?: true
    email?: true
    companyName?: true
    country?: true
    streetAddress?: true
    city?: true
    state?: true
    postalCode?: true
    phoneNumber?: true
    cardLastFour?: true
    cardType?: true
    cardExpiryMonth?: true
    cardExpiryYear?: true
    ewayReference?: true
    isActive?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EwayCustomerMaxAggregateInputType = {
    id?: true
    userId?: true
    ewayCustomerToken?: true
    firstName?: true
    lastName?: true
    email?: true
    companyName?: true
    country?: true
    streetAddress?: true
    city?: true
    state?: true
    postalCode?: true
    phoneNumber?: true
    cardLastFour?: true
    cardType?: true
    cardExpiryMonth?: true
    cardExpiryYear?: true
    ewayReference?: true
    isActive?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EwayCustomerCountAggregateInputType = {
    id?: true
    userId?: true
    ewayCustomerToken?: true
    firstName?: true
    lastName?: true
    email?: true
    companyName?: true
    country?: true
    streetAddress?: true
    city?: true
    state?: true
    postalCode?: true
    phoneNumber?: true
    cardLastFour?: true
    cardType?: true
    cardExpiryMonth?: true
    cardExpiryYear?: true
    ewayReference?: true
    isActive?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EwayCustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayCustomer to aggregate.
     */
    where?: EwayCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayCustomers to fetch.
     */
    orderBy?: EwayCustomerOrderByWithRelationInput | EwayCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EwayCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EwayCustomers
    **/
    _count?: true | EwayCustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EwayCustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EwayCustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EwayCustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EwayCustomerMaxAggregateInputType
  }

  export type GetEwayCustomerAggregateType<T extends EwayCustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateEwayCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEwayCustomer[P]>
      : GetScalarType<T[P], AggregateEwayCustomer[P]>
  }




  export type EwayCustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayCustomerWhereInput
    orderBy?: EwayCustomerOrderByWithAggregationInput | EwayCustomerOrderByWithAggregationInput[]
    by: EwayCustomerScalarFieldEnum[] | EwayCustomerScalarFieldEnum
    having?: EwayCustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EwayCustomerCountAggregateInputType | true
    _avg?: EwayCustomerAvgAggregateInputType
    _sum?: EwayCustomerSumAggregateInputType
    _min?: EwayCustomerMinAggregateInputType
    _max?: EwayCustomerMaxAggregateInputType
  }

  export type EwayCustomerGroupByOutputType = {
    id: string
    userId: string
    ewayCustomerToken: string
    firstName: string
    lastName: string
    email: string
    companyName: string | null
    country: string
    streetAddress: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    phoneNumber: string | null
    cardLastFour: string | null
    cardType: string | null
    cardExpiryMonth: number | null
    cardExpiryYear: number | null
    ewayReference: string | null
    isActive: boolean
    lastUsedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EwayCustomerCountAggregateOutputType | null
    _avg: EwayCustomerAvgAggregateOutputType | null
    _sum: EwayCustomerSumAggregateOutputType | null
    _min: EwayCustomerMinAggregateOutputType | null
    _max: EwayCustomerMaxAggregateOutputType | null
  }

  type GetEwayCustomerGroupByPayload<T extends EwayCustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EwayCustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EwayCustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EwayCustomerGroupByOutputType[P]>
            : GetScalarType<T[P], EwayCustomerGroupByOutputType[P]>
        }
      >
    >


  export type EwayCustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ewayCustomerToken?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    companyName?: boolean
    country?: boolean
    streetAddress?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    phoneNumber?: boolean
    cardLastFour?: boolean
    cardType?: boolean
    cardExpiryMonth?: boolean
    cardExpiryYear?: boolean
    ewayReference?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | EwayCustomer$transactionsArgs<ExtArgs>
    recurringSchedules?: boolean | EwayCustomer$recurringSchedulesArgs<ExtArgs>
    _count?: boolean | EwayCustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ewayCustomer"]>

  export type EwayCustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ewayCustomerToken?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    companyName?: boolean
    country?: boolean
    streetAddress?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    phoneNumber?: boolean
    cardLastFour?: boolean
    cardType?: boolean
    cardExpiryMonth?: boolean
    cardExpiryYear?: boolean
    ewayReference?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ewayCustomer"]>

  export type EwayCustomerSelectScalar = {
    id?: boolean
    userId?: boolean
    ewayCustomerToken?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    companyName?: boolean
    country?: boolean
    streetAddress?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    phoneNumber?: boolean
    cardLastFour?: boolean
    cardType?: boolean
    cardExpiryMonth?: boolean
    cardExpiryYear?: boolean
    ewayReference?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EwayCustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | EwayCustomer$transactionsArgs<ExtArgs>
    recurringSchedules?: boolean | EwayCustomer$recurringSchedulesArgs<ExtArgs>
    _count?: boolean | EwayCustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EwayCustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EwayCustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EwayCustomer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      transactions: Prisma.$EwayTransactionPayload<ExtArgs>[]
      recurringSchedules: Prisma.$EwayRecurringSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      ewayCustomerToken: string
      firstName: string
      lastName: string
      email: string
      companyName: string | null
      country: string
      streetAddress: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      phoneNumber: string | null
      cardLastFour: string | null
      cardType: string | null
      cardExpiryMonth: number | null
      cardExpiryYear: number | null
      ewayReference: string | null
      isActive: boolean
      lastUsedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ewayCustomer"]>
    composites: {}
  }

  type EwayCustomerGetPayload<S extends boolean | null | undefined | EwayCustomerDefaultArgs> = $Result.GetResult<Prisma.$EwayCustomerPayload, S>

  type EwayCustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EwayCustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EwayCustomerCountAggregateInputType | true
    }

  export interface EwayCustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EwayCustomer'], meta: { name: 'EwayCustomer' } }
    /**
     * Find zero or one EwayCustomer that matches the filter.
     * @param {EwayCustomerFindUniqueArgs} args - Arguments to find a EwayCustomer
     * @example
     * // Get one EwayCustomer
     * const ewayCustomer = await prisma.ewayCustomer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EwayCustomerFindUniqueArgs>(args: SelectSubset<T, EwayCustomerFindUniqueArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EwayCustomer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EwayCustomerFindUniqueOrThrowArgs} args - Arguments to find a EwayCustomer
     * @example
     * // Get one EwayCustomer
     * const ewayCustomer = await prisma.ewayCustomer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EwayCustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, EwayCustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EwayCustomer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerFindFirstArgs} args - Arguments to find a EwayCustomer
     * @example
     * // Get one EwayCustomer
     * const ewayCustomer = await prisma.ewayCustomer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EwayCustomerFindFirstArgs>(args?: SelectSubset<T, EwayCustomerFindFirstArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EwayCustomer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerFindFirstOrThrowArgs} args - Arguments to find a EwayCustomer
     * @example
     * // Get one EwayCustomer
     * const ewayCustomer = await prisma.ewayCustomer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EwayCustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, EwayCustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EwayCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EwayCustomers
     * const ewayCustomers = await prisma.ewayCustomer.findMany()
     * 
     * // Get first 10 EwayCustomers
     * const ewayCustomers = await prisma.ewayCustomer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ewayCustomerWithIdOnly = await prisma.ewayCustomer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EwayCustomerFindManyArgs>(args?: SelectSubset<T, EwayCustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EwayCustomer.
     * @param {EwayCustomerCreateArgs} args - Arguments to create a EwayCustomer.
     * @example
     * // Create one EwayCustomer
     * const EwayCustomer = await prisma.ewayCustomer.create({
     *   data: {
     *     // ... data to create a EwayCustomer
     *   }
     * })
     * 
     */
    create<T extends EwayCustomerCreateArgs>(args: SelectSubset<T, EwayCustomerCreateArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EwayCustomers.
     * @param {EwayCustomerCreateManyArgs} args - Arguments to create many EwayCustomers.
     * @example
     * // Create many EwayCustomers
     * const ewayCustomer = await prisma.ewayCustomer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EwayCustomerCreateManyArgs>(args?: SelectSubset<T, EwayCustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EwayCustomers and returns the data saved in the database.
     * @param {EwayCustomerCreateManyAndReturnArgs} args - Arguments to create many EwayCustomers.
     * @example
     * // Create many EwayCustomers
     * const ewayCustomer = await prisma.ewayCustomer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EwayCustomers and only return the `id`
     * const ewayCustomerWithIdOnly = await prisma.ewayCustomer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EwayCustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, EwayCustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EwayCustomer.
     * @param {EwayCustomerDeleteArgs} args - Arguments to delete one EwayCustomer.
     * @example
     * // Delete one EwayCustomer
     * const EwayCustomer = await prisma.ewayCustomer.delete({
     *   where: {
     *     // ... filter to delete one EwayCustomer
     *   }
     * })
     * 
     */
    delete<T extends EwayCustomerDeleteArgs>(args: SelectSubset<T, EwayCustomerDeleteArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EwayCustomer.
     * @param {EwayCustomerUpdateArgs} args - Arguments to update one EwayCustomer.
     * @example
     * // Update one EwayCustomer
     * const ewayCustomer = await prisma.ewayCustomer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EwayCustomerUpdateArgs>(args: SelectSubset<T, EwayCustomerUpdateArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EwayCustomers.
     * @param {EwayCustomerDeleteManyArgs} args - Arguments to filter EwayCustomers to delete.
     * @example
     * // Delete a few EwayCustomers
     * const { count } = await prisma.ewayCustomer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EwayCustomerDeleteManyArgs>(args?: SelectSubset<T, EwayCustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EwayCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EwayCustomers
     * const ewayCustomer = await prisma.ewayCustomer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EwayCustomerUpdateManyArgs>(args: SelectSubset<T, EwayCustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EwayCustomer.
     * @param {EwayCustomerUpsertArgs} args - Arguments to update or create a EwayCustomer.
     * @example
     * // Update or create a EwayCustomer
     * const ewayCustomer = await prisma.ewayCustomer.upsert({
     *   create: {
     *     // ... data to create a EwayCustomer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EwayCustomer we want to update
     *   }
     * })
     */
    upsert<T extends EwayCustomerUpsertArgs>(args: SelectSubset<T, EwayCustomerUpsertArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EwayCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerCountArgs} args - Arguments to filter EwayCustomers to count.
     * @example
     * // Count the number of EwayCustomers
     * const count = await prisma.ewayCustomer.count({
     *   where: {
     *     // ... the filter for the EwayCustomers we want to count
     *   }
     * })
    **/
    count<T extends EwayCustomerCountArgs>(
      args?: Subset<T, EwayCustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EwayCustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EwayCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EwayCustomerAggregateArgs>(args: Subset<T, EwayCustomerAggregateArgs>): Prisma.PrismaPromise<GetEwayCustomerAggregateType<T>>

    /**
     * Group by EwayCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EwayCustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EwayCustomerGroupByArgs['orderBy'] }
        : { orderBy?: EwayCustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EwayCustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEwayCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EwayCustomer model
   */
  readonly fields: EwayCustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EwayCustomer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EwayCustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends EwayCustomer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, EwayCustomer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    recurringSchedules<T extends EwayCustomer$recurringSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, EwayCustomer$recurringSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EwayCustomer model
   */ 
  interface EwayCustomerFieldRefs {
    readonly id: FieldRef<"EwayCustomer", 'String'>
    readonly userId: FieldRef<"EwayCustomer", 'String'>
    readonly ewayCustomerToken: FieldRef<"EwayCustomer", 'String'>
    readonly firstName: FieldRef<"EwayCustomer", 'String'>
    readonly lastName: FieldRef<"EwayCustomer", 'String'>
    readonly email: FieldRef<"EwayCustomer", 'String'>
    readonly companyName: FieldRef<"EwayCustomer", 'String'>
    readonly country: FieldRef<"EwayCustomer", 'String'>
    readonly streetAddress: FieldRef<"EwayCustomer", 'String'>
    readonly city: FieldRef<"EwayCustomer", 'String'>
    readonly state: FieldRef<"EwayCustomer", 'String'>
    readonly postalCode: FieldRef<"EwayCustomer", 'String'>
    readonly phoneNumber: FieldRef<"EwayCustomer", 'String'>
    readonly cardLastFour: FieldRef<"EwayCustomer", 'String'>
    readonly cardType: FieldRef<"EwayCustomer", 'String'>
    readonly cardExpiryMonth: FieldRef<"EwayCustomer", 'Int'>
    readonly cardExpiryYear: FieldRef<"EwayCustomer", 'Int'>
    readonly ewayReference: FieldRef<"EwayCustomer", 'String'>
    readonly isActive: FieldRef<"EwayCustomer", 'Boolean'>
    readonly lastUsedAt: FieldRef<"EwayCustomer", 'DateTime'>
    readonly createdAt: FieldRef<"EwayCustomer", 'DateTime'>
    readonly updatedAt: FieldRef<"EwayCustomer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EwayCustomer findUnique
   */
  export type EwayCustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * Filter, which EwayCustomer to fetch.
     */
    where: EwayCustomerWhereUniqueInput
  }

  /**
   * EwayCustomer findUniqueOrThrow
   */
  export type EwayCustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * Filter, which EwayCustomer to fetch.
     */
    where: EwayCustomerWhereUniqueInput
  }

  /**
   * EwayCustomer findFirst
   */
  export type EwayCustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * Filter, which EwayCustomer to fetch.
     */
    where?: EwayCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayCustomers to fetch.
     */
    orderBy?: EwayCustomerOrderByWithRelationInput | EwayCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayCustomers.
     */
    cursor?: EwayCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayCustomers.
     */
    distinct?: EwayCustomerScalarFieldEnum | EwayCustomerScalarFieldEnum[]
  }

  /**
   * EwayCustomer findFirstOrThrow
   */
  export type EwayCustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * Filter, which EwayCustomer to fetch.
     */
    where?: EwayCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayCustomers to fetch.
     */
    orderBy?: EwayCustomerOrderByWithRelationInput | EwayCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayCustomers.
     */
    cursor?: EwayCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayCustomers.
     */
    distinct?: EwayCustomerScalarFieldEnum | EwayCustomerScalarFieldEnum[]
  }

  /**
   * EwayCustomer findMany
   */
  export type EwayCustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * Filter, which EwayCustomers to fetch.
     */
    where?: EwayCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayCustomers to fetch.
     */
    orderBy?: EwayCustomerOrderByWithRelationInput | EwayCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EwayCustomers.
     */
    cursor?: EwayCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayCustomers.
     */
    skip?: number
    distinct?: EwayCustomerScalarFieldEnum | EwayCustomerScalarFieldEnum[]
  }

  /**
   * EwayCustomer create
   */
  export type EwayCustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a EwayCustomer.
     */
    data: XOR<EwayCustomerCreateInput, EwayCustomerUncheckedCreateInput>
  }

  /**
   * EwayCustomer createMany
   */
  export type EwayCustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EwayCustomers.
     */
    data: EwayCustomerCreateManyInput | EwayCustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EwayCustomer createManyAndReturn
   */
  export type EwayCustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EwayCustomers.
     */
    data: EwayCustomerCreateManyInput | EwayCustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EwayCustomer update
   */
  export type EwayCustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a EwayCustomer.
     */
    data: XOR<EwayCustomerUpdateInput, EwayCustomerUncheckedUpdateInput>
    /**
     * Choose, which EwayCustomer to update.
     */
    where: EwayCustomerWhereUniqueInput
  }

  /**
   * EwayCustomer updateMany
   */
  export type EwayCustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EwayCustomers.
     */
    data: XOR<EwayCustomerUpdateManyMutationInput, EwayCustomerUncheckedUpdateManyInput>
    /**
     * Filter which EwayCustomers to update
     */
    where?: EwayCustomerWhereInput
  }

  /**
   * EwayCustomer upsert
   */
  export type EwayCustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the EwayCustomer to update in case it exists.
     */
    where: EwayCustomerWhereUniqueInput
    /**
     * In case the EwayCustomer found by the `where` argument doesn't exist, create a new EwayCustomer with this data.
     */
    create: XOR<EwayCustomerCreateInput, EwayCustomerUncheckedCreateInput>
    /**
     * In case the EwayCustomer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EwayCustomerUpdateInput, EwayCustomerUncheckedUpdateInput>
  }

  /**
   * EwayCustomer delete
   */
  export type EwayCustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * Filter which EwayCustomer to delete.
     */
    where: EwayCustomerWhereUniqueInput
  }

  /**
   * EwayCustomer deleteMany
   */
  export type EwayCustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayCustomers to delete
     */
    where?: EwayCustomerWhereInput
  }

  /**
   * EwayCustomer.transactions
   */
  export type EwayCustomer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    where?: EwayTransactionWhereInput
    orderBy?: EwayTransactionOrderByWithRelationInput | EwayTransactionOrderByWithRelationInput[]
    cursor?: EwayTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EwayTransactionScalarFieldEnum | EwayTransactionScalarFieldEnum[]
  }

  /**
   * EwayCustomer.recurringSchedules
   */
  export type EwayCustomer$recurringSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    where?: EwayRecurringScheduleWhereInput
    orderBy?: EwayRecurringScheduleOrderByWithRelationInput | EwayRecurringScheduleOrderByWithRelationInput[]
    cursor?: EwayRecurringScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EwayRecurringScheduleScalarFieldEnum | EwayRecurringScheduleScalarFieldEnum[]
  }

  /**
   * EwayCustomer without action
   */
  export type EwayCustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
  }


  /**
   * Model EwayTransaction
   */

  export type AggregateEwayTransaction = {
    _count: EwayTransactionCountAggregateOutputType | null
    _avg: EwayTransactionAvgAggregateOutputType | null
    _sum: EwayTransactionSumAggregateOutputType | null
    _min: EwayTransactionMinAggregateOutputType | null
    _max: EwayTransactionMaxAggregateOutputType | null
  }

  export type EwayTransactionAvgAggregateOutputType = {
    amount: Decimal | null
    ewayTransactionId: number | null
    beagleScore: number | null
  }

  export type EwayTransactionSumAggregateOutputType = {
    amount: Decimal | null
    ewayTransactionId: bigint | null
    beagleScore: number | null
  }

  export type EwayTransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    ewayCustomerId: string | null
    subscriptionId: string | null
    transactionType: string | null
    amount: Decimal | null
    currency: string | null
    ewayTransactionId: bigint | null
    ewayAccessCode: string | null
    ewayAuthCode: string | null
    responseCode: string | null
    responseMessage: string | null
    transactionStatus: string | null
    isRecurring: boolean | null
    ewayInvoiceNumber: string | null
    ewayInvoiceReference: string | null
    fraudAction: string | null
    verificationStatus: string | null
    beagleScore: number | null
    errorCode: string | null
    errorMessage: string | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type EwayTransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    ewayCustomerId: string | null
    subscriptionId: string | null
    transactionType: string | null
    amount: Decimal | null
    currency: string | null
    ewayTransactionId: bigint | null
    ewayAccessCode: string | null
    ewayAuthCode: string | null
    responseCode: string | null
    responseMessage: string | null
    transactionStatus: string | null
    isRecurring: boolean | null
    ewayInvoiceNumber: string | null
    ewayInvoiceReference: string | null
    fraudAction: string | null
    verificationStatus: string | null
    beagleScore: number | null
    errorCode: string | null
    errorMessage: string | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type EwayTransactionCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    ewayCustomerId: number
    subscriptionId: number
    transactionType: number
    amount: number
    currency: number
    ewayTransactionId: number
    ewayAccessCode: number
    ewayAuthCode: number
    responseCode: number
    responseMessage: number
    transactionStatus: number
    isRecurring: number
    ewayInvoiceNumber: number
    ewayInvoiceReference: number
    fraudAction: number
    verificationStatus: number
    beagleScore: number
    errorCode: number
    errorMessage: number
    processedAt: number
    createdAt: number
    ewayRawResponse: number
    _all: number
  }


  export type EwayTransactionAvgAggregateInputType = {
    amount?: true
    ewayTransactionId?: true
    beagleScore?: true
  }

  export type EwayTransactionSumAggregateInputType = {
    amount?: true
    ewayTransactionId?: true
    beagleScore?: true
  }

  export type EwayTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    ewayCustomerId?: true
    subscriptionId?: true
    transactionType?: true
    amount?: true
    currency?: true
    ewayTransactionId?: true
    ewayAccessCode?: true
    ewayAuthCode?: true
    responseCode?: true
    responseMessage?: true
    transactionStatus?: true
    isRecurring?: true
    ewayInvoiceNumber?: true
    ewayInvoiceReference?: true
    fraudAction?: true
    verificationStatus?: true
    beagleScore?: true
    errorCode?: true
    errorMessage?: true
    processedAt?: true
    createdAt?: true
  }

  export type EwayTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    ewayCustomerId?: true
    subscriptionId?: true
    transactionType?: true
    amount?: true
    currency?: true
    ewayTransactionId?: true
    ewayAccessCode?: true
    ewayAuthCode?: true
    responseCode?: true
    responseMessage?: true
    transactionStatus?: true
    isRecurring?: true
    ewayInvoiceNumber?: true
    ewayInvoiceReference?: true
    fraudAction?: true
    verificationStatus?: true
    beagleScore?: true
    errorCode?: true
    errorMessage?: true
    processedAt?: true
    createdAt?: true
  }

  export type EwayTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    ewayCustomerId?: true
    subscriptionId?: true
    transactionType?: true
    amount?: true
    currency?: true
    ewayTransactionId?: true
    ewayAccessCode?: true
    ewayAuthCode?: true
    responseCode?: true
    responseMessage?: true
    transactionStatus?: true
    isRecurring?: true
    ewayInvoiceNumber?: true
    ewayInvoiceReference?: true
    fraudAction?: true
    verificationStatus?: true
    beagleScore?: true
    errorCode?: true
    errorMessage?: true
    processedAt?: true
    createdAt?: true
    ewayRawResponse?: true
    _all?: true
  }

  export type EwayTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayTransaction to aggregate.
     */
    where?: EwayTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayTransactions to fetch.
     */
    orderBy?: EwayTransactionOrderByWithRelationInput | EwayTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EwayTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EwayTransactions
    **/
    _count?: true | EwayTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EwayTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EwayTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EwayTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EwayTransactionMaxAggregateInputType
  }

  export type GetEwayTransactionAggregateType<T extends EwayTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateEwayTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEwayTransaction[P]>
      : GetScalarType<T[P], AggregateEwayTransaction[P]>
  }




  export type EwayTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayTransactionWhereInput
    orderBy?: EwayTransactionOrderByWithAggregationInput | EwayTransactionOrderByWithAggregationInput[]
    by: EwayTransactionScalarFieldEnum[] | EwayTransactionScalarFieldEnum
    having?: EwayTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EwayTransactionCountAggregateInputType | true
    _avg?: EwayTransactionAvgAggregateInputType
    _sum?: EwayTransactionSumAggregateInputType
    _min?: EwayTransactionMinAggregateInputType
    _max?: EwayTransactionMaxAggregateInputType
  }

  export type EwayTransactionGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    ewayCustomerId: string
    subscriptionId: string | null
    transactionType: string
    amount: Decimal
    currency: string
    ewayTransactionId: bigint | null
    ewayAccessCode: string | null
    ewayAuthCode: string | null
    responseCode: string | null
    responseMessage: string | null
    transactionStatus: string
    isRecurring: boolean
    ewayInvoiceNumber: string | null
    ewayInvoiceReference: string | null
    fraudAction: string | null
    verificationStatus: string | null
    beagleScore: number | null
    errorCode: string | null
    errorMessage: string | null
    processedAt: Date | null
    createdAt: Date
    ewayRawResponse: JsonValue | null
    _count: EwayTransactionCountAggregateOutputType | null
    _avg: EwayTransactionAvgAggregateOutputType | null
    _sum: EwayTransactionSumAggregateOutputType | null
    _min: EwayTransactionMinAggregateOutputType | null
    _max: EwayTransactionMaxAggregateOutputType | null
  }

  type GetEwayTransactionGroupByPayload<T extends EwayTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EwayTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EwayTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EwayTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], EwayTransactionGroupByOutputType[P]>
        }
      >
    >


  export type EwayTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    ewayCustomerId?: boolean
    subscriptionId?: boolean
    transactionType?: boolean
    amount?: boolean
    currency?: boolean
    ewayTransactionId?: boolean
    ewayAccessCode?: boolean
    ewayAuthCode?: boolean
    responseCode?: boolean
    responseMessage?: boolean
    transactionStatus?: boolean
    isRecurring?: boolean
    ewayInvoiceNumber?: boolean
    ewayInvoiceReference?: boolean
    fraudAction?: boolean
    verificationStatus?: boolean
    beagleScore?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    processedAt?: boolean
    createdAt?: boolean
    ewayRawResponse?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ewayCustomer?: boolean | EwayCustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ewayTransaction"]>

  export type EwayTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    ewayCustomerId?: boolean
    subscriptionId?: boolean
    transactionType?: boolean
    amount?: boolean
    currency?: boolean
    ewayTransactionId?: boolean
    ewayAccessCode?: boolean
    ewayAuthCode?: boolean
    responseCode?: boolean
    responseMessage?: boolean
    transactionStatus?: boolean
    isRecurring?: boolean
    ewayInvoiceNumber?: boolean
    ewayInvoiceReference?: boolean
    fraudAction?: boolean
    verificationStatus?: boolean
    beagleScore?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    processedAt?: boolean
    createdAt?: boolean
    ewayRawResponse?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ewayCustomer?: boolean | EwayCustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ewayTransaction"]>

  export type EwayTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    ewayCustomerId?: boolean
    subscriptionId?: boolean
    transactionType?: boolean
    amount?: boolean
    currency?: boolean
    ewayTransactionId?: boolean
    ewayAccessCode?: boolean
    ewayAuthCode?: boolean
    responseCode?: boolean
    responseMessage?: boolean
    transactionStatus?: boolean
    isRecurring?: boolean
    ewayInvoiceNumber?: boolean
    ewayInvoiceReference?: boolean
    fraudAction?: boolean
    verificationStatus?: boolean
    beagleScore?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    processedAt?: boolean
    createdAt?: boolean
    ewayRawResponse?: boolean
  }

  export type EwayTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ewayCustomer?: boolean | EwayCustomerDefaultArgs<ExtArgs>
  }
  export type EwayTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ewayCustomer?: boolean | EwayCustomerDefaultArgs<ExtArgs>
  }

  export type $EwayTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EwayTransaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ewayCustomer: Prisma.$EwayCustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      ewayCustomerId: string
      subscriptionId: string | null
      transactionType: string
      amount: Prisma.Decimal
      currency: string
      ewayTransactionId: bigint | null
      ewayAccessCode: string | null
      ewayAuthCode: string | null
      responseCode: string | null
      responseMessage: string | null
      transactionStatus: string
      isRecurring: boolean
      ewayInvoiceNumber: string | null
      ewayInvoiceReference: string | null
      fraudAction: string | null
      verificationStatus: string | null
      beagleScore: number | null
      errorCode: string | null
      errorMessage: string | null
      processedAt: Date | null
      createdAt: Date
      ewayRawResponse: Prisma.JsonValue | null
    }, ExtArgs["result"]["ewayTransaction"]>
    composites: {}
  }

  type EwayTransactionGetPayload<S extends boolean | null | undefined | EwayTransactionDefaultArgs> = $Result.GetResult<Prisma.$EwayTransactionPayload, S>

  type EwayTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EwayTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EwayTransactionCountAggregateInputType | true
    }

  export interface EwayTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EwayTransaction'], meta: { name: 'EwayTransaction' } }
    /**
     * Find zero or one EwayTransaction that matches the filter.
     * @param {EwayTransactionFindUniqueArgs} args - Arguments to find a EwayTransaction
     * @example
     * // Get one EwayTransaction
     * const ewayTransaction = await prisma.ewayTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EwayTransactionFindUniqueArgs>(args: SelectSubset<T, EwayTransactionFindUniqueArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EwayTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EwayTransactionFindUniqueOrThrowArgs} args - Arguments to find a EwayTransaction
     * @example
     * // Get one EwayTransaction
     * const ewayTransaction = await prisma.ewayTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EwayTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, EwayTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EwayTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionFindFirstArgs} args - Arguments to find a EwayTransaction
     * @example
     * // Get one EwayTransaction
     * const ewayTransaction = await prisma.ewayTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EwayTransactionFindFirstArgs>(args?: SelectSubset<T, EwayTransactionFindFirstArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EwayTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionFindFirstOrThrowArgs} args - Arguments to find a EwayTransaction
     * @example
     * // Get one EwayTransaction
     * const ewayTransaction = await prisma.ewayTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EwayTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, EwayTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EwayTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EwayTransactions
     * const ewayTransactions = await prisma.ewayTransaction.findMany()
     * 
     * // Get first 10 EwayTransactions
     * const ewayTransactions = await prisma.ewayTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ewayTransactionWithIdOnly = await prisma.ewayTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EwayTransactionFindManyArgs>(args?: SelectSubset<T, EwayTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EwayTransaction.
     * @param {EwayTransactionCreateArgs} args - Arguments to create a EwayTransaction.
     * @example
     * // Create one EwayTransaction
     * const EwayTransaction = await prisma.ewayTransaction.create({
     *   data: {
     *     // ... data to create a EwayTransaction
     *   }
     * })
     * 
     */
    create<T extends EwayTransactionCreateArgs>(args: SelectSubset<T, EwayTransactionCreateArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EwayTransactions.
     * @param {EwayTransactionCreateManyArgs} args - Arguments to create many EwayTransactions.
     * @example
     * // Create many EwayTransactions
     * const ewayTransaction = await prisma.ewayTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EwayTransactionCreateManyArgs>(args?: SelectSubset<T, EwayTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EwayTransactions and returns the data saved in the database.
     * @param {EwayTransactionCreateManyAndReturnArgs} args - Arguments to create many EwayTransactions.
     * @example
     * // Create many EwayTransactions
     * const ewayTransaction = await prisma.ewayTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EwayTransactions and only return the `id`
     * const ewayTransactionWithIdOnly = await prisma.ewayTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EwayTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, EwayTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EwayTransaction.
     * @param {EwayTransactionDeleteArgs} args - Arguments to delete one EwayTransaction.
     * @example
     * // Delete one EwayTransaction
     * const EwayTransaction = await prisma.ewayTransaction.delete({
     *   where: {
     *     // ... filter to delete one EwayTransaction
     *   }
     * })
     * 
     */
    delete<T extends EwayTransactionDeleteArgs>(args: SelectSubset<T, EwayTransactionDeleteArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EwayTransaction.
     * @param {EwayTransactionUpdateArgs} args - Arguments to update one EwayTransaction.
     * @example
     * // Update one EwayTransaction
     * const ewayTransaction = await prisma.ewayTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EwayTransactionUpdateArgs>(args: SelectSubset<T, EwayTransactionUpdateArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EwayTransactions.
     * @param {EwayTransactionDeleteManyArgs} args - Arguments to filter EwayTransactions to delete.
     * @example
     * // Delete a few EwayTransactions
     * const { count } = await prisma.ewayTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EwayTransactionDeleteManyArgs>(args?: SelectSubset<T, EwayTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EwayTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EwayTransactions
     * const ewayTransaction = await prisma.ewayTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EwayTransactionUpdateManyArgs>(args: SelectSubset<T, EwayTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EwayTransaction.
     * @param {EwayTransactionUpsertArgs} args - Arguments to update or create a EwayTransaction.
     * @example
     * // Update or create a EwayTransaction
     * const ewayTransaction = await prisma.ewayTransaction.upsert({
     *   create: {
     *     // ... data to create a EwayTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EwayTransaction we want to update
     *   }
     * })
     */
    upsert<T extends EwayTransactionUpsertArgs>(args: SelectSubset<T, EwayTransactionUpsertArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EwayTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionCountArgs} args - Arguments to filter EwayTransactions to count.
     * @example
     * // Count the number of EwayTransactions
     * const count = await prisma.ewayTransaction.count({
     *   where: {
     *     // ... the filter for the EwayTransactions we want to count
     *   }
     * })
    **/
    count<T extends EwayTransactionCountArgs>(
      args?: Subset<T, EwayTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EwayTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EwayTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EwayTransactionAggregateArgs>(args: Subset<T, EwayTransactionAggregateArgs>): Prisma.PrismaPromise<GetEwayTransactionAggregateType<T>>

    /**
     * Group by EwayTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EwayTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EwayTransactionGroupByArgs['orderBy'] }
        : { orderBy?: EwayTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EwayTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEwayTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EwayTransaction model
   */
  readonly fields: EwayTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EwayTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EwayTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ewayCustomer<T extends EwayCustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EwayCustomerDefaultArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EwayTransaction model
   */ 
  interface EwayTransactionFieldRefs {
    readonly id: FieldRef<"EwayTransaction", 'String'>
    readonly userId: FieldRef<"EwayTransaction", 'String'>
    readonly workspaceId: FieldRef<"EwayTransaction", 'String'>
    readonly ewayCustomerId: FieldRef<"EwayTransaction", 'String'>
    readonly subscriptionId: FieldRef<"EwayTransaction", 'String'>
    readonly transactionType: FieldRef<"EwayTransaction", 'String'>
    readonly amount: FieldRef<"EwayTransaction", 'Decimal'>
    readonly currency: FieldRef<"EwayTransaction", 'String'>
    readonly ewayTransactionId: FieldRef<"EwayTransaction", 'BigInt'>
    readonly ewayAccessCode: FieldRef<"EwayTransaction", 'String'>
    readonly ewayAuthCode: FieldRef<"EwayTransaction", 'String'>
    readonly responseCode: FieldRef<"EwayTransaction", 'String'>
    readonly responseMessage: FieldRef<"EwayTransaction", 'String'>
    readonly transactionStatus: FieldRef<"EwayTransaction", 'String'>
    readonly isRecurring: FieldRef<"EwayTransaction", 'Boolean'>
    readonly ewayInvoiceNumber: FieldRef<"EwayTransaction", 'String'>
    readonly ewayInvoiceReference: FieldRef<"EwayTransaction", 'String'>
    readonly fraudAction: FieldRef<"EwayTransaction", 'String'>
    readonly verificationStatus: FieldRef<"EwayTransaction", 'String'>
    readonly beagleScore: FieldRef<"EwayTransaction", 'Float'>
    readonly errorCode: FieldRef<"EwayTransaction", 'String'>
    readonly errorMessage: FieldRef<"EwayTransaction", 'String'>
    readonly processedAt: FieldRef<"EwayTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"EwayTransaction", 'DateTime'>
    readonly ewayRawResponse: FieldRef<"EwayTransaction", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * EwayTransaction findUnique
   */
  export type EwayTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * Filter, which EwayTransaction to fetch.
     */
    where: EwayTransactionWhereUniqueInput
  }

  /**
   * EwayTransaction findUniqueOrThrow
   */
  export type EwayTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * Filter, which EwayTransaction to fetch.
     */
    where: EwayTransactionWhereUniqueInput
  }

  /**
   * EwayTransaction findFirst
   */
  export type EwayTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * Filter, which EwayTransaction to fetch.
     */
    where?: EwayTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayTransactions to fetch.
     */
    orderBy?: EwayTransactionOrderByWithRelationInput | EwayTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayTransactions.
     */
    cursor?: EwayTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayTransactions.
     */
    distinct?: EwayTransactionScalarFieldEnum | EwayTransactionScalarFieldEnum[]
  }

  /**
   * EwayTransaction findFirstOrThrow
   */
  export type EwayTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * Filter, which EwayTransaction to fetch.
     */
    where?: EwayTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayTransactions to fetch.
     */
    orderBy?: EwayTransactionOrderByWithRelationInput | EwayTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayTransactions.
     */
    cursor?: EwayTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayTransactions.
     */
    distinct?: EwayTransactionScalarFieldEnum | EwayTransactionScalarFieldEnum[]
  }

  /**
   * EwayTransaction findMany
   */
  export type EwayTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * Filter, which EwayTransactions to fetch.
     */
    where?: EwayTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayTransactions to fetch.
     */
    orderBy?: EwayTransactionOrderByWithRelationInput | EwayTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EwayTransactions.
     */
    cursor?: EwayTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayTransactions.
     */
    skip?: number
    distinct?: EwayTransactionScalarFieldEnum | EwayTransactionScalarFieldEnum[]
  }

  /**
   * EwayTransaction create
   */
  export type EwayTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a EwayTransaction.
     */
    data: XOR<EwayTransactionCreateInput, EwayTransactionUncheckedCreateInput>
  }

  /**
   * EwayTransaction createMany
   */
  export type EwayTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EwayTransactions.
     */
    data: EwayTransactionCreateManyInput | EwayTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EwayTransaction createManyAndReturn
   */
  export type EwayTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EwayTransactions.
     */
    data: EwayTransactionCreateManyInput | EwayTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EwayTransaction update
   */
  export type EwayTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a EwayTransaction.
     */
    data: XOR<EwayTransactionUpdateInput, EwayTransactionUncheckedUpdateInput>
    /**
     * Choose, which EwayTransaction to update.
     */
    where: EwayTransactionWhereUniqueInput
  }

  /**
   * EwayTransaction updateMany
   */
  export type EwayTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EwayTransactions.
     */
    data: XOR<EwayTransactionUpdateManyMutationInput, EwayTransactionUncheckedUpdateManyInput>
    /**
     * Filter which EwayTransactions to update
     */
    where?: EwayTransactionWhereInput
  }

  /**
   * EwayTransaction upsert
   */
  export type EwayTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the EwayTransaction to update in case it exists.
     */
    where: EwayTransactionWhereUniqueInput
    /**
     * In case the EwayTransaction found by the `where` argument doesn't exist, create a new EwayTransaction with this data.
     */
    create: XOR<EwayTransactionCreateInput, EwayTransactionUncheckedCreateInput>
    /**
     * In case the EwayTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EwayTransactionUpdateInput, EwayTransactionUncheckedUpdateInput>
  }

  /**
   * EwayTransaction delete
   */
  export type EwayTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * Filter which EwayTransaction to delete.
     */
    where: EwayTransactionWhereUniqueInput
  }

  /**
   * EwayTransaction deleteMany
   */
  export type EwayTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayTransactions to delete
     */
    where?: EwayTransactionWhereInput
  }

  /**
   * EwayTransaction without action
   */
  export type EwayTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
  }


  /**
   * Model EwayRecurringSchedule
   */

  export type AggregateEwayRecurringSchedule = {
    _count: EwayRecurringScheduleCountAggregateOutputType | null
    _avg: EwayRecurringScheduleAvgAggregateOutputType | null
    _sum: EwayRecurringScheduleSumAggregateOutputType | null
    _min: EwayRecurringScheduleMinAggregateOutputType | null
    _max: EwayRecurringScheduleMaxAggregateOutputType | null
  }

  export type EwayRecurringScheduleAvgAggregateOutputType = {
    billingAmount: Decimal | null
    failedAttempts: number | null
  }

  export type EwayRecurringScheduleSumAggregateOutputType = {
    billingAmount: Decimal | null
    failedAttempts: number | null
  }

  export type EwayRecurringScheduleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    ewayCustomerId: string | null
    subscriptionId: string | null
    scheduleType: string | null
    billingAmount: Decimal | null
    currency: string | null
    startDate: Date | null
    nextBillingDate: Date | null
    lastProcessedAt: Date | null
    status: string | null
    failedAttempts: number | null
    lastTransactionId: string | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EwayRecurringScheduleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    ewayCustomerId: string | null
    subscriptionId: string | null
    scheduleType: string | null
    billingAmount: Decimal | null
    currency: string | null
    startDate: Date | null
    nextBillingDate: Date | null
    lastProcessedAt: Date | null
    status: string | null
    failedAttempts: number | null
    lastTransactionId: string | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EwayRecurringScheduleCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    ewayCustomerId: number
    subscriptionId: number
    scheduleType: number
    billingAmount: number
    currency: number
    startDate: number
    nextBillingDate: number
    lastProcessedAt: number
    status: number
    failedAttempts: number
    lastTransactionId: number
    cancelledAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EwayRecurringScheduleAvgAggregateInputType = {
    billingAmount?: true
    failedAttempts?: true
  }

  export type EwayRecurringScheduleSumAggregateInputType = {
    billingAmount?: true
    failedAttempts?: true
  }

  export type EwayRecurringScheduleMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    ewayCustomerId?: true
    subscriptionId?: true
    scheduleType?: true
    billingAmount?: true
    currency?: true
    startDate?: true
    nextBillingDate?: true
    lastProcessedAt?: true
    status?: true
    failedAttempts?: true
    lastTransactionId?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EwayRecurringScheduleMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    ewayCustomerId?: true
    subscriptionId?: true
    scheduleType?: true
    billingAmount?: true
    currency?: true
    startDate?: true
    nextBillingDate?: true
    lastProcessedAt?: true
    status?: true
    failedAttempts?: true
    lastTransactionId?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EwayRecurringScheduleCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    ewayCustomerId?: true
    subscriptionId?: true
    scheduleType?: true
    billingAmount?: true
    currency?: true
    startDate?: true
    nextBillingDate?: true
    lastProcessedAt?: true
    status?: true
    failedAttempts?: true
    lastTransactionId?: true
    cancelledAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EwayRecurringScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayRecurringSchedule to aggregate.
     */
    where?: EwayRecurringScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayRecurringSchedules to fetch.
     */
    orderBy?: EwayRecurringScheduleOrderByWithRelationInput | EwayRecurringScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EwayRecurringScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayRecurringSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayRecurringSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EwayRecurringSchedules
    **/
    _count?: true | EwayRecurringScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EwayRecurringScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EwayRecurringScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EwayRecurringScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EwayRecurringScheduleMaxAggregateInputType
  }

  export type GetEwayRecurringScheduleAggregateType<T extends EwayRecurringScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateEwayRecurringSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEwayRecurringSchedule[P]>
      : GetScalarType<T[P], AggregateEwayRecurringSchedule[P]>
  }




  export type EwayRecurringScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayRecurringScheduleWhereInput
    orderBy?: EwayRecurringScheduleOrderByWithAggregationInput | EwayRecurringScheduleOrderByWithAggregationInput[]
    by: EwayRecurringScheduleScalarFieldEnum[] | EwayRecurringScheduleScalarFieldEnum
    having?: EwayRecurringScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EwayRecurringScheduleCountAggregateInputType | true
    _avg?: EwayRecurringScheduleAvgAggregateInputType
    _sum?: EwayRecurringScheduleSumAggregateInputType
    _min?: EwayRecurringScheduleMinAggregateInputType
    _max?: EwayRecurringScheduleMaxAggregateInputType
  }

  export type EwayRecurringScheduleGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    ewayCustomerId: string
    subscriptionId: string
    scheduleType: string
    billingAmount: Decimal
    currency: string
    startDate: Date
    nextBillingDate: Date
    lastProcessedAt: Date | null
    status: string
    failedAttempts: number
    lastTransactionId: string | null
    cancelledAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: EwayRecurringScheduleCountAggregateOutputType | null
    _avg: EwayRecurringScheduleAvgAggregateOutputType | null
    _sum: EwayRecurringScheduleSumAggregateOutputType | null
    _min: EwayRecurringScheduleMinAggregateOutputType | null
    _max: EwayRecurringScheduleMaxAggregateOutputType | null
  }

  type GetEwayRecurringScheduleGroupByPayload<T extends EwayRecurringScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EwayRecurringScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EwayRecurringScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EwayRecurringScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], EwayRecurringScheduleGroupByOutputType[P]>
        }
      >
    >


  export type EwayRecurringScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    ewayCustomerId?: boolean
    subscriptionId?: boolean
    scheduleType?: boolean
    billingAmount?: boolean
    currency?: boolean
    startDate?: boolean
    nextBillingDate?: boolean
    lastProcessedAt?: boolean
    status?: boolean
    failedAttempts?: boolean
    lastTransactionId?: boolean
    cancelledAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ewayCustomer?: boolean | EwayCustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ewayRecurringSchedule"]>

  export type EwayRecurringScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    ewayCustomerId?: boolean
    subscriptionId?: boolean
    scheduleType?: boolean
    billingAmount?: boolean
    currency?: boolean
    startDate?: boolean
    nextBillingDate?: boolean
    lastProcessedAt?: boolean
    status?: boolean
    failedAttempts?: boolean
    lastTransactionId?: boolean
    cancelledAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ewayCustomer?: boolean | EwayCustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ewayRecurringSchedule"]>

  export type EwayRecurringScheduleSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    ewayCustomerId?: boolean
    subscriptionId?: boolean
    scheduleType?: boolean
    billingAmount?: boolean
    currency?: boolean
    startDate?: boolean
    nextBillingDate?: boolean
    lastProcessedAt?: boolean
    status?: boolean
    failedAttempts?: boolean
    lastTransactionId?: boolean
    cancelledAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EwayRecurringScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ewayCustomer?: boolean | EwayCustomerDefaultArgs<ExtArgs>
  }
  export type EwayRecurringScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ewayCustomer?: boolean | EwayCustomerDefaultArgs<ExtArgs>
  }

  export type $EwayRecurringSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EwayRecurringSchedule"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ewayCustomer: Prisma.$EwayCustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      ewayCustomerId: string
      subscriptionId: string
      scheduleType: string
      billingAmount: Prisma.Decimal
      currency: string
      startDate: Date
      nextBillingDate: Date
      lastProcessedAt: Date | null
      status: string
      failedAttempts: number
      lastTransactionId: string | null
      cancelledAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ewayRecurringSchedule"]>
    composites: {}
  }

  type EwayRecurringScheduleGetPayload<S extends boolean | null | undefined | EwayRecurringScheduleDefaultArgs> = $Result.GetResult<Prisma.$EwayRecurringSchedulePayload, S>

  type EwayRecurringScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EwayRecurringScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EwayRecurringScheduleCountAggregateInputType | true
    }

  export interface EwayRecurringScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EwayRecurringSchedule'], meta: { name: 'EwayRecurringSchedule' } }
    /**
     * Find zero or one EwayRecurringSchedule that matches the filter.
     * @param {EwayRecurringScheduleFindUniqueArgs} args - Arguments to find a EwayRecurringSchedule
     * @example
     * // Get one EwayRecurringSchedule
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EwayRecurringScheduleFindUniqueArgs>(args: SelectSubset<T, EwayRecurringScheduleFindUniqueArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EwayRecurringSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EwayRecurringScheduleFindUniqueOrThrowArgs} args - Arguments to find a EwayRecurringSchedule
     * @example
     * // Get one EwayRecurringSchedule
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EwayRecurringScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, EwayRecurringScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EwayRecurringSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleFindFirstArgs} args - Arguments to find a EwayRecurringSchedule
     * @example
     * // Get one EwayRecurringSchedule
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EwayRecurringScheduleFindFirstArgs>(args?: SelectSubset<T, EwayRecurringScheduleFindFirstArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EwayRecurringSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleFindFirstOrThrowArgs} args - Arguments to find a EwayRecurringSchedule
     * @example
     * // Get one EwayRecurringSchedule
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EwayRecurringScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, EwayRecurringScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EwayRecurringSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EwayRecurringSchedules
     * const ewayRecurringSchedules = await prisma.ewayRecurringSchedule.findMany()
     * 
     * // Get first 10 EwayRecurringSchedules
     * const ewayRecurringSchedules = await prisma.ewayRecurringSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ewayRecurringScheduleWithIdOnly = await prisma.ewayRecurringSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EwayRecurringScheduleFindManyArgs>(args?: SelectSubset<T, EwayRecurringScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EwayRecurringSchedule.
     * @param {EwayRecurringScheduleCreateArgs} args - Arguments to create a EwayRecurringSchedule.
     * @example
     * // Create one EwayRecurringSchedule
     * const EwayRecurringSchedule = await prisma.ewayRecurringSchedule.create({
     *   data: {
     *     // ... data to create a EwayRecurringSchedule
     *   }
     * })
     * 
     */
    create<T extends EwayRecurringScheduleCreateArgs>(args: SelectSubset<T, EwayRecurringScheduleCreateArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EwayRecurringSchedules.
     * @param {EwayRecurringScheduleCreateManyArgs} args - Arguments to create many EwayRecurringSchedules.
     * @example
     * // Create many EwayRecurringSchedules
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EwayRecurringScheduleCreateManyArgs>(args?: SelectSubset<T, EwayRecurringScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EwayRecurringSchedules and returns the data saved in the database.
     * @param {EwayRecurringScheduleCreateManyAndReturnArgs} args - Arguments to create many EwayRecurringSchedules.
     * @example
     * // Create many EwayRecurringSchedules
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EwayRecurringSchedules and only return the `id`
     * const ewayRecurringScheduleWithIdOnly = await prisma.ewayRecurringSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EwayRecurringScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, EwayRecurringScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EwayRecurringSchedule.
     * @param {EwayRecurringScheduleDeleteArgs} args - Arguments to delete one EwayRecurringSchedule.
     * @example
     * // Delete one EwayRecurringSchedule
     * const EwayRecurringSchedule = await prisma.ewayRecurringSchedule.delete({
     *   where: {
     *     // ... filter to delete one EwayRecurringSchedule
     *   }
     * })
     * 
     */
    delete<T extends EwayRecurringScheduleDeleteArgs>(args: SelectSubset<T, EwayRecurringScheduleDeleteArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EwayRecurringSchedule.
     * @param {EwayRecurringScheduleUpdateArgs} args - Arguments to update one EwayRecurringSchedule.
     * @example
     * // Update one EwayRecurringSchedule
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EwayRecurringScheduleUpdateArgs>(args: SelectSubset<T, EwayRecurringScheduleUpdateArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EwayRecurringSchedules.
     * @param {EwayRecurringScheduleDeleteManyArgs} args - Arguments to filter EwayRecurringSchedules to delete.
     * @example
     * // Delete a few EwayRecurringSchedules
     * const { count } = await prisma.ewayRecurringSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EwayRecurringScheduleDeleteManyArgs>(args?: SelectSubset<T, EwayRecurringScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EwayRecurringSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EwayRecurringSchedules
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EwayRecurringScheduleUpdateManyArgs>(args: SelectSubset<T, EwayRecurringScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EwayRecurringSchedule.
     * @param {EwayRecurringScheduleUpsertArgs} args - Arguments to update or create a EwayRecurringSchedule.
     * @example
     * // Update or create a EwayRecurringSchedule
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.upsert({
     *   create: {
     *     // ... data to create a EwayRecurringSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EwayRecurringSchedule we want to update
     *   }
     * })
     */
    upsert<T extends EwayRecurringScheduleUpsertArgs>(args: SelectSubset<T, EwayRecurringScheduleUpsertArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EwayRecurringSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleCountArgs} args - Arguments to filter EwayRecurringSchedules to count.
     * @example
     * // Count the number of EwayRecurringSchedules
     * const count = await prisma.ewayRecurringSchedule.count({
     *   where: {
     *     // ... the filter for the EwayRecurringSchedules we want to count
     *   }
     * })
    **/
    count<T extends EwayRecurringScheduleCountArgs>(
      args?: Subset<T, EwayRecurringScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EwayRecurringScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EwayRecurringSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EwayRecurringScheduleAggregateArgs>(args: Subset<T, EwayRecurringScheduleAggregateArgs>): Prisma.PrismaPromise<GetEwayRecurringScheduleAggregateType<T>>

    /**
     * Group by EwayRecurringSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EwayRecurringScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EwayRecurringScheduleGroupByArgs['orderBy'] }
        : { orderBy?: EwayRecurringScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EwayRecurringScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEwayRecurringScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EwayRecurringSchedule model
   */
  readonly fields: EwayRecurringScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EwayRecurringSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EwayRecurringScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ewayCustomer<T extends EwayCustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EwayCustomerDefaultArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EwayRecurringSchedule model
   */ 
  interface EwayRecurringScheduleFieldRefs {
    readonly id: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly userId: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly workspaceId: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly ewayCustomerId: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly subscriptionId: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly scheduleType: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly billingAmount: FieldRef<"EwayRecurringSchedule", 'Decimal'>
    readonly currency: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly startDate: FieldRef<"EwayRecurringSchedule", 'DateTime'>
    readonly nextBillingDate: FieldRef<"EwayRecurringSchedule", 'DateTime'>
    readonly lastProcessedAt: FieldRef<"EwayRecurringSchedule", 'DateTime'>
    readonly status: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly failedAttempts: FieldRef<"EwayRecurringSchedule", 'Int'>
    readonly lastTransactionId: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly cancelledAt: FieldRef<"EwayRecurringSchedule", 'DateTime'>
    readonly metadata: FieldRef<"EwayRecurringSchedule", 'Json'>
    readonly createdAt: FieldRef<"EwayRecurringSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"EwayRecurringSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EwayRecurringSchedule findUnique
   */
  export type EwayRecurringScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EwayRecurringSchedule to fetch.
     */
    where: EwayRecurringScheduleWhereUniqueInput
  }

  /**
   * EwayRecurringSchedule findUniqueOrThrow
   */
  export type EwayRecurringScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EwayRecurringSchedule to fetch.
     */
    where: EwayRecurringScheduleWhereUniqueInput
  }

  /**
   * EwayRecurringSchedule findFirst
   */
  export type EwayRecurringScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EwayRecurringSchedule to fetch.
     */
    where?: EwayRecurringScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayRecurringSchedules to fetch.
     */
    orderBy?: EwayRecurringScheduleOrderByWithRelationInput | EwayRecurringScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayRecurringSchedules.
     */
    cursor?: EwayRecurringScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayRecurringSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayRecurringSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayRecurringSchedules.
     */
    distinct?: EwayRecurringScheduleScalarFieldEnum | EwayRecurringScheduleScalarFieldEnum[]
  }

  /**
   * EwayRecurringSchedule findFirstOrThrow
   */
  export type EwayRecurringScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EwayRecurringSchedule to fetch.
     */
    where?: EwayRecurringScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayRecurringSchedules to fetch.
     */
    orderBy?: EwayRecurringScheduleOrderByWithRelationInput | EwayRecurringScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayRecurringSchedules.
     */
    cursor?: EwayRecurringScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayRecurringSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayRecurringSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayRecurringSchedules.
     */
    distinct?: EwayRecurringScheduleScalarFieldEnum | EwayRecurringScheduleScalarFieldEnum[]
  }

  /**
   * EwayRecurringSchedule findMany
   */
  export type EwayRecurringScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EwayRecurringSchedules to fetch.
     */
    where?: EwayRecurringScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayRecurringSchedules to fetch.
     */
    orderBy?: EwayRecurringScheduleOrderByWithRelationInput | EwayRecurringScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EwayRecurringSchedules.
     */
    cursor?: EwayRecurringScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayRecurringSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayRecurringSchedules.
     */
    skip?: number
    distinct?: EwayRecurringScheduleScalarFieldEnum | EwayRecurringScheduleScalarFieldEnum[]
  }

  /**
   * EwayRecurringSchedule create
   */
  export type EwayRecurringScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a EwayRecurringSchedule.
     */
    data: XOR<EwayRecurringScheduleCreateInput, EwayRecurringScheduleUncheckedCreateInput>
  }

  /**
   * EwayRecurringSchedule createMany
   */
  export type EwayRecurringScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EwayRecurringSchedules.
     */
    data: EwayRecurringScheduleCreateManyInput | EwayRecurringScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EwayRecurringSchedule createManyAndReturn
   */
  export type EwayRecurringScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EwayRecurringSchedules.
     */
    data: EwayRecurringScheduleCreateManyInput | EwayRecurringScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EwayRecurringSchedule update
   */
  export type EwayRecurringScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a EwayRecurringSchedule.
     */
    data: XOR<EwayRecurringScheduleUpdateInput, EwayRecurringScheduleUncheckedUpdateInput>
    /**
     * Choose, which EwayRecurringSchedule to update.
     */
    where: EwayRecurringScheduleWhereUniqueInput
  }

  /**
   * EwayRecurringSchedule updateMany
   */
  export type EwayRecurringScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EwayRecurringSchedules.
     */
    data: XOR<EwayRecurringScheduleUpdateManyMutationInput, EwayRecurringScheduleUncheckedUpdateManyInput>
    /**
     * Filter which EwayRecurringSchedules to update
     */
    where?: EwayRecurringScheduleWhereInput
  }

  /**
   * EwayRecurringSchedule upsert
   */
  export type EwayRecurringScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the EwayRecurringSchedule to update in case it exists.
     */
    where: EwayRecurringScheduleWhereUniqueInput
    /**
     * In case the EwayRecurringSchedule found by the `where` argument doesn't exist, create a new EwayRecurringSchedule with this data.
     */
    create: XOR<EwayRecurringScheduleCreateInput, EwayRecurringScheduleUncheckedCreateInput>
    /**
     * In case the EwayRecurringSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EwayRecurringScheduleUpdateInput, EwayRecurringScheduleUncheckedUpdateInput>
  }

  /**
   * EwayRecurringSchedule delete
   */
  export type EwayRecurringScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * Filter which EwayRecurringSchedule to delete.
     */
    where: EwayRecurringScheduleWhereUniqueInput
  }

  /**
   * EwayRecurringSchedule deleteMany
   */
  export type EwayRecurringScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayRecurringSchedules to delete
     */
    where?: EwayRecurringScheduleWhereInput
  }

  /**
   * EwayRecurringSchedule without action
   */
  export type EwayRecurringScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
  }


  /**
   * Model EwayWebhookEvent
   */

  export type AggregateEwayWebhookEvent = {
    _count: EwayWebhookEventCountAggregateOutputType | null
    _avg: EwayWebhookEventAvgAggregateOutputType | null
    _sum: EwayWebhookEventSumAggregateOutputType | null
    _min: EwayWebhookEventMinAggregateOutputType | null
    _max: EwayWebhookEventMaxAggregateOutputType | null
  }

  export type EwayWebhookEventAvgAggregateOutputType = {
    ewayTransactionId: number | null
  }

  export type EwayWebhookEventSumAggregateOutputType = {
    ewayTransactionId: bigint | null
  }

  export type EwayWebhookEventMinAggregateOutputType = {
    id: string | null
    eventType: string | null
    ewayTransactionId: bigint | null
    ewayCustomerToken: string | null
    rawPayload: string | null
    processed: boolean | null
    processedAt: Date | null
    sourceIp: string | null
    createdAt: Date | null
  }

  export type EwayWebhookEventMaxAggregateOutputType = {
    id: string | null
    eventType: string | null
    ewayTransactionId: bigint | null
    ewayCustomerToken: string | null
    rawPayload: string | null
    processed: boolean | null
    processedAt: Date | null
    sourceIp: string | null
    createdAt: Date | null
  }

  export type EwayWebhookEventCountAggregateOutputType = {
    id: number
    eventType: number
    ewayTransactionId: number
    ewayCustomerToken: number
    eventData: number
    rawPayload: number
    processed: number
    processedAt: number
    sourceIp: number
    createdAt: number
    _all: number
  }


  export type EwayWebhookEventAvgAggregateInputType = {
    ewayTransactionId?: true
  }

  export type EwayWebhookEventSumAggregateInputType = {
    ewayTransactionId?: true
  }

  export type EwayWebhookEventMinAggregateInputType = {
    id?: true
    eventType?: true
    ewayTransactionId?: true
    ewayCustomerToken?: true
    rawPayload?: true
    processed?: true
    processedAt?: true
    sourceIp?: true
    createdAt?: true
  }

  export type EwayWebhookEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    ewayTransactionId?: true
    ewayCustomerToken?: true
    rawPayload?: true
    processed?: true
    processedAt?: true
    sourceIp?: true
    createdAt?: true
  }

  export type EwayWebhookEventCountAggregateInputType = {
    id?: true
    eventType?: true
    ewayTransactionId?: true
    ewayCustomerToken?: true
    eventData?: true
    rawPayload?: true
    processed?: true
    processedAt?: true
    sourceIp?: true
    createdAt?: true
    _all?: true
  }

  export type EwayWebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayWebhookEvent to aggregate.
     */
    where?: EwayWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayWebhookEvents to fetch.
     */
    orderBy?: EwayWebhookEventOrderByWithRelationInput | EwayWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EwayWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EwayWebhookEvents
    **/
    _count?: true | EwayWebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EwayWebhookEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EwayWebhookEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EwayWebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EwayWebhookEventMaxAggregateInputType
  }

  export type GetEwayWebhookEventAggregateType<T extends EwayWebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateEwayWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEwayWebhookEvent[P]>
      : GetScalarType<T[P], AggregateEwayWebhookEvent[P]>
  }




  export type EwayWebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayWebhookEventWhereInput
    orderBy?: EwayWebhookEventOrderByWithAggregationInput | EwayWebhookEventOrderByWithAggregationInput[]
    by: EwayWebhookEventScalarFieldEnum[] | EwayWebhookEventScalarFieldEnum
    having?: EwayWebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EwayWebhookEventCountAggregateInputType | true
    _avg?: EwayWebhookEventAvgAggregateInputType
    _sum?: EwayWebhookEventSumAggregateInputType
    _min?: EwayWebhookEventMinAggregateInputType
    _max?: EwayWebhookEventMaxAggregateInputType
  }

  export type EwayWebhookEventGroupByOutputType = {
    id: string
    eventType: string
    ewayTransactionId: bigint | null
    ewayCustomerToken: string | null
    eventData: JsonValue
    rawPayload: string
    processed: boolean
    processedAt: Date | null
    sourceIp: string | null
    createdAt: Date
    _count: EwayWebhookEventCountAggregateOutputType | null
    _avg: EwayWebhookEventAvgAggregateOutputType | null
    _sum: EwayWebhookEventSumAggregateOutputType | null
    _min: EwayWebhookEventMinAggregateOutputType | null
    _max: EwayWebhookEventMaxAggregateOutputType | null
  }

  type GetEwayWebhookEventGroupByPayload<T extends EwayWebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EwayWebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EwayWebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EwayWebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], EwayWebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type EwayWebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    ewayTransactionId?: boolean
    ewayCustomerToken?: boolean
    eventData?: boolean
    rawPayload?: boolean
    processed?: boolean
    processedAt?: boolean
    sourceIp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ewayWebhookEvent"]>

  export type EwayWebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    ewayTransactionId?: boolean
    ewayCustomerToken?: boolean
    eventData?: boolean
    rawPayload?: boolean
    processed?: boolean
    processedAt?: boolean
    sourceIp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ewayWebhookEvent"]>

  export type EwayWebhookEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    ewayTransactionId?: boolean
    ewayCustomerToken?: boolean
    eventData?: boolean
    rawPayload?: boolean
    processed?: boolean
    processedAt?: boolean
    sourceIp?: boolean
    createdAt?: boolean
  }


  export type $EwayWebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EwayWebhookEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: string
      ewayTransactionId: bigint | null
      ewayCustomerToken: string | null
      eventData: Prisma.JsonValue
      rawPayload: string
      processed: boolean
      processedAt: Date | null
      sourceIp: string | null
      createdAt: Date
    }, ExtArgs["result"]["ewayWebhookEvent"]>
    composites: {}
  }

  type EwayWebhookEventGetPayload<S extends boolean | null | undefined | EwayWebhookEventDefaultArgs> = $Result.GetResult<Prisma.$EwayWebhookEventPayload, S>

  type EwayWebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EwayWebhookEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EwayWebhookEventCountAggregateInputType | true
    }

  export interface EwayWebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EwayWebhookEvent'], meta: { name: 'EwayWebhookEvent' } }
    /**
     * Find zero or one EwayWebhookEvent that matches the filter.
     * @param {EwayWebhookEventFindUniqueArgs} args - Arguments to find a EwayWebhookEvent
     * @example
     * // Get one EwayWebhookEvent
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EwayWebhookEventFindUniqueArgs>(args: SelectSubset<T, EwayWebhookEventFindUniqueArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EwayWebhookEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EwayWebhookEventFindUniqueOrThrowArgs} args - Arguments to find a EwayWebhookEvent
     * @example
     * // Get one EwayWebhookEvent
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EwayWebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, EwayWebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EwayWebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventFindFirstArgs} args - Arguments to find a EwayWebhookEvent
     * @example
     * // Get one EwayWebhookEvent
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EwayWebhookEventFindFirstArgs>(args?: SelectSubset<T, EwayWebhookEventFindFirstArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EwayWebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventFindFirstOrThrowArgs} args - Arguments to find a EwayWebhookEvent
     * @example
     * // Get one EwayWebhookEvent
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EwayWebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, EwayWebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EwayWebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EwayWebhookEvents
     * const ewayWebhookEvents = await prisma.ewayWebhookEvent.findMany()
     * 
     * // Get first 10 EwayWebhookEvents
     * const ewayWebhookEvents = await prisma.ewayWebhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ewayWebhookEventWithIdOnly = await prisma.ewayWebhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EwayWebhookEventFindManyArgs>(args?: SelectSubset<T, EwayWebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EwayWebhookEvent.
     * @param {EwayWebhookEventCreateArgs} args - Arguments to create a EwayWebhookEvent.
     * @example
     * // Create one EwayWebhookEvent
     * const EwayWebhookEvent = await prisma.ewayWebhookEvent.create({
     *   data: {
     *     // ... data to create a EwayWebhookEvent
     *   }
     * })
     * 
     */
    create<T extends EwayWebhookEventCreateArgs>(args: SelectSubset<T, EwayWebhookEventCreateArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EwayWebhookEvents.
     * @param {EwayWebhookEventCreateManyArgs} args - Arguments to create many EwayWebhookEvents.
     * @example
     * // Create many EwayWebhookEvents
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EwayWebhookEventCreateManyArgs>(args?: SelectSubset<T, EwayWebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EwayWebhookEvents and returns the data saved in the database.
     * @param {EwayWebhookEventCreateManyAndReturnArgs} args - Arguments to create many EwayWebhookEvents.
     * @example
     * // Create many EwayWebhookEvents
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EwayWebhookEvents and only return the `id`
     * const ewayWebhookEventWithIdOnly = await prisma.ewayWebhookEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EwayWebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, EwayWebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EwayWebhookEvent.
     * @param {EwayWebhookEventDeleteArgs} args - Arguments to delete one EwayWebhookEvent.
     * @example
     * // Delete one EwayWebhookEvent
     * const EwayWebhookEvent = await prisma.ewayWebhookEvent.delete({
     *   where: {
     *     // ... filter to delete one EwayWebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends EwayWebhookEventDeleteArgs>(args: SelectSubset<T, EwayWebhookEventDeleteArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EwayWebhookEvent.
     * @param {EwayWebhookEventUpdateArgs} args - Arguments to update one EwayWebhookEvent.
     * @example
     * // Update one EwayWebhookEvent
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EwayWebhookEventUpdateArgs>(args: SelectSubset<T, EwayWebhookEventUpdateArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EwayWebhookEvents.
     * @param {EwayWebhookEventDeleteManyArgs} args - Arguments to filter EwayWebhookEvents to delete.
     * @example
     * // Delete a few EwayWebhookEvents
     * const { count } = await prisma.ewayWebhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EwayWebhookEventDeleteManyArgs>(args?: SelectSubset<T, EwayWebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EwayWebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EwayWebhookEvents
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EwayWebhookEventUpdateManyArgs>(args: SelectSubset<T, EwayWebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EwayWebhookEvent.
     * @param {EwayWebhookEventUpsertArgs} args - Arguments to update or create a EwayWebhookEvent.
     * @example
     * // Update or create a EwayWebhookEvent
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.upsert({
     *   create: {
     *     // ... data to create a EwayWebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EwayWebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends EwayWebhookEventUpsertArgs>(args: SelectSubset<T, EwayWebhookEventUpsertArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EwayWebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventCountArgs} args - Arguments to filter EwayWebhookEvents to count.
     * @example
     * // Count the number of EwayWebhookEvents
     * const count = await prisma.ewayWebhookEvent.count({
     *   where: {
     *     // ... the filter for the EwayWebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends EwayWebhookEventCountArgs>(
      args?: Subset<T, EwayWebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EwayWebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EwayWebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EwayWebhookEventAggregateArgs>(args: Subset<T, EwayWebhookEventAggregateArgs>): Prisma.PrismaPromise<GetEwayWebhookEventAggregateType<T>>

    /**
     * Group by EwayWebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EwayWebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EwayWebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: EwayWebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EwayWebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEwayWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EwayWebhookEvent model
   */
  readonly fields: EwayWebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EwayWebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EwayWebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EwayWebhookEvent model
   */ 
  interface EwayWebhookEventFieldRefs {
    readonly id: FieldRef<"EwayWebhookEvent", 'String'>
    readonly eventType: FieldRef<"EwayWebhookEvent", 'String'>
    readonly ewayTransactionId: FieldRef<"EwayWebhookEvent", 'BigInt'>
    readonly ewayCustomerToken: FieldRef<"EwayWebhookEvent", 'String'>
    readonly eventData: FieldRef<"EwayWebhookEvent", 'Json'>
    readonly rawPayload: FieldRef<"EwayWebhookEvent", 'String'>
    readonly processed: FieldRef<"EwayWebhookEvent", 'Boolean'>
    readonly processedAt: FieldRef<"EwayWebhookEvent", 'DateTime'>
    readonly sourceIp: FieldRef<"EwayWebhookEvent", 'String'>
    readonly createdAt: FieldRef<"EwayWebhookEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EwayWebhookEvent findUnique
   */
  export type EwayWebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which EwayWebhookEvent to fetch.
     */
    where: EwayWebhookEventWhereUniqueInput
  }

  /**
   * EwayWebhookEvent findUniqueOrThrow
   */
  export type EwayWebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which EwayWebhookEvent to fetch.
     */
    where: EwayWebhookEventWhereUniqueInput
  }

  /**
   * EwayWebhookEvent findFirst
   */
  export type EwayWebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which EwayWebhookEvent to fetch.
     */
    where?: EwayWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayWebhookEvents to fetch.
     */
    orderBy?: EwayWebhookEventOrderByWithRelationInput | EwayWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayWebhookEvents.
     */
    cursor?: EwayWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayWebhookEvents.
     */
    distinct?: EwayWebhookEventScalarFieldEnum | EwayWebhookEventScalarFieldEnum[]
  }

  /**
   * EwayWebhookEvent findFirstOrThrow
   */
  export type EwayWebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which EwayWebhookEvent to fetch.
     */
    where?: EwayWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayWebhookEvents to fetch.
     */
    orderBy?: EwayWebhookEventOrderByWithRelationInput | EwayWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayWebhookEvents.
     */
    cursor?: EwayWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayWebhookEvents.
     */
    distinct?: EwayWebhookEventScalarFieldEnum | EwayWebhookEventScalarFieldEnum[]
  }

  /**
   * EwayWebhookEvent findMany
   */
  export type EwayWebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which EwayWebhookEvents to fetch.
     */
    where?: EwayWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayWebhookEvents to fetch.
     */
    orderBy?: EwayWebhookEventOrderByWithRelationInput | EwayWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EwayWebhookEvents.
     */
    cursor?: EwayWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayWebhookEvents.
     */
    skip?: number
    distinct?: EwayWebhookEventScalarFieldEnum | EwayWebhookEventScalarFieldEnum[]
  }

  /**
   * EwayWebhookEvent create
   */
  export type EwayWebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * The data needed to create a EwayWebhookEvent.
     */
    data: XOR<EwayWebhookEventCreateInput, EwayWebhookEventUncheckedCreateInput>
  }

  /**
   * EwayWebhookEvent createMany
   */
  export type EwayWebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EwayWebhookEvents.
     */
    data: EwayWebhookEventCreateManyInput | EwayWebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EwayWebhookEvent createManyAndReturn
   */
  export type EwayWebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EwayWebhookEvents.
     */
    data: EwayWebhookEventCreateManyInput | EwayWebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EwayWebhookEvent update
   */
  export type EwayWebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * The data needed to update a EwayWebhookEvent.
     */
    data: XOR<EwayWebhookEventUpdateInput, EwayWebhookEventUncheckedUpdateInput>
    /**
     * Choose, which EwayWebhookEvent to update.
     */
    where: EwayWebhookEventWhereUniqueInput
  }

  /**
   * EwayWebhookEvent updateMany
   */
  export type EwayWebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EwayWebhookEvents.
     */
    data: XOR<EwayWebhookEventUpdateManyMutationInput, EwayWebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which EwayWebhookEvents to update
     */
    where?: EwayWebhookEventWhereInput
  }

  /**
   * EwayWebhookEvent upsert
   */
  export type EwayWebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * The filter to search for the EwayWebhookEvent to update in case it exists.
     */
    where: EwayWebhookEventWhereUniqueInput
    /**
     * In case the EwayWebhookEvent found by the `where` argument doesn't exist, create a new EwayWebhookEvent with this data.
     */
    create: XOR<EwayWebhookEventCreateInput, EwayWebhookEventUncheckedCreateInput>
    /**
     * In case the EwayWebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EwayWebhookEventUpdateInput, EwayWebhookEventUncheckedUpdateInput>
  }

  /**
   * EwayWebhookEvent delete
   */
  export type EwayWebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * Filter which EwayWebhookEvent to delete.
     */
    where: EwayWebhookEventWhereUniqueInput
  }

  /**
   * EwayWebhookEvent deleteMany
   */
  export type EwayWebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayWebhookEvents to delete
     */
    where?: EwayWebhookEventWhereInput
  }

  /**
   * EwayWebhookEvent without action
   */
  export type EwayWebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
  }


  /**
   * Model ExportHistory
   */

  export type AggregateExportHistory = {
    _count: ExportHistoryCountAggregateOutputType | null
    _avg: ExportHistoryAvgAggregateOutputType | null
    _sum: ExportHistorySumAggregateOutputType | null
    _min: ExportHistoryMinAggregateOutputType | null
    _max: ExportHistoryMaxAggregateOutputType | null
  }

  export type ExportHistoryAvgAggregateOutputType = {
    fileSize: number | null
    downloadCount: number | null
  }

  export type ExportHistorySumAggregateOutputType = {
    fileSize: bigint | null
    downloadCount: number | null
  }

  export type ExportHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    exportType: string | null
    dataType: string | null
    dateFrom: Date | null
    dateTo: Date | null
    filename: string | null
    fileSize: bigint | null
    storagePath: string | null
    downloadUrl: string | null
    expiresAt: Date | null
    status: string | null
    downloadCount: number | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type ExportHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    exportType: string | null
    dataType: string | null
    dateFrom: Date | null
    dateTo: Date | null
    filename: string | null
    fileSize: bigint | null
    storagePath: string | null
    downloadUrl: string | null
    expiresAt: Date | null
    status: string | null
    downloadCount: number | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type ExportHistoryCountAggregateOutputType = {
    id: number
    userId: number
    exportType: number
    dataType: number
    dateFrom: number
    dateTo: number
    workspaceIds: number
    filters: number
    filename: number
    fileSize: number
    storagePath: number
    downloadUrl: number
    expiresAt: number
    status: number
    downloadCount: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type ExportHistoryAvgAggregateInputType = {
    fileSize?: true
    downloadCount?: true
  }

  export type ExportHistorySumAggregateInputType = {
    fileSize?: true
    downloadCount?: true
  }

  export type ExportHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    exportType?: true
    dataType?: true
    dateFrom?: true
    dateTo?: true
    filename?: true
    fileSize?: true
    storagePath?: true
    downloadUrl?: true
    expiresAt?: true
    status?: true
    downloadCount?: true
    createdAt?: true
    completedAt?: true
  }

  export type ExportHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    exportType?: true
    dataType?: true
    dateFrom?: true
    dateTo?: true
    filename?: true
    fileSize?: true
    storagePath?: true
    downloadUrl?: true
    expiresAt?: true
    status?: true
    downloadCount?: true
    createdAt?: true
    completedAt?: true
  }

  export type ExportHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    exportType?: true
    dataType?: true
    dateFrom?: true
    dateTo?: true
    workspaceIds?: true
    filters?: true
    filename?: true
    fileSize?: true
    storagePath?: true
    downloadUrl?: true
    expiresAt?: true
    status?: true
    downloadCount?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type ExportHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportHistory to aggregate.
     */
    where?: ExportHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportHistories to fetch.
     */
    orderBy?: ExportHistoryOrderByWithRelationInput | ExportHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExportHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExportHistories
    **/
    _count?: true | ExportHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExportHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExportHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExportHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExportHistoryMaxAggregateInputType
  }

  export type GetExportHistoryAggregateType<T extends ExportHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExportHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExportHistory[P]>
      : GetScalarType<T[P], AggregateExportHistory[P]>
  }




  export type ExportHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportHistoryWhereInput
    orderBy?: ExportHistoryOrderByWithAggregationInput | ExportHistoryOrderByWithAggregationInput[]
    by: ExportHistoryScalarFieldEnum[] | ExportHistoryScalarFieldEnum
    having?: ExportHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExportHistoryCountAggregateInputType | true
    _avg?: ExportHistoryAvgAggregateInputType
    _sum?: ExportHistorySumAggregateInputType
    _min?: ExportHistoryMinAggregateInputType
    _max?: ExportHistoryMaxAggregateInputType
  }

  export type ExportHistoryGroupByOutputType = {
    id: string
    userId: string
    exportType: string
    dataType: string
    dateFrom: Date | null
    dateTo: Date | null
    workspaceIds: string[]
    filters: JsonValue | null
    filename: string
    fileSize: bigint
    storagePath: string | null
    downloadUrl: string | null
    expiresAt: Date | null
    status: string
    downloadCount: number
    createdAt: Date
    completedAt: Date | null
    _count: ExportHistoryCountAggregateOutputType | null
    _avg: ExportHistoryAvgAggregateOutputType | null
    _sum: ExportHistorySumAggregateOutputType | null
    _min: ExportHistoryMinAggregateOutputType | null
    _max: ExportHistoryMaxAggregateOutputType | null
  }

  type GetExportHistoryGroupByPayload<T extends ExportHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExportHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExportHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExportHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExportHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ExportHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exportType?: boolean
    dataType?: boolean
    dateFrom?: boolean
    dateTo?: boolean
    workspaceIds?: boolean
    filters?: boolean
    filename?: boolean
    fileSize?: boolean
    storagePath?: boolean
    downloadUrl?: boolean
    expiresAt?: boolean
    status?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exportHistory"]>

  export type ExportHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exportType?: boolean
    dataType?: boolean
    dateFrom?: boolean
    dateTo?: boolean
    workspaceIds?: boolean
    filters?: boolean
    filename?: boolean
    fileSize?: boolean
    storagePath?: boolean
    downloadUrl?: boolean
    expiresAt?: boolean
    status?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exportHistory"]>

  export type ExportHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    exportType?: boolean
    dataType?: boolean
    dateFrom?: boolean
    dateTo?: boolean
    workspaceIds?: boolean
    filters?: boolean
    filename?: boolean
    fileSize?: boolean
    storagePath?: boolean
    downloadUrl?: boolean
    expiresAt?: boolean
    status?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }

  export type ExportHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExportHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExportHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExportHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      exportType: string
      dataType: string
      dateFrom: Date | null
      dateTo: Date | null
      workspaceIds: string[]
      filters: Prisma.JsonValue | null
      filename: string
      fileSize: bigint
      storagePath: string | null
      downloadUrl: string | null
      expiresAt: Date | null
      status: string
      downloadCount: number
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["exportHistory"]>
    composites: {}
  }

  type ExportHistoryGetPayload<S extends boolean | null | undefined | ExportHistoryDefaultArgs> = $Result.GetResult<Prisma.$ExportHistoryPayload, S>

  type ExportHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExportHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExportHistoryCountAggregateInputType | true
    }

  export interface ExportHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExportHistory'], meta: { name: 'ExportHistory' } }
    /**
     * Find zero or one ExportHistory that matches the filter.
     * @param {ExportHistoryFindUniqueArgs} args - Arguments to find a ExportHistory
     * @example
     * // Get one ExportHistory
     * const exportHistory = await prisma.exportHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExportHistoryFindUniqueArgs>(args: SelectSubset<T, ExportHistoryFindUniqueArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExportHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExportHistoryFindUniqueOrThrowArgs} args - Arguments to find a ExportHistory
     * @example
     * // Get one ExportHistory
     * const exportHistory = await prisma.exportHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExportHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExportHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExportHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryFindFirstArgs} args - Arguments to find a ExportHistory
     * @example
     * // Get one ExportHistory
     * const exportHistory = await prisma.exportHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExportHistoryFindFirstArgs>(args?: SelectSubset<T, ExportHistoryFindFirstArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExportHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryFindFirstOrThrowArgs} args - Arguments to find a ExportHistory
     * @example
     * // Get one ExportHistory
     * const exportHistory = await prisma.exportHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExportHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExportHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExportHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExportHistories
     * const exportHistories = await prisma.exportHistory.findMany()
     * 
     * // Get first 10 ExportHistories
     * const exportHistories = await prisma.exportHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exportHistoryWithIdOnly = await prisma.exportHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExportHistoryFindManyArgs>(args?: SelectSubset<T, ExportHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExportHistory.
     * @param {ExportHistoryCreateArgs} args - Arguments to create a ExportHistory.
     * @example
     * // Create one ExportHistory
     * const ExportHistory = await prisma.exportHistory.create({
     *   data: {
     *     // ... data to create a ExportHistory
     *   }
     * })
     * 
     */
    create<T extends ExportHistoryCreateArgs>(args: SelectSubset<T, ExportHistoryCreateArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExportHistories.
     * @param {ExportHistoryCreateManyArgs} args - Arguments to create many ExportHistories.
     * @example
     * // Create many ExportHistories
     * const exportHistory = await prisma.exportHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExportHistoryCreateManyArgs>(args?: SelectSubset<T, ExportHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExportHistories and returns the data saved in the database.
     * @param {ExportHistoryCreateManyAndReturnArgs} args - Arguments to create many ExportHistories.
     * @example
     * // Create many ExportHistories
     * const exportHistory = await prisma.exportHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExportHistories and only return the `id`
     * const exportHistoryWithIdOnly = await prisma.exportHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExportHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExportHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExportHistory.
     * @param {ExportHistoryDeleteArgs} args - Arguments to delete one ExportHistory.
     * @example
     * // Delete one ExportHistory
     * const ExportHistory = await prisma.exportHistory.delete({
     *   where: {
     *     // ... filter to delete one ExportHistory
     *   }
     * })
     * 
     */
    delete<T extends ExportHistoryDeleteArgs>(args: SelectSubset<T, ExportHistoryDeleteArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExportHistory.
     * @param {ExportHistoryUpdateArgs} args - Arguments to update one ExportHistory.
     * @example
     * // Update one ExportHistory
     * const exportHistory = await prisma.exportHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExportHistoryUpdateArgs>(args: SelectSubset<T, ExportHistoryUpdateArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExportHistories.
     * @param {ExportHistoryDeleteManyArgs} args - Arguments to filter ExportHistories to delete.
     * @example
     * // Delete a few ExportHistories
     * const { count } = await prisma.exportHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExportHistoryDeleteManyArgs>(args?: SelectSubset<T, ExportHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExportHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExportHistories
     * const exportHistory = await prisma.exportHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExportHistoryUpdateManyArgs>(args: SelectSubset<T, ExportHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExportHistory.
     * @param {ExportHistoryUpsertArgs} args - Arguments to update or create a ExportHistory.
     * @example
     * // Update or create a ExportHistory
     * const exportHistory = await prisma.exportHistory.upsert({
     *   create: {
     *     // ... data to create a ExportHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExportHistory we want to update
     *   }
     * })
     */
    upsert<T extends ExportHistoryUpsertArgs>(args: SelectSubset<T, ExportHistoryUpsertArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExportHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryCountArgs} args - Arguments to filter ExportHistories to count.
     * @example
     * // Count the number of ExportHistories
     * const count = await prisma.exportHistory.count({
     *   where: {
     *     // ... the filter for the ExportHistories we want to count
     *   }
     * })
    **/
    count<T extends ExportHistoryCountArgs>(
      args?: Subset<T, ExportHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExportHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExportHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExportHistoryAggregateArgs>(args: Subset<T, ExportHistoryAggregateArgs>): Prisma.PrismaPromise<GetExportHistoryAggregateType<T>>

    /**
     * Group by ExportHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExportHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExportHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ExportHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExportHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExportHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExportHistory model
   */
  readonly fields: ExportHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExportHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExportHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExportHistory model
   */ 
  interface ExportHistoryFieldRefs {
    readonly id: FieldRef<"ExportHistory", 'String'>
    readonly userId: FieldRef<"ExportHistory", 'String'>
    readonly exportType: FieldRef<"ExportHistory", 'String'>
    readonly dataType: FieldRef<"ExportHistory", 'String'>
    readonly dateFrom: FieldRef<"ExportHistory", 'DateTime'>
    readonly dateTo: FieldRef<"ExportHistory", 'DateTime'>
    readonly workspaceIds: FieldRef<"ExportHistory", 'String[]'>
    readonly filters: FieldRef<"ExportHistory", 'Json'>
    readonly filename: FieldRef<"ExportHistory", 'String'>
    readonly fileSize: FieldRef<"ExportHistory", 'BigInt'>
    readonly storagePath: FieldRef<"ExportHistory", 'String'>
    readonly downloadUrl: FieldRef<"ExportHistory", 'String'>
    readonly expiresAt: FieldRef<"ExportHistory", 'DateTime'>
    readonly status: FieldRef<"ExportHistory", 'String'>
    readonly downloadCount: FieldRef<"ExportHistory", 'Int'>
    readonly createdAt: FieldRef<"ExportHistory", 'DateTime'>
    readonly completedAt: FieldRef<"ExportHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExportHistory findUnique
   */
  export type ExportHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExportHistory to fetch.
     */
    where: ExportHistoryWhereUniqueInput
  }

  /**
   * ExportHistory findUniqueOrThrow
   */
  export type ExportHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExportHistory to fetch.
     */
    where: ExportHistoryWhereUniqueInput
  }

  /**
   * ExportHistory findFirst
   */
  export type ExportHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExportHistory to fetch.
     */
    where?: ExportHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportHistories to fetch.
     */
    orderBy?: ExportHistoryOrderByWithRelationInput | ExportHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportHistories.
     */
    cursor?: ExportHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportHistories.
     */
    distinct?: ExportHistoryScalarFieldEnum | ExportHistoryScalarFieldEnum[]
  }

  /**
   * ExportHistory findFirstOrThrow
   */
  export type ExportHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExportHistory to fetch.
     */
    where?: ExportHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportHistories to fetch.
     */
    orderBy?: ExportHistoryOrderByWithRelationInput | ExportHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportHistories.
     */
    cursor?: ExportHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportHistories.
     */
    distinct?: ExportHistoryScalarFieldEnum | ExportHistoryScalarFieldEnum[]
  }

  /**
   * ExportHistory findMany
   */
  export type ExportHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExportHistories to fetch.
     */
    where?: ExportHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportHistories to fetch.
     */
    orderBy?: ExportHistoryOrderByWithRelationInput | ExportHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExportHistories.
     */
    cursor?: ExportHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportHistories.
     */
    skip?: number
    distinct?: ExportHistoryScalarFieldEnum | ExportHistoryScalarFieldEnum[]
  }

  /**
   * ExportHistory create
   */
  export type ExportHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExportHistory.
     */
    data: XOR<ExportHistoryCreateInput, ExportHistoryUncheckedCreateInput>
  }

  /**
   * ExportHistory createMany
   */
  export type ExportHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExportHistories.
     */
    data: ExportHistoryCreateManyInput | ExportHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportHistory createManyAndReturn
   */
  export type ExportHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExportHistories.
     */
    data: ExportHistoryCreateManyInput | ExportHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExportHistory update
   */
  export type ExportHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExportHistory.
     */
    data: XOR<ExportHistoryUpdateInput, ExportHistoryUncheckedUpdateInput>
    /**
     * Choose, which ExportHistory to update.
     */
    where: ExportHistoryWhereUniqueInput
  }

  /**
   * ExportHistory updateMany
   */
  export type ExportHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExportHistories.
     */
    data: XOR<ExportHistoryUpdateManyMutationInput, ExportHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ExportHistories to update
     */
    where?: ExportHistoryWhereInput
  }

  /**
   * ExportHistory upsert
   */
  export type ExportHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExportHistory to update in case it exists.
     */
    where: ExportHistoryWhereUniqueInput
    /**
     * In case the ExportHistory found by the `where` argument doesn't exist, create a new ExportHistory with this data.
     */
    create: XOR<ExportHistoryCreateInput, ExportHistoryUncheckedCreateInput>
    /**
     * In case the ExportHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExportHistoryUpdateInput, ExportHistoryUncheckedUpdateInput>
  }

  /**
   * ExportHistory delete
   */
  export type ExportHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportHistoryInclude<ExtArgs> | null
    /**
     * Filter which ExportHistory to delete.
     */
    where: ExportHistoryWhereUniqueInput
  }

  /**
   * ExportHistory deleteMany
   */
  export type ExportHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportHistories to delete
     */
    where?: ExportHistoryWhereInput
  }

  /**
   * ExportHistory without action
   */
  export type ExportHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    requestId: string | null
    severity: string | null
    category: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    requestId: string | null
    severity: string | null
    category: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    action: number
    resource: number
    resourceId: number
    ipAddress: number
    userAgent: number
    requestId: number
    details: number
    oldValues: number
    newValues: number
    severity: number
    category: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    requestId?: true
    severity?: true
    category?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    requestId?: true
    severity?: true
    category?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    requestId?: true
    details?: true
    oldValues?: true
    newValues?: true
    severity?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    workspaceId: string | null
    action: string
    resource: string
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    requestId: string | null
    details: JsonValue | null
    oldValues: JsonValue | null
    newValues: JsonValue | null
    severity: string
    category: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    details?: boolean
    oldValues?: boolean
    newValues?: boolean
    severity?: boolean
    category?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
    workspace?: boolean | AuditLog$workspaceArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    details?: boolean
    oldValues?: boolean
    newValues?: boolean
    severity?: boolean
    category?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
    workspace?: boolean | AuditLog$workspaceArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    details?: boolean
    oldValues?: boolean
    newValues?: boolean
    severity?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
    workspace?: boolean | AuditLog$workspaceArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
    workspace?: boolean | AuditLog$workspaceArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      workspace: Prisma.$WorkspacePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      workspaceId: string | null
      action: string
      resource: string
      resourceId: string | null
      ipAddress: string | null
      userAgent: string | null
      requestId: string | null
      details: Prisma.JsonValue | null
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      severity: string
      category: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    workspace<T extends AuditLog$workspaceArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$workspaceArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly workspaceId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly requestId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly severity: FieldRef<"AuditLog", 'String'>
    readonly category: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog.workspace
   */
  export type AuditLog$workspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model DataRetentionPolicy
   */

  export type AggregateDataRetentionPolicy = {
    _count: DataRetentionPolicyCountAggregateOutputType | null
    _avg: DataRetentionPolicyAvgAggregateOutputType | null
    _sum: DataRetentionPolicySumAggregateOutputType | null
    _min: DataRetentionPolicyMinAggregateOutputType | null
    _max: DataRetentionPolicyMaxAggregateOutputType | null
  }

  export type DataRetentionPolicyAvgAggregateOutputType = {
    retentionDays: number | null
  }

  export type DataRetentionPolicySumAggregateOutputType = {
    retentionDays: number | null
  }

  export type DataRetentionPolicyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    dataType: string | null
    retentionDays: number | null
    autoDelete: boolean | null
    archiveBeforeDelete: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastRunAt: Date | null
  }

  export type DataRetentionPolicyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    dataType: string | null
    retentionDays: number | null
    autoDelete: boolean | null
    archiveBeforeDelete: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastRunAt: Date | null
  }

  export type DataRetentionPolicyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    dataType: number
    retentionDays: number
    autoDelete: number
    archiveBeforeDelete: number
    appliesToWorkspaces: number
    excludeWorkspaces: number
    isActive: number
    createdAt: number
    updatedAt: number
    lastRunAt: number
    _all: number
  }


  export type DataRetentionPolicyAvgAggregateInputType = {
    retentionDays?: true
  }

  export type DataRetentionPolicySumAggregateInputType = {
    retentionDays?: true
  }

  export type DataRetentionPolicyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dataType?: true
    retentionDays?: true
    autoDelete?: true
    archiveBeforeDelete?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastRunAt?: true
  }

  export type DataRetentionPolicyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dataType?: true
    retentionDays?: true
    autoDelete?: true
    archiveBeforeDelete?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastRunAt?: true
  }

  export type DataRetentionPolicyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dataType?: true
    retentionDays?: true
    autoDelete?: true
    archiveBeforeDelete?: true
    appliesToWorkspaces?: true
    excludeWorkspaces?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastRunAt?: true
    _all?: true
  }

  export type DataRetentionPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRetentionPolicy to aggregate.
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionPolicies to fetch.
     */
    orderBy?: DataRetentionPolicyOrderByWithRelationInput | DataRetentionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataRetentionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataRetentionPolicies
    **/
    _count?: true | DataRetentionPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataRetentionPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataRetentionPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataRetentionPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataRetentionPolicyMaxAggregateInputType
  }

  export type GetDataRetentionPolicyAggregateType<T extends DataRetentionPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateDataRetentionPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataRetentionPolicy[P]>
      : GetScalarType<T[P], AggregateDataRetentionPolicy[P]>
  }




  export type DataRetentionPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataRetentionPolicyWhereInput
    orderBy?: DataRetentionPolicyOrderByWithAggregationInput | DataRetentionPolicyOrderByWithAggregationInput[]
    by: DataRetentionPolicyScalarFieldEnum[] | DataRetentionPolicyScalarFieldEnum
    having?: DataRetentionPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataRetentionPolicyCountAggregateInputType | true
    _avg?: DataRetentionPolicyAvgAggregateInputType
    _sum?: DataRetentionPolicySumAggregateInputType
    _min?: DataRetentionPolicyMinAggregateInputType
    _max?: DataRetentionPolicyMaxAggregateInputType
  }

  export type DataRetentionPolicyGroupByOutputType = {
    id: string
    name: string
    description: string | null
    dataType: string
    retentionDays: number
    autoDelete: boolean
    archiveBeforeDelete: boolean
    appliesToWorkspaces: string[]
    excludeWorkspaces: string[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    lastRunAt: Date | null
    _count: DataRetentionPolicyCountAggregateOutputType | null
    _avg: DataRetentionPolicyAvgAggregateOutputType | null
    _sum: DataRetentionPolicySumAggregateOutputType | null
    _min: DataRetentionPolicyMinAggregateOutputType | null
    _max: DataRetentionPolicyMaxAggregateOutputType | null
  }

  type GetDataRetentionPolicyGroupByPayload<T extends DataRetentionPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataRetentionPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataRetentionPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataRetentionPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], DataRetentionPolicyGroupByOutputType[P]>
        }
      >
    >


  export type DataRetentionPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    dataType?: boolean
    retentionDays?: boolean
    autoDelete?: boolean
    archiveBeforeDelete?: boolean
    appliesToWorkspaces?: boolean
    excludeWorkspaces?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastRunAt?: boolean
  }, ExtArgs["result"]["dataRetentionPolicy"]>

  export type DataRetentionPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    dataType?: boolean
    retentionDays?: boolean
    autoDelete?: boolean
    archiveBeforeDelete?: boolean
    appliesToWorkspaces?: boolean
    excludeWorkspaces?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastRunAt?: boolean
  }, ExtArgs["result"]["dataRetentionPolicy"]>

  export type DataRetentionPolicySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    dataType?: boolean
    retentionDays?: boolean
    autoDelete?: boolean
    archiveBeforeDelete?: boolean
    appliesToWorkspaces?: boolean
    excludeWorkspaces?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastRunAt?: boolean
  }


  export type $DataRetentionPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataRetentionPolicy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      dataType: string
      retentionDays: number
      autoDelete: boolean
      archiveBeforeDelete: boolean
      appliesToWorkspaces: string[]
      excludeWorkspaces: string[]
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      lastRunAt: Date | null
    }, ExtArgs["result"]["dataRetentionPolicy"]>
    composites: {}
  }

  type DataRetentionPolicyGetPayload<S extends boolean | null | undefined | DataRetentionPolicyDefaultArgs> = $Result.GetResult<Prisma.$DataRetentionPolicyPayload, S>

  type DataRetentionPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DataRetentionPolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DataRetentionPolicyCountAggregateInputType | true
    }

  export interface DataRetentionPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataRetentionPolicy'], meta: { name: 'DataRetentionPolicy' } }
    /**
     * Find zero or one DataRetentionPolicy that matches the filter.
     * @param {DataRetentionPolicyFindUniqueArgs} args - Arguments to find a DataRetentionPolicy
     * @example
     * // Get one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataRetentionPolicyFindUniqueArgs>(args: SelectSubset<T, DataRetentionPolicyFindUniqueArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DataRetentionPolicy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DataRetentionPolicyFindUniqueOrThrowArgs} args - Arguments to find a DataRetentionPolicy
     * @example
     * // Get one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataRetentionPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, DataRetentionPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DataRetentionPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyFindFirstArgs} args - Arguments to find a DataRetentionPolicy
     * @example
     * // Get one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataRetentionPolicyFindFirstArgs>(args?: SelectSubset<T, DataRetentionPolicyFindFirstArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DataRetentionPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyFindFirstOrThrowArgs} args - Arguments to find a DataRetentionPolicy
     * @example
     * // Get one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataRetentionPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, DataRetentionPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DataRetentionPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataRetentionPolicies
     * const dataRetentionPolicies = await prisma.dataRetentionPolicy.findMany()
     * 
     * // Get first 10 DataRetentionPolicies
     * const dataRetentionPolicies = await prisma.dataRetentionPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataRetentionPolicyWithIdOnly = await prisma.dataRetentionPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataRetentionPolicyFindManyArgs>(args?: SelectSubset<T, DataRetentionPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DataRetentionPolicy.
     * @param {DataRetentionPolicyCreateArgs} args - Arguments to create a DataRetentionPolicy.
     * @example
     * // Create one DataRetentionPolicy
     * const DataRetentionPolicy = await prisma.dataRetentionPolicy.create({
     *   data: {
     *     // ... data to create a DataRetentionPolicy
     *   }
     * })
     * 
     */
    create<T extends DataRetentionPolicyCreateArgs>(args: SelectSubset<T, DataRetentionPolicyCreateArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DataRetentionPolicies.
     * @param {DataRetentionPolicyCreateManyArgs} args - Arguments to create many DataRetentionPolicies.
     * @example
     * // Create many DataRetentionPolicies
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataRetentionPolicyCreateManyArgs>(args?: SelectSubset<T, DataRetentionPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataRetentionPolicies and returns the data saved in the database.
     * @param {DataRetentionPolicyCreateManyAndReturnArgs} args - Arguments to create many DataRetentionPolicies.
     * @example
     * // Create many DataRetentionPolicies
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataRetentionPolicies and only return the `id`
     * const dataRetentionPolicyWithIdOnly = await prisma.dataRetentionPolicy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataRetentionPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, DataRetentionPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DataRetentionPolicy.
     * @param {DataRetentionPolicyDeleteArgs} args - Arguments to delete one DataRetentionPolicy.
     * @example
     * // Delete one DataRetentionPolicy
     * const DataRetentionPolicy = await prisma.dataRetentionPolicy.delete({
     *   where: {
     *     // ... filter to delete one DataRetentionPolicy
     *   }
     * })
     * 
     */
    delete<T extends DataRetentionPolicyDeleteArgs>(args: SelectSubset<T, DataRetentionPolicyDeleteArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DataRetentionPolicy.
     * @param {DataRetentionPolicyUpdateArgs} args - Arguments to update one DataRetentionPolicy.
     * @example
     * // Update one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataRetentionPolicyUpdateArgs>(args: SelectSubset<T, DataRetentionPolicyUpdateArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DataRetentionPolicies.
     * @param {DataRetentionPolicyDeleteManyArgs} args - Arguments to filter DataRetentionPolicies to delete.
     * @example
     * // Delete a few DataRetentionPolicies
     * const { count } = await prisma.dataRetentionPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataRetentionPolicyDeleteManyArgs>(args?: SelectSubset<T, DataRetentionPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataRetentionPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataRetentionPolicies
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataRetentionPolicyUpdateManyArgs>(args: SelectSubset<T, DataRetentionPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataRetentionPolicy.
     * @param {DataRetentionPolicyUpsertArgs} args - Arguments to update or create a DataRetentionPolicy.
     * @example
     * // Update or create a DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.upsert({
     *   create: {
     *     // ... data to create a DataRetentionPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataRetentionPolicy we want to update
     *   }
     * })
     */
    upsert<T extends DataRetentionPolicyUpsertArgs>(args: SelectSubset<T, DataRetentionPolicyUpsertArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DataRetentionPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyCountArgs} args - Arguments to filter DataRetentionPolicies to count.
     * @example
     * // Count the number of DataRetentionPolicies
     * const count = await prisma.dataRetentionPolicy.count({
     *   where: {
     *     // ... the filter for the DataRetentionPolicies we want to count
     *   }
     * })
    **/
    count<T extends DataRetentionPolicyCountArgs>(
      args?: Subset<T, DataRetentionPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataRetentionPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataRetentionPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataRetentionPolicyAggregateArgs>(args: Subset<T, DataRetentionPolicyAggregateArgs>): Prisma.PrismaPromise<GetDataRetentionPolicyAggregateType<T>>

    /**
     * Group by DataRetentionPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataRetentionPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataRetentionPolicyGroupByArgs['orderBy'] }
        : { orderBy?: DataRetentionPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataRetentionPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataRetentionPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataRetentionPolicy model
   */
  readonly fields: DataRetentionPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataRetentionPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataRetentionPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataRetentionPolicy model
   */ 
  interface DataRetentionPolicyFieldRefs {
    readonly id: FieldRef<"DataRetentionPolicy", 'String'>
    readonly name: FieldRef<"DataRetentionPolicy", 'String'>
    readonly description: FieldRef<"DataRetentionPolicy", 'String'>
    readonly dataType: FieldRef<"DataRetentionPolicy", 'String'>
    readonly retentionDays: FieldRef<"DataRetentionPolicy", 'Int'>
    readonly autoDelete: FieldRef<"DataRetentionPolicy", 'Boolean'>
    readonly archiveBeforeDelete: FieldRef<"DataRetentionPolicy", 'Boolean'>
    readonly appliesToWorkspaces: FieldRef<"DataRetentionPolicy", 'String[]'>
    readonly excludeWorkspaces: FieldRef<"DataRetentionPolicy", 'String[]'>
    readonly isActive: FieldRef<"DataRetentionPolicy", 'Boolean'>
    readonly createdAt: FieldRef<"DataRetentionPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"DataRetentionPolicy", 'DateTime'>
    readonly lastRunAt: FieldRef<"DataRetentionPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataRetentionPolicy findUnique
   */
  export type DataRetentionPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicy to fetch.
     */
    where: DataRetentionPolicyWhereUniqueInput
  }

  /**
   * DataRetentionPolicy findUniqueOrThrow
   */
  export type DataRetentionPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicy to fetch.
     */
    where: DataRetentionPolicyWhereUniqueInput
  }

  /**
   * DataRetentionPolicy findFirst
   */
  export type DataRetentionPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicy to fetch.
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionPolicies to fetch.
     */
    orderBy?: DataRetentionPolicyOrderByWithRelationInput | DataRetentionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRetentionPolicies.
     */
    cursor?: DataRetentionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRetentionPolicies.
     */
    distinct?: DataRetentionPolicyScalarFieldEnum | DataRetentionPolicyScalarFieldEnum[]
  }

  /**
   * DataRetentionPolicy findFirstOrThrow
   */
  export type DataRetentionPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicy to fetch.
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionPolicies to fetch.
     */
    orderBy?: DataRetentionPolicyOrderByWithRelationInput | DataRetentionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRetentionPolicies.
     */
    cursor?: DataRetentionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRetentionPolicies.
     */
    distinct?: DataRetentionPolicyScalarFieldEnum | DataRetentionPolicyScalarFieldEnum[]
  }

  /**
   * DataRetentionPolicy findMany
   */
  export type DataRetentionPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicies to fetch.
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionPolicies to fetch.
     */
    orderBy?: DataRetentionPolicyOrderByWithRelationInput | DataRetentionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataRetentionPolicies.
     */
    cursor?: DataRetentionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionPolicies.
     */
    skip?: number
    distinct?: DataRetentionPolicyScalarFieldEnum | DataRetentionPolicyScalarFieldEnum[]
  }

  /**
   * DataRetentionPolicy create
   */
  export type DataRetentionPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * The data needed to create a DataRetentionPolicy.
     */
    data: XOR<DataRetentionPolicyCreateInput, DataRetentionPolicyUncheckedCreateInput>
  }

  /**
   * DataRetentionPolicy createMany
   */
  export type DataRetentionPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataRetentionPolicies.
     */
    data: DataRetentionPolicyCreateManyInput | DataRetentionPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataRetentionPolicy createManyAndReturn
   */
  export type DataRetentionPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DataRetentionPolicies.
     */
    data: DataRetentionPolicyCreateManyInput | DataRetentionPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataRetentionPolicy update
   */
  export type DataRetentionPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * The data needed to update a DataRetentionPolicy.
     */
    data: XOR<DataRetentionPolicyUpdateInput, DataRetentionPolicyUncheckedUpdateInput>
    /**
     * Choose, which DataRetentionPolicy to update.
     */
    where: DataRetentionPolicyWhereUniqueInput
  }

  /**
   * DataRetentionPolicy updateMany
   */
  export type DataRetentionPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataRetentionPolicies.
     */
    data: XOR<DataRetentionPolicyUpdateManyMutationInput, DataRetentionPolicyUncheckedUpdateManyInput>
    /**
     * Filter which DataRetentionPolicies to update
     */
    where?: DataRetentionPolicyWhereInput
  }

  /**
   * DataRetentionPolicy upsert
   */
  export type DataRetentionPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * The filter to search for the DataRetentionPolicy to update in case it exists.
     */
    where: DataRetentionPolicyWhereUniqueInput
    /**
     * In case the DataRetentionPolicy found by the `where` argument doesn't exist, create a new DataRetentionPolicy with this data.
     */
    create: XOR<DataRetentionPolicyCreateInput, DataRetentionPolicyUncheckedCreateInput>
    /**
     * In case the DataRetentionPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataRetentionPolicyUpdateInput, DataRetentionPolicyUncheckedUpdateInput>
  }

  /**
   * DataRetentionPolicy delete
   */
  export type DataRetentionPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Filter which DataRetentionPolicy to delete.
     */
    where: DataRetentionPolicyWhereUniqueInput
  }

  /**
   * DataRetentionPolicy deleteMany
   */
  export type DataRetentionPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRetentionPolicies to delete
     */
    where?: DataRetentionPolicyWhereInput
  }

  /**
   * DataRetentionPolicy without action
   */
  export type DataRetentionPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    expiryMonth: number | null
    expiryYear: number | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    expiryMonth: number | null
    expiryYear: number | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    provider: string | null
    providerMethodId: string | null
    type: string | null
    last4: string | null
    brand: string | null
    expiryMonth: number | null
    expiryYear: number | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    provider: string | null
    providerMethodId: string | null
    type: string | null
    last4: string | null
    brand: string | null
    expiryMonth: number | null
    expiryYear: number | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    workspaceId: number
    provider: number
    providerMethodId: number
    type: number
    last4: number
    brand: number
    expiryMonth: number
    expiryYear: number
    isDefault: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    expiryMonth?: true
    expiryYear?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    expiryMonth?: true
    expiryYear?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    workspaceId?: true
    provider?: true
    providerMethodId?: true
    type?: true
    last4?: true
    brand?: true
    expiryMonth?: true
    expiryYear?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    provider?: true
    providerMethodId?: true
    type?: true
    last4?: true
    brand?: true
    expiryMonth?: true
    expiryYear?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    workspaceId?: true
    provider?: true
    providerMethodId?: true
    type?: true
    last4?: true
    brand?: true
    expiryMonth?: true
    expiryYear?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    workspaceId: string
    provider: string
    providerMethodId: string
    type: string
    last4: string | null
    brand: string | null
    expiryMonth: number | null
    expiryYear: number | null
    isDefault: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    provider?: boolean
    providerMethodId?: boolean
    type?: boolean
    last4?: boolean
    brand?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    provider?: boolean
    providerMethodId?: boolean
    type?: boolean
    last4?: boolean
    brand?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    provider?: boolean
    providerMethodId?: boolean
    type?: boolean
    last4?: boolean
    brand?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      provider: string
      providerMethodId: string
      type: string
      last4: string | null
      brand: string | null
      expiryMonth: number | null
      expiryYear: number | null
      isDefault: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */ 
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly workspaceId: FieldRef<"PaymentMethod", 'String'>
    readonly provider: FieldRef<"PaymentMethod", 'String'>
    readonly providerMethodId: FieldRef<"PaymentMethod", 'String'>
    readonly type: FieldRef<"PaymentMethod", 'String'>
    readonly last4: FieldRef<"PaymentMethod", 'String'>
    readonly brand: FieldRef<"PaymentMethod", 'String'>
    readonly expiryMonth: FieldRef<"PaymentMethod", 'Int'>
    readonly expiryYear: FieldRef<"PaymentMethod", 'Int'>
    readonly isDefault: FieldRef<"PaymentMethod", 'Boolean'>
    readonly isActive: FieldRef<"PaymentMethod", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
  }


  /**
   * Model Testimonial
   */

  export type AggregateTestimonial = {
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  export type TestimonialAvgAggregateOutputType = {
    rating: number | null
    displayOrder: number | null
  }

  export type TestimonialSumAggregateOutputType = {
    rating: number | null
    displayOrder: number | null
  }

  export type TestimonialMinAggregateOutputType = {
    id: string | null
    customerName: string | null
    customerRole: string | null
    companyName: string | null
    avatarUrl: string | null
    content: string | null
    rating: number | null
    featuredOn: string | null
    useCase: string | null
    isVerified: boolean | null
    verificationMethod: string | null
    isActive: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type TestimonialMaxAggregateOutputType = {
    id: string | null
    customerName: string | null
    customerRole: string | null
    companyName: string | null
    avatarUrl: string | null
    content: string | null
    rating: number | null
    featuredOn: string | null
    useCase: string | null
    isVerified: boolean | null
    verificationMethod: string | null
    isActive: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type TestimonialCountAggregateOutputType = {
    id: number
    customerName: number
    customerRole: number
    companyName: number
    avatarUrl: number
    content: number
    rating: number
    featuredOn: number
    useCase: number
    isVerified: number
    verificationMethod: number
    isActive: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type TestimonialAvgAggregateInputType = {
    rating?: true
    displayOrder?: true
  }

  export type TestimonialSumAggregateInputType = {
    rating?: true
    displayOrder?: true
  }

  export type TestimonialMinAggregateInputType = {
    id?: true
    customerName?: true
    customerRole?: true
    companyName?: true
    avatarUrl?: true
    content?: true
    rating?: true
    featuredOn?: true
    useCase?: true
    isVerified?: true
    verificationMethod?: true
    isActive?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type TestimonialMaxAggregateInputType = {
    id?: true
    customerName?: true
    customerRole?: true
    companyName?: true
    avatarUrl?: true
    content?: true
    rating?: true
    featuredOn?: true
    useCase?: true
    isVerified?: true
    verificationMethod?: true
    isActive?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type TestimonialCountAggregateInputType = {
    id?: true
    customerName?: true
    customerRole?: true
    companyName?: true
    avatarUrl?: true
    content?: true
    rating?: true
    featuredOn?: true
    useCase?: true
    isVerified?: true
    verificationMethod?: true
    isActive?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type TestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonial to aggregate.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Testimonials
    **/
    _count?: true | TestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialMaxAggregateInputType
  }

  export type GetTestimonialAggregateType<T extends TestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonial[P]>
      : GetScalarType<T[P], AggregateTestimonial[P]>
  }




  export type TestimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithAggregationInput | TestimonialOrderByWithAggregationInput[]
    by: TestimonialScalarFieldEnum[] | TestimonialScalarFieldEnum
    having?: TestimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialCountAggregateInputType | true
    _avg?: TestimonialAvgAggregateInputType
    _sum?: TestimonialSumAggregateInputType
    _min?: TestimonialMinAggregateInputType
    _max?: TestimonialMaxAggregateInputType
  }

  export type TestimonialGroupByOutputType = {
    id: string
    customerName: string
    customerRole: string | null
    companyName: string | null
    avatarUrl: string | null
    content: string
    rating: number
    featuredOn: string | null
    useCase: string | null
    isVerified: boolean
    verificationMethod: string | null
    isActive: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  type GetTestimonialGroupByPayload<T extends TestimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
        }
      >
    >


  export type TestimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerName?: boolean
    customerRole?: boolean
    companyName?: boolean
    avatarUrl?: boolean
    content?: boolean
    rating?: boolean
    featuredOn?: boolean
    useCase?: boolean
    isVerified?: boolean
    verificationMethod?: boolean
    isActive?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Testimonial$userArgs<ExtArgs>
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerName?: boolean
    customerRole?: boolean
    companyName?: boolean
    avatarUrl?: boolean
    content?: boolean
    rating?: boolean
    featuredOn?: boolean
    useCase?: boolean
    isVerified?: boolean
    verificationMethod?: boolean
    isActive?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Testimonial$userArgs<ExtArgs>
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectScalar = {
    id?: boolean
    customerName?: boolean
    customerRole?: boolean
    companyName?: boolean
    avatarUrl?: boolean
    content?: boolean
    rating?: boolean
    featuredOn?: boolean
    useCase?: boolean
    isVerified?: boolean
    verificationMethod?: boolean
    isActive?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type TestimonialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Testimonial$userArgs<ExtArgs>
  }
  export type TestimonialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Testimonial$userArgs<ExtArgs>
  }

  export type $TestimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Testimonial"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerName: string
      customerRole: string | null
      companyName: string | null
      avatarUrl: string | null
      content: string
      rating: number
      featuredOn: string | null
      useCase: string | null
      isVerified: boolean
      verificationMethod: string | null
      isActive: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
      userId: string | null
    }, ExtArgs["result"]["testimonial"]>
    composites: {}
  }

  type TestimonialGetPayload<S extends boolean | null | undefined | TestimonialDefaultArgs> = $Result.GetResult<Prisma.$TestimonialPayload, S>

  type TestimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestimonialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestimonialCountAggregateInputType | true
    }

  export interface TestimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Testimonial'], meta: { name: 'Testimonial' } }
    /**
     * Find zero or one Testimonial that matches the filter.
     * @param {TestimonialFindUniqueArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestimonialFindUniqueArgs>(args: SelectSubset<T, TestimonialFindUniqueArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Testimonial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestimonialFindUniqueOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, TestimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Testimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestimonialFindFirstArgs>(args?: SelectSubset<T, TestimonialFindFirstArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Testimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, TestimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonial.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestimonialFindManyArgs>(args?: SelectSubset<T, TestimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Testimonial.
     * @param {TestimonialCreateArgs} args - Arguments to create a Testimonial.
     * @example
     * // Create one Testimonial
     * const Testimonial = await prisma.testimonial.create({
     *   data: {
     *     // ... data to create a Testimonial
     *   }
     * })
     * 
     */
    create<T extends TestimonialCreateArgs>(args: SelectSubset<T, TestimonialCreateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Testimonials.
     * @param {TestimonialCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestimonialCreateManyArgs>(args?: SelectSubset<T, TestimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Testimonials and returns the data saved in the database.
     * @param {TestimonialCreateManyAndReturnArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Testimonials and only return the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestimonialCreateManyAndReturnArgs>(args?: SelectSubset<T, TestimonialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Testimonial.
     * @param {TestimonialDeleteArgs} args - Arguments to delete one Testimonial.
     * @example
     * // Delete one Testimonial
     * const Testimonial = await prisma.testimonial.delete({
     *   where: {
     *     // ... filter to delete one Testimonial
     *   }
     * })
     * 
     */
    delete<T extends TestimonialDeleteArgs>(args: SelectSubset<T, TestimonialDeleteArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Testimonial.
     * @param {TestimonialUpdateArgs} args - Arguments to update one Testimonial.
     * @example
     * // Update one Testimonial
     * const testimonial = await prisma.testimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestimonialUpdateArgs>(args: SelectSubset<T, TestimonialUpdateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Testimonials.
     * @param {TestimonialDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestimonialDeleteManyArgs>(args?: SelectSubset<T, TestimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestimonialUpdateManyArgs>(args: SelectSubset<T, TestimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testimonial.
     * @param {TestimonialUpsertArgs} args - Arguments to update or create a Testimonial.
     * @example
     * // Update or create a Testimonial
     * const testimonial = await prisma.testimonial.upsert({
     *   create: {
     *     // ... data to create a Testimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonial we want to update
     *   }
     * })
     */
    upsert<T extends TestimonialUpsertArgs>(args: SelectSubset<T, TestimonialUpsertArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonial.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends TestimonialCountArgs>(
      args?: Subset<T, TestimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialAggregateArgs>(args: Subset<T, TestimonialAggregateArgs>): Prisma.PrismaPromise<GetTestimonialAggregateType<T>>

    /**
     * Group by Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestimonialGroupByArgs['orderBy'] }
        : { orderBy?: TestimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Testimonial model
   */
  readonly fields: TestimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Testimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Testimonial$userArgs<ExtArgs> = {}>(args?: Subset<T, Testimonial$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Testimonial model
   */ 
  interface TestimonialFieldRefs {
    readonly id: FieldRef<"Testimonial", 'String'>
    readonly customerName: FieldRef<"Testimonial", 'String'>
    readonly customerRole: FieldRef<"Testimonial", 'String'>
    readonly companyName: FieldRef<"Testimonial", 'String'>
    readonly avatarUrl: FieldRef<"Testimonial", 'String'>
    readonly content: FieldRef<"Testimonial", 'String'>
    readonly rating: FieldRef<"Testimonial", 'Int'>
    readonly featuredOn: FieldRef<"Testimonial", 'String'>
    readonly useCase: FieldRef<"Testimonial", 'String'>
    readonly isVerified: FieldRef<"Testimonial", 'Boolean'>
    readonly verificationMethod: FieldRef<"Testimonial", 'String'>
    readonly isActive: FieldRef<"Testimonial", 'Boolean'>
    readonly displayOrder: FieldRef<"Testimonial", 'Int'>
    readonly createdAt: FieldRef<"Testimonial", 'DateTime'>
    readonly updatedAt: FieldRef<"Testimonial", 'DateTime'>
    readonly userId: FieldRef<"Testimonial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Testimonial findUnique
   */
  export type TestimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findUniqueOrThrow
   */
  export type TestimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findFirst
   */
  export type TestimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findFirstOrThrow
   */
  export type TestimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findMany
   */
  export type TestimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonials to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial create
   */
  export type TestimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * The data needed to create a Testimonial.
     */
    data: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
  }

  /**
   * Testimonial createMany
   */
  export type TestimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial createManyAndReturn
   */
  export type TestimonialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Testimonial update
   */
  export type TestimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * The data needed to update a Testimonial.
     */
    data: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
    /**
     * Choose, which Testimonial to update.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial updateMany
   */
  export type TestimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Testimonials.
     */
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyInput>
    /**
     * Filter which Testimonials to update
     */
    where?: TestimonialWhereInput
  }

  /**
   * Testimonial upsert
   */
  export type TestimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * The filter to search for the Testimonial to update in case it exists.
     */
    where: TestimonialWhereUniqueInput
    /**
     * In case the Testimonial found by the `where` argument doesn't exist, create a new Testimonial with this data.
     */
    create: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
    /**
     * In case the Testimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
  }

  /**
   * Testimonial delete
   */
  export type TestimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter which Testimonial to delete.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial deleteMany
   */
  export type TestimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonials to delete
     */
    where?: TestimonialWhereInput
  }

  /**
   * Testimonial.user
   */
  export type Testimonial$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Testimonial without action
   */
  export type TestimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
  }


  /**
   * Model WebsiteContent
   */

  export type AggregateWebsiteContent = {
    _count: WebsiteContentCountAggregateOutputType | null
    _avg: WebsiteContentAvgAggregateOutputType | null
    _sum: WebsiteContentSumAggregateOutputType | null
    _min: WebsiteContentMinAggregateOutputType | null
    _max: WebsiteContentMaxAggregateOutputType | null
  }

  export type WebsiteContentAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type WebsiteContentSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type WebsiteContentMinAggregateOutputType = {
    id: string | null
    contentKey: string | null
    contentType: string | null
    contentValue: string | null
    section: string | null
    page: string | null
    isActive: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebsiteContentMaxAggregateOutputType = {
    id: string | null
    contentKey: string | null
    contentType: string | null
    contentValue: string | null
    section: string | null
    page: string | null
    isActive: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebsiteContentCountAggregateOutputType = {
    id: number
    contentKey: number
    contentType: number
    contentValue: number
    contentMetadata: number
    section: number
    page: number
    isActive: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebsiteContentAvgAggregateInputType = {
    displayOrder?: true
  }

  export type WebsiteContentSumAggregateInputType = {
    displayOrder?: true
  }

  export type WebsiteContentMinAggregateInputType = {
    id?: true
    contentKey?: true
    contentType?: true
    contentValue?: true
    section?: true
    page?: true
    isActive?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebsiteContentMaxAggregateInputType = {
    id?: true
    contentKey?: true
    contentType?: true
    contentValue?: true
    section?: true
    page?: true
    isActive?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebsiteContentCountAggregateInputType = {
    id?: true
    contentKey?: true
    contentType?: true
    contentValue?: true
    contentMetadata?: true
    section?: true
    page?: true
    isActive?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebsiteContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebsiteContent to aggregate.
     */
    where?: WebsiteContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteContents to fetch.
     */
    orderBy?: WebsiteContentOrderByWithRelationInput | WebsiteContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebsiteContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebsiteContents
    **/
    _count?: true | WebsiteContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebsiteContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebsiteContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebsiteContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebsiteContentMaxAggregateInputType
  }

  export type GetWebsiteContentAggregateType<T extends WebsiteContentAggregateArgs> = {
        [P in keyof T & keyof AggregateWebsiteContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebsiteContent[P]>
      : GetScalarType<T[P], AggregateWebsiteContent[P]>
  }




  export type WebsiteContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsiteContentWhereInput
    orderBy?: WebsiteContentOrderByWithAggregationInput | WebsiteContentOrderByWithAggregationInput[]
    by: WebsiteContentScalarFieldEnum[] | WebsiteContentScalarFieldEnum
    having?: WebsiteContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebsiteContentCountAggregateInputType | true
    _avg?: WebsiteContentAvgAggregateInputType
    _sum?: WebsiteContentSumAggregateInputType
    _min?: WebsiteContentMinAggregateInputType
    _max?: WebsiteContentMaxAggregateInputType
  }

  export type WebsiteContentGroupByOutputType = {
    id: string
    contentKey: string
    contentType: string
    contentValue: string
    contentMetadata: JsonValue | null
    section: string | null
    page: string
    isActive: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: WebsiteContentCountAggregateOutputType | null
    _avg: WebsiteContentAvgAggregateOutputType | null
    _sum: WebsiteContentSumAggregateOutputType | null
    _min: WebsiteContentMinAggregateOutputType | null
    _max: WebsiteContentMaxAggregateOutputType | null
  }

  type GetWebsiteContentGroupByPayload<T extends WebsiteContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebsiteContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebsiteContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebsiteContentGroupByOutputType[P]>
            : GetScalarType<T[P], WebsiteContentGroupByOutputType[P]>
        }
      >
    >


  export type WebsiteContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentKey?: boolean
    contentType?: boolean
    contentValue?: boolean
    contentMetadata?: boolean
    section?: boolean
    page?: boolean
    isActive?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["websiteContent"]>

  export type WebsiteContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentKey?: boolean
    contentType?: boolean
    contentValue?: boolean
    contentMetadata?: boolean
    section?: boolean
    page?: boolean
    isActive?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["websiteContent"]>

  export type WebsiteContentSelectScalar = {
    id?: boolean
    contentKey?: boolean
    contentType?: boolean
    contentValue?: boolean
    contentMetadata?: boolean
    section?: boolean
    page?: boolean
    isActive?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $WebsiteContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebsiteContent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentKey: string
      contentType: string
      contentValue: string
      contentMetadata: Prisma.JsonValue | null
      section: string | null
      page: string
      isActive: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["websiteContent"]>
    composites: {}
  }

  type WebsiteContentGetPayload<S extends boolean | null | undefined | WebsiteContentDefaultArgs> = $Result.GetResult<Prisma.$WebsiteContentPayload, S>

  type WebsiteContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebsiteContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebsiteContentCountAggregateInputType | true
    }

  export interface WebsiteContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebsiteContent'], meta: { name: 'WebsiteContent' } }
    /**
     * Find zero or one WebsiteContent that matches the filter.
     * @param {WebsiteContentFindUniqueArgs} args - Arguments to find a WebsiteContent
     * @example
     * // Get one WebsiteContent
     * const websiteContent = await prisma.websiteContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebsiteContentFindUniqueArgs>(args: SelectSubset<T, WebsiteContentFindUniqueArgs<ExtArgs>>): Prisma__WebsiteContentClient<$Result.GetResult<Prisma.$WebsiteContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebsiteContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebsiteContentFindUniqueOrThrowArgs} args - Arguments to find a WebsiteContent
     * @example
     * // Get one WebsiteContent
     * const websiteContent = await prisma.websiteContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebsiteContentFindUniqueOrThrowArgs>(args: SelectSubset<T, WebsiteContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebsiteContentClient<$Result.GetResult<Prisma.$WebsiteContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebsiteContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteContentFindFirstArgs} args - Arguments to find a WebsiteContent
     * @example
     * // Get one WebsiteContent
     * const websiteContent = await prisma.websiteContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebsiteContentFindFirstArgs>(args?: SelectSubset<T, WebsiteContentFindFirstArgs<ExtArgs>>): Prisma__WebsiteContentClient<$Result.GetResult<Prisma.$WebsiteContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebsiteContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteContentFindFirstOrThrowArgs} args - Arguments to find a WebsiteContent
     * @example
     * // Get one WebsiteContent
     * const websiteContent = await prisma.websiteContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebsiteContentFindFirstOrThrowArgs>(args?: SelectSubset<T, WebsiteContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebsiteContentClient<$Result.GetResult<Prisma.$WebsiteContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebsiteContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebsiteContents
     * const websiteContents = await prisma.websiteContent.findMany()
     * 
     * // Get first 10 WebsiteContents
     * const websiteContents = await prisma.websiteContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const websiteContentWithIdOnly = await prisma.websiteContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebsiteContentFindManyArgs>(args?: SelectSubset<T, WebsiteContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebsiteContent.
     * @param {WebsiteContentCreateArgs} args - Arguments to create a WebsiteContent.
     * @example
     * // Create one WebsiteContent
     * const WebsiteContent = await prisma.websiteContent.create({
     *   data: {
     *     // ... data to create a WebsiteContent
     *   }
     * })
     * 
     */
    create<T extends WebsiteContentCreateArgs>(args: SelectSubset<T, WebsiteContentCreateArgs<ExtArgs>>): Prisma__WebsiteContentClient<$Result.GetResult<Prisma.$WebsiteContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebsiteContents.
     * @param {WebsiteContentCreateManyArgs} args - Arguments to create many WebsiteContents.
     * @example
     * // Create many WebsiteContents
     * const websiteContent = await prisma.websiteContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebsiteContentCreateManyArgs>(args?: SelectSubset<T, WebsiteContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebsiteContents and returns the data saved in the database.
     * @param {WebsiteContentCreateManyAndReturnArgs} args - Arguments to create many WebsiteContents.
     * @example
     * // Create many WebsiteContents
     * const websiteContent = await prisma.websiteContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebsiteContents and only return the `id`
     * const websiteContentWithIdOnly = await prisma.websiteContent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebsiteContentCreateManyAndReturnArgs>(args?: SelectSubset<T, WebsiteContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteContentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebsiteContent.
     * @param {WebsiteContentDeleteArgs} args - Arguments to delete one WebsiteContent.
     * @example
     * // Delete one WebsiteContent
     * const WebsiteContent = await prisma.websiteContent.delete({
     *   where: {
     *     // ... filter to delete one WebsiteContent
     *   }
     * })
     * 
     */
    delete<T extends WebsiteContentDeleteArgs>(args: SelectSubset<T, WebsiteContentDeleteArgs<ExtArgs>>): Prisma__WebsiteContentClient<$Result.GetResult<Prisma.$WebsiteContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebsiteContent.
     * @param {WebsiteContentUpdateArgs} args - Arguments to update one WebsiteContent.
     * @example
     * // Update one WebsiteContent
     * const websiteContent = await prisma.websiteContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebsiteContentUpdateArgs>(args: SelectSubset<T, WebsiteContentUpdateArgs<ExtArgs>>): Prisma__WebsiteContentClient<$Result.GetResult<Prisma.$WebsiteContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebsiteContents.
     * @param {WebsiteContentDeleteManyArgs} args - Arguments to filter WebsiteContents to delete.
     * @example
     * // Delete a few WebsiteContents
     * const { count } = await prisma.websiteContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebsiteContentDeleteManyArgs>(args?: SelectSubset<T, WebsiteContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebsiteContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebsiteContents
     * const websiteContent = await prisma.websiteContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebsiteContentUpdateManyArgs>(args: SelectSubset<T, WebsiteContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebsiteContent.
     * @param {WebsiteContentUpsertArgs} args - Arguments to update or create a WebsiteContent.
     * @example
     * // Update or create a WebsiteContent
     * const websiteContent = await prisma.websiteContent.upsert({
     *   create: {
     *     // ... data to create a WebsiteContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebsiteContent we want to update
     *   }
     * })
     */
    upsert<T extends WebsiteContentUpsertArgs>(args: SelectSubset<T, WebsiteContentUpsertArgs<ExtArgs>>): Prisma__WebsiteContentClient<$Result.GetResult<Prisma.$WebsiteContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebsiteContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteContentCountArgs} args - Arguments to filter WebsiteContents to count.
     * @example
     * // Count the number of WebsiteContents
     * const count = await prisma.websiteContent.count({
     *   where: {
     *     // ... the filter for the WebsiteContents we want to count
     *   }
     * })
    **/
    count<T extends WebsiteContentCountArgs>(
      args?: Subset<T, WebsiteContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebsiteContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebsiteContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebsiteContentAggregateArgs>(args: Subset<T, WebsiteContentAggregateArgs>): Prisma.PrismaPromise<GetWebsiteContentAggregateType<T>>

    /**
     * Group by WebsiteContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebsiteContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebsiteContentGroupByArgs['orderBy'] }
        : { orderBy?: WebsiteContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebsiteContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebsiteContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebsiteContent model
   */
  readonly fields: WebsiteContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebsiteContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebsiteContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebsiteContent model
   */ 
  interface WebsiteContentFieldRefs {
    readonly id: FieldRef<"WebsiteContent", 'String'>
    readonly contentKey: FieldRef<"WebsiteContent", 'String'>
    readonly contentType: FieldRef<"WebsiteContent", 'String'>
    readonly contentValue: FieldRef<"WebsiteContent", 'String'>
    readonly contentMetadata: FieldRef<"WebsiteContent", 'Json'>
    readonly section: FieldRef<"WebsiteContent", 'String'>
    readonly page: FieldRef<"WebsiteContent", 'String'>
    readonly isActive: FieldRef<"WebsiteContent", 'Boolean'>
    readonly displayOrder: FieldRef<"WebsiteContent", 'Int'>
    readonly createdAt: FieldRef<"WebsiteContent", 'DateTime'>
    readonly updatedAt: FieldRef<"WebsiteContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebsiteContent findUnique
   */
  export type WebsiteContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteContent
     */
    select?: WebsiteContentSelect<ExtArgs> | null
    /**
     * Filter, which WebsiteContent to fetch.
     */
    where: WebsiteContentWhereUniqueInput
  }

  /**
   * WebsiteContent findUniqueOrThrow
   */
  export type WebsiteContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteContent
     */
    select?: WebsiteContentSelect<ExtArgs> | null
    /**
     * Filter, which WebsiteContent to fetch.
     */
    where: WebsiteContentWhereUniqueInput
  }

  /**
   * WebsiteContent findFirst
   */
  export type WebsiteContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteContent
     */
    select?: WebsiteContentSelect<ExtArgs> | null
    /**
     * Filter, which WebsiteContent to fetch.
     */
    where?: WebsiteContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteContents to fetch.
     */
    orderBy?: WebsiteContentOrderByWithRelationInput | WebsiteContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebsiteContents.
     */
    cursor?: WebsiteContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebsiteContents.
     */
    distinct?: WebsiteContentScalarFieldEnum | WebsiteContentScalarFieldEnum[]
  }

  /**
   * WebsiteContent findFirstOrThrow
   */
  export type WebsiteContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteContent
     */
    select?: WebsiteContentSelect<ExtArgs> | null
    /**
     * Filter, which WebsiteContent to fetch.
     */
    where?: WebsiteContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteContents to fetch.
     */
    orderBy?: WebsiteContentOrderByWithRelationInput | WebsiteContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebsiteContents.
     */
    cursor?: WebsiteContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebsiteContents.
     */
    distinct?: WebsiteContentScalarFieldEnum | WebsiteContentScalarFieldEnum[]
  }

  /**
   * WebsiteContent findMany
   */
  export type WebsiteContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteContent
     */
    select?: WebsiteContentSelect<ExtArgs> | null
    /**
     * Filter, which WebsiteContents to fetch.
     */
    where?: WebsiteContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteContents to fetch.
     */
    orderBy?: WebsiteContentOrderByWithRelationInput | WebsiteContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebsiteContents.
     */
    cursor?: WebsiteContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteContents.
     */
    skip?: number
    distinct?: WebsiteContentScalarFieldEnum | WebsiteContentScalarFieldEnum[]
  }

  /**
   * WebsiteContent create
   */
  export type WebsiteContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteContent
     */
    select?: WebsiteContentSelect<ExtArgs> | null
    /**
     * The data needed to create a WebsiteContent.
     */
    data: XOR<WebsiteContentCreateInput, WebsiteContentUncheckedCreateInput>
  }

  /**
   * WebsiteContent createMany
   */
  export type WebsiteContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebsiteContents.
     */
    data: WebsiteContentCreateManyInput | WebsiteContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebsiteContent createManyAndReturn
   */
  export type WebsiteContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteContent
     */
    select?: WebsiteContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebsiteContents.
     */
    data: WebsiteContentCreateManyInput | WebsiteContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebsiteContent update
   */
  export type WebsiteContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteContent
     */
    select?: WebsiteContentSelect<ExtArgs> | null
    /**
     * The data needed to update a WebsiteContent.
     */
    data: XOR<WebsiteContentUpdateInput, WebsiteContentUncheckedUpdateInput>
    /**
     * Choose, which WebsiteContent to update.
     */
    where: WebsiteContentWhereUniqueInput
  }

  /**
   * WebsiteContent updateMany
   */
  export type WebsiteContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebsiteContents.
     */
    data: XOR<WebsiteContentUpdateManyMutationInput, WebsiteContentUncheckedUpdateManyInput>
    /**
     * Filter which WebsiteContents to update
     */
    where?: WebsiteContentWhereInput
  }

  /**
   * WebsiteContent upsert
   */
  export type WebsiteContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteContent
     */
    select?: WebsiteContentSelect<ExtArgs> | null
    /**
     * The filter to search for the WebsiteContent to update in case it exists.
     */
    where: WebsiteContentWhereUniqueInput
    /**
     * In case the WebsiteContent found by the `where` argument doesn't exist, create a new WebsiteContent with this data.
     */
    create: XOR<WebsiteContentCreateInput, WebsiteContentUncheckedCreateInput>
    /**
     * In case the WebsiteContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebsiteContentUpdateInput, WebsiteContentUncheckedUpdateInput>
  }

  /**
   * WebsiteContent delete
   */
  export type WebsiteContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteContent
     */
    select?: WebsiteContentSelect<ExtArgs> | null
    /**
     * Filter which WebsiteContent to delete.
     */
    where: WebsiteContentWhereUniqueInput
  }

  /**
   * WebsiteContent deleteMany
   */
  export type WebsiteContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebsiteContents to delete
     */
    where?: WebsiteContentWhereInput
  }

  /**
   * WebsiteContent without action
   */
  export type WebsiteContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteContent
     */
    select?: WebsiteContentSelect<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    isSystemRole: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    isSystemRole: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    isSystemRole: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    isSystemRole?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    isSystemRole?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    isSystemRole?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    isSystemRole: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    isSystemRole?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    isSystemRole?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    isSystemRole?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      users: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      isSystemRole: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly displayName: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly isSystemRole: FieldRef<"Role", 'Boolean'>
    readonly isActive: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    resource: string | null
    action: string | null
    isSystemPermission: boolean | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    resource: string | null
    action: string | null
    isSystemPermission: boolean | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    resource: number
    action: number
    isSystemPermission: number
    createdAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    resource?: true
    action?: true
    isSystemPermission?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    resource?: true
    action?: true
    isSystemPermission?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    resource?: true
    action?: true
    isSystemPermission?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    resource: string
    action: string
    isSystemPermission: boolean
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    isSystemPermission?: boolean
    createdAt?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    isSystemPermission?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    isSystemPermission?: boolean
    createdAt?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      resource: string
      action: string
      isSystemPermission: boolean
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly displayName: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly resource: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly isSystemPermission: FieldRef<"Permission", 'Boolean'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    roleId: string
    permissionId: string
    createdAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
  }

  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      permissionId: string
      createdAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    assignedBy: string | null
    assignedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    assignedBy: string | null
    assignedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    assignedBy: number
    assignedAt: number
    expiresAt: number
    isActive: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedBy?: true
    assignedAt?: true
    expiresAt?: true
    isActive?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedBy?: true
    assignedAt?: true
    expiresAt?: true
    isActive?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedBy?: true
    assignedAt?: true
    expiresAt?: true
    isActive?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    assignedBy: string | null
    assignedAt: Date
    expiresAt: Date | null
    isActive: boolean
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedBy?: boolean
    assignedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    assignedByUser?: boolean | UserRole$assignedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedBy?: boolean
    assignedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    assignedByUser?: boolean | UserRole$assignedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedBy?: boolean
    assignedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    assignedByUser?: boolean | UserRole$assignedByUserArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    assignedByUser?: boolean | UserRole$assignedByUserArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
      assignedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
      assignedBy: string | null
      assignedAt: Date
      expiresAt: Date | null
      isActive: boolean
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedByUser<T extends UserRole$assignedByUserArgs<ExtArgs> = {}>(args?: Subset<T, UserRole$assignedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
    readonly assignedBy: FieldRef<"UserRole", 'String'>
    readonly assignedAt: FieldRef<"UserRole", 'DateTime'>
    readonly expiresAt: FieldRef<"UserRole", 'DateTime'>
    readonly isActive: FieldRef<"UserRole", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole.assignedByUser
   */
  export type UserRole$assignedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const WorkspaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt',
    isActive: 'isActive',
    firstName: 'firstName',
    lastName: 'lastName',
    avatarUrl: 'avatarUrl',
    timezone: 'timezone',
    businessName: 'businessName',
    mobileNumber: 'mobileNumber',
    country: 'country',
    currency: 'currency',
    businessAddress: 'businessAddress',
    businessPhone: 'businessPhone',
    taxNumber: 'taxNumber',
    companySize: 'companySize',
    industry: 'industry'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WorkspaceUserScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    permissions: 'permissions',
    lastActiveAt: 'lastActiveAt'
  };

  export type WorkspaceUserScalarFieldEnum = (typeof WorkspaceUserScalarFieldEnum)[keyof typeof WorkspaceUserScalarFieldEnum]


  export const WorkspaceInvitationScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    email: 'email',
    role: 'role',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    acceptedAt: 'acceptedAt',
    invitedById: 'invitedById'
  };

  export type WorkspaceInvitationScalarFieldEnum = (typeof WorkspaceInvitationScalarFieldEnum)[keyof typeof WorkspaceInvitationScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    revokedAt: 'revokedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenHash: 'tokenHash',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SecurityEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventType: 'eventType',
    severity: 'severity',
    description: 'description',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    resolvedAt: 'resolvedAt'
  };

  export type SecurityEventScalarFieldEnum = (typeof SecurityEventScalarFieldEnum)[keyof typeof SecurityEventScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    userId: 'userId',
    openaiApiKeyEncrypted: 'openaiApiKeyEncrypted',
    elevenlabsApiKeyEncrypted: 'elevenlabsApiKeyEncrypted',
    preferredLanguage: 'preferredLanguage',
    summaryQuality: 'summaryQuality',
    defaultSummaryStyle: 'defaultSummaryStyle',
    defaultTemperature: 'defaultTemperature',
    defaultMaxTokens: 'defaultMaxTokens',
    showCostEstimates: 'showCostEstimates',
    emailNotifications: 'emailNotifications',
    processingNotifications: 'processingNotifications',
    settingsJson: 'settingsJson',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const WorkspaceSettingsScalarFieldEnum: {
    workspaceId: 'workspaceId',
    defaultProcessingOptions: 'defaultProcessingOptions',
    allowedFileTypes: 'allowedFileTypes',
    maxFileSize: 'maxFileSize',
    maxProcessingTime: 'maxProcessingTime',
    allowPublicSharing: 'allowPublicSharing',
    allowGuestAccess: 'allowGuestAccess',
    requireApprovalForUploads: 'requireApprovalForUploads',
    webhookUrl: 'webhookUrl',
    webhookSecret: 'webhookSecret',
    settingsJson: 'settingsJson',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceSettingsScalarFieldEnum = (typeof WorkspaceSettingsScalarFieldEnum)[keyof typeof WorkspaceSettingsScalarFieldEnum]


  export const ProcessingTemplateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    summaryStyle: 'summaryStyle',
    temperature: 'temperature',
    maxTokens: 'maxTokens',
    language: 'language',
    configJson: 'configJson',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProcessingTemplateScalarFieldEnum = (typeof ProcessingTemplateScalarFieldEnum)[keyof typeof ProcessingTemplateScalarFieldEnum]


  export const ApiKeyManagementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    provider: 'provider',
    keyName: 'keyName',
    encryptedKey: 'encryptedKey',
    keyHash: 'keyHash',
    isActive: 'isActive',
    lastUsedAt: 'lastUsedAt',
    expiresAt: 'expiresAt',
    totalRequests: 'totalRequests',
    totalTokens: 'totalTokens',
    totalCost: 'totalCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiKeyManagementScalarFieldEnum = (typeof ApiKeyManagementScalarFieldEnum)[keyof typeof ApiKeyManagementScalarFieldEnum]


  export const AudioUploadScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    originalFilename: 'originalFilename',
    fileSize: 'fileSize',
    fileType: 'fileType',
    mimeType: 'mimeType',
    duration: 'duration',
    sampleRate: 'sampleRate',
    channels: 'channels',
    bitrate: 'bitrate',
    storageProvider: 'storageProvider',
    storagePath: 'storagePath',
    storageUrl: 'storageUrl',
    cdnUrl: 'cdnUrl',
    checksumMd5: 'checksumMd5',
    checksumSha256: 'checksumSha256',
    status: 'status',
    uploadedAt: 'uploadedAt',
    processingStartedAt: 'processingStartedAt',
    completedAt: 'completedAt'
  };

  export type AudioUploadScalarFieldEnum = (typeof AudioUploadScalarFieldEnum)[keyof typeof AudioUploadScalarFieldEnum]


  export const ProcessingJobScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    uploadId: 'uploadId',
    jobType: 'jobType',
    priority: 'priority',
    processingOptions: 'processingOptions',
    status: 'status',
    progress: 'progress',
    cpuTimeMs: 'cpuTimeMs',
    memoryUsageMb: 'memoryUsageMb',
    queuedAt: 'queuedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorMessage: 'errorMessage',
    retryCount: 'retryCount',
    maxRetries: 'maxRetries'
  };

  export type ProcessingJobScalarFieldEnum = (typeof ProcessingJobScalarFieldEnum)[keyof typeof ProcessingJobScalarFieldEnum]


  export const AudioHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    uploadId: 'uploadId',
    title: 'title',
    audioUrl: 'audioUrl',
    cdnUrl: 'cdnUrl',
    fileSizeBytes: 'fileSizeBytes',
    durationSeconds: 'durationSeconds',
    transcript: 'transcript',
    summary: 'summary',
    keyMoments: 'keyMoments',
    language: 'language',
    confidence: 'confidence',
    wordCount: 'wordCount',
    speakerCount: 'speakerCount',
    processingOptions: 'processingOptions',
    processingTime: 'processingTime',
    apiProvider: 'apiProvider',
    modelVersion: 'modelVersion',
    transcriptionCost: 'transcriptionCost',
    summarizationCost: 'summarizationCost',
    totalCost: 'totalCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AudioHistoryScalarFieldEnum = (typeof AudioHistoryScalarFieldEnum)[keyof typeof AudioHistoryScalarFieldEnum]


  export const AudioSegmentScalarFieldEnum: {
    id: 'id',
    historyId: 'historyId',
    segmentIndex: 'segmentIndex',
    startTime: 'startTime',
    endTime: 'endTime',
    text: 'text',
    confidence: 'confidence',
    language: 'language',
    speakerId: 'speakerId',
    emotion: 'emotion',
    sentiment: 'sentiment',
    tokens: 'tokens',
    logprobs: 'logprobs',
    temperature: 'temperature',
    avgLogprob: 'avgLogprob',
    compressionRatio: 'compressionRatio',
    noSpeechProb: 'noSpeechProb'
  };

  export type AudioSegmentScalarFieldEnum = (typeof AudioSegmentScalarFieldEnum)[keyof typeof AudioSegmentScalarFieldEnum]


  export const AudioChunkScalarFieldEnum: {
    id: 'id',
    uploadId: 'uploadId',
    chunkIndex: 'chunkIndex',
    startTime: 'startTime',
    endTime: 'endTime',
    fileSize: 'fileSize',
    storagePath: 'storagePath',
    checksumMd5: 'checksumMd5',
    status: 'status',
    processedAt: 'processedAt'
  };

  export type AudioChunkScalarFieldEnum = (typeof AudioChunkScalarFieldEnum)[keyof typeof AudioChunkScalarFieldEnum]


  export const AudioProjectScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    color: 'color',
    status: 'status',
    isPublic: 'isPublic',
    tags: 'tags',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AudioProjectScalarFieldEnum = (typeof AudioProjectScalarFieldEnum)[keyof typeof AudioProjectScalarFieldEnum]


  export const UsageMetricScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    metricType: 'metricType',
    provider: 'provider',
    quantity: 'quantity',
    cost: 'cost',
    currency: 'currency',
    metadata: 'metadata',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    recordedAt: 'recordedAt'
  };

  export type UsageMetricScalarFieldEnum = (typeof UsageMetricScalarFieldEnum)[keyof typeof UsageMetricScalarFieldEnum]


  export const UserQuotaScalarFieldEnum: {
    userId: 'userId',
    monthlyApiCalls: 'monthlyApiCalls',
    monthlyTokens: 'monthlyTokens',
    monthlyStorageMb: 'monthlyStorageMb',
    monthlyProcessingMin: 'monthlyProcessingMin',
    currentApiCalls: 'currentApiCalls',
    currentTokens: 'currentTokens',
    currentStorageMb: 'currentStorageMb',
    currentProcessingMin: 'currentProcessingMin',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    lastResetAt: 'lastResetAt',
    allowOverages: 'allowOverages',
    overageCostPerToken: 'overageCostPerToken'
  };

  export type UserQuotaScalarFieldEnum = (typeof UserQuotaScalarFieldEnum)[keyof typeof UserQuotaScalarFieldEnum]


  export const StorageQuotaScalarFieldEnum: {
    workspaceId: 'workspaceId',
    maxStorageBytes: 'maxStorageBytes',
    maxFileCount: 'maxFileCount',
    maxFileSize: 'maxFileSize',
    currentStorageBytes: 'currentStorageBytes',
    currentFileCount: 'currentFileCount',
    retentionDays: 'retentionDays',
    autoCleanup: 'autoCleanup',
    updatedAt: 'updatedAt'
  };

  export type StorageQuotaScalarFieldEnum = (typeof StorageQuotaScalarFieldEnum)[keyof typeof StorageQuotaScalarFieldEnum]


  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    planCode: 'planCode',
    price: 'price',
    currency: 'currency',
    billingInterval: 'billingInterval',
    tier: 'tier',
    sortOrder: 'sortOrder',
    maxApiCalls: 'maxApiCalls',
    maxTokens: 'maxTokens',
    maxStorageMb: 'maxStorageMb',
    maxProcessingMin: 'maxProcessingMin',
    maxWorkspaces: 'maxWorkspaces',
    maxUsers: 'maxUsers',
    maxFileSize: 'maxFileSize',
    maxTranscriptionsMonthly: 'maxTranscriptionsMonthly',
    maxFilesDaily: 'maxFilesDaily',
    maxFilesMonthly: 'maxFilesMonthly',
    maxConcurrentJobs: 'maxConcurrentJobs',
    maxVoiceSynthesisMonthly: 'maxVoiceSynthesisMonthly',
    maxExportOperationsMonthly: 'maxExportOperationsMonthly',
    maxAudioDurationMinutes: 'maxAudioDurationMinutes',
    priorityLevel: 'priorityLevel',
    planCategory: 'planCategory',
    trialDays: 'trialDays',
    isCustom: 'isCustom',
    isEnterprise: 'isEnterprise',
    features: 'features',
    recommendedFor: 'recommendedFor',
    allowedFileTypes: 'allowedFileTypes',
    analysisFeatures: 'analysisFeatures',
    collaborationFeatures: 'collaborationFeatures',
    integrationFeatures: 'integrationFeatures',
    isActive: 'isActive',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


  export const PlanPricingScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    currency: 'currency',
    price: 'price',
    billingPeriod: 'billingPeriod',
    region: 'region',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanPricingScalarFieldEnum = (typeof PlanPricingScalarFieldEnum)[keyof typeof PlanPricingScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    symbol: 'symbol',
    exchangeRate: 'exchangeRate',
    lastUpdated: 'lastUpdated',
    isActive: 'isActive',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const WorkspaceSubscriptionScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    planId: 'planId',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    nextBillingDate: 'nextBillingDate',
    trialEnd: 'trialEnd',
    paymentGateway: 'paymentGateway',
    paymentMethodId: 'paymentMethodId',
    currency: 'currency',
    amount: 'amount',
    ewayCustomerId: 'ewayCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripeCustomerId: 'stripeCustomerId',
    cancelledAt: 'cancelledAt',
    cancelReason: 'cancelReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceSubscriptionScalarFieldEnum = (typeof WorkspaceSubscriptionScalarFieldEnum)[keyof typeof WorkspaceSubscriptionScalarFieldEnum]


  export const BillingRecordScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    invoiceNumber: 'invoiceNumber',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    paymentMethod: 'paymentMethod',
    invoiceDate: 'invoiceDate',
    dueDate: 'dueDate',
    paidAt: 'paidAt',
    stripeInvoiceId: 'stripeInvoiceId',
    ewayTransactionId: 'ewayTransactionId',
    invoiceUrl: 'invoiceUrl',
    failureReason: 'failureReason',
    usageDetails: 'usageDetails',
    createdAt: 'createdAt'
  };

  export type BillingRecordScalarFieldEnum = (typeof BillingRecordScalarFieldEnum)[keyof typeof BillingRecordScalarFieldEnum]


  export const UsageRecordScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    recordType: 'recordType',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalCost: 'totalCost',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type UsageRecordScalarFieldEnum = (typeof UsageRecordScalarFieldEnum)[keyof typeof UsageRecordScalarFieldEnum]


  export const UsageCounterScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    periodType: 'periodType',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    transcriptionsUsed: 'transcriptionsUsed',
    filesUploaded: 'filesUploaded',
    voiceSynthesisUsed: 'voiceSynthesisUsed',
    exportOperationsUsed: 'exportOperationsUsed',
    totalProcessingMinutes: 'totalProcessingMinutes',
    concurrentJobsPeak: 'concurrentJobsPeak',
    featureUsage: 'featureUsage',
    lastResetAt: 'lastResetAt',
    autoReset: 'autoReset',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsageCounterScalarFieldEnum = (typeof UsageCounterScalarFieldEnum)[keyof typeof UsageCounterScalarFieldEnum]


  export const PlanRecommendationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    currentPlanId: 'currentPlanId',
    recommendedPlanId: 'recommendedPlanId',
    recommendationReason: 'recommendationReason',
    confidenceScore: 'confidenceScore',
    usagePattern: 'usagePattern',
    projectedSavings: 'projectedSavings',
    roiMonths: 'roiMonths',
    triggeredBy: 'triggeredBy',
    benefits: 'benefits',
    limitationsRemoved: 'limitationsRemoved',
    status: 'status',
    viewedAt: 'viewedAt',
    dismissedAt: 'dismissedAt',
    acceptedAt: 'acceptedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanRecommendationScalarFieldEnum = (typeof PlanRecommendationScalarFieldEnum)[keyof typeof PlanRecommendationScalarFieldEnum]


  export const CustomPlanScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    basePlanId: 'basePlanId',
    planName: 'planName',
    description: 'description',
    customMaxTranscriptionsMonthly: 'customMaxTranscriptionsMonthly',
    customMaxFilesDaily: 'customMaxFilesDaily',
    customMaxFilesMonthly: 'customMaxFilesMonthly',
    customMaxConcurrentJobs: 'customMaxConcurrentJobs',
    customMaxVoiceSynthesisMonthly: 'customMaxVoiceSynthesisMonthly',
    customMaxExportOperationsMonthly: 'customMaxExportOperationsMonthly',
    customMaxAudioDurationMinutes: 'customMaxAudioDurationMinutes',
    customPriorityLevel: 'customPriorityLevel',
    customFeatures: 'customFeatures',
    excludedFeatures: 'excludedFeatures',
    additionalFeatures: 'additionalFeatures',
    customPrice: 'customPrice',
    pricingModel: 'pricingModel',
    billingInterval: 'billingInterval',
    contractStartDate: 'contractStartDate',
    contractEndDate: 'contractEndDate',
    autoRenew: 'autoRenew',
    noticePeriodDays: 'noticePeriodDays',
    requestedBy: 'requestedBy',
    approvedBy: 'approvedBy',
    approvalStatus: 'approvalStatus',
    approvalNotes: 'approvalNotes',
    isActive: 'isActive',
    activatedAt: 'activatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomPlanScalarFieldEnum = (typeof CustomPlanScalarFieldEnum)[keyof typeof CustomPlanScalarFieldEnum]


  export const FeatureFlagScalarFieldEnum: {
    id: 'id',
    featureName: 'featureName',
    displayName: 'displayName',
    description: 'description',
    category: 'category',
    featureType: 'featureType',
    minPlanLevel: 'minPlanLevel',
    requiredPlans: 'requiredPlans',
    excludedPlans: 'excludedPlans',
    isEnabled: 'isEnabled',
    isBeta: 'isBeta',
    isDeprecated: 'isDeprecated',
    usageCount: 'usageCount',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureFlagScalarFieldEnum = (typeof FeatureFlagScalarFieldEnum)[keyof typeof FeatureFlagScalarFieldEnum]


  export const PlanFeatureMatrixScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    featureFlagId: 'featureFlagId',
    isEnabled: 'isEnabled',
    usageLimit: 'usageLimit',
    includedUsage: 'includedUsage',
    overageRate: 'overageRate',
    createdAt: 'createdAt'
  };

  export type PlanFeatureMatrixScalarFieldEnum = (typeof PlanFeatureMatrixScalarFieldEnum)[keyof typeof PlanFeatureMatrixScalarFieldEnum]


  export const EwayCustomerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ewayCustomerToken: 'ewayCustomerToken',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    companyName: 'companyName',
    country: 'country',
    streetAddress: 'streetAddress',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    phoneNumber: 'phoneNumber',
    cardLastFour: 'cardLastFour',
    cardType: 'cardType',
    cardExpiryMonth: 'cardExpiryMonth',
    cardExpiryYear: 'cardExpiryYear',
    ewayReference: 'ewayReference',
    isActive: 'isActive',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EwayCustomerScalarFieldEnum = (typeof EwayCustomerScalarFieldEnum)[keyof typeof EwayCustomerScalarFieldEnum]


  export const EwayTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    ewayCustomerId: 'ewayCustomerId',
    subscriptionId: 'subscriptionId',
    transactionType: 'transactionType',
    amount: 'amount',
    currency: 'currency',
    ewayTransactionId: 'ewayTransactionId',
    ewayAccessCode: 'ewayAccessCode',
    ewayAuthCode: 'ewayAuthCode',
    responseCode: 'responseCode',
    responseMessage: 'responseMessage',
    transactionStatus: 'transactionStatus',
    isRecurring: 'isRecurring',
    ewayInvoiceNumber: 'ewayInvoiceNumber',
    ewayInvoiceReference: 'ewayInvoiceReference',
    fraudAction: 'fraudAction',
    verificationStatus: 'verificationStatus',
    beagleScore: 'beagleScore',
    errorCode: 'errorCode',
    errorMessage: 'errorMessage',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    ewayRawResponse: 'ewayRawResponse'
  };

  export type EwayTransactionScalarFieldEnum = (typeof EwayTransactionScalarFieldEnum)[keyof typeof EwayTransactionScalarFieldEnum]


  export const EwayRecurringScheduleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    ewayCustomerId: 'ewayCustomerId',
    subscriptionId: 'subscriptionId',
    scheduleType: 'scheduleType',
    billingAmount: 'billingAmount',
    currency: 'currency',
    startDate: 'startDate',
    nextBillingDate: 'nextBillingDate',
    lastProcessedAt: 'lastProcessedAt',
    status: 'status',
    failedAttempts: 'failedAttempts',
    lastTransactionId: 'lastTransactionId',
    cancelledAt: 'cancelledAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EwayRecurringScheduleScalarFieldEnum = (typeof EwayRecurringScheduleScalarFieldEnum)[keyof typeof EwayRecurringScheduleScalarFieldEnum]


  export const EwayWebhookEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    ewayTransactionId: 'ewayTransactionId',
    ewayCustomerToken: 'ewayCustomerToken',
    eventData: 'eventData',
    rawPayload: 'rawPayload',
    processed: 'processed',
    processedAt: 'processedAt',
    sourceIp: 'sourceIp',
    createdAt: 'createdAt'
  };

  export type EwayWebhookEventScalarFieldEnum = (typeof EwayWebhookEventScalarFieldEnum)[keyof typeof EwayWebhookEventScalarFieldEnum]


  export const ExportHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    exportType: 'exportType',
    dataType: 'dataType',
    dateFrom: 'dateFrom',
    dateTo: 'dateTo',
    workspaceIds: 'workspaceIds',
    filters: 'filters',
    filename: 'filename',
    fileSize: 'fileSize',
    storagePath: 'storagePath',
    downloadUrl: 'downloadUrl',
    expiresAt: 'expiresAt',
    status: 'status',
    downloadCount: 'downloadCount',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type ExportHistoryScalarFieldEnum = (typeof ExportHistoryScalarFieldEnum)[keyof typeof ExportHistoryScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    requestId: 'requestId',
    details: 'details',
    oldValues: 'oldValues',
    newValues: 'newValues',
    severity: 'severity',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const DataRetentionPolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    dataType: 'dataType',
    retentionDays: 'retentionDays',
    autoDelete: 'autoDelete',
    archiveBeforeDelete: 'archiveBeforeDelete',
    appliesToWorkspaces: 'appliesToWorkspaces',
    excludeWorkspaces: 'excludeWorkspaces',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastRunAt: 'lastRunAt'
  };

  export type DataRetentionPolicyScalarFieldEnum = (typeof DataRetentionPolicyScalarFieldEnum)[keyof typeof DataRetentionPolicyScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    provider: 'provider',
    providerMethodId: 'providerMethodId',
    type: 'type',
    last4: 'last4',
    brand: 'brand',
    expiryMonth: 'expiryMonth',
    expiryYear: 'expiryYear',
    isDefault: 'isDefault',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const TestimonialScalarFieldEnum: {
    id: 'id',
    customerName: 'customerName',
    customerRole: 'customerRole',
    companyName: 'companyName',
    avatarUrl: 'avatarUrl',
    content: 'content',
    rating: 'rating',
    featuredOn: 'featuredOn',
    useCase: 'useCase',
    isVerified: 'isVerified',
    verificationMethod: 'verificationMethod',
    isActive: 'isActive',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type TestimonialScalarFieldEnum = (typeof TestimonialScalarFieldEnum)[keyof typeof TestimonialScalarFieldEnum]


  export const WebsiteContentScalarFieldEnum: {
    id: 'id',
    contentKey: 'contentKey',
    contentType: 'contentType',
    contentValue: 'contentValue',
    contentMetadata: 'contentMetadata',
    section: 'section',
    page: 'page',
    isActive: 'isActive',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebsiteContentScalarFieldEnum = (typeof WebsiteContentScalarFieldEnum)[keyof typeof WebsiteContentScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    isSystemRole: 'isSystemRole',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    resource: 'resource',
    action: 'action',
    isSystemPermission: 'isSystemPermission',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    assignedBy: 'assignedBy',
    assignedAt: 'assignedAt',
    expiresAt: 'expiresAt',
    isActive: 'isActive'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type WorkspaceWhereInput = {
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    id?: StringFilter<"Workspace"> | string
    name?: StringFilter<"Workspace"> | string
    slug?: StringFilter<"Workspace"> | string
    description?: StringNullableFilter<"Workspace"> | string | null
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    isActive?: BoolFilter<"Workspace"> | boolean
    users?: WorkspaceUserListRelationFilter
    invitations?: WorkspaceInvitationListRelationFilter
    audioHistory?: AudioHistoryListRelationFilter
    audioUploads?: AudioUploadListRelationFilter
    projects?: AudioProjectListRelationFilter
    settings?: XOR<WorkspaceSettingsNullableRelationFilter, WorkspaceSettingsWhereInput> | null
    usageMetrics?: UsageMetricListRelationFilter
    storageQuota?: XOR<StorageQuotaNullableRelationFilter, StorageQuotaWhereInput> | null
    subscriptions?: WorkspaceSubscriptionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type WorkspaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    users?: WorkspaceUserOrderByRelationAggregateInput
    invitations?: WorkspaceInvitationOrderByRelationAggregateInput
    audioHistory?: AudioHistoryOrderByRelationAggregateInput
    audioUploads?: AudioUploadOrderByRelationAggregateInput
    projects?: AudioProjectOrderByRelationAggregateInput
    settings?: WorkspaceSettingsOrderByWithRelationInput
    usageMetrics?: UsageMetricOrderByRelationAggregateInput
    storageQuota?: StorageQuotaOrderByWithRelationInput
    subscriptions?: WorkspaceSubscriptionOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type WorkspaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    name?: StringFilter<"Workspace"> | string
    description?: StringNullableFilter<"Workspace"> | string | null
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    isActive?: BoolFilter<"Workspace"> | boolean
    users?: WorkspaceUserListRelationFilter
    invitations?: WorkspaceInvitationListRelationFilter
    audioHistory?: AudioHistoryListRelationFilter
    audioUploads?: AudioUploadListRelationFilter
    projects?: AudioProjectListRelationFilter
    settings?: XOR<WorkspaceSettingsNullableRelationFilter, WorkspaceSettingsWhereInput> | null
    usageMetrics?: UsageMetricListRelationFilter
    storageQuota?: XOR<StorageQuotaNullableRelationFilter, StorageQuotaWhereInput> | null
    subscriptions?: WorkspaceSubscriptionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "slug">

  export type WorkspaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    _count?: WorkspaceCountOrderByAggregateInput
    _max?: WorkspaceMaxOrderByAggregateInput
    _min?: WorkspaceMinOrderByAggregateInput
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    OR?: WorkspaceScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workspace"> | string
    name?: StringWithAggregatesFilter<"Workspace"> | string
    slug?: StringWithAggregatesFilter<"Workspace"> | string
    description?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Workspace"> | boolean
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    timezone?: StringNullableFilter<"User"> | string | null
    businessName?: StringNullableFilter<"User"> | string | null
    mobileNumber?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    currency?: StringNullableFilter<"User"> | string | null
    businessAddress?: StringNullableFilter<"User"> | string | null
    businessPhone?: StringNullableFilter<"User"> | string | null
    taxNumber?: StringNullableFilter<"User"> | string | null
    companySize?: StringNullableFilter<"User"> | string | null
    industry?: StringNullableFilter<"User"> | string | null
    audioHistory?: AudioHistoryListRelationFilter
    sessions?: SessionListRelationFilter
    settings?: XOR<UserSettingsNullableRelationFilter, UserSettingsWhereInput> | null
    workspaces?: WorkspaceUserListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    audioUploads?: AudioUploadListRelationFilter
    projects?: AudioProjectListRelationFilter
    processingJobs?: ProcessingJobListRelationFilter
    usageMetrics?: UsageMetricListRelationFilter
    exports?: ExportHistoryListRelationFilter
    apiKeys?: ApiKeyManagementListRelationFilter
    quota?: XOR<UserQuotaNullableRelationFilter, UserQuotaWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    securityEvents?: SecurityEventListRelationFilter
    processingTemplates?: ProcessingTemplateListRelationFilter
    customPlans?: CustomPlanListRelationFilter
    planRecommendations?: PlanRecommendationListRelationFilter
    usageCounters?: UsageCounterListRelationFilter
    ewayCustomers?: EwayCustomerListRelationFilter
    ewayTransactions?: EwayTransactionListRelationFilter
    ewayRecurringSchedules?: EwayRecurringScheduleListRelationFilter
    userRoles?: UserRoleListRelationFilter
    assignedRoles?: UserRoleListRelationFilter
    testimonials?: TestimonialListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    mobileNumber?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    businessAddress?: SortOrderInput | SortOrder
    businessPhone?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    audioHistory?: AudioHistoryOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    settings?: UserSettingsOrderByWithRelationInput
    workspaces?: WorkspaceUserOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    audioUploads?: AudioUploadOrderByRelationAggregateInput
    projects?: AudioProjectOrderByRelationAggregateInput
    processingJobs?: ProcessingJobOrderByRelationAggregateInput
    usageMetrics?: UsageMetricOrderByRelationAggregateInput
    exports?: ExportHistoryOrderByRelationAggregateInput
    apiKeys?: ApiKeyManagementOrderByRelationAggregateInput
    quota?: UserQuotaOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    securityEvents?: SecurityEventOrderByRelationAggregateInput
    processingTemplates?: ProcessingTemplateOrderByRelationAggregateInput
    customPlans?: CustomPlanOrderByRelationAggregateInput
    planRecommendations?: PlanRecommendationOrderByRelationAggregateInput
    usageCounters?: UsageCounterOrderByRelationAggregateInput
    ewayCustomers?: EwayCustomerOrderByRelationAggregateInput
    ewayTransactions?: EwayTransactionOrderByRelationAggregateInput
    ewayRecurringSchedules?: EwayRecurringScheduleOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
    assignedRoles?: UserRoleOrderByRelationAggregateInput
    testimonials?: TestimonialOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    timezone?: StringNullableFilter<"User"> | string | null
    businessName?: StringNullableFilter<"User"> | string | null
    mobileNumber?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    currency?: StringNullableFilter<"User"> | string | null
    businessAddress?: StringNullableFilter<"User"> | string | null
    businessPhone?: StringNullableFilter<"User"> | string | null
    taxNumber?: StringNullableFilter<"User"> | string | null
    companySize?: StringNullableFilter<"User"> | string | null
    industry?: StringNullableFilter<"User"> | string | null
    audioHistory?: AudioHistoryListRelationFilter
    sessions?: SessionListRelationFilter
    settings?: XOR<UserSettingsNullableRelationFilter, UserSettingsWhereInput> | null
    workspaces?: WorkspaceUserListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    audioUploads?: AudioUploadListRelationFilter
    projects?: AudioProjectListRelationFilter
    processingJobs?: ProcessingJobListRelationFilter
    usageMetrics?: UsageMetricListRelationFilter
    exports?: ExportHistoryListRelationFilter
    apiKeys?: ApiKeyManagementListRelationFilter
    quota?: XOR<UserQuotaNullableRelationFilter, UserQuotaWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    securityEvents?: SecurityEventListRelationFilter
    processingTemplates?: ProcessingTemplateListRelationFilter
    customPlans?: CustomPlanListRelationFilter
    planRecommendations?: PlanRecommendationListRelationFilter
    usageCounters?: UsageCounterListRelationFilter
    ewayCustomers?: EwayCustomerListRelationFilter
    ewayTransactions?: EwayTransactionListRelationFilter
    ewayRecurringSchedules?: EwayRecurringScheduleListRelationFilter
    userRoles?: UserRoleListRelationFilter
    assignedRoles?: UserRoleListRelationFilter
    testimonials?: TestimonialListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    mobileNumber?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    businessAddress?: SortOrderInput | SortOrder
    businessPhone?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"User"> | string | null
    businessName?: StringNullableWithAggregatesFilter<"User"> | string | null
    mobileNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    currency?: StringNullableWithAggregatesFilter<"User"> | string | null
    businessAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    businessPhone?: StringNullableWithAggregatesFilter<"User"> | string | null
    taxNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    companySize?: StringNullableWithAggregatesFilter<"User"> | string | null
    industry?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type WorkspaceUserWhereInput = {
    AND?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    OR?: WorkspaceUserWhereInput[]
    NOT?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    id?: StringFilter<"WorkspaceUser"> | string
    workspaceId?: StringFilter<"WorkspaceUser"> | string
    userId?: StringFilter<"WorkspaceUser"> | string
    role?: StringFilter<"WorkspaceUser"> | string
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    permissions?: JsonNullableFilter<"WorkspaceUser">
    lastActiveAt?: DateTimeNullableFilter<"WorkspaceUser"> | Date | string | null
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WorkspaceUserOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    permissions?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type WorkspaceUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_userId?: WorkspaceUserWorkspaceIdUserIdCompoundUniqueInput
    AND?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    OR?: WorkspaceUserWhereInput[]
    NOT?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    workspaceId?: StringFilter<"WorkspaceUser"> | string
    userId?: StringFilter<"WorkspaceUser"> | string
    role?: StringFilter<"WorkspaceUser"> | string
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    permissions?: JsonNullableFilter<"WorkspaceUser">
    lastActiveAt?: DateTimeNullableFilter<"WorkspaceUser"> | Date | string | null
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "workspaceId_userId">

  export type WorkspaceUserOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    permissions?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    _count?: WorkspaceUserCountOrderByAggregateInput
    _max?: WorkspaceUserMaxOrderByAggregateInput
    _min?: WorkspaceUserMinOrderByAggregateInput
  }

  export type WorkspaceUserScalarWhereWithAggregatesInput = {
    AND?: WorkspaceUserScalarWhereWithAggregatesInput | WorkspaceUserScalarWhereWithAggregatesInput[]
    OR?: WorkspaceUserScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceUserScalarWhereWithAggregatesInput | WorkspaceUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    userId?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    role?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"WorkspaceUser"> | Date | string
    permissions?: JsonNullableWithAggregatesFilter<"WorkspaceUser">
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"WorkspaceUser"> | Date | string | null
  }

  export type WorkspaceInvitationWhereInput = {
    AND?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    OR?: WorkspaceInvitationWhereInput[]
    NOT?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    id?: StringFilter<"WorkspaceInvitation"> | string
    workspaceId?: StringFilter<"WorkspaceInvitation"> | string
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: StringFilter<"WorkspaceInvitation"> | string
    token?: StringFilter<"WorkspaceInvitation"> | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"WorkspaceInvitation"> | Date | string | null
    invitedById?: StringNullableFilter<"WorkspaceInvitation"> | string | null
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type WorkspaceInvitationOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    invitedById?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type WorkspaceInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    OR?: WorkspaceInvitationWhereInput[]
    NOT?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    workspaceId?: StringFilter<"WorkspaceInvitation"> | string
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: StringFilter<"WorkspaceInvitation"> | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"WorkspaceInvitation"> | Date | string | null
    invitedById?: StringNullableFilter<"WorkspaceInvitation"> | string | null
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id" | "token">

  export type WorkspaceInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    invitedById?: SortOrderInput | SortOrder
    _count?: WorkspaceInvitationCountOrderByAggregateInput
    _max?: WorkspaceInvitationMaxOrderByAggregateInput
    _min?: WorkspaceInvitationMinOrderByAggregateInput
  }

  export type WorkspaceInvitationScalarWhereWithAggregatesInput = {
    AND?: WorkspaceInvitationScalarWhereWithAggregatesInput | WorkspaceInvitationScalarWhereWithAggregatesInput[]
    OR?: WorkspaceInvitationScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceInvitationScalarWhereWithAggregatesInput | WorkspaceInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    email?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    role?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    token?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"WorkspaceInvitation"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"WorkspaceInvitation"> | Date | string | null
    invitedById?: StringNullableWithAggregatesFilter<"WorkspaceInvitation"> | string | null
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    tokenHash?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "tokenHash">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    tokenHash?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
  }

  export type SecurityEventWhereInput = {
    AND?: SecurityEventWhereInput | SecurityEventWhereInput[]
    OR?: SecurityEventWhereInput[]
    NOT?: SecurityEventWhereInput | SecurityEventWhereInput[]
    id?: StringFilter<"SecurityEvent"> | string
    userId?: StringNullableFilter<"SecurityEvent"> | string | null
    eventType?: StringFilter<"SecurityEvent"> | string
    severity?: StringFilter<"SecurityEvent"> | string
    description?: StringNullableFilter<"SecurityEvent"> | string | null
    metadata?: JsonNullableFilter<"SecurityEvent">
    ipAddress?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"SecurityEvent"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type SecurityEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SecurityEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityEventWhereInput | SecurityEventWhereInput[]
    OR?: SecurityEventWhereInput[]
    NOT?: SecurityEventWhereInput | SecurityEventWhereInput[]
    userId?: StringNullableFilter<"SecurityEvent"> | string | null
    eventType?: StringFilter<"SecurityEvent"> | string
    severity?: StringFilter<"SecurityEvent"> | string
    description?: StringNullableFilter<"SecurityEvent"> | string | null
    metadata?: JsonNullableFilter<"SecurityEvent">
    ipAddress?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"SecurityEvent"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type SecurityEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: SecurityEventCountOrderByAggregateInput
    _max?: SecurityEventMaxOrderByAggregateInput
    _min?: SecurityEventMinOrderByAggregateInput
  }

  export type SecurityEventScalarWhereWithAggregatesInput = {
    AND?: SecurityEventScalarWhereWithAggregatesInput | SecurityEventScalarWhereWithAggregatesInput[]
    OR?: SecurityEventScalarWhereWithAggregatesInput[]
    NOT?: SecurityEventScalarWhereWithAggregatesInput | SecurityEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityEvent"> | string
    userId?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    eventType?: StringWithAggregatesFilter<"SecurityEvent"> | string
    severity?: StringWithAggregatesFilter<"SecurityEvent"> | string
    description?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"SecurityEvent">
    ipAddress?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecurityEvent"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"SecurityEvent"> | Date | string | null
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    userId?: StringFilter<"UserSettings"> | string
    openaiApiKeyEncrypted?: StringNullableFilter<"UserSettings"> | string | null
    elevenlabsApiKeyEncrypted?: StringNullableFilter<"UserSettings"> | string | null
    preferredLanguage?: StringFilter<"UserSettings"> | string
    summaryQuality?: StringFilter<"UserSettings"> | string
    defaultSummaryStyle?: StringFilter<"UserSettings"> | string
    defaultTemperature?: FloatFilter<"UserSettings"> | number
    defaultMaxTokens?: IntFilter<"UserSettings"> | number
    showCostEstimates?: BoolFilter<"UserSettings"> | boolean
    emailNotifications?: BoolFilter<"UserSettings"> | boolean
    processingNotifications?: BoolFilter<"UserSettings"> | boolean
    settingsJson?: JsonFilter<"UserSettings">
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    userId?: SortOrder
    openaiApiKeyEncrypted?: SortOrderInput | SortOrder
    elevenlabsApiKeyEncrypted?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrder
    summaryQuality?: SortOrder
    defaultSummaryStyle?: SortOrder
    defaultTemperature?: SortOrder
    defaultMaxTokens?: SortOrder
    showCostEstimates?: SortOrder
    emailNotifications?: SortOrder
    processingNotifications?: SortOrder
    settingsJson?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    openaiApiKeyEncrypted?: StringNullableFilter<"UserSettings"> | string | null
    elevenlabsApiKeyEncrypted?: StringNullableFilter<"UserSettings"> | string | null
    preferredLanguage?: StringFilter<"UserSettings"> | string
    summaryQuality?: StringFilter<"UserSettings"> | string
    defaultSummaryStyle?: StringFilter<"UserSettings"> | string
    defaultTemperature?: FloatFilter<"UserSettings"> | number
    defaultMaxTokens?: IntFilter<"UserSettings"> | number
    showCostEstimates?: BoolFilter<"UserSettings"> | boolean
    emailNotifications?: BoolFilter<"UserSettings"> | boolean
    processingNotifications?: BoolFilter<"UserSettings"> | boolean
    settingsJson?: JsonFilter<"UserSettings">
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    userId?: SortOrder
    openaiApiKeyEncrypted?: SortOrderInput | SortOrder
    elevenlabsApiKeyEncrypted?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrder
    summaryQuality?: SortOrder
    defaultSummaryStyle?: SortOrder
    defaultTemperature?: SortOrder
    defaultMaxTokens?: SortOrder
    showCostEstimates?: SortOrder
    emailNotifications?: SortOrder
    processingNotifications?: SortOrder
    settingsJson?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _avg?: UserSettingsAvgOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
    _sum?: UserSettingsSumOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    openaiApiKeyEncrypted?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    elevenlabsApiKeyEncrypted?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    preferredLanguage?: StringWithAggregatesFilter<"UserSettings"> | string
    summaryQuality?: StringWithAggregatesFilter<"UserSettings"> | string
    defaultSummaryStyle?: StringWithAggregatesFilter<"UserSettings"> | string
    defaultTemperature?: FloatWithAggregatesFilter<"UserSettings"> | number
    defaultMaxTokens?: IntWithAggregatesFilter<"UserSettings"> | number
    showCostEstimates?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    emailNotifications?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    processingNotifications?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    settingsJson?: JsonWithAggregatesFilter<"UserSettings">
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type WorkspaceSettingsWhereInput = {
    AND?: WorkspaceSettingsWhereInput | WorkspaceSettingsWhereInput[]
    OR?: WorkspaceSettingsWhereInput[]
    NOT?: WorkspaceSettingsWhereInput | WorkspaceSettingsWhereInput[]
    workspaceId?: StringFilter<"WorkspaceSettings"> | string
    defaultProcessingOptions?: JsonFilter<"WorkspaceSettings">
    allowedFileTypes?: StringNullableListFilter<"WorkspaceSettings">
    maxFileSize?: BigIntFilter<"WorkspaceSettings"> | bigint | number
    maxProcessingTime?: IntFilter<"WorkspaceSettings"> | number
    allowPublicSharing?: BoolFilter<"WorkspaceSettings"> | boolean
    allowGuestAccess?: BoolFilter<"WorkspaceSettings"> | boolean
    requireApprovalForUploads?: BoolFilter<"WorkspaceSettings"> | boolean
    webhookUrl?: StringNullableFilter<"WorkspaceSettings"> | string | null
    webhookSecret?: StringNullableFilter<"WorkspaceSettings"> | string | null
    settingsJson?: JsonFilter<"WorkspaceSettings">
    updatedAt?: DateTimeFilter<"WorkspaceSettings"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type WorkspaceSettingsOrderByWithRelationInput = {
    workspaceId?: SortOrder
    defaultProcessingOptions?: SortOrder
    allowedFileTypes?: SortOrder
    maxFileSize?: SortOrder
    maxProcessingTime?: SortOrder
    allowPublicSharing?: SortOrder
    allowGuestAccess?: SortOrder
    requireApprovalForUploads?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    webhookSecret?: SortOrderInput | SortOrder
    settingsJson?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type WorkspaceSettingsWhereUniqueInput = Prisma.AtLeast<{
    workspaceId?: string
    AND?: WorkspaceSettingsWhereInput | WorkspaceSettingsWhereInput[]
    OR?: WorkspaceSettingsWhereInput[]
    NOT?: WorkspaceSettingsWhereInput | WorkspaceSettingsWhereInput[]
    defaultProcessingOptions?: JsonFilter<"WorkspaceSettings">
    allowedFileTypes?: StringNullableListFilter<"WorkspaceSettings">
    maxFileSize?: BigIntFilter<"WorkspaceSettings"> | bigint | number
    maxProcessingTime?: IntFilter<"WorkspaceSettings"> | number
    allowPublicSharing?: BoolFilter<"WorkspaceSettings"> | boolean
    allowGuestAccess?: BoolFilter<"WorkspaceSettings"> | boolean
    requireApprovalForUploads?: BoolFilter<"WorkspaceSettings"> | boolean
    webhookUrl?: StringNullableFilter<"WorkspaceSettings"> | string | null
    webhookSecret?: StringNullableFilter<"WorkspaceSettings"> | string | null
    settingsJson?: JsonFilter<"WorkspaceSettings">
    updatedAt?: DateTimeFilter<"WorkspaceSettings"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "workspaceId">

  export type WorkspaceSettingsOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    defaultProcessingOptions?: SortOrder
    allowedFileTypes?: SortOrder
    maxFileSize?: SortOrder
    maxProcessingTime?: SortOrder
    allowPublicSharing?: SortOrder
    allowGuestAccess?: SortOrder
    requireApprovalForUploads?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    webhookSecret?: SortOrderInput | SortOrder
    settingsJson?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceSettingsCountOrderByAggregateInput
    _avg?: WorkspaceSettingsAvgOrderByAggregateInput
    _max?: WorkspaceSettingsMaxOrderByAggregateInput
    _min?: WorkspaceSettingsMinOrderByAggregateInput
    _sum?: WorkspaceSettingsSumOrderByAggregateInput
  }

  export type WorkspaceSettingsScalarWhereWithAggregatesInput = {
    AND?: WorkspaceSettingsScalarWhereWithAggregatesInput | WorkspaceSettingsScalarWhereWithAggregatesInput[]
    OR?: WorkspaceSettingsScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceSettingsScalarWhereWithAggregatesInput | WorkspaceSettingsScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"WorkspaceSettings"> | string
    defaultProcessingOptions?: JsonWithAggregatesFilter<"WorkspaceSettings">
    allowedFileTypes?: StringNullableListFilter<"WorkspaceSettings">
    maxFileSize?: BigIntWithAggregatesFilter<"WorkspaceSettings"> | bigint | number
    maxProcessingTime?: IntWithAggregatesFilter<"WorkspaceSettings"> | number
    allowPublicSharing?: BoolWithAggregatesFilter<"WorkspaceSettings"> | boolean
    allowGuestAccess?: BoolWithAggregatesFilter<"WorkspaceSettings"> | boolean
    requireApprovalForUploads?: BoolWithAggregatesFilter<"WorkspaceSettings"> | boolean
    webhookUrl?: StringNullableWithAggregatesFilter<"WorkspaceSettings"> | string | null
    webhookSecret?: StringNullableWithAggregatesFilter<"WorkspaceSettings"> | string | null
    settingsJson?: JsonWithAggregatesFilter<"WorkspaceSettings">
    updatedAt?: DateTimeWithAggregatesFilter<"WorkspaceSettings"> | Date | string
  }

  export type ProcessingTemplateWhereInput = {
    AND?: ProcessingTemplateWhereInput | ProcessingTemplateWhereInput[]
    OR?: ProcessingTemplateWhereInput[]
    NOT?: ProcessingTemplateWhereInput | ProcessingTemplateWhereInput[]
    id?: StringFilter<"ProcessingTemplate"> | string
    userId?: StringFilter<"ProcessingTemplate"> | string
    workspaceId?: StringNullableFilter<"ProcessingTemplate"> | string | null
    name?: StringFilter<"ProcessingTemplate"> | string
    description?: StringNullableFilter<"ProcessingTemplate"> | string | null
    summaryStyle?: StringFilter<"ProcessingTemplate"> | string
    temperature?: FloatFilter<"ProcessingTemplate"> | number
    maxTokens?: IntFilter<"ProcessingTemplate"> | number
    language?: StringFilter<"ProcessingTemplate"> | string
    configJson?: JsonFilter<"ProcessingTemplate">
    isPublic?: BoolFilter<"ProcessingTemplate"> | boolean
    createdAt?: DateTimeFilter<"ProcessingTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessingTemplate"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProcessingTemplateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    summaryStyle?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    language?: SortOrder
    configJson?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProcessingTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessingTemplateWhereInput | ProcessingTemplateWhereInput[]
    OR?: ProcessingTemplateWhereInput[]
    NOT?: ProcessingTemplateWhereInput | ProcessingTemplateWhereInput[]
    userId?: StringFilter<"ProcessingTemplate"> | string
    workspaceId?: StringNullableFilter<"ProcessingTemplate"> | string | null
    name?: StringFilter<"ProcessingTemplate"> | string
    description?: StringNullableFilter<"ProcessingTemplate"> | string | null
    summaryStyle?: StringFilter<"ProcessingTemplate"> | string
    temperature?: FloatFilter<"ProcessingTemplate"> | number
    maxTokens?: IntFilter<"ProcessingTemplate"> | number
    language?: StringFilter<"ProcessingTemplate"> | string
    configJson?: JsonFilter<"ProcessingTemplate">
    isPublic?: BoolFilter<"ProcessingTemplate"> | boolean
    createdAt?: DateTimeFilter<"ProcessingTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessingTemplate"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ProcessingTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    summaryStyle?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    language?: SortOrder
    configJson?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProcessingTemplateCountOrderByAggregateInput
    _avg?: ProcessingTemplateAvgOrderByAggregateInput
    _max?: ProcessingTemplateMaxOrderByAggregateInput
    _min?: ProcessingTemplateMinOrderByAggregateInput
    _sum?: ProcessingTemplateSumOrderByAggregateInput
  }

  export type ProcessingTemplateScalarWhereWithAggregatesInput = {
    AND?: ProcessingTemplateScalarWhereWithAggregatesInput | ProcessingTemplateScalarWhereWithAggregatesInput[]
    OR?: ProcessingTemplateScalarWhereWithAggregatesInput[]
    NOT?: ProcessingTemplateScalarWhereWithAggregatesInput | ProcessingTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProcessingTemplate"> | string
    userId?: StringWithAggregatesFilter<"ProcessingTemplate"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"ProcessingTemplate"> | string | null
    name?: StringWithAggregatesFilter<"ProcessingTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ProcessingTemplate"> | string | null
    summaryStyle?: StringWithAggregatesFilter<"ProcessingTemplate"> | string
    temperature?: FloatWithAggregatesFilter<"ProcessingTemplate"> | number
    maxTokens?: IntWithAggregatesFilter<"ProcessingTemplate"> | number
    language?: StringWithAggregatesFilter<"ProcessingTemplate"> | string
    configJson?: JsonWithAggregatesFilter<"ProcessingTemplate">
    isPublic?: BoolWithAggregatesFilter<"ProcessingTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProcessingTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProcessingTemplate"> | Date | string
  }

  export type ApiKeyManagementWhereInput = {
    AND?: ApiKeyManagementWhereInput | ApiKeyManagementWhereInput[]
    OR?: ApiKeyManagementWhereInput[]
    NOT?: ApiKeyManagementWhereInput | ApiKeyManagementWhereInput[]
    id?: StringFilter<"ApiKeyManagement"> | string
    userId?: StringFilter<"ApiKeyManagement"> | string
    workspaceId?: StringNullableFilter<"ApiKeyManagement"> | string | null
    provider?: StringFilter<"ApiKeyManagement"> | string
    keyName?: StringFilter<"ApiKeyManagement"> | string
    encryptedKey?: StringFilter<"ApiKeyManagement"> | string
    keyHash?: StringFilter<"ApiKeyManagement"> | string
    isActive?: BoolFilter<"ApiKeyManagement"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"ApiKeyManagement"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKeyManagement"> | Date | string | null
    totalRequests?: BigIntFilter<"ApiKeyManagement"> | bigint | number
    totalTokens?: BigIntFilter<"ApiKeyManagement"> | bigint | number
    totalCost?: DecimalFilter<"ApiKeyManagement"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ApiKeyManagement"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKeyManagement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ApiKeyManagementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    provider?: SortOrder
    keyName?: SortOrder
    encryptedKey?: SortOrder
    keyHash?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    totalRequests?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ApiKeyManagementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_provider_keyName?: ApiKeyManagementUserIdProviderKeyNameCompoundUniqueInput
    AND?: ApiKeyManagementWhereInput | ApiKeyManagementWhereInput[]
    OR?: ApiKeyManagementWhereInput[]
    NOT?: ApiKeyManagementWhereInput | ApiKeyManagementWhereInput[]
    userId?: StringFilter<"ApiKeyManagement"> | string
    workspaceId?: StringNullableFilter<"ApiKeyManagement"> | string | null
    provider?: StringFilter<"ApiKeyManagement"> | string
    keyName?: StringFilter<"ApiKeyManagement"> | string
    encryptedKey?: StringFilter<"ApiKeyManagement"> | string
    keyHash?: StringFilter<"ApiKeyManagement"> | string
    isActive?: BoolFilter<"ApiKeyManagement"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"ApiKeyManagement"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKeyManagement"> | Date | string | null
    totalRequests?: BigIntFilter<"ApiKeyManagement"> | bigint | number
    totalTokens?: BigIntFilter<"ApiKeyManagement"> | bigint | number
    totalCost?: DecimalFilter<"ApiKeyManagement"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ApiKeyManagement"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKeyManagement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_provider_keyName">

  export type ApiKeyManagementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    provider?: SortOrder
    keyName?: SortOrder
    encryptedKey?: SortOrder
    keyHash?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    totalRequests?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiKeyManagementCountOrderByAggregateInput
    _avg?: ApiKeyManagementAvgOrderByAggregateInput
    _max?: ApiKeyManagementMaxOrderByAggregateInput
    _min?: ApiKeyManagementMinOrderByAggregateInput
    _sum?: ApiKeyManagementSumOrderByAggregateInput
  }

  export type ApiKeyManagementScalarWhereWithAggregatesInput = {
    AND?: ApiKeyManagementScalarWhereWithAggregatesInput | ApiKeyManagementScalarWhereWithAggregatesInput[]
    OR?: ApiKeyManagementScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyManagementScalarWhereWithAggregatesInput | ApiKeyManagementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKeyManagement"> | string
    userId?: StringWithAggregatesFilter<"ApiKeyManagement"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"ApiKeyManagement"> | string | null
    provider?: StringWithAggregatesFilter<"ApiKeyManagement"> | string
    keyName?: StringWithAggregatesFilter<"ApiKeyManagement"> | string
    encryptedKey?: StringWithAggregatesFilter<"ApiKeyManagement"> | string
    keyHash?: StringWithAggregatesFilter<"ApiKeyManagement"> | string
    isActive?: BoolWithAggregatesFilter<"ApiKeyManagement"> | boolean
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKeyManagement"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKeyManagement"> | Date | string | null
    totalRequests?: BigIntWithAggregatesFilter<"ApiKeyManagement"> | bigint | number
    totalTokens?: BigIntWithAggregatesFilter<"ApiKeyManagement"> | bigint | number
    totalCost?: DecimalWithAggregatesFilter<"ApiKeyManagement"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"ApiKeyManagement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKeyManagement"> | Date | string
  }

  export type AudioUploadWhereInput = {
    AND?: AudioUploadWhereInput | AudioUploadWhereInput[]
    OR?: AudioUploadWhereInput[]
    NOT?: AudioUploadWhereInput | AudioUploadWhereInput[]
    id?: StringFilter<"AudioUpload"> | string
    userId?: StringFilter<"AudioUpload"> | string
    workspaceId?: StringNullableFilter<"AudioUpload"> | string | null
    originalFilename?: StringFilter<"AudioUpload"> | string
    fileSize?: BigIntFilter<"AudioUpload"> | bigint | number
    fileType?: StringFilter<"AudioUpload"> | string
    mimeType?: StringFilter<"AudioUpload"> | string
    duration?: FloatNullableFilter<"AudioUpload"> | number | null
    sampleRate?: IntNullableFilter<"AudioUpload"> | number | null
    channels?: IntNullableFilter<"AudioUpload"> | number | null
    bitrate?: IntNullableFilter<"AudioUpload"> | number | null
    storageProvider?: StringFilter<"AudioUpload"> | string
    storagePath?: StringFilter<"AudioUpload"> | string
    storageUrl?: StringNullableFilter<"AudioUpload"> | string | null
    cdnUrl?: StringNullableFilter<"AudioUpload"> | string | null
    checksumMd5?: StringNullableFilter<"AudioUpload"> | string | null
    checksumSha256?: StringNullableFilter<"AudioUpload"> | string | null
    status?: StringFilter<"AudioUpload"> | string
    uploadedAt?: DateTimeFilter<"AudioUpload"> | Date | string
    processingStartedAt?: DateTimeNullableFilter<"AudioUpload"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AudioUpload"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
    audioHistory?: AudioHistoryListRelationFilter
    processingJobs?: ProcessingJobListRelationFilter
    audioChunks?: AudioChunkListRelationFilter
  }

  export type AudioUploadOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrder
    duration?: SortOrderInput | SortOrder
    sampleRate?: SortOrderInput | SortOrder
    channels?: SortOrderInput | SortOrder
    bitrate?: SortOrderInput | SortOrder
    storageProvider?: SortOrder
    storagePath?: SortOrder
    storageUrl?: SortOrderInput | SortOrder
    cdnUrl?: SortOrderInput | SortOrder
    checksumMd5?: SortOrderInput | SortOrder
    checksumSha256?: SortOrderInput | SortOrder
    status?: SortOrder
    uploadedAt?: SortOrder
    processingStartedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    audioHistory?: AudioHistoryOrderByRelationAggregateInput
    processingJobs?: ProcessingJobOrderByRelationAggregateInput
    audioChunks?: AudioChunkOrderByRelationAggregateInput
  }

  export type AudioUploadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AudioUploadWhereInput | AudioUploadWhereInput[]
    OR?: AudioUploadWhereInput[]
    NOT?: AudioUploadWhereInput | AudioUploadWhereInput[]
    userId?: StringFilter<"AudioUpload"> | string
    workspaceId?: StringNullableFilter<"AudioUpload"> | string | null
    originalFilename?: StringFilter<"AudioUpload"> | string
    fileSize?: BigIntFilter<"AudioUpload"> | bigint | number
    fileType?: StringFilter<"AudioUpload"> | string
    mimeType?: StringFilter<"AudioUpload"> | string
    duration?: FloatNullableFilter<"AudioUpload"> | number | null
    sampleRate?: IntNullableFilter<"AudioUpload"> | number | null
    channels?: IntNullableFilter<"AudioUpload"> | number | null
    bitrate?: IntNullableFilter<"AudioUpload"> | number | null
    storageProvider?: StringFilter<"AudioUpload"> | string
    storagePath?: StringFilter<"AudioUpload"> | string
    storageUrl?: StringNullableFilter<"AudioUpload"> | string | null
    cdnUrl?: StringNullableFilter<"AudioUpload"> | string | null
    checksumMd5?: StringNullableFilter<"AudioUpload"> | string | null
    checksumSha256?: StringNullableFilter<"AudioUpload"> | string | null
    status?: StringFilter<"AudioUpload"> | string
    uploadedAt?: DateTimeFilter<"AudioUpload"> | Date | string
    processingStartedAt?: DateTimeNullableFilter<"AudioUpload"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AudioUpload"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
    audioHistory?: AudioHistoryListRelationFilter
    processingJobs?: ProcessingJobListRelationFilter
    audioChunks?: AudioChunkListRelationFilter
  }, "id">

  export type AudioUploadOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrder
    duration?: SortOrderInput | SortOrder
    sampleRate?: SortOrderInput | SortOrder
    channels?: SortOrderInput | SortOrder
    bitrate?: SortOrderInput | SortOrder
    storageProvider?: SortOrder
    storagePath?: SortOrder
    storageUrl?: SortOrderInput | SortOrder
    cdnUrl?: SortOrderInput | SortOrder
    checksumMd5?: SortOrderInput | SortOrder
    checksumSha256?: SortOrderInput | SortOrder
    status?: SortOrder
    uploadedAt?: SortOrder
    processingStartedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: AudioUploadCountOrderByAggregateInput
    _avg?: AudioUploadAvgOrderByAggregateInput
    _max?: AudioUploadMaxOrderByAggregateInput
    _min?: AudioUploadMinOrderByAggregateInput
    _sum?: AudioUploadSumOrderByAggregateInput
  }

  export type AudioUploadScalarWhereWithAggregatesInput = {
    AND?: AudioUploadScalarWhereWithAggregatesInput | AudioUploadScalarWhereWithAggregatesInput[]
    OR?: AudioUploadScalarWhereWithAggregatesInput[]
    NOT?: AudioUploadScalarWhereWithAggregatesInput | AudioUploadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioUpload"> | string
    userId?: StringWithAggregatesFilter<"AudioUpload"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"AudioUpload"> | string | null
    originalFilename?: StringWithAggregatesFilter<"AudioUpload"> | string
    fileSize?: BigIntWithAggregatesFilter<"AudioUpload"> | bigint | number
    fileType?: StringWithAggregatesFilter<"AudioUpload"> | string
    mimeType?: StringWithAggregatesFilter<"AudioUpload"> | string
    duration?: FloatNullableWithAggregatesFilter<"AudioUpload"> | number | null
    sampleRate?: IntNullableWithAggregatesFilter<"AudioUpload"> | number | null
    channels?: IntNullableWithAggregatesFilter<"AudioUpload"> | number | null
    bitrate?: IntNullableWithAggregatesFilter<"AudioUpload"> | number | null
    storageProvider?: StringWithAggregatesFilter<"AudioUpload"> | string
    storagePath?: StringWithAggregatesFilter<"AudioUpload"> | string
    storageUrl?: StringNullableWithAggregatesFilter<"AudioUpload"> | string | null
    cdnUrl?: StringNullableWithAggregatesFilter<"AudioUpload"> | string | null
    checksumMd5?: StringNullableWithAggregatesFilter<"AudioUpload"> | string | null
    checksumSha256?: StringNullableWithAggregatesFilter<"AudioUpload"> | string | null
    status?: StringWithAggregatesFilter<"AudioUpload"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"AudioUpload"> | Date | string
    processingStartedAt?: DateTimeNullableWithAggregatesFilter<"AudioUpload"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"AudioUpload"> | Date | string | null
  }

  export type ProcessingJobWhereInput = {
    AND?: ProcessingJobWhereInput | ProcessingJobWhereInput[]
    OR?: ProcessingJobWhereInput[]
    NOT?: ProcessingJobWhereInput | ProcessingJobWhereInput[]
    id?: StringFilter<"ProcessingJob"> | string
    userId?: StringFilter<"ProcessingJob"> | string
    uploadId?: StringFilter<"ProcessingJob"> | string
    jobType?: StringFilter<"ProcessingJob"> | string
    priority?: IntFilter<"ProcessingJob"> | number
    processingOptions?: JsonFilter<"ProcessingJob">
    status?: StringFilter<"ProcessingJob"> | string
    progress?: FloatFilter<"ProcessingJob"> | number
    cpuTimeMs?: BigIntNullableFilter<"ProcessingJob"> | bigint | number | null
    memoryUsageMb?: IntNullableFilter<"ProcessingJob"> | number | null
    queuedAt?: DateTimeFilter<"ProcessingJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"ProcessingJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProcessingJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"ProcessingJob"> | string | null
    retryCount?: IntFilter<"ProcessingJob"> | number
    maxRetries?: IntFilter<"ProcessingJob"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    upload?: XOR<AudioUploadRelationFilter, AudioUploadWhereInput>
  }

  export type ProcessingJobOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    uploadId?: SortOrder
    jobType?: SortOrder
    priority?: SortOrder
    processingOptions?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    cpuTimeMs?: SortOrderInput | SortOrder
    memoryUsageMb?: SortOrderInput | SortOrder
    queuedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    user?: UserOrderByWithRelationInput
    upload?: AudioUploadOrderByWithRelationInput
  }

  export type ProcessingJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessingJobWhereInput | ProcessingJobWhereInput[]
    OR?: ProcessingJobWhereInput[]
    NOT?: ProcessingJobWhereInput | ProcessingJobWhereInput[]
    userId?: StringFilter<"ProcessingJob"> | string
    uploadId?: StringFilter<"ProcessingJob"> | string
    jobType?: StringFilter<"ProcessingJob"> | string
    priority?: IntFilter<"ProcessingJob"> | number
    processingOptions?: JsonFilter<"ProcessingJob">
    status?: StringFilter<"ProcessingJob"> | string
    progress?: FloatFilter<"ProcessingJob"> | number
    cpuTimeMs?: BigIntNullableFilter<"ProcessingJob"> | bigint | number | null
    memoryUsageMb?: IntNullableFilter<"ProcessingJob"> | number | null
    queuedAt?: DateTimeFilter<"ProcessingJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"ProcessingJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProcessingJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"ProcessingJob"> | string | null
    retryCount?: IntFilter<"ProcessingJob"> | number
    maxRetries?: IntFilter<"ProcessingJob"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    upload?: XOR<AudioUploadRelationFilter, AudioUploadWhereInput>
  }, "id">

  export type ProcessingJobOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    uploadId?: SortOrder
    jobType?: SortOrder
    priority?: SortOrder
    processingOptions?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    cpuTimeMs?: SortOrderInput | SortOrder
    memoryUsageMb?: SortOrderInput | SortOrder
    queuedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    _count?: ProcessingJobCountOrderByAggregateInput
    _avg?: ProcessingJobAvgOrderByAggregateInput
    _max?: ProcessingJobMaxOrderByAggregateInput
    _min?: ProcessingJobMinOrderByAggregateInput
    _sum?: ProcessingJobSumOrderByAggregateInput
  }

  export type ProcessingJobScalarWhereWithAggregatesInput = {
    AND?: ProcessingJobScalarWhereWithAggregatesInput | ProcessingJobScalarWhereWithAggregatesInput[]
    OR?: ProcessingJobScalarWhereWithAggregatesInput[]
    NOT?: ProcessingJobScalarWhereWithAggregatesInput | ProcessingJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProcessingJob"> | string
    userId?: StringWithAggregatesFilter<"ProcessingJob"> | string
    uploadId?: StringWithAggregatesFilter<"ProcessingJob"> | string
    jobType?: StringWithAggregatesFilter<"ProcessingJob"> | string
    priority?: IntWithAggregatesFilter<"ProcessingJob"> | number
    processingOptions?: JsonWithAggregatesFilter<"ProcessingJob">
    status?: StringWithAggregatesFilter<"ProcessingJob"> | string
    progress?: FloatWithAggregatesFilter<"ProcessingJob"> | number
    cpuTimeMs?: BigIntNullableWithAggregatesFilter<"ProcessingJob"> | bigint | number | null
    memoryUsageMb?: IntNullableWithAggregatesFilter<"ProcessingJob"> | number | null
    queuedAt?: DateTimeWithAggregatesFilter<"ProcessingJob"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"ProcessingJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ProcessingJob"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"ProcessingJob"> | string | null
    retryCount?: IntWithAggregatesFilter<"ProcessingJob"> | number
    maxRetries?: IntWithAggregatesFilter<"ProcessingJob"> | number
  }

  export type AudioHistoryWhereInput = {
    AND?: AudioHistoryWhereInput | AudioHistoryWhereInput[]
    OR?: AudioHistoryWhereInput[]
    NOT?: AudioHistoryWhereInput | AudioHistoryWhereInput[]
    id?: StringFilter<"AudioHistory"> | string
    userId?: StringFilter<"AudioHistory"> | string
    workspaceId?: StringNullableFilter<"AudioHistory"> | string | null
    uploadId?: StringNullableFilter<"AudioHistory"> | string | null
    title?: StringNullableFilter<"AudioHistory"> | string | null
    audioUrl?: StringNullableFilter<"AudioHistory"> | string | null
    cdnUrl?: StringNullableFilter<"AudioHistory"> | string | null
    fileSizeBytes?: BigIntNullableFilter<"AudioHistory"> | bigint | number | null
    durationSeconds?: IntNullableFilter<"AudioHistory"> | number | null
    transcript?: StringNullableFilter<"AudioHistory"> | string | null
    summary?: StringNullableFilter<"AudioHistory"> | string | null
    keyMoments?: JsonNullableFilter<"AudioHistory">
    language?: StringNullableFilter<"AudioHistory"> | string | null
    confidence?: FloatNullableFilter<"AudioHistory"> | number | null
    wordCount?: IntNullableFilter<"AudioHistory"> | number | null
    speakerCount?: IntNullableFilter<"AudioHistory"> | number | null
    processingOptions?: JsonNullableFilter<"AudioHistory">
    processingTime?: FloatNullableFilter<"AudioHistory"> | number | null
    apiProvider?: StringNullableFilter<"AudioHistory"> | string | null
    modelVersion?: StringNullableFilter<"AudioHistory"> | string | null
    transcriptionCost?: DecimalNullableFilter<"AudioHistory"> | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: DecimalNullableFilter<"AudioHistory"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"AudioHistory"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AudioHistory"> | Date | string
    updatedAt?: DateTimeFilter<"AudioHistory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
    upload?: XOR<AudioUploadNullableRelationFilter, AudioUploadWhereInput> | null
    segments?: AudioSegmentListRelationFilter
  }

  export type AudioHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    uploadId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    cdnUrl?: SortOrderInput | SortOrder
    fileSizeBytes?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    keyMoments?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    speakerCount?: SortOrderInput | SortOrder
    processingOptions?: SortOrderInput | SortOrder
    processingTime?: SortOrderInput | SortOrder
    apiProvider?: SortOrderInput | SortOrder
    modelVersion?: SortOrderInput | SortOrder
    transcriptionCost?: SortOrderInput | SortOrder
    summarizationCost?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    upload?: AudioUploadOrderByWithRelationInput
    segments?: AudioSegmentOrderByRelationAggregateInput
  }

  export type AudioHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AudioHistoryWhereInput | AudioHistoryWhereInput[]
    OR?: AudioHistoryWhereInput[]
    NOT?: AudioHistoryWhereInput | AudioHistoryWhereInput[]
    userId?: StringFilter<"AudioHistory"> | string
    workspaceId?: StringNullableFilter<"AudioHistory"> | string | null
    uploadId?: StringNullableFilter<"AudioHistory"> | string | null
    title?: StringNullableFilter<"AudioHistory"> | string | null
    audioUrl?: StringNullableFilter<"AudioHistory"> | string | null
    cdnUrl?: StringNullableFilter<"AudioHistory"> | string | null
    fileSizeBytes?: BigIntNullableFilter<"AudioHistory"> | bigint | number | null
    durationSeconds?: IntNullableFilter<"AudioHistory"> | number | null
    transcript?: StringNullableFilter<"AudioHistory"> | string | null
    summary?: StringNullableFilter<"AudioHistory"> | string | null
    keyMoments?: JsonNullableFilter<"AudioHistory">
    language?: StringNullableFilter<"AudioHistory"> | string | null
    confidence?: FloatNullableFilter<"AudioHistory"> | number | null
    wordCount?: IntNullableFilter<"AudioHistory"> | number | null
    speakerCount?: IntNullableFilter<"AudioHistory"> | number | null
    processingOptions?: JsonNullableFilter<"AudioHistory">
    processingTime?: FloatNullableFilter<"AudioHistory"> | number | null
    apiProvider?: StringNullableFilter<"AudioHistory"> | string | null
    modelVersion?: StringNullableFilter<"AudioHistory"> | string | null
    transcriptionCost?: DecimalNullableFilter<"AudioHistory"> | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: DecimalNullableFilter<"AudioHistory"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"AudioHistory"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AudioHistory"> | Date | string
    updatedAt?: DateTimeFilter<"AudioHistory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
    upload?: XOR<AudioUploadNullableRelationFilter, AudioUploadWhereInput> | null
    segments?: AudioSegmentListRelationFilter
  }, "id">

  export type AudioHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    uploadId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    cdnUrl?: SortOrderInput | SortOrder
    fileSizeBytes?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    keyMoments?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    speakerCount?: SortOrderInput | SortOrder
    processingOptions?: SortOrderInput | SortOrder
    processingTime?: SortOrderInput | SortOrder
    apiProvider?: SortOrderInput | SortOrder
    modelVersion?: SortOrderInput | SortOrder
    transcriptionCost?: SortOrderInput | SortOrder
    summarizationCost?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AudioHistoryCountOrderByAggregateInput
    _avg?: AudioHistoryAvgOrderByAggregateInput
    _max?: AudioHistoryMaxOrderByAggregateInput
    _min?: AudioHistoryMinOrderByAggregateInput
    _sum?: AudioHistorySumOrderByAggregateInput
  }

  export type AudioHistoryScalarWhereWithAggregatesInput = {
    AND?: AudioHistoryScalarWhereWithAggregatesInput | AudioHistoryScalarWhereWithAggregatesInput[]
    OR?: AudioHistoryScalarWhereWithAggregatesInput[]
    NOT?: AudioHistoryScalarWhereWithAggregatesInput | AudioHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioHistory"> | string
    userId?: StringWithAggregatesFilter<"AudioHistory"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    uploadId?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    title?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    audioUrl?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    cdnUrl?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    fileSizeBytes?: BigIntNullableWithAggregatesFilter<"AudioHistory"> | bigint | number | null
    durationSeconds?: IntNullableWithAggregatesFilter<"AudioHistory"> | number | null
    transcript?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    summary?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    keyMoments?: JsonNullableWithAggregatesFilter<"AudioHistory">
    language?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    confidence?: FloatNullableWithAggregatesFilter<"AudioHistory"> | number | null
    wordCount?: IntNullableWithAggregatesFilter<"AudioHistory"> | number | null
    speakerCount?: IntNullableWithAggregatesFilter<"AudioHistory"> | number | null
    processingOptions?: JsonNullableWithAggregatesFilter<"AudioHistory">
    processingTime?: FloatNullableWithAggregatesFilter<"AudioHistory"> | number | null
    apiProvider?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    modelVersion?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    transcriptionCost?: DecimalNullableWithAggregatesFilter<"AudioHistory"> | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: DecimalNullableWithAggregatesFilter<"AudioHistory"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableWithAggregatesFilter<"AudioHistory"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AudioHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AudioHistory"> | Date | string
  }

  export type AudioSegmentWhereInput = {
    AND?: AudioSegmentWhereInput | AudioSegmentWhereInput[]
    OR?: AudioSegmentWhereInput[]
    NOT?: AudioSegmentWhereInput | AudioSegmentWhereInput[]
    id?: StringFilter<"AudioSegment"> | string
    historyId?: StringFilter<"AudioSegment"> | string
    segmentIndex?: IntFilter<"AudioSegment"> | number
    startTime?: FloatFilter<"AudioSegment"> | number
    endTime?: FloatFilter<"AudioSegment"> | number
    text?: StringFilter<"AudioSegment"> | string
    confidence?: FloatNullableFilter<"AudioSegment"> | number | null
    language?: StringNullableFilter<"AudioSegment"> | string | null
    speakerId?: StringNullableFilter<"AudioSegment"> | string | null
    emotion?: StringNullableFilter<"AudioSegment"> | string | null
    sentiment?: StringNullableFilter<"AudioSegment"> | string | null
    tokens?: IntNullableListFilter<"AudioSegment">
    logprobs?: FloatNullableListFilter<"AudioSegment">
    temperature?: FloatNullableFilter<"AudioSegment"> | number | null
    avgLogprob?: FloatNullableFilter<"AudioSegment"> | number | null
    compressionRatio?: FloatNullableFilter<"AudioSegment"> | number | null
    noSpeechProb?: FloatNullableFilter<"AudioSegment"> | number | null
    history?: XOR<AudioHistoryRelationFilter, AudioHistoryWhereInput>
  }

  export type AudioSegmentOrderByWithRelationInput = {
    id?: SortOrder
    historyId?: SortOrder
    segmentIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    text?: SortOrder
    confidence?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    speakerId?: SortOrderInput | SortOrder
    emotion?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    tokens?: SortOrder
    logprobs?: SortOrder
    temperature?: SortOrderInput | SortOrder
    avgLogprob?: SortOrderInput | SortOrder
    compressionRatio?: SortOrderInput | SortOrder
    noSpeechProb?: SortOrderInput | SortOrder
    history?: AudioHistoryOrderByWithRelationInput
  }

  export type AudioSegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AudioSegmentWhereInput | AudioSegmentWhereInput[]
    OR?: AudioSegmentWhereInput[]
    NOT?: AudioSegmentWhereInput | AudioSegmentWhereInput[]
    historyId?: StringFilter<"AudioSegment"> | string
    segmentIndex?: IntFilter<"AudioSegment"> | number
    startTime?: FloatFilter<"AudioSegment"> | number
    endTime?: FloatFilter<"AudioSegment"> | number
    text?: StringFilter<"AudioSegment"> | string
    confidence?: FloatNullableFilter<"AudioSegment"> | number | null
    language?: StringNullableFilter<"AudioSegment"> | string | null
    speakerId?: StringNullableFilter<"AudioSegment"> | string | null
    emotion?: StringNullableFilter<"AudioSegment"> | string | null
    sentiment?: StringNullableFilter<"AudioSegment"> | string | null
    tokens?: IntNullableListFilter<"AudioSegment">
    logprobs?: FloatNullableListFilter<"AudioSegment">
    temperature?: FloatNullableFilter<"AudioSegment"> | number | null
    avgLogprob?: FloatNullableFilter<"AudioSegment"> | number | null
    compressionRatio?: FloatNullableFilter<"AudioSegment"> | number | null
    noSpeechProb?: FloatNullableFilter<"AudioSegment"> | number | null
    history?: XOR<AudioHistoryRelationFilter, AudioHistoryWhereInput>
  }, "id">

  export type AudioSegmentOrderByWithAggregationInput = {
    id?: SortOrder
    historyId?: SortOrder
    segmentIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    text?: SortOrder
    confidence?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    speakerId?: SortOrderInput | SortOrder
    emotion?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    tokens?: SortOrder
    logprobs?: SortOrder
    temperature?: SortOrderInput | SortOrder
    avgLogprob?: SortOrderInput | SortOrder
    compressionRatio?: SortOrderInput | SortOrder
    noSpeechProb?: SortOrderInput | SortOrder
    _count?: AudioSegmentCountOrderByAggregateInput
    _avg?: AudioSegmentAvgOrderByAggregateInput
    _max?: AudioSegmentMaxOrderByAggregateInput
    _min?: AudioSegmentMinOrderByAggregateInput
    _sum?: AudioSegmentSumOrderByAggregateInput
  }

  export type AudioSegmentScalarWhereWithAggregatesInput = {
    AND?: AudioSegmentScalarWhereWithAggregatesInput | AudioSegmentScalarWhereWithAggregatesInput[]
    OR?: AudioSegmentScalarWhereWithAggregatesInput[]
    NOT?: AudioSegmentScalarWhereWithAggregatesInput | AudioSegmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioSegment"> | string
    historyId?: StringWithAggregatesFilter<"AudioSegment"> | string
    segmentIndex?: IntWithAggregatesFilter<"AudioSegment"> | number
    startTime?: FloatWithAggregatesFilter<"AudioSegment"> | number
    endTime?: FloatWithAggregatesFilter<"AudioSegment"> | number
    text?: StringWithAggregatesFilter<"AudioSegment"> | string
    confidence?: FloatNullableWithAggregatesFilter<"AudioSegment"> | number | null
    language?: StringNullableWithAggregatesFilter<"AudioSegment"> | string | null
    speakerId?: StringNullableWithAggregatesFilter<"AudioSegment"> | string | null
    emotion?: StringNullableWithAggregatesFilter<"AudioSegment"> | string | null
    sentiment?: StringNullableWithAggregatesFilter<"AudioSegment"> | string | null
    tokens?: IntNullableListFilter<"AudioSegment">
    logprobs?: FloatNullableListFilter<"AudioSegment">
    temperature?: FloatNullableWithAggregatesFilter<"AudioSegment"> | number | null
    avgLogprob?: FloatNullableWithAggregatesFilter<"AudioSegment"> | number | null
    compressionRatio?: FloatNullableWithAggregatesFilter<"AudioSegment"> | number | null
    noSpeechProb?: FloatNullableWithAggregatesFilter<"AudioSegment"> | number | null
  }

  export type AudioChunkWhereInput = {
    AND?: AudioChunkWhereInput | AudioChunkWhereInput[]
    OR?: AudioChunkWhereInput[]
    NOT?: AudioChunkWhereInput | AudioChunkWhereInput[]
    id?: StringFilter<"AudioChunk"> | string
    uploadId?: StringFilter<"AudioChunk"> | string
    chunkIndex?: IntFilter<"AudioChunk"> | number
    startTime?: FloatFilter<"AudioChunk"> | number
    endTime?: FloatFilter<"AudioChunk"> | number
    fileSize?: BigIntFilter<"AudioChunk"> | bigint | number
    storagePath?: StringFilter<"AudioChunk"> | string
    checksumMd5?: StringNullableFilter<"AudioChunk"> | string | null
    status?: StringFilter<"AudioChunk"> | string
    processedAt?: DateTimeNullableFilter<"AudioChunk"> | Date | string | null
    upload?: XOR<AudioUploadRelationFilter, AudioUploadWhereInput>
  }

  export type AudioChunkOrderByWithRelationInput = {
    id?: SortOrder
    uploadId?: SortOrder
    chunkIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    checksumMd5?: SortOrderInput | SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    upload?: AudioUploadOrderByWithRelationInput
  }

  export type AudioChunkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AudioChunkWhereInput | AudioChunkWhereInput[]
    OR?: AudioChunkWhereInput[]
    NOT?: AudioChunkWhereInput | AudioChunkWhereInput[]
    uploadId?: StringFilter<"AudioChunk"> | string
    chunkIndex?: IntFilter<"AudioChunk"> | number
    startTime?: FloatFilter<"AudioChunk"> | number
    endTime?: FloatFilter<"AudioChunk"> | number
    fileSize?: BigIntFilter<"AudioChunk"> | bigint | number
    storagePath?: StringFilter<"AudioChunk"> | string
    checksumMd5?: StringNullableFilter<"AudioChunk"> | string | null
    status?: StringFilter<"AudioChunk"> | string
    processedAt?: DateTimeNullableFilter<"AudioChunk"> | Date | string | null
    upload?: XOR<AudioUploadRelationFilter, AudioUploadWhereInput>
  }, "id">

  export type AudioChunkOrderByWithAggregationInput = {
    id?: SortOrder
    uploadId?: SortOrder
    chunkIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    checksumMd5?: SortOrderInput | SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: AudioChunkCountOrderByAggregateInput
    _avg?: AudioChunkAvgOrderByAggregateInput
    _max?: AudioChunkMaxOrderByAggregateInput
    _min?: AudioChunkMinOrderByAggregateInput
    _sum?: AudioChunkSumOrderByAggregateInput
  }

  export type AudioChunkScalarWhereWithAggregatesInput = {
    AND?: AudioChunkScalarWhereWithAggregatesInput | AudioChunkScalarWhereWithAggregatesInput[]
    OR?: AudioChunkScalarWhereWithAggregatesInput[]
    NOT?: AudioChunkScalarWhereWithAggregatesInput | AudioChunkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioChunk"> | string
    uploadId?: StringWithAggregatesFilter<"AudioChunk"> | string
    chunkIndex?: IntWithAggregatesFilter<"AudioChunk"> | number
    startTime?: FloatWithAggregatesFilter<"AudioChunk"> | number
    endTime?: FloatWithAggregatesFilter<"AudioChunk"> | number
    fileSize?: BigIntWithAggregatesFilter<"AudioChunk"> | bigint | number
    storagePath?: StringWithAggregatesFilter<"AudioChunk"> | string
    checksumMd5?: StringNullableWithAggregatesFilter<"AudioChunk"> | string | null
    status?: StringWithAggregatesFilter<"AudioChunk"> | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"AudioChunk"> | Date | string | null
  }

  export type AudioProjectWhereInput = {
    AND?: AudioProjectWhereInput | AudioProjectWhereInput[]
    OR?: AudioProjectWhereInput[]
    NOT?: AudioProjectWhereInput | AudioProjectWhereInput[]
    id?: StringFilter<"AudioProject"> | string
    userId?: StringFilter<"AudioProject"> | string
    workspaceId?: StringNullableFilter<"AudioProject"> | string | null
    name?: StringFilter<"AudioProject"> | string
    description?: StringNullableFilter<"AudioProject"> | string | null
    color?: StringNullableFilter<"AudioProject"> | string | null
    status?: StringFilter<"AudioProject"> | string
    isPublic?: BoolFilter<"AudioProject"> | boolean
    tags?: StringNullableListFilter<"AudioProject">
    metadata?: JsonNullableFilter<"AudioProject">
    createdAt?: DateTimeFilter<"AudioProject"> | Date | string
    updatedAt?: DateTimeFilter<"AudioProject"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
  }

  export type AudioProjectOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type AudioProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AudioProjectWhereInput | AudioProjectWhereInput[]
    OR?: AudioProjectWhereInput[]
    NOT?: AudioProjectWhereInput | AudioProjectWhereInput[]
    userId?: StringFilter<"AudioProject"> | string
    workspaceId?: StringNullableFilter<"AudioProject"> | string | null
    name?: StringFilter<"AudioProject"> | string
    description?: StringNullableFilter<"AudioProject"> | string | null
    color?: StringNullableFilter<"AudioProject"> | string | null
    status?: StringFilter<"AudioProject"> | string
    isPublic?: BoolFilter<"AudioProject"> | boolean
    tags?: StringNullableListFilter<"AudioProject">
    metadata?: JsonNullableFilter<"AudioProject">
    createdAt?: DateTimeFilter<"AudioProject"> | Date | string
    updatedAt?: DateTimeFilter<"AudioProject"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
  }, "id">

  export type AudioProjectOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AudioProjectCountOrderByAggregateInput
    _max?: AudioProjectMaxOrderByAggregateInput
    _min?: AudioProjectMinOrderByAggregateInput
  }

  export type AudioProjectScalarWhereWithAggregatesInput = {
    AND?: AudioProjectScalarWhereWithAggregatesInput | AudioProjectScalarWhereWithAggregatesInput[]
    OR?: AudioProjectScalarWhereWithAggregatesInput[]
    NOT?: AudioProjectScalarWhereWithAggregatesInput | AudioProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioProject"> | string
    userId?: StringWithAggregatesFilter<"AudioProject"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"AudioProject"> | string | null
    name?: StringWithAggregatesFilter<"AudioProject"> | string
    description?: StringNullableWithAggregatesFilter<"AudioProject"> | string | null
    color?: StringNullableWithAggregatesFilter<"AudioProject"> | string | null
    status?: StringWithAggregatesFilter<"AudioProject"> | string
    isPublic?: BoolWithAggregatesFilter<"AudioProject"> | boolean
    tags?: StringNullableListFilter<"AudioProject">
    metadata?: JsonNullableWithAggregatesFilter<"AudioProject">
    createdAt?: DateTimeWithAggregatesFilter<"AudioProject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AudioProject"> | Date | string
  }

  export type UsageMetricWhereInput = {
    AND?: UsageMetricWhereInput | UsageMetricWhereInput[]
    OR?: UsageMetricWhereInput[]
    NOT?: UsageMetricWhereInput | UsageMetricWhereInput[]
    id?: StringFilter<"UsageMetric"> | string
    userId?: StringFilter<"UsageMetric"> | string
    workspaceId?: StringNullableFilter<"UsageMetric"> | string | null
    metricType?: StringFilter<"UsageMetric"> | string
    provider?: StringNullableFilter<"UsageMetric"> | string | null
    quantity?: BigIntFilter<"UsageMetric"> | bigint | number
    cost?: DecimalFilter<"UsageMetric"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"UsageMetric"> | string
    metadata?: JsonNullableFilter<"UsageMetric">
    periodStart?: DateTimeFilter<"UsageMetric"> | Date | string
    periodEnd?: DateTimeFilter<"UsageMetric"> | Date | string
    recordedAt?: DateTimeFilter<"UsageMetric"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
  }

  export type UsageMetricOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    metricType?: SortOrder
    provider?: SortOrderInput | SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    currency?: SortOrder
    metadata?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    recordedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type UsageMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageMetricWhereInput | UsageMetricWhereInput[]
    OR?: UsageMetricWhereInput[]
    NOT?: UsageMetricWhereInput | UsageMetricWhereInput[]
    userId?: StringFilter<"UsageMetric"> | string
    workspaceId?: StringNullableFilter<"UsageMetric"> | string | null
    metricType?: StringFilter<"UsageMetric"> | string
    provider?: StringNullableFilter<"UsageMetric"> | string | null
    quantity?: BigIntFilter<"UsageMetric"> | bigint | number
    cost?: DecimalFilter<"UsageMetric"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"UsageMetric"> | string
    metadata?: JsonNullableFilter<"UsageMetric">
    periodStart?: DateTimeFilter<"UsageMetric"> | Date | string
    periodEnd?: DateTimeFilter<"UsageMetric"> | Date | string
    recordedAt?: DateTimeFilter<"UsageMetric"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
  }, "id">

  export type UsageMetricOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    metricType?: SortOrder
    provider?: SortOrderInput | SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    currency?: SortOrder
    metadata?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    recordedAt?: SortOrder
    _count?: UsageMetricCountOrderByAggregateInput
    _avg?: UsageMetricAvgOrderByAggregateInput
    _max?: UsageMetricMaxOrderByAggregateInput
    _min?: UsageMetricMinOrderByAggregateInput
    _sum?: UsageMetricSumOrderByAggregateInput
  }

  export type UsageMetricScalarWhereWithAggregatesInput = {
    AND?: UsageMetricScalarWhereWithAggregatesInput | UsageMetricScalarWhereWithAggregatesInput[]
    OR?: UsageMetricScalarWhereWithAggregatesInput[]
    NOT?: UsageMetricScalarWhereWithAggregatesInput | UsageMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageMetric"> | string
    userId?: StringWithAggregatesFilter<"UsageMetric"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"UsageMetric"> | string | null
    metricType?: StringWithAggregatesFilter<"UsageMetric"> | string
    provider?: StringNullableWithAggregatesFilter<"UsageMetric"> | string | null
    quantity?: BigIntWithAggregatesFilter<"UsageMetric"> | bigint | number
    cost?: DecimalWithAggregatesFilter<"UsageMetric"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"UsageMetric"> | string
    metadata?: JsonNullableWithAggregatesFilter<"UsageMetric">
    periodStart?: DateTimeWithAggregatesFilter<"UsageMetric"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"UsageMetric"> | Date | string
    recordedAt?: DateTimeWithAggregatesFilter<"UsageMetric"> | Date | string
  }

  export type UserQuotaWhereInput = {
    AND?: UserQuotaWhereInput | UserQuotaWhereInput[]
    OR?: UserQuotaWhereInput[]
    NOT?: UserQuotaWhereInput | UserQuotaWhereInput[]
    userId?: StringFilter<"UserQuota"> | string
    monthlyApiCalls?: BigIntFilter<"UserQuota"> | bigint | number
    monthlyTokens?: BigIntFilter<"UserQuota"> | bigint | number
    monthlyStorageMb?: BigIntFilter<"UserQuota"> | bigint | number
    monthlyProcessingMin?: BigIntFilter<"UserQuota"> | bigint | number
    currentApiCalls?: BigIntFilter<"UserQuota"> | bigint | number
    currentTokens?: BigIntFilter<"UserQuota"> | bigint | number
    currentStorageMb?: BigIntFilter<"UserQuota"> | bigint | number
    currentProcessingMin?: BigIntFilter<"UserQuota"> | bigint | number
    periodStart?: DateTimeFilter<"UserQuota"> | Date | string
    periodEnd?: DateTimeFilter<"UserQuota"> | Date | string
    lastResetAt?: DateTimeFilter<"UserQuota"> | Date | string
    allowOverages?: BoolFilter<"UserQuota"> | boolean
    overageCostPerToken?: DecimalFilter<"UserQuota"> | Decimal | DecimalJsLike | number | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserQuotaOrderByWithRelationInput = {
    userId?: SortOrder
    monthlyApiCalls?: SortOrder
    monthlyTokens?: SortOrder
    monthlyStorageMb?: SortOrder
    monthlyProcessingMin?: SortOrder
    currentApiCalls?: SortOrder
    currentTokens?: SortOrder
    currentStorageMb?: SortOrder
    currentProcessingMin?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    lastResetAt?: SortOrder
    allowOverages?: SortOrder
    overageCostPerToken?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserQuotaWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserQuotaWhereInput | UserQuotaWhereInput[]
    OR?: UserQuotaWhereInput[]
    NOT?: UserQuotaWhereInput | UserQuotaWhereInput[]
    monthlyApiCalls?: BigIntFilter<"UserQuota"> | bigint | number
    monthlyTokens?: BigIntFilter<"UserQuota"> | bigint | number
    monthlyStorageMb?: BigIntFilter<"UserQuota"> | bigint | number
    monthlyProcessingMin?: BigIntFilter<"UserQuota"> | bigint | number
    currentApiCalls?: BigIntFilter<"UserQuota"> | bigint | number
    currentTokens?: BigIntFilter<"UserQuota"> | bigint | number
    currentStorageMb?: BigIntFilter<"UserQuota"> | bigint | number
    currentProcessingMin?: BigIntFilter<"UserQuota"> | bigint | number
    periodStart?: DateTimeFilter<"UserQuota"> | Date | string
    periodEnd?: DateTimeFilter<"UserQuota"> | Date | string
    lastResetAt?: DateTimeFilter<"UserQuota"> | Date | string
    allowOverages?: BoolFilter<"UserQuota"> | boolean
    overageCostPerToken?: DecimalFilter<"UserQuota"> | Decimal | DecimalJsLike | number | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId">

  export type UserQuotaOrderByWithAggregationInput = {
    userId?: SortOrder
    monthlyApiCalls?: SortOrder
    monthlyTokens?: SortOrder
    monthlyStorageMb?: SortOrder
    monthlyProcessingMin?: SortOrder
    currentApiCalls?: SortOrder
    currentTokens?: SortOrder
    currentStorageMb?: SortOrder
    currentProcessingMin?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    lastResetAt?: SortOrder
    allowOverages?: SortOrder
    overageCostPerToken?: SortOrder
    _count?: UserQuotaCountOrderByAggregateInput
    _avg?: UserQuotaAvgOrderByAggregateInput
    _max?: UserQuotaMaxOrderByAggregateInput
    _min?: UserQuotaMinOrderByAggregateInput
    _sum?: UserQuotaSumOrderByAggregateInput
  }

  export type UserQuotaScalarWhereWithAggregatesInput = {
    AND?: UserQuotaScalarWhereWithAggregatesInput | UserQuotaScalarWhereWithAggregatesInput[]
    OR?: UserQuotaScalarWhereWithAggregatesInput[]
    NOT?: UserQuotaScalarWhereWithAggregatesInput | UserQuotaScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserQuota"> | string
    monthlyApiCalls?: BigIntWithAggregatesFilter<"UserQuota"> | bigint | number
    monthlyTokens?: BigIntWithAggregatesFilter<"UserQuota"> | bigint | number
    monthlyStorageMb?: BigIntWithAggregatesFilter<"UserQuota"> | bigint | number
    monthlyProcessingMin?: BigIntWithAggregatesFilter<"UserQuota"> | bigint | number
    currentApiCalls?: BigIntWithAggregatesFilter<"UserQuota"> | bigint | number
    currentTokens?: BigIntWithAggregatesFilter<"UserQuota"> | bigint | number
    currentStorageMb?: BigIntWithAggregatesFilter<"UserQuota"> | bigint | number
    currentProcessingMin?: BigIntWithAggregatesFilter<"UserQuota"> | bigint | number
    periodStart?: DateTimeWithAggregatesFilter<"UserQuota"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"UserQuota"> | Date | string
    lastResetAt?: DateTimeWithAggregatesFilter<"UserQuota"> | Date | string
    allowOverages?: BoolWithAggregatesFilter<"UserQuota"> | boolean
    overageCostPerToken?: DecimalWithAggregatesFilter<"UserQuota"> | Decimal | DecimalJsLike | number | string
  }

  export type StorageQuotaWhereInput = {
    AND?: StorageQuotaWhereInput | StorageQuotaWhereInput[]
    OR?: StorageQuotaWhereInput[]
    NOT?: StorageQuotaWhereInput | StorageQuotaWhereInput[]
    workspaceId?: StringFilter<"StorageQuota"> | string
    maxStorageBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    maxFileCount?: IntFilter<"StorageQuota"> | number
    maxFileSize?: BigIntFilter<"StorageQuota"> | bigint | number
    currentStorageBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    currentFileCount?: IntFilter<"StorageQuota"> | number
    retentionDays?: IntNullableFilter<"StorageQuota"> | number | null
    autoCleanup?: BoolFilter<"StorageQuota"> | boolean
    updatedAt?: DateTimeFilter<"StorageQuota"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type StorageQuotaOrderByWithRelationInput = {
    workspaceId?: SortOrder
    maxStorageBytes?: SortOrder
    maxFileCount?: SortOrder
    maxFileSize?: SortOrder
    currentStorageBytes?: SortOrder
    currentFileCount?: SortOrder
    retentionDays?: SortOrderInput | SortOrder
    autoCleanup?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type StorageQuotaWhereUniqueInput = Prisma.AtLeast<{
    workspaceId?: string
    AND?: StorageQuotaWhereInput | StorageQuotaWhereInput[]
    OR?: StorageQuotaWhereInput[]
    NOT?: StorageQuotaWhereInput | StorageQuotaWhereInput[]
    maxStorageBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    maxFileCount?: IntFilter<"StorageQuota"> | number
    maxFileSize?: BigIntFilter<"StorageQuota"> | bigint | number
    currentStorageBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    currentFileCount?: IntFilter<"StorageQuota"> | number
    retentionDays?: IntNullableFilter<"StorageQuota"> | number | null
    autoCleanup?: BoolFilter<"StorageQuota"> | boolean
    updatedAt?: DateTimeFilter<"StorageQuota"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "workspaceId">

  export type StorageQuotaOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    maxStorageBytes?: SortOrder
    maxFileCount?: SortOrder
    maxFileSize?: SortOrder
    currentStorageBytes?: SortOrder
    currentFileCount?: SortOrder
    retentionDays?: SortOrderInput | SortOrder
    autoCleanup?: SortOrder
    updatedAt?: SortOrder
    _count?: StorageQuotaCountOrderByAggregateInput
    _avg?: StorageQuotaAvgOrderByAggregateInput
    _max?: StorageQuotaMaxOrderByAggregateInput
    _min?: StorageQuotaMinOrderByAggregateInput
    _sum?: StorageQuotaSumOrderByAggregateInput
  }

  export type StorageQuotaScalarWhereWithAggregatesInput = {
    AND?: StorageQuotaScalarWhereWithAggregatesInput | StorageQuotaScalarWhereWithAggregatesInput[]
    OR?: StorageQuotaScalarWhereWithAggregatesInput[]
    NOT?: StorageQuotaScalarWhereWithAggregatesInput | StorageQuotaScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"StorageQuota"> | string
    maxStorageBytes?: BigIntWithAggregatesFilter<"StorageQuota"> | bigint | number
    maxFileCount?: IntWithAggregatesFilter<"StorageQuota"> | number
    maxFileSize?: BigIntWithAggregatesFilter<"StorageQuota"> | bigint | number
    currentStorageBytes?: BigIntWithAggregatesFilter<"StorageQuota"> | bigint | number
    currentFileCount?: IntWithAggregatesFilter<"StorageQuota"> | number
    retentionDays?: IntNullableWithAggregatesFilter<"StorageQuota"> | number | null
    autoCleanup?: BoolWithAggregatesFilter<"StorageQuota"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"StorageQuota"> | Date | string
  }

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    id?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    displayName?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    planCode?: StringFilter<"SubscriptionPlan"> | string
    price?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    billingInterval?: StringFilter<"SubscriptionPlan"> | string
    tier?: StringFilter<"SubscriptionPlan"> | string
    sortOrder?: FloatFilter<"SubscriptionPlan"> | number
    maxApiCalls?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxTokens?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxStorageMb?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxProcessingMin?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxWorkspaces?: IntFilter<"SubscriptionPlan"> | number
    maxUsers?: IntFilter<"SubscriptionPlan"> | number
    maxFileSize?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxTranscriptionsMonthly?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxFilesDaily?: IntFilter<"SubscriptionPlan"> | number
    maxFilesMonthly?: IntFilter<"SubscriptionPlan"> | number
    maxConcurrentJobs?: IntFilter<"SubscriptionPlan"> | number
    maxVoiceSynthesisMonthly?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxExportOperationsMonthly?: IntFilter<"SubscriptionPlan"> | number
    maxAudioDurationMinutes?: IntFilter<"SubscriptionPlan"> | number
    priorityLevel?: IntFilter<"SubscriptionPlan"> | number
    planCategory?: StringFilter<"SubscriptionPlan"> | string
    trialDays?: IntFilter<"SubscriptionPlan"> | number
    isCustom?: BoolFilter<"SubscriptionPlan"> | boolean
    isEnterprise?: BoolFilter<"SubscriptionPlan"> | boolean
    features?: JsonFilter<"SubscriptionPlan">
    recommendedFor?: StringNullableListFilter<"SubscriptionPlan">
    allowedFileTypes?: StringNullableListFilter<"SubscriptionPlan">
    analysisFeatures?: StringNullableListFilter<"SubscriptionPlan">
    collaborationFeatures?: StringNullableListFilter<"SubscriptionPlan">
    integrationFeatures?: StringNullableListFilter<"SubscriptionPlan">
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    isPublic?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: WorkspaceSubscriptionListRelationFilter
    planPricing?: PlanPricingListRelationFilter
    planFeatures?: PlanFeatureMatrixListRelationFilter
    currentPlanRecommendations?: PlanRecommendationListRelationFilter
    recommendedPlanRecommendations?: PlanRecommendationListRelationFilter
    customPlans?: CustomPlanListRelationFilter
  }

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    planCode?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingInterval?: SortOrder
    tier?: SortOrder
    sortOrder?: SortOrder
    maxApiCalls?: SortOrder
    maxTokens?: SortOrder
    maxStorageMb?: SortOrder
    maxProcessingMin?: SortOrder
    maxWorkspaces?: SortOrder
    maxUsers?: SortOrder
    maxFileSize?: SortOrder
    maxTranscriptionsMonthly?: SortOrder
    maxFilesDaily?: SortOrder
    maxFilesMonthly?: SortOrder
    maxConcurrentJobs?: SortOrder
    maxVoiceSynthesisMonthly?: SortOrder
    maxExportOperationsMonthly?: SortOrder
    maxAudioDurationMinutes?: SortOrder
    priorityLevel?: SortOrder
    planCategory?: SortOrder
    trialDays?: SortOrder
    isCustom?: SortOrder
    isEnterprise?: SortOrder
    features?: SortOrder
    recommendedFor?: SortOrder
    allowedFileTypes?: SortOrder
    analysisFeatures?: SortOrder
    collaborationFeatures?: SortOrder
    integrationFeatures?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: WorkspaceSubscriptionOrderByRelationAggregateInput
    planPricing?: PlanPricingOrderByRelationAggregateInput
    planFeatures?: PlanFeatureMatrixOrderByRelationAggregateInput
    currentPlanRecommendations?: PlanRecommendationOrderByRelationAggregateInput
    recommendedPlanRecommendations?: PlanRecommendationOrderByRelationAggregateInput
    customPlans?: CustomPlanOrderByRelationAggregateInput
  }

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    displayName?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    planCode?: StringFilter<"SubscriptionPlan"> | string
    price?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    billingInterval?: StringFilter<"SubscriptionPlan"> | string
    tier?: StringFilter<"SubscriptionPlan"> | string
    sortOrder?: FloatFilter<"SubscriptionPlan"> | number
    maxApiCalls?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxTokens?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxStorageMb?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxProcessingMin?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxWorkspaces?: IntFilter<"SubscriptionPlan"> | number
    maxUsers?: IntFilter<"SubscriptionPlan"> | number
    maxFileSize?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxTranscriptionsMonthly?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxFilesDaily?: IntFilter<"SubscriptionPlan"> | number
    maxFilesMonthly?: IntFilter<"SubscriptionPlan"> | number
    maxConcurrentJobs?: IntFilter<"SubscriptionPlan"> | number
    maxVoiceSynthesisMonthly?: BigIntFilter<"SubscriptionPlan"> | bigint | number
    maxExportOperationsMonthly?: IntFilter<"SubscriptionPlan"> | number
    maxAudioDurationMinutes?: IntFilter<"SubscriptionPlan"> | number
    priorityLevel?: IntFilter<"SubscriptionPlan"> | number
    planCategory?: StringFilter<"SubscriptionPlan"> | string
    trialDays?: IntFilter<"SubscriptionPlan"> | number
    isCustom?: BoolFilter<"SubscriptionPlan"> | boolean
    isEnterprise?: BoolFilter<"SubscriptionPlan"> | boolean
    features?: JsonFilter<"SubscriptionPlan">
    recommendedFor?: StringNullableListFilter<"SubscriptionPlan">
    allowedFileTypes?: StringNullableListFilter<"SubscriptionPlan">
    analysisFeatures?: StringNullableListFilter<"SubscriptionPlan">
    collaborationFeatures?: StringNullableListFilter<"SubscriptionPlan">
    integrationFeatures?: StringNullableListFilter<"SubscriptionPlan">
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    isPublic?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: WorkspaceSubscriptionListRelationFilter
    planPricing?: PlanPricingListRelationFilter
    planFeatures?: PlanFeatureMatrixListRelationFilter
    currentPlanRecommendations?: PlanRecommendationListRelationFilter
    recommendedPlanRecommendations?: PlanRecommendationListRelationFilter
    customPlans?: CustomPlanListRelationFilter
  }, "id" | "name">

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    planCode?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingInterval?: SortOrder
    tier?: SortOrder
    sortOrder?: SortOrder
    maxApiCalls?: SortOrder
    maxTokens?: SortOrder
    maxStorageMb?: SortOrder
    maxProcessingMin?: SortOrder
    maxWorkspaces?: SortOrder
    maxUsers?: SortOrder
    maxFileSize?: SortOrder
    maxTranscriptionsMonthly?: SortOrder
    maxFilesDaily?: SortOrder
    maxFilesMonthly?: SortOrder
    maxConcurrentJobs?: SortOrder
    maxVoiceSynthesisMonthly?: SortOrder
    maxExportOperationsMonthly?: SortOrder
    maxAudioDurationMinutes?: SortOrder
    priorityLevel?: SortOrder
    planCategory?: SortOrder
    trialDays?: SortOrder
    isCustom?: SortOrder
    isEnterprise?: SortOrder
    features?: SortOrder
    recommendedFor?: SortOrder
    allowedFileTypes?: SortOrder
    analysisFeatures?: SortOrder
    collaborationFeatures?: SortOrder
    integrationFeatures?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionPlanCountOrderByAggregateInput
    _avg?: SubscriptionPlanAvgOrderByAggregateInput
    _max?: SubscriptionPlanMaxOrderByAggregateInput
    _min?: SubscriptionPlanMinOrderByAggregateInput
    _sum?: SubscriptionPlanSumOrderByAggregateInput
  }

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    displayName?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    description?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    planCode?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    price?: DecimalWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    billingInterval?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    tier?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    sortOrder?: FloatWithAggregatesFilter<"SubscriptionPlan"> | number
    maxApiCalls?: BigIntWithAggregatesFilter<"SubscriptionPlan"> | bigint | number
    maxTokens?: BigIntWithAggregatesFilter<"SubscriptionPlan"> | bigint | number
    maxStorageMb?: BigIntWithAggregatesFilter<"SubscriptionPlan"> | bigint | number
    maxProcessingMin?: BigIntWithAggregatesFilter<"SubscriptionPlan"> | bigint | number
    maxWorkspaces?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    maxUsers?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    maxFileSize?: BigIntWithAggregatesFilter<"SubscriptionPlan"> | bigint | number
    maxTranscriptionsMonthly?: BigIntWithAggregatesFilter<"SubscriptionPlan"> | bigint | number
    maxFilesDaily?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    maxFilesMonthly?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    maxConcurrentJobs?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    maxVoiceSynthesisMonthly?: BigIntWithAggregatesFilter<"SubscriptionPlan"> | bigint | number
    maxExportOperationsMonthly?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    maxAudioDurationMinutes?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    priorityLevel?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    planCategory?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    trialDays?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    isCustom?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    isEnterprise?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    features?: JsonWithAggregatesFilter<"SubscriptionPlan">
    recommendedFor?: StringNullableListFilter<"SubscriptionPlan">
    allowedFileTypes?: StringNullableListFilter<"SubscriptionPlan">
    analysisFeatures?: StringNullableListFilter<"SubscriptionPlan">
    collaborationFeatures?: StringNullableListFilter<"SubscriptionPlan">
    integrationFeatures?: StringNullableListFilter<"SubscriptionPlan">
    isActive?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    isPublic?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
  }

  export type PlanPricingWhereInput = {
    AND?: PlanPricingWhereInput | PlanPricingWhereInput[]
    OR?: PlanPricingWhereInput[]
    NOT?: PlanPricingWhereInput | PlanPricingWhereInput[]
    id?: StringFilter<"PlanPricing"> | string
    planId?: StringFilter<"PlanPricing"> | string
    currency?: StringFilter<"PlanPricing"> | string
    price?: DecimalFilter<"PlanPricing"> | Decimal | DecimalJsLike | number | string
    billingPeriod?: StringFilter<"PlanPricing"> | string
    region?: StringNullableFilter<"PlanPricing"> | string | null
    isActive?: BoolFilter<"PlanPricing"> | boolean
    createdAt?: DateTimeFilter<"PlanPricing"> | Date | string
    updatedAt?: DateTimeFilter<"PlanPricing"> | Date | string
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
  }

  export type PlanPricingOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    price?: SortOrder
    billingPeriod?: SortOrder
    region?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SubscriptionPlanOrderByWithRelationInput
  }

  export type PlanPricingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId_currency_billingPeriod_region?: PlanPricingPlanIdCurrencyBillingPeriodRegionCompoundUniqueInput
    AND?: PlanPricingWhereInput | PlanPricingWhereInput[]
    OR?: PlanPricingWhereInput[]
    NOT?: PlanPricingWhereInput | PlanPricingWhereInput[]
    planId?: StringFilter<"PlanPricing"> | string
    currency?: StringFilter<"PlanPricing"> | string
    price?: DecimalFilter<"PlanPricing"> | Decimal | DecimalJsLike | number | string
    billingPeriod?: StringFilter<"PlanPricing"> | string
    region?: StringNullableFilter<"PlanPricing"> | string | null
    isActive?: BoolFilter<"PlanPricing"> | boolean
    createdAt?: DateTimeFilter<"PlanPricing"> | Date | string
    updatedAt?: DateTimeFilter<"PlanPricing"> | Date | string
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
  }, "id" | "planId_currency_billingPeriod_region">

  export type PlanPricingOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    price?: SortOrder
    billingPeriod?: SortOrder
    region?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanPricingCountOrderByAggregateInput
    _avg?: PlanPricingAvgOrderByAggregateInput
    _max?: PlanPricingMaxOrderByAggregateInput
    _min?: PlanPricingMinOrderByAggregateInput
    _sum?: PlanPricingSumOrderByAggregateInput
  }

  export type PlanPricingScalarWhereWithAggregatesInput = {
    AND?: PlanPricingScalarWhereWithAggregatesInput | PlanPricingScalarWhereWithAggregatesInput[]
    OR?: PlanPricingScalarWhereWithAggregatesInput[]
    NOT?: PlanPricingScalarWhereWithAggregatesInput | PlanPricingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanPricing"> | string
    planId?: StringWithAggregatesFilter<"PlanPricing"> | string
    currency?: StringWithAggregatesFilter<"PlanPricing"> | string
    price?: DecimalWithAggregatesFilter<"PlanPricing"> | Decimal | DecimalJsLike | number | string
    billingPeriod?: StringWithAggregatesFilter<"PlanPricing"> | string
    region?: StringNullableWithAggregatesFilter<"PlanPricing"> | string | null
    isActive?: BoolWithAggregatesFilter<"PlanPricing"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlanPricing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanPricing"> | Date | string
  }

  export type CurrencyWhereInput = {
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    id?: StringFilter<"Currency"> | string
    code?: StringFilter<"Currency"> | string
    name?: StringFilter<"Currency"> | string
    symbol?: StringFilter<"Currency"> | string
    exchangeRate?: DecimalFilter<"Currency"> | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFilter<"Currency"> | Date | string
    isActive?: BoolFilter<"Currency"> | boolean
    isPrimary?: BoolFilter<"Currency"> | boolean
    createdAt?: DateTimeFilter<"Currency"> | Date | string
    updatedAt?: DateTimeFilter<"Currency"> | Date | string
  }

  export type CurrencyOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    exchangeRate?: SortOrder
    lastUpdated?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    name?: StringFilter<"Currency"> | string
    symbol?: StringFilter<"Currency"> | string
    exchangeRate?: DecimalFilter<"Currency"> | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFilter<"Currency"> | Date | string
    isActive?: BoolFilter<"Currency"> | boolean
    isPrimary?: BoolFilter<"Currency"> | boolean
    createdAt?: DateTimeFilter<"Currency"> | Date | string
    updatedAt?: DateTimeFilter<"Currency"> | Date | string
  }, "id" | "code">

  export type CurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    exchangeRate?: SortOrder
    lastUpdated?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CurrencyCountOrderByAggregateInput
    _avg?: CurrencyAvgOrderByAggregateInput
    _max?: CurrencyMaxOrderByAggregateInput
    _min?: CurrencyMinOrderByAggregateInput
    _sum?: CurrencySumOrderByAggregateInput
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    OR?: CurrencyScalarWhereWithAggregatesInput[]
    NOT?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Currency"> | string
    code?: StringWithAggregatesFilter<"Currency"> | string
    name?: StringWithAggregatesFilter<"Currency"> | string
    symbol?: StringWithAggregatesFilter<"Currency"> | string
    exchangeRate?: DecimalWithAggregatesFilter<"Currency"> | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Currency"> | boolean
    isPrimary?: BoolWithAggregatesFilter<"Currency"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
  }

  export type WorkspaceSubscriptionWhereInput = {
    AND?: WorkspaceSubscriptionWhereInput | WorkspaceSubscriptionWhereInput[]
    OR?: WorkspaceSubscriptionWhereInput[]
    NOT?: WorkspaceSubscriptionWhereInput | WorkspaceSubscriptionWhereInput[]
    id?: StringFilter<"WorkspaceSubscription"> | string
    workspaceId?: StringFilter<"WorkspaceSubscription"> | string
    planId?: StringFilter<"WorkspaceSubscription"> | string
    status?: StringFilter<"WorkspaceSubscription"> | string
    currentPeriodStart?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    nextBillingDate?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    paymentGateway?: StringFilter<"WorkspaceSubscription"> | string
    paymentMethodId?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    currency?: StringFilter<"WorkspaceSubscription"> | string
    amount?: DecimalFilter<"WorkspaceSubscription"> | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    cancelledAt?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    createdAt?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
    billingRecords?: BillingRecordListRelationFilter
    usageRecords?: UsageRecordListRelationFilter
  }

  export type WorkspaceSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    paymentGateway?: SortOrder
    paymentMethodId?: SortOrderInput | SortOrder
    currency?: SortOrder
    amount?: SortOrder
    ewayCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    plan?: SubscriptionPlanOrderByWithRelationInput
    billingRecords?: BillingRecordOrderByRelationAggregateInput
    usageRecords?: UsageRecordOrderByRelationAggregateInput
  }

  export type WorkspaceSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeSubscriptionId?: string
    AND?: WorkspaceSubscriptionWhereInput | WorkspaceSubscriptionWhereInput[]
    OR?: WorkspaceSubscriptionWhereInput[]
    NOT?: WorkspaceSubscriptionWhereInput | WorkspaceSubscriptionWhereInput[]
    workspaceId?: StringFilter<"WorkspaceSubscription"> | string
    planId?: StringFilter<"WorkspaceSubscription"> | string
    status?: StringFilter<"WorkspaceSubscription"> | string
    currentPeriodStart?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    nextBillingDate?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    paymentGateway?: StringFilter<"WorkspaceSubscription"> | string
    paymentMethodId?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    currency?: StringFilter<"WorkspaceSubscription"> | string
    amount?: DecimalFilter<"WorkspaceSubscription"> | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    cancelledAt?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    createdAt?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
    billingRecords?: BillingRecordListRelationFilter
    usageRecords?: UsageRecordListRelationFilter
  }, "id" | "stripeSubscriptionId">

  export type WorkspaceSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    paymentGateway?: SortOrder
    paymentMethodId?: SortOrderInput | SortOrder
    currency?: SortOrder
    amount?: SortOrder
    ewayCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceSubscriptionCountOrderByAggregateInput
    _avg?: WorkspaceSubscriptionAvgOrderByAggregateInput
    _max?: WorkspaceSubscriptionMaxOrderByAggregateInput
    _min?: WorkspaceSubscriptionMinOrderByAggregateInput
    _sum?: WorkspaceSubscriptionSumOrderByAggregateInput
  }

  export type WorkspaceSubscriptionScalarWhereWithAggregatesInput = {
    AND?: WorkspaceSubscriptionScalarWhereWithAggregatesInput | WorkspaceSubscriptionScalarWhereWithAggregatesInput[]
    OR?: WorkspaceSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceSubscriptionScalarWhereWithAggregatesInput | WorkspaceSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceSubscription"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceSubscription"> | string
    planId?: StringWithAggregatesFilter<"WorkspaceSubscription"> | string
    status?: StringWithAggregatesFilter<"WorkspaceSubscription"> | string
    currentPeriodStart?: DateTimeWithAggregatesFilter<"WorkspaceSubscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"WorkspaceSubscription"> | Date | string
    nextBillingDate?: DateTimeNullableWithAggregatesFilter<"WorkspaceSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter<"WorkspaceSubscription"> | Date | string | null
    paymentGateway?: StringWithAggregatesFilter<"WorkspaceSubscription"> | string
    paymentMethodId?: StringNullableWithAggregatesFilter<"WorkspaceSubscription"> | string | null
    currency?: StringWithAggregatesFilter<"WorkspaceSubscription"> | string
    amount?: DecimalWithAggregatesFilter<"WorkspaceSubscription"> | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: StringNullableWithAggregatesFilter<"WorkspaceSubscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"WorkspaceSubscription"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"WorkspaceSubscription"> | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"WorkspaceSubscription"> | Date | string | null
    cancelReason?: StringNullableWithAggregatesFilter<"WorkspaceSubscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkspaceSubscription"> | Date | string
  }

  export type BillingRecordWhereInput = {
    AND?: BillingRecordWhereInput | BillingRecordWhereInput[]
    OR?: BillingRecordWhereInput[]
    NOT?: BillingRecordWhereInput | BillingRecordWhereInput[]
    id?: StringFilter<"BillingRecord"> | string
    subscriptionId?: StringFilter<"BillingRecord"> | string
    invoiceNumber?: StringFilter<"BillingRecord"> | string
    amount?: DecimalFilter<"BillingRecord"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"BillingRecord"> | string
    status?: StringFilter<"BillingRecord"> | string
    paymentMethod?: StringNullableFilter<"BillingRecord"> | string | null
    invoiceDate?: DateTimeFilter<"BillingRecord"> | Date | string
    dueDate?: DateTimeFilter<"BillingRecord"> | Date | string
    paidAt?: DateTimeNullableFilter<"BillingRecord"> | Date | string | null
    stripeInvoiceId?: StringNullableFilter<"BillingRecord"> | string | null
    ewayTransactionId?: StringNullableFilter<"BillingRecord"> | string | null
    invoiceUrl?: StringNullableFilter<"BillingRecord"> | string | null
    failureReason?: StringNullableFilter<"BillingRecord"> | string | null
    usageDetails?: JsonNullableFilter<"BillingRecord">
    createdAt?: DateTimeFilter<"BillingRecord"> | Date | string
    subscription?: XOR<WorkspaceSubscriptionRelationFilter, WorkspaceSubscriptionWhereInput>
  }

  export type BillingRecordOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    ewayTransactionId?: SortOrderInput | SortOrder
    invoiceUrl?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    usageDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    subscription?: WorkspaceSubscriptionOrderByWithRelationInput
  }

  export type BillingRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    stripeInvoiceId?: string
    AND?: BillingRecordWhereInput | BillingRecordWhereInput[]
    OR?: BillingRecordWhereInput[]
    NOT?: BillingRecordWhereInput | BillingRecordWhereInput[]
    subscriptionId?: StringFilter<"BillingRecord"> | string
    amount?: DecimalFilter<"BillingRecord"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"BillingRecord"> | string
    status?: StringFilter<"BillingRecord"> | string
    paymentMethod?: StringNullableFilter<"BillingRecord"> | string | null
    invoiceDate?: DateTimeFilter<"BillingRecord"> | Date | string
    dueDate?: DateTimeFilter<"BillingRecord"> | Date | string
    paidAt?: DateTimeNullableFilter<"BillingRecord"> | Date | string | null
    ewayTransactionId?: StringNullableFilter<"BillingRecord"> | string | null
    invoiceUrl?: StringNullableFilter<"BillingRecord"> | string | null
    failureReason?: StringNullableFilter<"BillingRecord"> | string | null
    usageDetails?: JsonNullableFilter<"BillingRecord">
    createdAt?: DateTimeFilter<"BillingRecord"> | Date | string
    subscription?: XOR<WorkspaceSubscriptionRelationFilter, WorkspaceSubscriptionWhereInput>
  }, "id" | "invoiceNumber" | "stripeInvoiceId">

  export type BillingRecordOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    ewayTransactionId?: SortOrderInput | SortOrder
    invoiceUrl?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    usageDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BillingRecordCountOrderByAggregateInput
    _avg?: BillingRecordAvgOrderByAggregateInput
    _max?: BillingRecordMaxOrderByAggregateInput
    _min?: BillingRecordMinOrderByAggregateInput
    _sum?: BillingRecordSumOrderByAggregateInput
  }

  export type BillingRecordScalarWhereWithAggregatesInput = {
    AND?: BillingRecordScalarWhereWithAggregatesInput | BillingRecordScalarWhereWithAggregatesInput[]
    OR?: BillingRecordScalarWhereWithAggregatesInput[]
    NOT?: BillingRecordScalarWhereWithAggregatesInput | BillingRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingRecord"> | string
    subscriptionId?: StringWithAggregatesFilter<"BillingRecord"> | string
    invoiceNumber?: StringWithAggregatesFilter<"BillingRecord"> | string
    amount?: DecimalWithAggregatesFilter<"BillingRecord"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"BillingRecord"> | string
    status?: StringWithAggregatesFilter<"BillingRecord"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"BillingRecord"> | string | null
    invoiceDate?: DateTimeWithAggregatesFilter<"BillingRecord"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"BillingRecord"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"BillingRecord"> | Date | string | null
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"BillingRecord"> | string | null
    ewayTransactionId?: StringNullableWithAggregatesFilter<"BillingRecord"> | string | null
    invoiceUrl?: StringNullableWithAggregatesFilter<"BillingRecord"> | string | null
    failureReason?: StringNullableWithAggregatesFilter<"BillingRecord"> | string | null
    usageDetails?: JsonNullableWithAggregatesFilter<"BillingRecord">
    createdAt?: DateTimeWithAggregatesFilter<"BillingRecord"> | Date | string
  }

  export type UsageRecordWhereInput = {
    AND?: UsageRecordWhereInput | UsageRecordWhereInput[]
    OR?: UsageRecordWhereInput[]
    NOT?: UsageRecordWhereInput | UsageRecordWhereInput[]
    id?: StringFilter<"UsageRecord"> | string
    subscriptionId?: StringFilter<"UsageRecord"> | string
    recordType?: StringFilter<"UsageRecord"> | string
    quantity?: DecimalFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalNullableFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFilter<"UsageRecord"> | Date | string
    periodEnd?: DateTimeFilter<"UsageRecord"> | Date | string
    metadata?: JsonNullableFilter<"UsageRecord">
    createdAt?: DateTimeFilter<"UsageRecord"> | Date | string
    subscription?: XOR<WorkspaceSubscriptionRelationFilter, WorkspaceSubscriptionWhereInput>
  }

  export type UsageRecordOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    recordType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    subscription?: WorkspaceSubscriptionOrderByWithRelationInput
  }

  export type UsageRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageRecordWhereInput | UsageRecordWhereInput[]
    OR?: UsageRecordWhereInput[]
    NOT?: UsageRecordWhereInput | UsageRecordWhereInput[]
    subscriptionId?: StringFilter<"UsageRecord"> | string
    recordType?: StringFilter<"UsageRecord"> | string
    quantity?: DecimalFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalNullableFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFilter<"UsageRecord"> | Date | string
    periodEnd?: DateTimeFilter<"UsageRecord"> | Date | string
    metadata?: JsonNullableFilter<"UsageRecord">
    createdAt?: DateTimeFilter<"UsageRecord"> | Date | string
    subscription?: XOR<WorkspaceSubscriptionRelationFilter, WorkspaceSubscriptionWhereInput>
  }, "id">

  export type UsageRecordOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    recordType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UsageRecordCountOrderByAggregateInput
    _avg?: UsageRecordAvgOrderByAggregateInput
    _max?: UsageRecordMaxOrderByAggregateInput
    _min?: UsageRecordMinOrderByAggregateInput
    _sum?: UsageRecordSumOrderByAggregateInput
  }

  export type UsageRecordScalarWhereWithAggregatesInput = {
    AND?: UsageRecordScalarWhereWithAggregatesInput | UsageRecordScalarWhereWithAggregatesInput[]
    OR?: UsageRecordScalarWhereWithAggregatesInput[]
    NOT?: UsageRecordScalarWhereWithAggregatesInput | UsageRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageRecord"> | string
    subscriptionId?: StringWithAggregatesFilter<"UsageRecord"> | string
    recordType?: StringWithAggregatesFilter<"UsageRecord"> | string
    quantity?: DecimalWithAggregatesFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalNullableWithAggregatesFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableWithAggregatesFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeWithAggregatesFilter<"UsageRecord"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"UsageRecord"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"UsageRecord">
    createdAt?: DateTimeWithAggregatesFilter<"UsageRecord"> | Date | string
  }

  export type UsageCounterWhereInput = {
    AND?: UsageCounterWhereInput | UsageCounterWhereInput[]
    OR?: UsageCounterWhereInput[]
    NOT?: UsageCounterWhereInput | UsageCounterWhereInput[]
    id?: StringFilter<"UsageCounter"> | string
    userId?: StringFilter<"UsageCounter"> | string
    workspaceId?: StringNullableFilter<"UsageCounter"> | string | null
    periodType?: StringFilter<"UsageCounter"> | string
    periodStart?: DateTimeFilter<"UsageCounter"> | Date | string
    periodEnd?: DateTimeFilter<"UsageCounter"> | Date | string
    transcriptionsUsed?: IntFilter<"UsageCounter"> | number
    filesUploaded?: IntFilter<"UsageCounter"> | number
    voiceSynthesisUsed?: IntFilter<"UsageCounter"> | number
    exportOperationsUsed?: IntFilter<"UsageCounter"> | number
    totalProcessingMinutes?: DecimalFilter<"UsageCounter"> | Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: IntFilter<"UsageCounter"> | number
    featureUsage?: JsonFilter<"UsageCounter">
    lastResetAt?: DateTimeFilter<"UsageCounter"> | Date | string
    autoReset?: BoolFilter<"UsageCounter"> | boolean
    createdAt?: DateTimeFilter<"UsageCounter"> | Date | string
    updatedAt?: DateTimeFilter<"UsageCounter"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UsageCounterOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    periodType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    transcriptionsUsed?: SortOrder
    filesUploaded?: SortOrder
    voiceSynthesisUsed?: SortOrder
    exportOperationsUsed?: SortOrder
    totalProcessingMinutes?: SortOrder
    concurrentJobsPeak?: SortOrder
    featureUsage?: SortOrder
    lastResetAt?: SortOrder
    autoReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UsageCounterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_workspaceId_periodType_periodStart?: UsageCounterUserIdWorkspaceIdPeriodTypePeriodStartCompoundUniqueInput
    AND?: UsageCounterWhereInput | UsageCounterWhereInput[]
    OR?: UsageCounterWhereInput[]
    NOT?: UsageCounterWhereInput | UsageCounterWhereInput[]
    userId?: StringFilter<"UsageCounter"> | string
    workspaceId?: StringNullableFilter<"UsageCounter"> | string | null
    periodType?: StringFilter<"UsageCounter"> | string
    periodStart?: DateTimeFilter<"UsageCounter"> | Date | string
    periodEnd?: DateTimeFilter<"UsageCounter"> | Date | string
    transcriptionsUsed?: IntFilter<"UsageCounter"> | number
    filesUploaded?: IntFilter<"UsageCounter"> | number
    voiceSynthesisUsed?: IntFilter<"UsageCounter"> | number
    exportOperationsUsed?: IntFilter<"UsageCounter"> | number
    totalProcessingMinutes?: DecimalFilter<"UsageCounter"> | Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: IntFilter<"UsageCounter"> | number
    featureUsage?: JsonFilter<"UsageCounter">
    lastResetAt?: DateTimeFilter<"UsageCounter"> | Date | string
    autoReset?: BoolFilter<"UsageCounter"> | boolean
    createdAt?: DateTimeFilter<"UsageCounter"> | Date | string
    updatedAt?: DateTimeFilter<"UsageCounter"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_workspaceId_periodType_periodStart">

  export type UsageCounterOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    periodType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    transcriptionsUsed?: SortOrder
    filesUploaded?: SortOrder
    voiceSynthesisUsed?: SortOrder
    exportOperationsUsed?: SortOrder
    totalProcessingMinutes?: SortOrder
    concurrentJobsPeak?: SortOrder
    featureUsage?: SortOrder
    lastResetAt?: SortOrder
    autoReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsageCounterCountOrderByAggregateInput
    _avg?: UsageCounterAvgOrderByAggregateInput
    _max?: UsageCounterMaxOrderByAggregateInput
    _min?: UsageCounterMinOrderByAggregateInput
    _sum?: UsageCounterSumOrderByAggregateInput
  }

  export type UsageCounterScalarWhereWithAggregatesInput = {
    AND?: UsageCounterScalarWhereWithAggregatesInput | UsageCounterScalarWhereWithAggregatesInput[]
    OR?: UsageCounterScalarWhereWithAggregatesInput[]
    NOT?: UsageCounterScalarWhereWithAggregatesInput | UsageCounterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageCounter"> | string
    userId?: StringWithAggregatesFilter<"UsageCounter"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"UsageCounter"> | string | null
    periodType?: StringWithAggregatesFilter<"UsageCounter"> | string
    periodStart?: DateTimeWithAggregatesFilter<"UsageCounter"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"UsageCounter"> | Date | string
    transcriptionsUsed?: IntWithAggregatesFilter<"UsageCounter"> | number
    filesUploaded?: IntWithAggregatesFilter<"UsageCounter"> | number
    voiceSynthesisUsed?: IntWithAggregatesFilter<"UsageCounter"> | number
    exportOperationsUsed?: IntWithAggregatesFilter<"UsageCounter"> | number
    totalProcessingMinutes?: DecimalWithAggregatesFilter<"UsageCounter"> | Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: IntWithAggregatesFilter<"UsageCounter"> | number
    featureUsage?: JsonWithAggregatesFilter<"UsageCounter">
    lastResetAt?: DateTimeWithAggregatesFilter<"UsageCounter"> | Date | string
    autoReset?: BoolWithAggregatesFilter<"UsageCounter"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UsageCounter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UsageCounter"> | Date | string
  }

  export type PlanRecommendationWhereInput = {
    AND?: PlanRecommendationWhereInput | PlanRecommendationWhereInput[]
    OR?: PlanRecommendationWhereInput[]
    NOT?: PlanRecommendationWhereInput | PlanRecommendationWhereInput[]
    id?: StringFilter<"PlanRecommendation"> | string
    userId?: StringFilter<"PlanRecommendation"> | string
    workspaceId?: StringNullableFilter<"PlanRecommendation"> | string | null
    currentPlanId?: StringFilter<"PlanRecommendation"> | string
    recommendedPlanId?: StringFilter<"PlanRecommendation"> | string
    recommendationReason?: StringFilter<"PlanRecommendation"> | string
    confidenceScore?: DecimalNullableFilter<"PlanRecommendation"> | Decimal | DecimalJsLike | number | string | null
    usagePattern?: JsonNullableFilter<"PlanRecommendation">
    projectedSavings?: DecimalNullableFilter<"PlanRecommendation"> | Decimal | DecimalJsLike | number | string | null
    roiMonths?: IntNullableFilter<"PlanRecommendation"> | number | null
    triggeredBy?: StringNullableFilter<"PlanRecommendation"> | string | null
    benefits?: StringNullableListFilter<"PlanRecommendation">
    limitationsRemoved?: StringNullableListFilter<"PlanRecommendation">
    status?: StringFilter<"PlanRecommendation"> | string
    viewedAt?: DateTimeNullableFilter<"PlanRecommendation"> | Date | string | null
    dismissedAt?: DateTimeNullableFilter<"PlanRecommendation"> | Date | string | null
    acceptedAt?: DateTimeNullableFilter<"PlanRecommendation"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"PlanRecommendation"> | Date | string | null
    createdAt?: DateTimeFilter<"PlanRecommendation"> | Date | string
    updatedAt?: DateTimeFilter<"PlanRecommendation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    currentPlan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
    recommendedPlan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
  }

  export type PlanRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    currentPlanId?: SortOrder
    recommendedPlanId?: SortOrder
    recommendationReason?: SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    usagePattern?: SortOrderInput | SortOrder
    projectedSavings?: SortOrderInput | SortOrder
    roiMonths?: SortOrderInput | SortOrder
    triggeredBy?: SortOrderInput | SortOrder
    benefits?: SortOrder
    limitationsRemoved?: SortOrder
    status?: SortOrder
    viewedAt?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    currentPlan?: SubscriptionPlanOrderByWithRelationInput
    recommendedPlan?: SubscriptionPlanOrderByWithRelationInput
  }

  export type PlanRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanRecommendationWhereInput | PlanRecommendationWhereInput[]
    OR?: PlanRecommendationWhereInput[]
    NOT?: PlanRecommendationWhereInput | PlanRecommendationWhereInput[]
    userId?: StringFilter<"PlanRecommendation"> | string
    workspaceId?: StringNullableFilter<"PlanRecommendation"> | string | null
    currentPlanId?: StringFilter<"PlanRecommendation"> | string
    recommendedPlanId?: StringFilter<"PlanRecommendation"> | string
    recommendationReason?: StringFilter<"PlanRecommendation"> | string
    confidenceScore?: DecimalNullableFilter<"PlanRecommendation"> | Decimal | DecimalJsLike | number | string | null
    usagePattern?: JsonNullableFilter<"PlanRecommendation">
    projectedSavings?: DecimalNullableFilter<"PlanRecommendation"> | Decimal | DecimalJsLike | number | string | null
    roiMonths?: IntNullableFilter<"PlanRecommendation"> | number | null
    triggeredBy?: StringNullableFilter<"PlanRecommendation"> | string | null
    benefits?: StringNullableListFilter<"PlanRecommendation">
    limitationsRemoved?: StringNullableListFilter<"PlanRecommendation">
    status?: StringFilter<"PlanRecommendation"> | string
    viewedAt?: DateTimeNullableFilter<"PlanRecommendation"> | Date | string | null
    dismissedAt?: DateTimeNullableFilter<"PlanRecommendation"> | Date | string | null
    acceptedAt?: DateTimeNullableFilter<"PlanRecommendation"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"PlanRecommendation"> | Date | string | null
    createdAt?: DateTimeFilter<"PlanRecommendation"> | Date | string
    updatedAt?: DateTimeFilter<"PlanRecommendation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    currentPlan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
    recommendedPlan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
  }, "id">

  export type PlanRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    currentPlanId?: SortOrder
    recommendedPlanId?: SortOrder
    recommendationReason?: SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    usagePattern?: SortOrderInput | SortOrder
    projectedSavings?: SortOrderInput | SortOrder
    roiMonths?: SortOrderInput | SortOrder
    triggeredBy?: SortOrderInput | SortOrder
    benefits?: SortOrder
    limitationsRemoved?: SortOrder
    status?: SortOrder
    viewedAt?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanRecommendationCountOrderByAggregateInput
    _avg?: PlanRecommendationAvgOrderByAggregateInput
    _max?: PlanRecommendationMaxOrderByAggregateInput
    _min?: PlanRecommendationMinOrderByAggregateInput
    _sum?: PlanRecommendationSumOrderByAggregateInput
  }

  export type PlanRecommendationScalarWhereWithAggregatesInput = {
    AND?: PlanRecommendationScalarWhereWithAggregatesInput | PlanRecommendationScalarWhereWithAggregatesInput[]
    OR?: PlanRecommendationScalarWhereWithAggregatesInput[]
    NOT?: PlanRecommendationScalarWhereWithAggregatesInput | PlanRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanRecommendation"> | string
    userId?: StringWithAggregatesFilter<"PlanRecommendation"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"PlanRecommendation"> | string | null
    currentPlanId?: StringWithAggregatesFilter<"PlanRecommendation"> | string
    recommendedPlanId?: StringWithAggregatesFilter<"PlanRecommendation"> | string
    recommendationReason?: StringWithAggregatesFilter<"PlanRecommendation"> | string
    confidenceScore?: DecimalNullableWithAggregatesFilter<"PlanRecommendation"> | Decimal | DecimalJsLike | number | string | null
    usagePattern?: JsonNullableWithAggregatesFilter<"PlanRecommendation">
    projectedSavings?: DecimalNullableWithAggregatesFilter<"PlanRecommendation"> | Decimal | DecimalJsLike | number | string | null
    roiMonths?: IntNullableWithAggregatesFilter<"PlanRecommendation"> | number | null
    triggeredBy?: StringNullableWithAggregatesFilter<"PlanRecommendation"> | string | null
    benefits?: StringNullableListFilter<"PlanRecommendation">
    limitationsRemoved?: StringNullableListFilter<"PlanRecommendation">
    status?: StringWithAggregatesFilter<"PlanRecommendation"> | string
    viewedAt?: DateTimeNullableWithAggregatesFilter<"PlanRecommendation"> | Date | string | null
    dismissedAt?: DateTimeNullableWithAggregatesFilter<"PlanRecommendation"> | Date | string | null
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"PlanRecommendation"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PlanRecommendation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlanRecommendation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanRecommendation"> | Date | string
  }

  export type CustomPlanWhereInput = {
    AND?: CustomPlanWhereInput | CustomPlanWhereInput[]
    OR?: CustomPlanWhereInput[]
    NOT?: CustomPlanWhereInput | CustomPlanWhereInput[]
    id?: StringFilter<"CustomPlan"> | string
    workspaceId?: StringFilter<"CustomPlan"> | string
    basePlanId?: StringNullableFilter<"CustomPlan"> | string | null
    planName?: StringFilter<"CustomPlan"> | string
    description?: StringNullableFilter<"CustomPlan"> | string | null
    customMaxTranscriptionsMonthly?: BigIntNullableFilter<"CustomPlan"> | bigint | number | null
    customMaxFilesDaily?: IntNullableFilter<"CustomPlan"> | number | null
    customMaxFilesMonthly?: IntNullableFilter<"CustomPlan"> | number | null
    customMaxConcurrentJobs?: IntNullableFilter<"CustomPlan"> | number | null
    customMaxVoiceSynthesisMonthly?: BigIntNullableFilter<"CustomPlan"> | bigint | number | null
    customMaxExportOperationsMonthly?: IntNullableFilter<"CustomPlan"> | number | null
    customMaxAudioDurationMinutes?: IntNullableFilter<"CustomPlan"> | number | null
    customPriorityLevel?: IntNullableFilter<"CustomPlan"> | number | null
    customFeatures?: StringNullableListFilter<"CustomPlan">
    excludedFeatures?: StringNullableListFilter<"CustomPlan">
    additionalFeatures?: StringNullableListFilter<"CustomPlan">
    customPrice?: DecimalNullableFilter<"CustomPlan"> | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFilter<"CustomPlan"> | string
    billingInterval?: StringFilter<"CustomPlan"> | string
    contractStartDate?: DateTimeNullableFilter<"CustomPlan"> | Date | string | null
    contractEndDate?: DateTimeNullableFilter<"CustomPlan"> | Date | string | null
    autoRenew?: BoolFilter<"CustomPlan"> | boolean
    noticePeriodDays?: IntFilter<"CustomPlan"> | number
    requestedBy?: StringNullableFilter<"CustomPlan"> | string | null
    approvedBy?: StringNullableFilter<"CustomPlan"> | string | null
    approvalStatus?: StringFilter<"CustomPlan"> | string
    approvalNotes?: StringNullableFilter<"CustomPlan"> | string | null
    isActive?: BoolFilter<"CustomPlan"> | boolean
    activatedAt?: DateTimeNullableFilter<"CustomPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"CustomPlan"> | Date | string
    updatedAt?: DateTimeFilter<"CustomPlan"> | Date | string
    requestedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    basePlan?: XOR<SubscriptionPlanNullableRelationFilter, SubscriptionPlanWhereInput> | null
  }

  export type CustomPlanOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    basePlanId?: SortOrderInput | SortOrder
    planName?: SortOrder
    description?: SortOrderInput | SortOrder
    customMaxTranscriptionsMonthly?: SortOrderInput | SortOrder
    customMaxFilesDaily?: SortOrderInput | SortOrder
    customMaxFilesMonthly?: SortOrderInput | SortOrder
    customMaxConcurrentJobs?: SortOrderInput | SortOrder
    customMaxVoiceSynthesisMonthly?: SortOrderInput | SortOrder
    customMaxExportOperationsMonthly?: SortOrderInput | SortOrder
    customMaxAudioDurationMinutes?: SortOrderInput | SortOrder
    customPriorityLevel?: SortOrderInput | SortOrder
    customFeatures?: SortOrder
    excludedFeatures?: SortOrder
    additionalFeatures?: SortOrder
    customPrice?: SortOrderInput | SortOrder
    pricingModel?: SortOrder
    billingInterval?: SortOrder
    contractStartDate?: SortOrderInput | SortOrder
    contractEndDate?: SortOrderInput | SortOrder
    autoRenew?: SortOrder
    noticePeriodDays?: SortOrder
    requestedBy?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvalStatus?: SortOrder
    approvalNotes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    activatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requestedByUser?: UserOrderByWithRelationInput
    basePlan?: SubscriptionPlanOrderByWithRelationInput
  }

  export type CustomPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomPlanWhereInput | CustomPlanWhereInput[]
    OR?: CustomPlanWhereInput[]
    NOT?: CustomPlanWhereInput | CustomPlanWhereInput[]
    workspaceId?: StringFilter<"CustomPlan"> | string
    basePlanId?: StringNullableFilter<"CustomPlan"> | string | null
    planName?: StringFilter<"CustomPlan"> | string
    description?: StringNullableFilter<"CustomPlan"> | string | null
    customMaxTranscriptionsMonthly?: BigIntNullableFilter<"CustomPlan"> | bigint | number | null
    customMaxFilesDaily?: IntNullableFilter<"CustomPlan"> | number | null
    customMaxFilesMonthly?: IntNullableFilter<"CustomPlan"> | number | null
    customMaxConcurrentJobs?: IntNullableFilter<"CustomPlan"> | number | null
    customMaxVoiceSynthesisMonthly?: BigIntNullableFilter<"CustomPlan"> | bigint | number | null
    customMaxExportOperationsMonthly?: IntNullableFilter<"CustomPlan"> | number | null
    customMaxAudioDurationMinutes?: IntNullableFilter<"CustomPlan"> | number | null
    customPriorityLevel?: IntNullableFilter<"CustomPlan"> | number | null
    customFeatures?: StringNullableListFilter<"CustomPlan">
    excludedFeatures?: StringNullableListFilter<"CustomPlan">
    additionalFeatures?: StringNullableListFilter<"CustomPlan">
    customPrice?: DecimalNullableFilter<"CustomPlan"> | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFilter<"CustomPlan"> | string
    billingInterval?: StringFilter<"CustomPlan"> | string
    contractStartDate?: DateTimeNullableFilter<"CustomPlan"> | Date | string | null
    contractEndDate?: DateTimeNullableFilter<"CustomPlan"> | Date | string | null
    autoRenew?: BoolFilter<"CustomPlan"> | boolean
    noticePeriodDays?: IntFilter<"CustomPlan"> | number
    requestedBy?: StringNullableFilter<"CustomPlan"> | string | null
    approvedBy?: StringNullableFilter<"CustomPlan"> | string | null
    approvalStatus?: StringFilter<"CustomPlan"> | string
    approvalNotes?: StringNullableFilter<"CustomPlan"> | string | null
    isActive?: BoolFilter<"CustomPlan"> | boolean
    activatedAt?: DateTimeNullableFilter<"CustomPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"CustomPlan"> | Date | string
    updatedAt?: DateTimeFilter<"CustomPlan"> | Date | string
    requestedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    basePlan?: XOR<SubscriptionPlanNullableRelationFilter, SubscriptionPlanWhereInput> | null
  }, "id">

  export type CustomPlanOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    basePlanId?: SortOrderInput | SortOrder
    planName?: SortOrder
    description?: SortOrderInput | SortOrder
    customMaxTranscriptionsMonthly?: SortOrderInput | SortOrder
    customMaxFilesDaily?: SortOrderInput | SortOrder
    customMaxFilesMonthly?: SortOrderInput | SortOrder
    customMaxConcurrentJobs?: SortOrderInput | SortOrder
    customMaxVoiceSynthesisMonthly?: SortOrderInput | SortOrder
    customMaxExportOperationsMonthly?: SortOrderInput | SortOrder
    customMaxAudioDurationMinutes?: SortOrderInput | SortOrder
    customPriorityLevel?: SortOrderInput | SortOrder
    customFeatures?: SortOrder
    excludedFeatures?: SortOrder
    additionalFeatures?: SortOrder
    customPrice?: SortOrderInput | SortOrder
    pricingModel?: SortOrder
    billingInterval?: SortOrder
    contractStartDate?: SortOrderInput | SortOrder
    contractEndDate?: SortOrderInput | SortOrder
    autoRenew?: SortOrder
    noticePeriodDays?: SortOrder
    requestedBy?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvalStatus?: SortOrder
    approvalNotes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    activatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomPlanCountOrderByAggregateInput
    _avg?: CustomPlanAvgOrderByAggregateInput
    _max?: CustomPlanMaxOrderByAggregateInput
    _min?: CustomPlanMinOrderByAggregateInput
    _sum?: CustomPlanSumOrderByAggregateInput
  }

  export type CustomPlanScalarWhereWithAggregatesInput = {
    AND?: CustomPlanScalarWhereWithAggregatesInput | CustomPlanScalarWhereWithAggregatesInput[]
    OR?: CustomPlanScalarWhereWithAggregatesInput[]
    NOT?: CustomPlanScalarWhereWithAggregatesInput | CustomPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomPlan"> | string
    workspaceId?: StringWithAggregatesFilter<"CustomPlan"> | string
    basePlanId?: StringNullableWithAggregatesFilter<"CustomPlan"> | string | null
    planName?: StringWithAggregatesFilter<"CustomPlan"> | string
    description?: StringNullableWithAggregatesFilter<"CustomPlan"> | string | null
    customMaxTranscriptionsMonthly?: BigIntNullableWithAggregatesFilter<"CustomPlan"> | bigint | number | null
    customMaxFilesDaily?: IntNullableWithAggregatesFilter<"CustomPlan"> | number | null
    customMaxFilesMonthly?: IntNullableWithAggregatesFilter<"CustomPlan"> | number | null
    customMaxConcurrentJobs?: IntNullableWithAggregatesFilter<"CustomPlan"> | number | null
    customMaxVoiceSynthesisMonthly?: BigIntNullableWithAggregatesFilter<"CustomPlan"> | bigint | number | null
    customMaxExportOperationsMonthly?: IntNullableWithAggregatesFilter<"CustomPlan"> | number | null
    customMaxAudioDurationMinutes?: IntNullableWithAggregatesFilter<"CustomPlan"> | number | null
    customPriorityLevel?: IntNullableWithAggregatesFilter<"CustomPlan"> | number | null
    customFeatures?: StringNullableListFilter<"CustomPlan">
    excludedFeatures?: StringNullableListFilter<"CustomPlan">
    additionalFeatures?: StringNullableListFilter<"CustomPlan">
    customPrice?: DecimalNullableWithAggregatesFilter<"CustomPlan"> | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringWithAggregatesFilter<"CustomPlan"> | string
    billingInterval?: StringWithAggregatesFilter<"CustomPlan"> | string
    contractStartDate?: DateTimeNullableWithAggregatesFilter<"CustomPlan"> | Date | string | null
    contractEndDate?: DateTimeNullableWithAggregatesFilter<"CustomPlan"> | Date | string | null
    autoRenew?: BoolWithAggregatesFilter<"CustomPlan"> | boolean
    noticePeriodDays?: IntWithAggregatesFilter<"CustomPlan"> | number
    requestedBy?: StringNullableWithAggregatesFilter<"CustomPlan"> | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"CustomPlan"> | string | null
    approvalStatus?: StringWithAggregatesFilter<"CustomPlan"> | string
    approvalNotes?: StringNullableWithAggregatesFilter<"CustomPlan"> | string | null
    isActive?: BoolWithAggregatesFilter<"CustomPlan"> | boolean
    activatedAt?: DateTimeNullableWithAggregatesFilter<"CustomPlan"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CustomPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomPlan"> | Date | string
  }

  export type FeatureFlagWhereInput = {
    AND?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    OR?: FeatureFlagWhereInput[]
    NOT?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    id?: StringFilter<"FeatureFlag"> | string
    featureName?: StringFilter<"FeatureFlag"> | string
    displayName?: StringFilter<"FeatureFlag"> | string
    description?: StringNullableFilter<"FeatureFlag"> | string | null
    category?: StringNullableFilter<"FeatureFlag"> | string | null
    featureType?: StringNullableFilter<"FeatureFlag"> | string | null
    minPlanLevel?: IntFilter<"FeatureFlag"> | number
    requiredPlans?: StringNullableListFilter<"FeatureFlag">
    excludedPlans?: StringNullableListFilter<"FeatureFlag">
    isEnabled?: BoolFilter<"FeatureFlag"> | boolean
    isBeta?: BoolFilter<"FeatureFlag"> | boolean
    isDeprecated?: BoolFilter<"FeatureFlag"> | boolean
    usageCount?: BigIntFilter<"FeatureFlag"> | bigint | number
    lastUsedAt?: DateTimeNullableFilter<"FeatureFlag"> | Date | string | null
    createdAt?: DateTimeFilter<"FeatureFlag"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureFlag"> | Date | string
    planFeatures?: PlanFeatureMatrixListRelationFilter
  }

  export type FeatureFlagOrderByWithRelationInput = {
    id?: SortOrder
    featureName?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    featureType?: SortOrderInput | SortOrder
    minPlanLevel?: SortOrder
    requiredPlans?: SortOrder
    excludedPlans?: SortOrder
    isEnabled?: SortOrder
    isBeta?: SortOrder
    isDeprecated?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planFeatures?: PlanFeatureMatrixOrderByRelationAggregateInput
  }

  export type FeatureFlagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    featureName?: string
    AND?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    OR?: FeatureFlagWhereInput[]
    NOT?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    displayName?: StringFilter<"FeatureFlag"> | string
    description?: StringNullableFilter<"FeatureFlag"> | string | null
    category?: StringNullableFilter<"FeatureFlag"> | string | null
    featureType?: StringNullableFilter<"FeatureFlag"> | string | null
    minPlanLevel?: IntFilter<"FeatureFlag"> | number
    requiredPlans?: StringNullableListFilter<"FeatureFlag">
    excludedPlans?: StringNullableListFilter<"FeatureFlag">
    isEnabled?: BoolFilter<"FeatureFlag"> | boolean
    isBeta?: BoolFilter<"FeatureFlag"> | boolean
    isDeprecated?: BoolFilter<"FeatureFlag"> | boolean
    usageCount?: BigIntFilter<"FeatureFlag"> | bigint | number
    lastUsedAt?: DateTimeNullableFilter<"FeatureFlag"> | Date | string | null
    createdAt?: DateTimeFilter<"FeatureFlag"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureFlag"> | Date | string
    planFeatures?: PlanFeatureMatrixListRelationFilter
  }, "id" | "featureName">

  export type FeatureFlagOrderByWithAggregationInput = {
    id?: SortOrder
    featureName?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    featureType?: SortOrderInput | SortOrder
    minPlanLevel?: SortOrder
    requiredPlans?: SortOrder
    excludedPlans?: SortOrder
    isEnabled?: SortOrder
    isBeta?: SortOrder
    isDeprecated?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureFlagCountOrderByAggregateInput
    _avg?: FeatureFlagAvgOrderByAggregateInput
    _max?: FeatureFlagMaxOrderByAggregateInput
    _min?: FeatureFlagMinOrderByAggregateInput
    _sum?: FeatureFlagSumOrderByAggregateInput
  }

  export type FeatureFlagScalarWhereWithAggregatesInput = {
    AND?: FeatureFlagScalarWhereWithAggregatesInput | FeatureFlagScalarWhereWithAggregatesInput[]
    OR?: FeatureFlagScalarWhereWithAggregatesInput[]
    NOT?: FeatureFlagScalarWhereWithAggregatesInput | FeatureFlagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeatureFlag"> | string
    featureName?: StringWithAggregatesFilter<"FeatureFlag"> | string
    displayName?: StringWithAggregatesFilter<"FeatureFlag"> | string
    description?: StringNullableWithAggregatesFilter<"FeatureFlag"> | string | null
    category?: StringNullableWithAggregatesFilter<"FeatureFlag"> | string | null
    featureType?: StringNullableWithAggregatesFilter<"FeatureFlag"> | string | null
    minPlanLevel?: IntWithAggregatesFilter<"FeatureFlag"> | number
    requiredPlans?: StringNullableListFilter<"FeatureFlag">
    excludedPlans?: StringNullableListFilter<"FeatureFlag">
    isEnabled?: BoolWithAggregatesFilter<"FeatureFlag"> | boolean
    isBeta?: BoolWithAggregatesFilter<"FeatureFlag"> | boolean
    isDeprecated?: BoolWithAggregatesFilter<"FeatureFlag"> | boolean
    usageCount?: BigIntWithAggregatesFilter<"FeatureFlag"> | bigint | number
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"FeatureFlag"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FeatureFlag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeatureFlag"> | Date | string
  }

  export type PlanFeatureMatrixWhereInput = {
    AND?: PlanFeatureMatrixWhereInput | PlanFeatureMatrixWhereInput[]
    OR?: PlanFeatureMatrixWhereInput[]
    NOT?: PlanFeatureMatrixWhereInput | PlanFeatureMatrixWhereInput[]
    id?: StringFilter<"PlanFeatureMatrix"> | string
    planId?: StringFilter<"PlanFeatureMatrix"> | string
    featureFlagId?: StringFilter<"PlanFeatureMatrix"> | string
    isEnabled?: BoolFilter<"PlanFeatureMatrix"> | boolean
    usageLimit?: IntNullableFilter<"PlanFeatureMatrix"> | number | null
    includedUsage?: IntFilter<"PlanFeatureMatrix"> | number
    overageRate?: DecimalNullableFilter<"PlanFeatureMatrix"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PlanFeatureMatrix"> | Date | string
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
    featureFlag?: XOR<FeatureFlagRelationFilter, FeatureFlagWhereInput>
  }

  export type PlanFeatureMatrixOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    featureFlagId?: SortOrder
    isEnabled?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    includedUsage?: SortOrder
    overageRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    plan?: SubscriptionPlanOrderByWithRelationInput
    featureFlag?: FeatureFlagOrderByWithRelationInput
  }

  export type PlanFeatureMatrixWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId_featureFlagId?: PlanFeatureMatrixPlanIdFeatureFlagIdCompoundUniqueInput
    AND?: PlanFeatureMatrixWhereInput | PlanFeatureMatrixWhereInput[]
    OR?: PlanFeatureMatrixWhereInput[]
    NOT?: PlanFeatureMatrixWhereInput | PlanFeatureMatrixWhereInput[]
    planId?: StringFilter<"PlanFeatureMatrix"> | string
    featureFlagId?: StringFilter<"PlanFeatureMatrix"> | string
    isEnabled?: BoolFilter<"PlanFeatureMatrix"> | boolean
    usageLimit?: IntNullableFilter<"PlanFeatureMatrix"> | number | null
    includedUsage?: IntFilter<"PlanFeatureMatrix"> | number
    overageRate?: DecimalNullableFilter<"PlanFeatureMatrix"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PlanFeatureMatrix"> | Date | string
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
    featureFlag?: XOR<FeatureFlagRelationFilter, FeatureFlagWhereInput>
  }, "id" | "planId_featureFlagId">

  export type PlanFeatureMatrixOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    featureFlagId?: SortOrder
    isEnabled?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    includedUsage?: SortOrder
    overageRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PlanFeatureMatrixCountOrderByAggregateInput
    _avg?: PlanFeatureMatrixAvgOrderByAggregateInput
    _max?: PlanFeatureMatrixMaxOrderByAggregateInput
    _min?: PlanFeatureMatrixMinOrderByAggregateInput
    _sum?: PlanFeatureMatrixSumOrderByAggregateInput
  }

  export type PlanFeatureMatrixScalarWhereWithAggregatesInput = {
    AND?: PlanFeatureMatrixScalarWhereWithAggregatesInput | PlanFeatureMatrixScalarWhereWithAggregatesInput[]
    OR?: PlanFeatureMatrixScalarWhereWithAggregatesInput[]
    NOT?: PlanFeatureMatrixScalarWhereWithAggregatesInput | PlanFeatureMatrixScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanFeatureMatrix"> | string
    planId?: StringWithAggregatesFilter<"PlanFeatureMatrix"> | string
    featureFlagId?: StringWithAggregatesFilter<"PlanFeatureMatrix"> | string
    isEnabled?: BoolWithAggregatesFilter<"PlanFeatureMatrix"> | boolean
    usageLimit?: IntNullableWithAggregatesFilter<"PlanFeatureMatrix"> | number | null
    includedUsage?: IntWithAggregatesFilter<"PlanFeatureMatrix"> | number
    overageRate?: DecimalNullableWithAggregatesFilter<"PlanFeatureMatrix"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlanFeatureMatrix"> | Date | string
  }

  export type EwayCustomerWhereInput = {
    AND?: EwayCustomerWhereInput | EwayCustomerWhereInput[]
    OR?: EwayCustomerWhereInput[]
    NOT?: EwayCustomerWhereInput | EwayCustomerWhereInput[]
    id?: StringFilter<"EwayCustomer"> | string
    userId?: StringFilter<"EwayCustomer"> | string
    ewayCustomerToken?: StringFilter<"EwayCustomer"> | string
    firstName?: StringFilter<"EwayCustomer"> | string
    lastName?: StringFilter<"EwayCustomer"> | string
    email?: StringFilter<"EwayCustomer"> | string
    companyName?: StringNullableFilter<"EwayCustomer"> | string | null
    country?: StringFilter<"EwayCustomer"> | string
    streetAddress?: StringNullableFilter<"EwayCustomer"> | string | null
    city?: StringNullableFilter<"EwayCustomer"> | string | null
    state?: StringNullableFilter<"EwayCustomer"> | string | null
    postalCode?: StringNullableFilter<"EwayCustomer"> | string | null
    phoneNumber?: StringNullableFilter<"EwayCustomer"> | string | null
    cardLastFour?: StringNullableFilter<"EwayCustomer"> | string | null
    cardType?: StringNullableFilter<"EwayCustomer"> | string | null
    cardExpiryMonth?: IntNullableFilter<"EwayCustomer"> | number | null
    cardExpiryYear?: IntNullableFilter<"EwayCustomer"> | number | null
    ewayReference?: StringNullableFilter<"EwayCustomer"> | string | null
    isActive?: BoolFilter<"EwayCustomer"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"EwayCustomer"> | Date | string | null
    createdAt?: DateTimeFilter<"EwayCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"EwayCustomer"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactions?: EwayTransactionListRelationFilter
    recurringSchedules?: EwayRecurringScheduleListRelationFilter
  }

  export type EwayCustomerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    ewayCustomerToken?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    companyName?: SortOrderInput | SortOrder
    country?: SortOrder
    streetAddress?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    cardLastFour?: SortOrderInput | SortOrder
    cardType?: SortOrderInput | SortOrder
    cardExpiryMonth?: SortOrderInput | SortOrder
    cardExpiryYear?: SortOrderInput | SortOrder
    ewayReference?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    transactions?: EwayTransactionOrderByRelationAggregateInput
    recurringSchedules?: EwayRecurringScheduleOrderByRelationAggregateInput
  }

  export type EwayCustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ewayCustomerToken?: string
    AND?: EwayCustomerWhereInput | EwayCustomerWhereInput[]
    OR?: EwayCustomerWhereInput[]
    NOT?: EwayCustomerWhereInput | EwayCustomerWhereInput[]
    userId?: StringFilter<"EwayCustomer"> | string
    firstName?: StringFilter<"EwayCustomer"> | string
    lastName?: StringFilter<"EwayCustomer"> | string
    email?: StringFilter<"EwayCustomer"> | string
    companyName?: StringNullableFilter<"EwayCustomer"> | string | null
    country?: StringFilter<"EwayCustomer"> | string
    streetAddress?: StringNullableFilter<"EwayCustomer"> | string | null
    city?: StringNullableFilter<"EwayCustomer"> | string | null
    state?: StringNullableFilter<"EwayCustomer"> | string | null
    postalCode?: StringNullableFilter<"EwayCustomer"> | string | null
    phoneNumber?: StringNullableFilter<"EwayCustomer"> | string | null
    cardLastFour?: StringNullableFilter<"EwayCustomer"> | string | null
    cardType?: StringNullableFilter<"EwayCustomer"> | string | null
    cardExpiryMonth?: IntNullableFilter<"EwayCustomer"> | number | null
    cardExpiryYear?: IntNullableFilter<"EwayCustomer"> | number | null
    ewayReference?: StringNullableFilter<"EwayCustomer"> | string | null
    isActive?: BoolFilter<"EwayCustomer"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"EwayCustomer"> | Date | string | null
    createdAt?: DateTimeFilter<"EwayCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"EwayCustomer"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactions?: EwayTransactionListRelationFilter
    recurringSchedules?: EwayRecurringScheduleListRelationFilter
  }, "id" | "ewayCustomerToken">

  export type EwayCustomerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    ewayCustomerToken?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    companyName?: SortOrderInput | SortOrder
    country?: SortOrder
    streetAddress?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    cardLastFour?: SortOrderInput | SortOrder
    cardType?: SortOrderInput | SortOrder
    cardExpiryMonth?: SortOrderInput | SortOrder
    cardExpiryYear?: SortOrderInput | SortOrder
    ewayReference?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EwayCustomerCountOrderByAggregateInput
    _avg?: EwayCustomerAvgOrderByAggregateInput
    _max?: EwayCustomerMaxOrderByAggregateInput
    _min?: EwayCustomerMinOrderByAggregateInput
    _sum?: EwayCustomerSumOrderByAggregateInput
  }

  export type EwayCustomerScalarWhereWithAggregatesInput = {
    AND?: EwayCustomerScalarWhereWithAggregatesInput | EwayCustomerScalarWhereWithAggregatesInput[]
    OR?: EwayCustomerScalarWhereWithAggregatesInput[]
    NOT?: EwayCustomerScalarWhereWithAggregatesInput | EwayCustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EwayCustomer"> | string
    userId?: StringWithAggregatesFilter<"EwayCustomer"> | string
    ewayCustomerToken?: StringWithAggregatesFilter<"EwayCustomer"> | string
    firstName?: StringWithAggregatesFilter<"EwayCustomer"> | string
    lastName?: StringWithAggregatesFilter<"EwayCustomer"> | string
    email?: StringWithAggregatesFilter<"EwayCustomer"> | string
    companyName?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    country?: StringWithAggregatesFilter<"EwayCustomer"> | string
    streetAddress?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    city?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    state?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    cardLastFour?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    cardType?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    cardExpiryMonth?: IntNullableWithAggregatesFilter<"EwayCustomer"> | number | null
    cardExpiryYear?: IntNullableWithAggregatesFilter<"EwayCustomer"> | number | null
    ewayReference?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    isActive?: BoolWithAggregatesFilter<"EwayCustomer"> | boolean
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"EwayCustomer"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EwayCustomer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EwayCustomer"> | Date | string
  }

  export type EwayTransactionWhereInput = {
    AND?: EwayTransactionWhereInput | EwayTransactionWhereInput[]
    OR?: EwayTransactionWhereInput[]
    NOT?: EwayTransactionWhereInput | EwayTransactionWhereInput[]
    id?: StringFilter<"EwayTransaction"> | string
    userId?: StringFilter<"EwayTransaction"> | string
    workspaceId?: StringNullableFilter<"EwayTransaction"> | string | null
    ewayCustomerId?: StringFilter<"EwayTransaction"> | string
    subscriptionId?: StringNullableFilter<"EwayTransaction"> | string | null
    transactionType?: StringFilter<"EwayTransaction"> | string
    amount?: DecimalFilter<"EwayTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"EwayTransaction"> | string
    ewayTransactionId?: BigIntNullableFilter<"EwayTransaction"> | bigint | number | null
    ewayAccessCode?: StringNullableFilter<"EwayTransaction"> | string | null
    ewayAuthCode?: StringNullableFilter<"EwayTransaction"> | string | null
    responseCode?: StringNullableFilter<"EwayTransaction"> | string | null
    responseMessage?: StringNullableFilter<"EwayTransaction"> | string | null
    transactionStatus?: StringFilter<"EwayTransaction"> | string
    isRecurring?: BoolFilter<"EwayTransaction"> | boolean
    ewayInvoiceNumber?: StringNullableFilter<"EwayTransaction"> | string | null
    ewayInvoiceReference?: StringNullableFilter<"EwayTransaction"> | string | null
    fraudAction?: StringNullableFilter<"EwayTransaction"> | string | null
    verificationStatus?: StringNullableFilter<"EwayTransaction"> | string | null
    beagleScore?: FloatNullableFilter<"EwayTransaction"> | number | null
    errorCode?: StringNullableFilter<"EwayTransaction"> | string | null
    errorMessage?: StringNullableFilter<"EwayTransaction"> | string | null
    processedAt?: DateTimeNullableFilter<"EwayTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"EwayTransaction"> | Date | string
    ewayRawResponse?: JsonNullableFilter<"EwayTransaction">
    user?: XOR<UserRelationFilter, UserWhereInput>
    ewayCustomer?: XOR<EwayCustomerRelationFilter, EwayCustomerWhereInput>
  }

  export type EwayTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    ewayCustomerId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    ewayTransactionId?: SortOrderInput | SortOrder
    ewayAccessCode?: SortOrderInput | SortOrder
    ewayAuthCode?: SortOrderInput | SortOrder
    responseCode?: SortOrderInput | SortOrder
    responseMessage?: SortOrderInput | SortOrder
    transactionStatus?: SortOrder
    isRecurring?: SortOrder
    ewayInvoiceNumber?: SortOrderInput | SortOrder
    ewayInvoiceReference?: SortOrderInput | SortOrder
    fraudAction?: SortOrderInput | SortOrder
    verificationStatus?: SortOrderInput | SortOrder
    beagleScore?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    ewayRawResponse?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    ewayCustomer?: EwayCustomerOrderByWithRelationInput
  }

  export type EwayTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EwayTransactionWhereInput | EwayTransactionWhereInput[]
    OR?: EwayTransactionWhereInput[]
    NOT?: EwayTransactionWhereInput | EwayTransactionWhereInput[]
    userId?: StringFilter<"EwayTransaction"> | string
    workspaceId?: StringNullableFilter<"EwayTransaction"> | string | null
    ewayCustomerId?: StringFilter<"EwayTransaction"> | string
    subscriptionId?: StringNullableFilter<"EwayTransaction"> | string | null
    transactionType?: StringFilter<"EwayTransaction"> | string
    amount?: DecimalFilter<"EwayTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"EwayTransaction"> | string
    ewayTransactionId?: BigIntNullableFilter<"EwayTransaction"> | bigint | number | null
    ewayAccessCode?: StringNullableFilter<"EwayTransaction"> | string | null
    ewayAuthCode?: StringNullableFilter<"EwayTransaction"> | string | null
    responseCode?: StringNullableFilter<"EwayTransaction"> | string | null
    responseMessage?: StringNullableFilter<"EwayTransaction"> | string | null
    transactionStatus?: StringFilter<"EwayTransaction"> | string
    isRecurring?: BoolFilter<"EwayTransaction"> | boolean
    ewayInvoiceNumber?: StringNullableFilter<"EwayTransaction"> | string | null
    ewayInvoiceReference?: StringNullableFilter<"EwayTransaction"> | string | null
    fraudAction?: StringNullableFilter<"EwayTransaction"> | string | null
    verificationStatus?: StringNullableFilter<"EwayTransaction"> | string | null
    beagleScore?: FloatNullableFilter<"EwayTransaction"> | number | null
    errorCode?: StringNullableFilter<"EwayTransaction"> | string | null
    errorMessage?: StringNullableFilter<"EwayTransaction"> | string | null
    processedAt?: DateTimeNullableFilter<"EwayTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"EwayTransaction"> | Date | string
    ewayRawResponse?: JsonNullableFilter<"EwayTransaction">
    user?: XOR<UserRelationFilter, UserWhereInput>
    ewayCustomer?: XOR<EwayCustomerRelationFilter, EwayCustomerWhereInput>
  }, "id">

  export type EwayTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    ewayCustomerId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    ewayTransactionId?: SortOrderInput | SortOrder
    ewayAccessCode?: SortOrderInput | SortOrder
    ewayAuthCode?: SortOrderInput | SortOrder
    responseCode?: SortOrderInput | SortOrder
    responseMessage?: SortOrderInput | SortOrder
    transactionStatus?: SortOrder
    isRecurring?: SortOrder
    ewayInvoiceNumber?: SortOrderInput | SortOrder
    ewayInvoiceReference?: SortOrderInput | SortOrder
    fraudAction?: SortOrderInput | SortOrder
    verificationStatus?: SortOrderInput | SortOrder
    beagleScore?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    ewayRawResponse?: SortOrderInput | SortOrder
    _count?: EwayTransactionCountOrderByAggregateInput
    _avg?: EwayTransactionAvgOrderByAggregateInput
    _max?: EwayTransactionMaxOrderByAggregateInput
    _min?: EwayTransactionMinOrderByAggregateInput
    _sum?: EwayTransactionSumOrderByAggregateInput
  }

  export type EwayTransactionScalarWhereWithAggregatesInput = {
    AND?: EwayTransactionScalarWhereWithAggregatesInput | EwayTransactionScalarWhereWithAggregatesInput[]
    OR?: EwayTransactionScalarWhereWithAggregatesInput[]
    NOT?: EwayTransactionScalarWhereWithAggregatesInput | EwayTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EwayTransaction"> | string
    userId?: StringWithAggregatesFilter<"EwayTransaction"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    ewayCustomerId?: StringWithAggregatesFilter<"EwayTransaction"> | string
    subscriptionId?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    transactionType?: StringWithAggregatesFilter<"EwayTransaction"> | string
    amount?: DecimalWithAggregatesFilter<"EwayTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"EwayTransaction"> | string
    ewayTransactionId?: BigIntNullableWithAggregatesFilter<"EwayTransaction"> | bigint | number | null
    ewayAccessCode?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    ewayAuthCode?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    responseCode?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    responseMessage?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    transactionStatus?: StringWithAggregatesFilter<"EwayTransaction"> | string
    isRecurring?: BoolWithAggregatesFilter<"EwayTransaction"> | boolean
    ewayInvoiceNumber?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    ewayInvoiceReference?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    fraudAction?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    verificationStatus?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    beagleScore?: FloatNullableWithAggregatesFilter<"EwayTransaction"> | number | null
    errorCode?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"EwayTransaction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EwayTransaction"> | Date | string
    ewayRawResponse?: JsonNullableWithAggregatesFilter<"EwayTransaction">
  }

  export type EwayRecurringScheduleWhereInput = {
    AND?: EwayRecurringScheduleWhereInput | EwayRecurringScheduleWhereInput[]
    OR?: EwayRecurringScheduleWhereInput[]
    NOT?: EwayRecurringScheduleWhereInput | EwayRecurringScheduleWhereInput[]
    id?: StringFilter<"EwayRecurringSchedule"> | string
    userId?: StringFilter<"EwayRecurringSchedule"> | string
    workspaceId?: StringNullableFilter<"EwayRecurringSchedule"> | string | null
    ewayCustomerId?: StringFilter<"EwayRecurringSchedule"> | string
    subscriptionId?: StringFilter<"EwayRecurringSchedule"> | string
    scheduleType?: StringFilter<"EwayRecurringSchedule"> | string
    billingAmount?: DecimalFilter<"EwayRecurringSchedule"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"EwayRecurringSchedule"> | string
    startDate?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    nextBillingDate?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    lastProcessedAt?: DateTimeNullableFilter<"EwayRecurringSchedule"> | Date | string | null
    status?: StringFilter<"EwayRecurringSchedule"> | string
    failedAttempts?: IntFilter<"EwayRecurringSchedule"> | number
    lastTransactionId?: StringNullableFilter<"EwayRecurringSchedule"> | string | null
    cancelledAt?: DateTimeNullableFilter<"EwayRecurringSchedule"> | Date | string | null
    metadata?: JsonNullableFilter<"EwayRecurringSchedule">
    createdAt?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ewayCustomer?: XOR<EwayCustomerRelationFilter, EwayCustomerWhereInput>
  }

  export type EwayRecurringScheduleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    ewayCustomerId?: SortOrder
    subscriptionId?: SortOrder
    scheduleType?: SortOrder
    billingAmount?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrder
    lastProcessedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    failedAttempts?: SortOrder
    lastTransactionId?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    ewayCustomer?: EwayCustomerOrderByWithRelationInput
  }

  export type EwayRecurringScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EwayRecurringScheduleWhereInput | EwayRecurringScheduleWhereInput[]
    OR?: EwayRecurringScheduleWhereInput[]
    NOT?: EwayRecurringScheduleWhereInput | EwayRecurringScheduleWhereInput[]
    userId?: StringFilter<"EwayRecurringSchedule"> | string
    workspaceId?: StringNullableFilter<"EwayRecurringSchedule"> | string | null
    ewayCustomerId?: StringFilter<"EwayRecurringSchedule"> | string
    subscriptionId?: StringFilter<"EwayRecurringSchedule"> | string
    scheduleType?: StringFilter<"EwayRecurringSchedule"> | string
    billingAmount?: DecimalFilter<"EwayRecurringSchedule"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"EwayRecurringSchedule"> | string
    startDate?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    nextBillingDate?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    lastProcessedAt?: DateTimeNullableFilter<"EwayRecurringSchedule"> | Date | string | null
    status?: StringFilter<"EwayRecurringSchedule"> | string
    failedAttempts?: IntFilter<"EwayRecurringSchedule"> | number
    lastTransactionId?: StringNullableFilter<"EwayRecurringSchedule"> | string | null
    cancelledAt?: DateTimeNullableFilter<"EwayRecurringSchedule"> | Date | string | null
    metadata?: JsonNullableFilter<"EwayRecurringSchedule">
    createdAt?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ewayCustomer?: XOR<EwayCustomerRelationFilter, EwayCustomerWhereInput>
  }, "id">

  export type EwayRecurringScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    ewayCustomerId?: SortOrder
    subscriptionId?: SortOrder
    scheduleType?: SortOrder
    billingAmount?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrder
    lastProcessedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    failedAttempts?: SortOrder
    lastTransactionId?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EwayRecurringScheduleCountOrderByAggregateInput
    _avg?: EwayRecurringScheduleAvgOrderByAggregateInput
    _max?: EwayRecurringScheduleMaxOrderByAggregateInput
    _min?: EwayRecurringScheduleMinOrderByAggregateInput
    _sum?: EwayRecurringScheduleSumOrderByAggregateInput
  }

  export type EwayRecurringScheduleScalarWhereWithAggregatesInput = {
    AND?: EwayRecurringScheduleScalarWhereWithAggregatesInput | EwayRecurringScheduleScalarWhereWithAggregatesInput[]
    OR?: EwayRecurringScheduleScalarWhereWithAggregatesInput[]
    NOT?: EwayRecurringScheduleScalarWhereWithAggregatesInput | EwayRecurringScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EwayRecurringSchedule"> | string
    userId?: StringWithAggregatesFilter<"EwayRecurringSchedule"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"EwayRecurringSchedule"> | string | null
    ewayCustomerId?: StringWithAggregatesFilter<"EwayRecurringSchedule"> | string
    subscriptionId?: StringWithAggregatesFilter<"EwayRecurringSchedule"> | string
    scheduleType?: StringWithAggregatesFilter<"EwayRecurringSchedule"> | string
    billingAmount?: DecimalWithAggregatesFilter<"EwayRecurringSchedule"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"EwayRecurringSchedule"> | string
    startDate?: DateTimeWithAggregatesFilter<"EwayRecurringSchedule"> | Date | string
    nextBillingDate?: DateTimeWithAggregatesFilter<"EwayRecurringSchedule"> | Date | string
    lastProcessedAt?: DateTimeNullableWithAggregatesFilter<"EwayRecurringSchedule"> | Date | string | null
    status?: StringWithAggregatesFilter<"EwayRecurringSchedule"> | string
    failedAttempts?: IntWithAggregatesFilter<"EwayRecurringSchedule"> | number
    lastTransactionId?: StringNullableWithAggregatesFilter<"EwayRecurringSchedule"> | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"EwayRecurringSchedule"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"EwayRecurringSchedule">
    createdAt?: DateTimeWithAggregatesFilter<"EwayRecurringSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EwayRecurringSchedule"> | Date | string
  }

  export type EwayWebhookEventWhereInput = {
    AND?: EwayWebhookEventWhereInput | EwayWebhookEventWhereInput[]
    OR?: EwayWebhookEventWhereInput[]
    NOT?: EwayWebhookEventWhereInput | EwayWebhookEventWhereInput[]
    id?: StringFilter<"EwayWebhookEvent"> | string
    eventType?: StringFilter<"EwayWebhookEvent"> | string
    ewayTransactionId?: BigIntNullableFilter<"EwayWebhookEvent"> | bigint | number | null
    ewayCustomerToken?: StringNullableFilter<"EwayWebhookEvent"> | string | null
    eventData?: JsonFilter<"EwayWebhookEvent">
    rawPayload?: StringFilter<"EwayWebhookEvent"> | string
    processed?: BoolFilter<"EwayWebhookEvent"> | boolean
    processedAt?: DateTimeNullableFilter<"EwayWebhookEvent"> | Date | string | null
    sourceIp?: StringNullableFilter<"EwayWebhookEvent"> | string | null
    createdAt?: DateTimeFilter<"EwayWebhookEvent"> | Date | string
  }

  export type EwayWebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    ewayTransactionId?: SortOrderInput | SortOrder
    ewayCustomerToken?: SortOrderInput | SortOrder
    eventData?: SortOrder
    rawPayload?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    sourceIp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type EwayWebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EwayWebhookEventWhereInput | EwayWebhookEventWhereInput[]
    OR?: EwayWebhookEventWhereInput[]
    NOT?: EwayWebhookEventWhereInput | EwayWebhookEventWhereInput[]
    eventType?: StringFilter<"EwayWebhookEvent"> | string
    ewayTransactionId?: BigIntNullableFilter<"EwayWebhookEvent"> | bigint | number | null
    ewayCustomerToken?: StringNullableFilter<"EwayWebhookEvent"> | string | null
    eventData?: JsonFilter<"EwayWebhookEvent">
    rawPayload?: StringFilter<"EwayWebhookEvent"> | string
    processed?: BoolFilter<"EwayWebhookEvent"> | boolean
    processedAt?: DateTimeNullableFilter<"EwayWebhookEvent"> | Date | string | null
    sourceIp?: StringNullableFilter<"EwayWebhookEvent"> | string | null
    createdAt?: DateTimeFilter<"EwayWebhookEvent"> | Date | string
  }, "id">

  export type EwayWebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    ewayTransactionId?: SortOrderInput | SortOrder
    ewayCustomerToken?: SortOrderInput | SortOrder
    eventData?: SortOrder
    rawPayload?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    sourceIp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EwayWebhookEventCountOrderByAggregateInput
    _avg?: EwayWebhookEventAvgOrderByAggregateInput
    _max?: EwayWebhookEventMaxOrderByAggregateInput
    _min?: EwayWebhookEventMinOrderByAggregateInput
    _sum?: EwayWebhookEventSumOrderByAggregateInput
  }

  export type EwayWebhookEventScalarWhereWithAggregatesInput = {
    AND?: EwayWebhookEventScalarWhereWithAggregatesInput | EwayWebhookEventScalarWhereWithAggregatesInput[]
    OR?: EwayWebhookEventScalarWhereWithAggregatesInput[]
    NOT?: EwayWebhookEventScalarWhereWithAggregatesInput | EwayWebhookEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EwayWebhookEvent"> | string
    eventType?: StringWithAggregatesFilter<"EwayWebhookEvent"> | string
    ewayTransactionId?: BigIntNullableWithAggregatesFilter<"EwayWebhookEvent"> | bigint | number | null
    ewayCustomerToken?: StringNullableWithAggregatesFilter<"EwayWebhookEvent"> | string | null
    eventData?: JsonWithAggregatesFilter<"EwayWebhookEvent">
    rawPayload?: StringWithAggregatesFilter<"EwayWebhookEvent"> | string
    processed?: BoolWithAggregatesFilter<"EwayWebhookEvent"> | boolean
    processedAt?: DateTimeNullableWithAggregatesFilter<"EwayWebhookEvent"> | Date | string | null
    sourceIp?: StringNullableWithAggregatesFilter<"EwayWebhookEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EwayWebhookEvent"> | Date | string
  }

  export type ExportHistoryWhereInput = {
    AND?: ExportHistoryWhereInput | ExportHistoryWhereInput[]
    OR?: ExportHistoryWhereInput[]
    NOT?: ExportHistoryWhereInput | ExportHistoryWhereInput[]
    id?: StringFilter<"ExportHistory"> | string
    userId?: StringFilter<"ExportHistory"> | string
    exportType?: StringFilter<"ExportHistory"> | string
    dataType?: StringFilter<"ExportHistory"> | string
    dateFrom?: DateTimeNullableFilter<"ExportHistory"> | Date | string | null
    dateTo?: DateTimeNullableFilter<"ExportHistory"> | Date | string | null
    workspaceIds?: StringNullableListFilter<"ExportHistory">
    filters?: JsonNullableFilter<"ExportHistory">
    filename?: StringFilter<"ExportHistory"> | string
    fileSize?: BigIntFilter<"ExportHistory"> | bigint | number
    storagePath?: StringNullableFilter<"ExportHistory"> | string | null
    downloadUrl?: StringNullableFilter<"ExportHistory"> | string | null
    expiresAt?: DateTimeNullableFilter<"ExportHistory"> | Date | string | null
    status?: StringFilter<"ExportHistory"> | string
    downloadCount?: IntFilter<"ExportHistory"> | number
    createdAt?: DateTimeFilter<"ExportHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"ExportHistory"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ExportHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    exportType?: SortOrder
    dataType?: SortOrder
    dateFrom?: SortOrderInput | SortOrder
    dateTo?: SortOrderInput | SortOrder
    workspaceIds?: SortOrder
    filters?: SortOrderInput | SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrderInput | SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    status?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ExportHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExportHistoryWhereInput | ExportHistoryWhereInput[]
    OR?: ExportHistoryWhereInput[]
    NOT?: ExportHistoryWhereInput | ExportHistoryWhereInput[]
    userId?: StringFilter<"ExportHistory"> | string
    exportType?: StringFilter<"ExportHistory"> | string
    dataType?: StringFilter<"ExportHistory"> | string
    dateFrom?: DateTimeNullableFilter<"ExportHistory"> | Date | string | null
    dateTo?: DateTimeNullableFilter<"ExportHistory"> | Date | string | null
    workspaceIds?: StringNullableListFilter<"ExportHistory">
    filters?: JsonNullableFilter<"ExportHistory">
    filename?: StringFilter<"ExportHistory"> | string
    fileSize?: BigIntFilter<"ExportHistory"> | bigint | number
    storagePath?: StringNullableFilter<"ExportHistory"> | string | null
    downloadUrl?: StringNullableFilter<"ExportHistory"> | string | null
    expiresAt?: DateTimeNullableFilter<"ExportHistory"> | Date | string | null
    status?: StringFilter<"ExportHistory"> | string
    downloadCount?: IntFilter<"ExportHistory"> | number
    createdAt?: DateTimeFilter<"ExportHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"ExportHistory"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ExportHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    exportType?: SortOrder
    dataType?: SortOrder
    dateFrom?: SortOrderInput | SortOrder
    dateTo?: SortOrderInput | SortOrder
    workspaceIds?: SortOrder
    filters?: SortOrderInput | SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrderInput | SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    status?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ExportHistoryCountOrderByAggregateInput
    _avg?: ExportHistoryAvgOrderByAggregateInput
    _max?: ExportHistoryMaxOrderByAggregateInput
    _min?: ExportHistoryMinOrderByAggregateInput
    _sum?: ExportHistorySumOrderByAggregateInput
  }

  export type ExportHistoryScalarWhereWithAggregatesInput = {
    AND?: ExportHistoryScalarWhereWithAggregatesInput | ExportHistoryScalarWhereWithAggregatesInput[]
    OR?: ExportHistoryScalarWhereWithAggregatesInput[]
    NOT?: ExportHistoryScalarWhereWithAggregatesInput | ExportHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExportHistory"> | string
    userId?: StringWithAggregatesFilter<"ExportHistory"> | string
    exportType?: StringWithAggregatesFilter<"ExportHistory"> | string
    dataType?: StringWithAggregatesFilter<"ExportHistory"> | string
    dateFrom?: DateTimeNullableWithAggregatesFilter<"ExportHistory"> | Date | string | null
    dateTo?: DateTimeNullableWithAggregatesFilter<"ExportHistory"> | Date | string | null
    workspaceIds?: StringNullableListFilter<"ExportHistory">
    filters?: JsonNullableWithAggregatesFilter<"ExportHistory">
    filename?: StringWithAggregatesFilter<"ExportHistory"> | string
    fileSize?: BigIntWithAggregatesFilter<"ExportHistory"> | bigint | number
    storagePath?: StringNullableWithAggregatesFilter<"ExportHistory"> | string | null
    downloadUrl?: StringNullableWithAggregatesFilter<"ExportHistory"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ExportHistory"> | Date | string | null
    status?: StringWithAggregatesFilter<"ExportHistory"> | string
    downloadCount?: IntWithAggregatesFilter<"ExportHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ExportHistory"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ExportHistory"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    workspaceId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    requestId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    severity?: StringFilter<"AuditLog"> | string
    category?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    workspaceId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    severity?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    workspaceId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    requestId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    severity?: StringFilter<"AuditLog"> | string
    category?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    workspaceId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    severity?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    workspaceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    severity?: StringWithAggregatesFilter<"AuditLog"> | string
    category?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type DataRetentionPolicyWhereInput = {
    AND?: DataRetentionPolicyWhereInput | DataRetentionPolicyWhereInput[]
    OR?: DataRetentionPolicyWhereInput[]
    NOT?: DataRetentionPolicyWhereInput | DataRetentionPolicyWhereInput[]
    id?: StringFilter<"DataRetentionPolicy"> | string
    name?: StringFilter<"DataRetentionPolicy"> | string
    description?: StringNullableFilter<"DataRetentionPolicy"> | string | null
    dataType?: StringFilter<"DataRetentionPolicy"> | string
    retentionDays?: IntFilter<"DataRetentionPolicy"> | number
    autoDelete?: BoolFilter<"DataRetentionPolicy"> | boolean
    archiveBeforeDelete?: BoolFilter<"DataRetentionPolicy"> | boolean
    appliesToWorkspaces?: StringNullableListFilter<"DataRetentionPolicy">
    excludeWorkspaces?: StringNullableListFilter<"DataRetentionPolicy">
    isActive?: BoolFilter<"DataRetentionPolicy"> | boolean
    createdAt?: DateTimeFilter<"DataRetentionPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"DataRetentionPolicy"> | Date | string
    lastRunAt?: DateTimeNullableFilter<"DataRetentionPolicy"> | Date | string | null
  }

  export type DataRetentionPolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    dataType?: SortOrder
    retentionDays?: SortOrder
    autoDelete?: SortOrder
    archiveBeforeDelete?: SortOrder
    appliesToWorkspaces?: SortOrder
    excludeWorkspaces?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
  }

  export type DataRetentionPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DataRetentionPolicyWhereInput | DataRetentionPolicyWhereInput[]
    OR?: DataRetentionPolicyWhereInput[]
    NOT?: DataRetentionPolicyWhereInput | DataRetentionPolicyWhereInput[]
    description?: StringNullableFilter<"DataRetentionPolicy"> | string | null
    dataType?: StringFilter<"DataRetentionPolicy"> | string
    retentionDays?: IntFilter<"DataRetentionPolicy"> | number
    autoDelete?: BoolFilter<"DataRetentionPolicy"> | boolean
    archiveBeforeDelete?: BoolFilter<"DataRetentionPolicy"> | boolean
    appliesToWorkspaces?: StringNullableListFilter<"DataRetentionPolicy">
    excludeWorkspaces?: StringNullableListFilter<"DataRetentionPolicy">
    isActive?: BoolFilter<"DataRetentionPolicy"> | boolean
    createdAt?: DateTimeFilter<"DataRetentionPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"DataRetentionPolicy"> | Date | string
    lastRunAt?: DateTimeNullableFilter<"DataRetentionPolicy"> | Date | string | null
  }, "id" | "name">

  export type DataRetentionPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    dataType?: SortOrder
    retentionDays?: SortOrder
    autoDelete?: SortOrder
    archiveBeforeDelete?: SortOrder
    appliesToWorkspaces?: SortOrder
    excludeWorkspaces?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    _count?: DataRetentionPolicyCountOrderByAggregateInput
    _avg?: DataRetentionPolicyAvgOrderByAggregateInput
    _max?: DataRetentionPolicyMaxOrderByAggregateInput
    _min?: DataRetentionPolicyMinOrderByAggregateInput
    _sum?: DataRetentionPolicySumOrderByAggregateInput
  }

  export type DataRetentionPolicyScalarWhereWithAggregatesInput = {
    AND?: DataRetentionPolicyScalarWhereWithAggregatesInput | DataRetentionPolicyScalarWhereWithAggregatesInput[]
    OR?: DataRetentionPolicyScalarWhereWithAggregatesInput[]
    NOT?: DataRetentionPolicyScalarWhereWithAggregatesInput | DataRetentionPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataRetentionPolicy"> | string
    name?: StringWithAggregatesFilter<"DataRetentionPolicy"> | string
    description?: StringNullableWithAggregatesFilter<"DataRetentionPolicy"> | string | null
    dataType?: StringWithAggregatesFilter<"DataRetentionPolicy"> | string
    retentionDays?: IntWithAggregatesFilter<"DataRetentionPolicy"> | number
    autoDelete?: BoolWithAggregatesFilter<"DataRetentionPolicy"> | boolean
    archiveBeforeDelete?: BoolWithAggregatesFilter<"DataRetentionPolicy"> | boolean
    appliesToWorkspaces?: StringNullableListFilter<"DataRetentionPolicy">
    excludeWorkspaces?: StringNullableListFilter<"DataRetentionPolicy">
    isActive?: BoolWithAggregatesFilter<"DataRetentionPolicy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DataRetentionPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DataRetentionPolicy"> | Date | string
    lastRunAt?: DateTimeNullableWithAggregatesFilter<"DataRetentionPolicy"> | Date | string | null
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    workspaceId?: StringFilter<"PaymentMethod"> | string
    provider?: StringFilter<"PaymentMethod"> | string
    providerMethodId?: StringFilter<"PaymentMethod"> | string
    type?: StringFilter<"PaymentMethod"> | string
    last4?: StringNullableFilter<"PaymentMethod"> | string | null
    brand?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    providerMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    expiryMonth?: SortOrderInput | SortOrder
    expiryYear?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    workspaceId?: StringFilter<"PaymentMethod"> | string
    provider?: StringFilter<"PaymentMethod"> | string
    providerMethodId?: StringFilter<"PaymentMethod"> | string
    type?: StringFilter<"PaymentMethod"> | string
    last4?: StringNullableFilter<"PaymentMethod"> | string | null
    brand?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }, "id">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    providerMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    expiryMonth?: SortOrderInput | SortOrder
    expiryYear?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    workspaceId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    provider?: StringWithAggregatesFilter<"PaymentMethod"> | string
    providerMethodId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    type?: StringWithAggregatesFilter<"PaymentMethod"> | string
    last4?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    brand?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableWithAggregatesFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableWithAggregatesFilter<"PaymentMethod"> | number | null
    isDefault?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    isActive?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type TestimonialWhereInput = {
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    id?: StringFilter<"Testimonial"> | string
    customerName?: StringFilter<"Testimonial"> | string
    customerRole?: StringNullableFilter<"Testimonial"> | string | null
    companyName?: StringNullableFilter<"Testimonial"> | string | null
    avatarUrl?: StringNullableFilter<"Testimonial"> | string | null
    content?: StringFilter<"Testimonial"> | string
    rating?: IntFilter<"Testimonial"> | number
    featuredOn?: StringNullableFilter<"Testimonial"> | string | null
    useCase?: StringNullableFilter<"Testimonial"> | string | null
    isVerified?: BoolFilter<"Testimonial"> | boolean
    verificationMethod?: StringNullableFilter<"Testimonial"> | string | null
    isActive?: BoolFilter<"Testimonial"> | boolean
    displayOrder?: IntFilter<"Testimonial"> | number
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
    userId?: StringNullableFilter<"Testimonial"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type TestimonialOrderByWithRelationInput = {
    id?: SortOrder
    customerName?: SortOrder
    customerRole?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    content?: SortOrder
    rating?: SortOrder
    featuredOn?: SortOrderInput | SortOrder
    useCase?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verificationMethod?: SortOrderInput | SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TestimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    customerName?: StringFilter<"Testimonial"> | string
    customerRole?: StringNullableFilter<"Testimonial"> | string | null
    companyName?: StringNullableFilter<"Testimonial"> | string | null
    avatarUrl?: StringNullableFilter<"Testimonial"> | string | null
    content?: StringFilter<"Testimonial"> | string
    rating?: IntFilter<"Testimonial"> | number
    featuredOn?: StringNullableFilter<"Testimonial"> | string | null
    useCase?: StringNullableFilter<"Testimonial"> | string | null
    isVerified?: BoolFilter<"Testimonial"> | boolean
    verificationMethod?: StringNullableFilter<"Testimonial"> | string | null
    isActive?: BoolFilter<"Testimonial"> | boolean
    displayOrder?: IntFilter<"Testimonial"> | number
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
    userId?: StringNullableFilter<"Testimonial"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type TestimonialOrderByWithAggregationInput = {
    id?: SortOrder
    customerName?: SortOrder
    customerRole?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    content?: SortOrder
    rating?: SortOrder
    featuredOn?: SortOrderInput | SortOrder
    useCase?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verificationMethod?: SortOrderInput | SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: TestimonialCountOrderByAggregateInput
    _avg?: TestimonialAvgOrderByAggregateInput
    _max?: TestimonialMaxOrderByAggregateInput
    _min?: TestimonialMinOrderByAggregateInput
    _sum?: TestimonialSumOrderByAggregateInput
  }

  export type TestimonialScalarWhereWithAggregatesInput = {
    AND?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    OR?: TestimonialScalarWhereWithAggregatesInput[]
    NOT?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Testimonial"> | string
    customerName?: StringWithAggregatesFilter<"Testimonial"> | string
    customerRole?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    content?: StringWithAggregatesFilter<"Testimonial"> | string
    rating?: IntWithAggregatesFilter<"Testimonial"> | number
    featuredOn?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    useCase?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Testimonial"> | boolean
    verificationMethod?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    isActive?: BoolWithAggregatesFilter<"Testimonial"> | boolean
    displayOrder?: IntWithAggregatesFilter<"Testimonial"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
  }

  export type WebsiteContentWhereInput = {
    AND?: WebsiteContentWhereInput | WebsiteContentWhereInput[]
    OR?: WebsiteContentWhereInput[]
    NOT?: WebsiteContentWhereInput | WebsiteContentWhereInput[]
    id?: StringFilter<"WebsiteContent"> | string
    contentKey?: StringFilter<"WebsiteContent"> | string
    contentType?: StringFilter<"WebsiteContent"> | string
    contentValue?: StringFilter<"WebsiteContent"> | string
    contentMetadata?: JsonNullableFilter<"WebsiteContent">
    section?: StringNullableFilter<"WebsiteContent"> | string | null
    page?: StringFilter<"WebsiteContent"> | string
    isActive?: BoolFilter<"WebsiteContent"> | boolean
    displayOrder?: IntFilter<"WebsiteContent"> | number
    createdAt?: DateTimeFilter<"WebsiteContent"> | Date | string
    updatedAt?: DateTimeFilter<"WebsiteContent"> | Date | string
  }

  export type WebsiteContentOrderByWithRelationInput = {
    id?: SortOrder
    contentKey?: SortOrder
    contentType?: SortOrder
    contentValue?: SortOrder
    contentMetadata?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    page?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentKey?: string
    AND?: WebsiteContentWhereInput | WebsiteContentWhereInput[]
    OR?: WebsiteContentWhereInput[]
    NOT?: WebsiteContentWhereInput | WebsiteContentWhereInput[]
    contentType?: StringFilter<"WebsiteContent"> | string
    contentValue?: StringFilter<"WebsiteContent"> | string
    contentMetadata?: JsonNullableFilter<"WebsiteContent">
    section?: StringNullableFilter<"WebsiteContent"> | string | null
    page?: StringFilter<"WebsiteContent"> | string
    isActive?: BoolFilter<"WebsiteContent"> | boolean
    displayOrder?: IntFilter<"WebsiteContent"> | number
    createdAt?: DateTimeFilter<"WebsiteContent"> | Date | string
    updatedAt?: DateTimeFilter<"WebsiteContent"> | Date | string
  }, "id" | "contentKey">

  export type WebsiteContentOrderByWithAggregationInput = {
    id?: SortOrder
    contentKey?: SortOrder
    contentType?: SortOrder
    contentValue?: SortOrder
    contentMetadata?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    page?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebsiteContentCountOrderByAggregateInput
    _avg?: WebsiteContentAvgOrderByAggregateInput
    _max?: WebsiteContentMaxOrderByAggregateInput
    _min?: WebsiteContentMinOrderByAggregateInput
    _sum?: WebsiteContentSumOrderByAggregateInput
  }

  export type WebsiteContentScalarWhereWithAggregatesInput = {
    AND?: WebsiteContentScalarWhereWithAggregatesInput | WebsiteContentScalarWhereWithAggregatesInput[]
    OR?: WebsiteContentScalarWhereWithAggregatesInput[]
    NOT?: WebsiteContentScalarWhereWithAggregatesInput | WebsiteContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebsiteContent"> | string
    contentKey?: StringWithAggregatesFilter<"WebsiteContent"> | string
    contentType?: StringWithAggregatesFilter<"WebsiteContent"> | string
    contentValue?: StringWithAggregatesFilter<"WebsiteContent"> | string
    contentMetadata?: JsonNullableWithAggregatesFilter<"WebsiteContent">
    section?: StringNullableWithAggregatesFilter<"WebsiteContent"> | string | null
    page?: StringWithAggregatesFilter<"WebsiteContent"> | string
    isActive?: BoolWithAggregatesFilter<"WebsiteContent"> | boolean
    displayOrder?: IntWithAggregatesFilter<"WebsiteContent"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WebsiteContent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebsiteContent"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    displayName?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystemRole?: BoolFilter<"Role"> | boolean
    isActive?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
    users?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystemRole?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: RolePermissionOrderByRelationAggregateInput
    users?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    displayName?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystemRole?: BoolFilter<"Role"> | boolean
    isActive?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
    users?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystemRole?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    displayName?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isSystemRole?: BoolWithAggregatesFilter<"Role"> | boolean
    isActive?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    displayName?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    isSystemPermission?: BoolFilter<"Permission"> | boolean
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    resource?: SortOrder
    action?: SortOrder
    isSystemPermission?: SortOrder
    createdAt?: SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    displayName?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    isSystemPermission?: BoolFilter<"Permission"> | boolean
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    resource?: SortOrder
    action?: SortOrder
    isSystemPermission?: SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    displayName?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    resource?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    isSystemPermission?: BoolWithAggregatesFilter<"Permission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolePermission"> | string
    roleId?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedBy?: StringNullableFilter<"UserRole"> | string | null
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    expiresAt?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    isActive?: BoolFilter<"UserRole"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    assignedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    assignedByUser?: UserOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedBy?: StringNullableFilter<"UserRole"> | string | null
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    expiresAt?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    isActive?: BoolFilter<"UserRole"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    assignedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRole"> | string
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
    assignedBy?: StringNullableWithAggregatesFilter<"UserRole"> | string | null
    assignedAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"UserRole"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"UserRole"> | boolean
  }

  export type WorkspaceCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsUncheckedCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaUncheckedCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUncheckedUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUncheckedUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type WorkspaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceUserCreateInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutWorkspacesInput
  }

  export type WorkspaceUserUncheckedCreateInput = {
    id?: string
    workspaceId: string
    userId: string
    role?: string
    joinedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: Date | string | null
  }

  export type WorkspaceUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
  }

  export type WorkspaceUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceUserCreateManyInput = {
    id?: string
    workspaceId: string
    userId: string
    role?: string
    joinedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: Date | string | null
  }

  export type WorkspaceUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationCreateInput = {
    id?: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    invitedById?: string | null
    workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
  }

  export type WorkspaceInvitationUncheckedCreateInput = {
    id?: string
    workspaceId: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    invitedById?: string | null
  }

  export type WorkspaceInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceInvitationCreateManyInput = {
    id?: string
    workspaceId: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    invitedById?: string | null
  }

  export type WorkspaceInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    createdAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    createdAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    createdAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityEventCreateInput = {
    id?: string
    eventType: string
    severity?: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutSecurityEventsInput
  }

  export type SecurityEventUncheckedCreateInput = {
    id?: string
    userId?: string | null
    eventType: string
    severity?: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SecurityEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutSecurityEventsNestedInput
  }

  export type SecurityEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityEventCreateManyInput = {
    id?: string
    userId?: string | null
    eventType: string
    severity?: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SecurityEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSettingsCreateInput = {
    openaiApiKeyEncrypted?: string | null
    elevenlabsApiKeyEncrypted?: string | null
    preferredLanguage?: string
    summaryQuality?: string
    defaultSummaryStyle?: string
    defaultTemperature?: number
    defaultMaxTokens?: number
    showCostEstimates?: boolean
    emailNotifications?: boolean
    processingNotifications?: boolean
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    userId: string
    openaiApiKeyEncrypted?: string | null
    elevenlabsApiKeyEncrypted?: string | null
    preferredLanguage?: string
    summaryQuality?: string
    defaultSummaryStyle?: string
    defaultTemperature?: number
    defaultMaxTokens?: number
    showCostEstimates?: boolean
    emailNotifications?: boolean
    processingNotifications?: boolean
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    openaiApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    elevenlabsApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    summaryQuality?: StringFieldUpdateOperationsInput | string
    defaultSummaryStyle?: StringFieldUpdateOperationsInput | string
    defaultTemperature?: FloatFieldUpdateOperationsInput | number
    defaultMaxTokens?: IntFieldUpdateOperationsInput | number
    showCostEstimates?: BoolFieldUpdateOperationsInput | boolean
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    processingNotifications?: BoolFieldUpdateOperationsInput | boolean
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    openaiApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    elevenlabsApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    summaryQuality?: StringFieldUpdateOperationsInput | string
    defaultSummaryStyle?: StringFieldUpdateOperationsInput | string
    defaultTemperature?: FloatFieldUpdateOperationsInput | number
    defaultMaxTokens?: IntFieldUpdateOperationsInput | number
    showCostEstimates?: BoolFieldUpdateOperationsInput | boolean
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    processingNotifications?: BoolFieldUpdateOperationsInput | boolean
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    userId: string
    openaiApiKeyEncrypted?: string | null
    elevenlabsApiKeyEncrypted?: string | null
    preferredLanguage?: string
    summaryQuality?: string
    defaultSummaryStyle?: string
    defaultTemperature?: number
    defaultMaxTokens?: number
    showCostEstimates?: boolean
    emailNotifications?: boolean
    processingNotifications?: boolean
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    openaiApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    elevenlabsApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    summaryQuality?: StringFieldUpdateOperationsInput | string
    defaultSummaryStyle?: StringFieldUpdateOperationsInput | string
    defaultTemperature?: FloatFieldUpdateOperationsInput | number
    defaultMaxTokens?: IntFieldUpdateOperationsInput | number
    showCostEstimates?: BoolFieldUpdateOperationsInput | boolean
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    processingNotifications?: BoolFieldUpdateOperationsInput | boolean
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    openaiApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    elevenlabsApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    summaryQuality?: StringFieldUpdateOperationsInput | string
    defaultSummaryStyle?: StringFieldUpdateOperationsInput | string
    defaultTemperature?: FloatFieldUpdateOperationsInput | number
    defaultMaxTokens?: IntFieldUpdateOperationsInput | number
    showCostEstimates?: BoolFieldUpdateOperationsInput | boolean
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    processingNotifications?: BoolFieldUpdateOperationsInput | boolean
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceSettingsCreateInput = {
    defaultProcessingOptions?: JsonNullValueInput | InputJsonValue
    allowedFileTypes?: WorkspaceSettingsCreateallowedFileTypesInput | string[]
    maxFileSize?: bigint | number
    maxProcessingTime?: number
    allowPublicSharing?: boolean
    allowGuestAccess?: boolean
    requireApprovalForUploads?: boolean
    webhookUrl?: string | null
    webhookSecret?: string | null
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSettingsInput
  }

  export type WorkspaceSettingsUncheckedCreateInput = {
    workspaceId: string
    defaultProcessingOptions?: JsonNullValueInput | InputJsonValue
    allowedFileTypes?: WorkspaceSettingsCreateallowedFileTypesInput | string[]
    maxFileSize?: bigint | number
    maxProcessingTime?: number
    allowPublicSharing?: boolean
    allowGuestAccess?: boolean
    requireApprovalForUploads?: boolean
    webhookUrl?: string | null
    webhookSecret?: string | null
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type WorkspaceSettingsUpdateInput = {
    defaultProcessingOptions?: JsonNullValueInput | InputJsonValue
    allowedFileTypes?: WorkspaceSettingsUpdateallowedFileTypesInput | string[]
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingTime?: IntFieldUpdateOperationsInput | number
    allowPublicSharing?: BoolFieldUpdateOperationsInput | boolean
    allowGuestAccess?: BoolFieldUpdateOperationsInput | boolean
    requireApprovalForUploads?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type WorkspaceSettingsUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    defaultProcessingOptions?: JsonNullValueInput | InputJsonValue
    allowedFileTypes?: WorkspaceSettingsUpdateallowedFileTypesInput | string[]
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingTime?: IntFieldUpdateOperationsInput | number
    allowPublicSharing?: BoolFieldUpdateOperationsInput | boolean
    allowGuestAccess?: BoolFieldUpdateOperationsInput | boolean
    requireApprovalForUploads?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceSettingsCreateManyInput = {
    workspaceId: string
    defaultProcessingOptions?: JsonNullValueInput | InputJsonValue
    allowedFileTypes?: WorkspaceSettingsCreateallowedFileTypesInput | string[]
    maxFileSize?: bigint | number
    maxProcessingTime?: number
    allowPublicSharing?: boolean
    allowGuestAccess?: boolean
    requireApprovalForUploads?: boolean
    webhookUrl?: string | null
    webhookSecret?: string | null
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type WorkspaceSettingsUpdateManyMutationInput = {
    defaultProcessingOptions?: JsonNullValueInput | InputJsonValue
    allowedFileTypes?: WorkspaceSettingsUpdateallowedFileTypesInput | string[]
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingTime?: IntFieldUpdateOperationsInput | number
    allowPublicSharing?: BoolFieldUpdateOperationsInput | boolean
    allowGuestAccess?: BoolFieldUpdateOperationsInput | boolean
    requireApprovalForUploads?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceSettingsUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    defaultProcessingOptions?: JsonNullValueInput | InputJsonValue
    allowedFileTypes?: WorkspaceSettingsUpdateallowedFileTypesInput | string[]
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingTime?: IntFieldUpdateOperationsInput | number
    allowPublicSharing?: BoolFieldUpdateOperationsInput | boolean
    allowGuestAccess?: BoolFieldUpdateOperationsInput | boolean
    requireApprovalForUploads?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessingTemplateCreateInput = {
    id?: string
    workspaceId?: string | null
    name: string
    description?: string | null
    summaryStyle?: string
    temperature?: number
    maxTokens?: number
    language?: string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProcessingTemplatesInput
  }

  export type ProcessingTemplateUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    name: string
    description?: string | null
    summaryStyle?: string
    temperature?: number
    maxTokens?: number
    language?: string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessingTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summaryStyle?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProcessingTemplatesNestedInput
  }

  export type ProcessingTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summaryStyle?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessingTemplateCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    name: string
    description?: string | null
    summaryStyle?: string
    temperature?: number
    maxTokens?: number
    language?: string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessingTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summaryStyle?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessingTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summaryStyle?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyManagementCreateInput = {
    id?: string
    workspaceId?: string | null
    provider: string
    keyName: string
    encryptedKey: string
    keyHash: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    totalRequests?: bigint | number
    totalTokens?: bigint | number
    totalCost?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyManagementUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    provider: string
    keyName: string
    encryptedKey: string
    keyHash: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    totalRequests?: bigint | number
    totalTokens?: bigint | number
    totalCost?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyManagementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRequests?: BigIntFieldUpdateOperationsInput | bigint | number
    totalTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyManagementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRequests?: BigIntFieldUpdateOperationsInput | bigint | number
    totalTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyManagementCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    provider: string
    keyName: string
    encryptedKey: string
    keyHash: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    totalRequests?: bigint | number
    totalTokens?: bigint | number
    totalCost?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyManagementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRequests?: BigIntFieldUpdateOperationsInput | bigint | number
    totalTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyManagementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRequests?: BigIntFieldUpdateOperationsInput | bigint | number
    totalTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioUploadCreateInput = {
    id?: string
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAudioUploadsInput
    workspace?: WorkspaceCreateNestedOneWithoutAudioUploadsInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUploadInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUploadInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkUncheckedCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAudioUploadsNestedInput
    workspace?: WorkspaceUpdateOneWithoutAudioUploadsNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUploadNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUpdateManyWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUploadNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUncheckedUpdateManyWithoutUploadNestedInput
  }

  export type AudioUploadCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AudioUploadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioUploadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProcessingJobCreateInput = {
    id?: string
    jobType: string
    priority?: number
    processingOptions: JsonNullValueInput | InputJsonValue
    status?: string
    progress?: number
    cpuTimeMs?: bigint | number | null
    memoryUsageMb?: number | null
    queuedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    maxRetries?: number
    user: UserCreateNestedOneWithoutProcessingJobsInput
    upload: AudioUploadCreateNestedOneWithoutProcessingJobsInput
  }

  export type ProcessingJobUncheckedCreateInput = {
    id?: string
    userId: string
    uploadId: string
    jobType: string
    priority?: number
    processingOptions: JsonNullValueInput | InputJsonValue
    status?: string
    progress?: number
    cpuTimeMs?: bigint | number | null
    memoryUsageMb?: number | null
    queuedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    maxRetries?: number
  }

  export type ProcessingJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    processingOptions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    cpuTimeMs?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    memoryUsageMb?: NullableIntFieldUpdateOperationsInput | number | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutProcessingJobsNestedInput
    upload?: AudioUploadUpdateOneRequiredWithoutProcessingJobsNestedInput
  }

  export type ProcessingJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    processingOptions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    cpuTimeMs?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    memoryUsageMb?: NullableIntFieldUpdateOperationsInput | number | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessingJobCreateManyInput = {
    id?: string
    userId: string
    uploadId: string
    jobType: string
    priority?: number
    processingOptions: JsonNullValueInput | InputJsonValue
    status?: string
    progress?: number
    cpuTimeMs?: bigint | number | null
    memoryUsageMb?: number | null
    queuedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    maxRetries?: number
  }

  export type ProcessingJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    processingOptions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    cpuTimeMs?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    memoryUsageMb?: NullableIntFieldUpdateOperationsInput | number | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessingJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    processingOptions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    cpuTimeMs?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    memoryUsageMb?: NullableIntFieldUpdateOperationsInput | number | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
  }

  export type AudioHistoryCreateInput = {
    id?: string
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAudioHistoryInput
    workspace?: WorkspaceCreateNestedOneWithoutAudioHistoryInput
    upload?: AudioUploadCreateNestedOneWithoutAudioHistoryInput
    segments?: AudioSegmentCreateNestedManyWithoutHistoryInput
  }

  export type AudioHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    uploadId?: string | null
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    segments?: AudioSegmentUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type AudioHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioHistoryNestedInput
    workspace?: WorkspaceUpdateOneWithoutAudioHistoryNestedInput
    upload?: AudioUploadUpdateOneWithoutAudioHistoryNestedInput
    segments?: AudioSegmentUpdateManyWithoutHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segments?: AudioSegmentUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type AudioHistoryCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    uploadId?: string | null
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioSegmentCreateInput = {
    id?: string
    segmentIndex: number
    startTime: number
    endTime: number
    text: string
    confidence?: number | null
    language?: string | null
    speakerId?: string | null
    emotion?: string | null
    sentiment?: string | null
    tokens?: AudioSegmentCreatetokensInput | number[]
    logprobs?: AudioSegmentCreatelogprobsInput | number[]
    temperature?: number | null
    avgLogprob?: number | null
    compressionRatio?: number | null
    noSpeechProb?: number | null
    history: AudioHistoryCreateNestedOneWithoutSegmentsInput
  }

  export type AudioSegmentUncheckedCreateInput = {
    id?: string
    historyId: string
    segmentIndex: number
    startTime: number
    endTime: number
    text: string
    confidence?: number | null
    language?: string | null
    speakerId?: string | null
    emotion?: string | null
    sentiment?: string | null
    tokens?: AudioSegmentCreatetokensInput | number[]
    logprobs?: AudioSegmentCreatelogprobsInput | number[]
    temperature?: number | null
    avgLogprob?: number | null
    compressionRatio?: number | null
    noSpeechProb?: number | null
  }

  export type AudioSegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    tokens?: AudioSegmentUpdatetokensInput | number[]
    logprobs?: AudioSegmentUpdatelogprobsInput | number[]
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    avgLogprob?: NullableFloatFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    noSpeechProb?: NullableFloatFieldUpdateOperationsInput | number | null
    history?: AudioHistoryUpdateOneRequiredWithoutSegmentsNestedInput
  }

  export type AudioSegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    historyId?: StringFieldUpdateOperationsInput | string
    segmentIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    tokens?: AudioSegmentUpdatetokensInput | number[]
    logprobs?: AudioSegmentUpdatelogprobsInput | number[]
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    avgLogprob?: NullableFloatFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    noSpeechProb?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AudioSegmentCreateManyInput = {
    id?: string
    historyId: string
    segmentIndex: number
    startTime: number
    endTime: number
    text: string
    confidence?: number | null
    language?: string | null
    speakerId?: string | null
    emotion?: string | null
    sentiment?: string | null
    tokens?: AudioSegmentCreatetokensInput | number[]
    logprobs?: AudioSegmentCreatelogprobsInput | number[]
    temperature?: number | null
    avgLogprob?: number | null
    compressionRatio?: number | null
    noSpeechProb?: number | null
  }

  export type AudioSegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    tokens?: AudioSegmentUpdatetokensInput | number[]
    logprobs?: AudioSegmentUpdatelogprobsInput | number[]
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    avgLogprob?: NullableFloatFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    noSpeechProb?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AudioSegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    historyId?: StringFieldUpdateOperationsInput | string
    segmentIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    tokens?: AudioSegmentUpdatetokensInput | number[]
    logprobs?: AudioSegmentUpdatelogprobsInput | number[]
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    avgLogprob?: NullableFloatFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    noSpeechProb?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AudioChunkCreateInput = {
    id?: string
    chunkIndex: number
    startTime: number
    endTime: number
    fileSize: bigint | number
    storagePath: string
    checksumMd5?: string | null
    status?: string
    processedAt?: Date | string | null
    upload: AudioUploadCreateNestedOneWithoutAudioChunksInput
  }

  export type AudioChunkUncheckedCreateInput = {
    id?: string
    uploadId: string
    chunkIndex: number
    startTime: number
    endTime: number
    fileSize: bigint | number
    storagePath: string
    checksumMd5?: string | null
    status?: string
    processedAt?: Date | string | null
  }

  export type AudioChunkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upload?: AudioUploadUpdateOneRequiredWithoutAudioChunksNestedInput
  }

  export type AudioChunkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioChunkCreateManyInput = {
    id?: string
    uploadId: string
    chunkIndex: number
    startTime: number
    endTime: number
    fileSize: bigint | number
    storagePath: string
    checksumMd5?: string | null
    status?: string
    processedAt?: Date | string | null
  }

  export type AudioChunkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioChunkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    status?: string
    isPublic?: boolean
    tags?: AudioProjectCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    workspace?: WorkspaceCreateNestedOneWithoutProjectsInput
  }

  export type AudioProjectUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    name: string
    description?: string | null
    color?: string | null
    status?: string
    isPublic?: boolean
    tags?: AudioProjectCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: AudioProjectUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    workspace?: WorkspaceUpdateOneWithoutProjectsNestedInput
  }

  export type AudioProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: AudioProjectUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioProjectCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    name: string
    description?: string | null
    color?: string | null
    status?: string
    isPublic?: boolean
    tags?: AudioProjectCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: AudioProjectUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: AudioProjectUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricCreateInput = {
    id?: string
    metricType: string
    provider?: string | null
    quantity: bigint | number
    cost: Decimal | DecimalJsLike | number | string
    currency?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
    recordedAt?: Date | string
    user: UserCreateNestedOneWithoutUsageMetricsInput
    workspace?: WorkspaceCreateNestedOneWithoutUsageMetricsInput
  }

  export type UsageMetricUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    metricType: string
    provider?: string | null
    quantity: bigint | number
    cost: Decimal | DecimalJsLike | number | string
    currency?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
    recordedAt?: Date | string
  }

  export type UsageMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsageMetricsNestedInput
    workspace?: WorkspaceUpdateOneWithoutUsageMetricsNestedInput
  }

  export type UsageMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    metricType?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    metricType: string
    provider?: string | null
    quantity: bigint | number
    cost: Decimal | DecimalJsLike | number | string
    currency?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
    recordedAt?: Date | string
  }

  export type UsageMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    metricType?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuotaCreateInput = {
    monthlyApiCalls?: bigint | number
    monthlyTokens?: bigint | number
    monthlyStorageMb?: bigint | number
    monthlyProcessingMin?: bigint | number
    currentApiCalls?: bigint | number
    currentTokens?: bigint | number
    currentStorageMb?: bigint | number
    currentProcessingMin?: bigint | number
    periodStart: Date | string
    periodEnd: Date | string
    lastResetAt?: Date | string
    allowOverages?: boolean
    overageCostPerToken?: Decimal | DecimalJsLike | number | string
    user: UserCreateNestedOneWithoutQuotaInput
  }

  export type UserQuotaUncheckedCreateInput = {
    userId: string
    monthlyApiCalls?: bigint | number
    monthlyTokens?: bigint | number
    monthlyStorageMb?: bigint | number
    monthlyProcessingMin?: bigint | number
    currentApiCalls?: bigint | number
    currentTokens?: bigint | number
    currentStorageMb?: bigint | number
    currentProcessingMin?: bigint | number
    periodStart: Date | string
    periodEnd: Date | string
    lastResetAt?: Date | string
    allowOverages?: boolean
    overageCostPerToken?: Decimal | DecimalJsLike | number | string
  }

  export type UserQuotaUpdateInput = {
    monthlyApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    currentApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    currentTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    currentStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    currentProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowOverages?: BoolFieldUpdateOperationsInput | boolean
    overageCostPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user?: UserUpdateOneRequiredWithoutQuotaNestedInput
  }

  export type UserQuotaUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    monthlyApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    currentApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    currentTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    currentStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    currentProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowOverages?: BoolFieldUpdateOperationsInput | boolean
    overageCostPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserQuotaCreateManyInput = {
    userId: string
    monthlyApiCalls?: bigint | number
    monthlyTokens?: bigint | number
    monthlyStorageMb?: bigint | number
    monthlyProcessingMin?: bigint | number
    currentApiCalls?: bigint | number
    currentTokens?: bigint | number
    currentStorageMb?: bigint | number
    currentProcessingMin?: bigint | number
    periodStart: Date | string
    periodEnd: Date | string
    lastResetAt?: Date | string
    allowOverages?: boolean
    overageCostPerToken?: Decimal | DecimalJsLike | number | string
  }

  export type UserQuotaUpdateManyMutationInput = {
    monthlyApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    currentApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    currentTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    currentStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    currentProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowOverages?: BoolFieldUpdateOperationsInput | boolean
    overageCostPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserQuotaUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    monthlyApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    currentApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    currentTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    currentStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    currentProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowOverages?: BoolFieldUpdateOperationsInput | boolean
    overageCostPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StorageQuotaCreateInput = {
    maxStorageBytes: bigint | number
    maxFileCount: number
    maxFileSize: bigint | number
    currentStorageBytes?: bigint | number
    currentFileCount?: number
    retentionDays?: number | null
    autoCleanup?: boolean
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutStorageQuotaInput
  }

  export type StorageQuotaUncheckedCreateInput = {
    workspaceId: string
    maxStorageBytes: bigint | number
    maxFileCount: number
    maxFileSize: bigint | number
    currentStorageBytes?: bigint | number
    currentFileCount?: number
    retentionDays?: number | null
    autoCleanup?: boolean
    updatedAt?: Date | string
  }

  export type StorageQuotaUpdateInput = {
    maxStorageBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    currentStorageBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    currentFileCount?: IntFieldUpdateOperationsInput | number
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    autoCleanup?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutStorageQuotaNestedInput
  }

  export type StorageQuotaUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    maxStorageBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    currentStorageBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    currentFileCount?: IntFieldUpdateOperationsInput | number
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    autoCleanup?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaCreateManyInput = {
    workspaceId: string
    maxStorageBytes: bigint | number
    maxFileCount: number
    maxFileSize: bigint | number
    currentStorageBytes?: bigint | number
    currentFileCount?: number
    retentionDays?: number | null
    autoCleanup?: boolean
    updatedAt?: Date | string
  }

  export type StorageQuotaUpdateManyMutationInput = {
    maxStorageBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    currentStorageBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    currentFileCount?: IntFieldUpdateOperationsInput | number
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    autoCleanup?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    maxStorageBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    currentStorageBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    currentFileCount?: IntFieldUpdateOperationsInput | number
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    autoCleanup?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutPlanInput
    planPricing?: PlanPricingCreateNestedManyWithoutPlanInput
    planFeatures?: PlanFeatureMatrixCreateNestedManyWithoutPlanInput
    currentPlanRecommendations?: PlanRecommendationCreateNestedManyWithoutCurrentPlanInput
    recommendedPlanRecommendations?: PlanRecommendationCreateNestedManyWithoutRecommendedPlanInput
    customPlans?: CustomPlanCreateNestedManyWithoutBasePlanInput
  }

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutPlanInput
    planPricing?: PlanPricingUncheckedCreateNestedManyWithoutPlanInput
    planFeatures?: PlanFeatureMatrixUncheckedCreateNestedManyWithoutPlanInput
    currentPlanRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutCurrentPlanInput
    recommendedPlanRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutRecommendedPlanInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutBasePlanInput
  }

  export type SubscriptionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutPlanNestedInput
    planPricing?: PlanPricingUpdateManyWithoutPlanNestedInput
    planFeatures?: PlanFeatureMatrixUpdateManyWithoutPlanNestedInput
    currentPlanRecommendations?: PlanRecommendationUpdateManyWithoutCurrentPlanNestedInput
    recommendedPlanRecommendations?: PlanRecommendationUpdateManyWithoutRecommendedPlanNestedInput
    customPlans?: CustomPlanUpdateManyWithoutBasePlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    planPricing?: PlanPricingUncheckedUpdateManyWithoutPlanNestedInput
    planFeatures?: PlanFeatureMatrixUncheckedUpdateManyWithoutPlanNestedInput
    currentPlanRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutCurrentPlanNestedInput
    recommendedPlanRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutRecommendedPlanNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutBasePlanNestedInput
  }

  export type SubscriptionPlanCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPricingCreateInput = {
    id?: string
    currency: string
    price: Decimal | DecimalJsLike | number | string
    billingPeriod: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutPlanPricingInput
  }

  export type PlanPricingUncheckedCreateInput = {
    id?: string
    planId: string
    currency: string
    price: Decimal | DecimalJsLike | number | string
    billingPeriod: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPricingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutPlanPricingNestedInput
  }

  export type PlanPricingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPricingCreateManyInput = {
    id?: string
    planId: string
    currency: string
    price: Decimal | DecimalJsLike | number | string
    billingPeriod: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPricingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPricingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyCreateInput = {
    id?: string
    code: string
    name: string
    symbol: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    lastUpdated?: Date | string
    isActive?: boolean
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    symbol: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    lastUpdated?: Date | string
    isActive?: boolean
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyCreateManyInput = {
    id?: string
    code: string
    name: string
    symbol: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    lastUpdated?: Date | string
    isActive?: boolean
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceSubscriptionCreateInput = {
    id?: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    billingRecords?: BillingRecordCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionUncheckedCreateInput = {
    id?: string
    workspaceId: string
    planId: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingRecords?: BillingRecordUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    billingRecords?: BillingRecordUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingRecords?: BillingRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionCreateManyInput = {
    id?: string
    workspaceId: string
    planId: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRecordCreateInput = {
    id?: string
    invoiceNumber: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    paymentMethod?: string | null
    invoiceDate: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    stripeInvoiceId?: string | null
    ewayTransactionId?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    subscription: WorkspaceSubscriptionCreateNestedOneWithoutBillingRecordsInput
  }

  export type BillingRecordUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    invoiceNumber: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    paymentMethod?: string | null
    invoiceDate: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    stripeInvoiceId?: string | null
    ewayTransactionId?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: WorkspaceSubscriptionUpdateOneRequiredWithoutBillingRecordsNestedInput
  }

  export type BillingRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRecordCreateManyInput = {
    id?: string
    subscriptionId: string
    invoiceNumber: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    paymentMethod?: string | null
    invoiceDate: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    stripeInvoiceId?: string | null
    ewayTransactionId?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordCreateInput = {
    id?: string
    recordType: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    subscription: WorkspaceSubscriptionCreateNestedOneWithoutUsageRecordsInput
  }

  export type UsageRecordUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    recordType: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: WorkspaceSubscriptionUpdateOneRequiredWithoutUsageRecordsNestedInput
  }

  export type UsageRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordCreateManyInput = {
    id?: string
    subscriptionId: string
    recordType: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageCounterCreateInput = {
    id?: string
    workspaceId?: string | null
    periodType: string
    periodStart: Date | string
    periodEnd: Date | string
    transcriptionsUsed?: number
    filesUploaded?: number
    voiceSynthesisUsed?: number
    exportOperationsUsed?: number
    totalProcessingMinutes?: Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: Date | string
    autoReset?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUsageCountersInput
  }

  export type UsageCounterUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    periodType: string
    periodStart: Date | string
    periodEnd: Date | string
    transcriptionsUsed?: number
    filesUploaded?: number
    voiceSynthesisUsed?: number
    exportOperationsUsed?: number
    totalProcessingMinutes?: Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: Date | string
    autoReset?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageCounterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    periodType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptionsUsed?: IntFieldUpdateOperationsInput | number
    filesUploaded?: IntFieldUpdateOperationsInput | number
    voiceSynthesisUsed?: IntFieldUpdateOperationsInput | number
    exportOperationsUsed?: IntFieldUpdateOperationsInput | number
    totalProcessingMinutes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: IntFieldUpdateOperationsInput | number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoReset?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsageCountersNestedInput
  }

  export type UsageCounterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    periodType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptionsUsed?: IntFieldUpdateOperationsInput | number
    filesUploaded?: IntFieldUpdateOperationsInput | number
    voiceSynthesisUsed?: IntFieldUpdateOperationsInput | number
    exportOperationsUsed?: IntFieldUpdateOperationsInput | number
    totalProcessingMinutes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: IntFieldUpdateOperationsInput | number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoReset?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageCounterCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    periodType: string
    periodStart: Date | string
    periodEnd: Date | string
    transcriptionsUsed?: number
    filesUploaded?: number
    voiceSynthesisUsed?: number
    exportOperationsUsed?: number
    totalProcessingMinutes?: Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: Date | string
    autoReset?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageCounterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    periodType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptionsUsed?: IntFieldUpdateOperationsInput | number
    filesUploaded?: IntFieldUpdateOperationsInput | number
    voiceSynthesisUsed?: IntFieldUpdateOperationsInput | number
    exportOperationsUsed?: IntFieldUpdateOperationsInput | number
    totalProcessingMinutes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: IntFieldUpdateOperationsInput | number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoReset?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageCounterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    periodType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptionsUsed?: IntFieldUpdateOperationsInput | number
    filesUploaded?: IntFieldUpdateOperationsInput | number
    voiceSynthesisUsed?: IntFieldUpdateOperationsInput | number
    exportOperationsUsed?: IntFieldUpdateOperationsInput | number
    totalProcessingMinutes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: IntFieldUpdateOperationsInput | number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoReset?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanRecommendationCreateInput = {
    id?: string
    workspaceId?: string | null
    recommendationReason: string
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: Decimal | DecimalJsLike | number | string | null
    roiMonths?: number | null
    triggeredBy?: string | null
    benefits?: PlanRecommendationCreatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationCreatelimitationsRemovedInput | string[]
    status?: string
    viewedAt?: Date | string | null
    dismissedAt?: Date | string | null
    acceptedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlanRecommendationsInput
    currentPlan: SubscriptionPlanCreateNestedOneWithoutCurrentPlanRecommendationsInput
    recommendedPlan: SubscriptionPlanCreateNestedOneWithoutRecommendedPlanRecommendationsInput
  }

  export type PlanRecommendationUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    currentPlanId: string
    recommendedPlanId: string
    recommendationReason: string
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: Decimal | DecimalJsLike | number | string | null
    roiMonths?: number | null
    triggeredBy?: string | null
    benefits?: PlanRecommendationCreatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationCreatelimitationsRemovedInput | string[]
    status?: string
    viewedAt?: Date | string | null
    dismissedAt?: Date | string | null
    acceptedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlanRecommendationsNestedInput
    currentPlan?: SubscriptionPlanUpdateOneRequiredWithoutCurrentPlanRecommendationsNestedInput
    recommendedPlan?: SubscriptionPlanUpdateOneRequiredWithoutRecommendedPlanRecommendationsNestedInput
  }

  export type PlanRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPlanId?: StringFieldUpdateOperationsInput | string
    recommendedPlanId?: StringFieldUpdateOperationsInput | string
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanRecommendationCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    currentPlanId: string
    recommendedPlanId: string
    recommendationReason: string
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: Decimal | DecimalJsLike | number | string | null
    roiMonths?: number | null
    triggeredBy?: string | null
    benefits?: PlanRecommendationCreatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationCreatelimitationsRemovedInput | string[]
    status?: string
    viewedAt?: Date | string | null
    dismissedAt?: Date | string | null
    acceptedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPlanId?: StringFieldUpdateOperationsInput | string
    recommendedPlanId?: StringFieldUpdateOperationsInput | string
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPlanCreateInput = {
    id?: string
    workspaceId: string
    planName: string
    description?: string | null
    customMaxTranscriptionsMonthly?: bigint | number | null
    customMaxFilesDaily?: number | null
    customMaxFilesMonthly?: number | null
    customMaxConcurrentJobs?: number | null
    customMaxVoiceSynthesisMonthly?: bigint | number | null
    customMaxExportOperationsMonthly?: number | null
    customMaxAudioDurationMinutes?: number | null
    customPriorityLevel?: number | null
    customFeatures?: CustomPlanCreatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanCreateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanCreateadditionalFeaturesInput | string[]
    customPrice?: Decimal | DecimalJsLike | number | string | null
    pricingModel?: string
    billingInterval?: string
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenew?: boolean
    noticePeriodDays?: number
    approvedBy?: string | null
    approvalStatus?: string
    approvalNotes?: string | null
    isActive?: boolean
    activatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedByUser?: UserCreateNestedOneWithoutCustomPlansInput
    basePlan?: SubscriptionPlanCreateNestedOneWithoutCustomPlansInput
  }

  export type CustomPlanUncheckedCreateInput = {
    id?: string
    workspaceId: string
    basePlanId?: string | null
    planName: string
    description?: string | null
    customMaxTranscriptionsMonthly?: bigint | number | null
    customMaxFilesDaily?: number | null
    customMaxFilesMonthly?: number | null
    customMaxConcurrentJobs?: number | null
    customMaxVoiceSynthesisMonthly?: bigint | number | null
    customMaxExportOperationsMonthly?: number | null
    customMaxAudioDurationMinutes?: number | null
    customPriorityLevel?: number | null
    customFeatures?: CustomPlanCreatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanCreateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanCreateadditionalFeaturesInput | string[]
    customPrice?: Decimal | DecimalJsLike | number | string | null
    pricingModel?: string
    billingInterval?: string
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenew?: boolean
    noticePeriodDays?: number
    requestedBy?: string | null
    approvedBy?: string | null
    approvalStatus?: string
    approvalNotes?: string | null
    isActive?: boolean
    activatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customMaxTranscriptionsMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxFilesDaily?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxFilesMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxConcurrentJobs?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxVoiceSynthesisMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxExportOperationsMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxAudioDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customPriorityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    customFeatures?: CustomPlanUpdatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanUpdateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanUpdateadditionalFeaturesInput | string[]
    customPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    noticePeriodDays?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedByUser?: UserUpdateOneWithoutCustomPlansNestedInput
    basePlan?: SubscriptionPlanUpdateOneWithoutCustomPlansNestedInput
  }

  export type CustomPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    basePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customMaxTranscriptionsMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxFilesDaily?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxFilesMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxConcurrentJobs?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxVoiceSynthesisMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxExportOperationsMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxAudioDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customPriorityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    customFeatures?: CustomPlanUpdatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanUpdateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanUpdateadditionalFeaturesInput | string[]
    customPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    noticePeriodDays?: IntFieldUpdateOperationsInput | number
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPlanCreateManyInput = {
    id?: string
    workspaceId: string
    basePlanId?: string | null
    planName: string
    description?: string | null
    customMaxTranscriptionsMonthly?: bigint | number | null
    customMaxFilesDaily?: number | null
    customMaxFilesMonthly?: number | null
    customMaxConcurrentJobs?: number | null
    customMaxVoiceSynthesisMonthly?: bigint | number | null
    customMaxExportOperationsMonthly?: number | null
    customMaxAudioDurationMinutes?: number | null
    customPriorityLevel?: number | null
    customFeatures?: CustomPlanCreatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanCreateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanCreateadditionalFeaturesInput | string[]
    customPrice?: Decimal | DecimalJsLike | number | string | null
    pricingModel?: string
    billingInterval?: string
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenew?: boolean
    noticePeriodDays?: number
    requestedBy?: string | null
    approvedBy?: string | null
    approvalStatus?: string
    approvalNotes?: string | null
    isActive?: boolean
    activatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customMaxTranscriptionsMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxFilesDaily?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxFilesMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxConcurrentJobs?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxVoiceSynthesisMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxExportOperationsMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxAudioDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customPriorityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    customFeatures?: CustomPlanUpdatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanUpdateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanUpdateadditionalFeaturesInput | string[]
    customPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    noticePeriodDays?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    basePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customMaxTranscriptionsMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxFilesDaily?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxFilesMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxConcurrentJobs?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxVoiceSynthesisMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxExportOperationsMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxAudioDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customPriorityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    customFeatures?: CustomPlanUpdatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanUpdateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanUpdateadditionalFeaturesInput | string[]
    customPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    noticePeriodDays?: IntFieldUpdateOperationsInput | number
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagCreateInput = {
    id?: string
    featureName: string
    displayName: string
    description?: string | null
    category?: string | null
    featureType?: string | null
    minPlanLevel?: number
    requiredPlans?: FeatureFlagCreaterequiredPlansInput | string[]
    excludedPlans?: FeatureFlagCreateexcludedPlansInput | string[]
    isEnabled?: boolean
    isBeta?: boolean
    isDeprecated?: boolean
    usageCount?: bigint | number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planFeatures?: PlanFeatureMatrixCreateNestedManyWithoutFeatureFlagInput
  }

  export type FeatureFlagUncheckedCreateInput = {
    id?: string
    featureName: string
    displayName: string
    description?: string | null
    category?: string | null
    featureType?: string | null
    minPlanLevel?: number
    requiredPlans?: FeatureFlagCreaterequiredPlansInput | string[]
    excludedPlans?: FeatureFlagCreateexcludedPlansInput | string[]
    isEnabled?: boolean
    isBeta?: boolean
    isDeprecated?: boolean
    usageCount?: bigint | number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planFeatures?: PlanFeatureMatrixUncheckedCreateNestedManyWithoutFeatureFlagInput
  }

  export type FeatureFlagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    minPlanLevel?: IntFieldUpdateOperationsInput | number
    requiredPlans?: FeatureFlagUpdaterequiredPlansInput | string[]
    excludedPlans?: FeatureFlagUpdateexcludedPlansInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isBeta?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: BigIntFieldUpdateOperationsInput | bigint | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planFeatures?: PlanFeatureMatrixUpdateManyWithoutFeatureFlagNestedInput
  }

  export type FeatureFlagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    minPlanLevel?: IntFieldUpdateOperationsInput | number
    requiredPlans?: FeatureFlagUpdaterequiredPlansInput | string[]
    excludedPlans?: FeatureFlagUpdateexcludedPlansInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isBeta?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: BigIntFieldUpdateOperationsInput | bigint | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planFeatures?: PlanFeatureMatrixUncheckedUpdateManyWithoutFeatureFlagNestedInput
  }

  export type FeatureFlagCreateManyInput = {
    id?: string
    featureName: string
    displayName: string
    description?: string | null
    category?: string | null
    featureType?: string | null
    minPlanLevel?: number
    requiredPlans?: FeatureFlagCreaterequiredPlansInput | string[]
    excludedPlans?: FeatureFlagCreateexcludedPlansInput | string[]
    isEnabled?: boolean
    isBeta?: boolean
    isDeprecated?: boolean
    usageCount?: bigint | number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    minPlanLevel?: IntFieldUpdateOperationsInput | number
    requiredPlans?: FeatureFlagUpdaterequiredPlansInput | string[]
    excludedPlans?: FeatureFlagUpdateexcludedPlansInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isBeta?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: BigIntFieldUpdateOperationsInput | bigint | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    minPlanLevel?: IntFieldUpdateOperationsInput | number
    requiredPlans?: FeatureFlagUpdaterequiredPlansInput | string[]
    excludedPlans?: FeatureFlagUpdateexcludedPlansInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isBeta?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: BigIntFieldUpdateOperationsInput | bigint | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureMatrixCreateInput = {
    id?: string
    isEnabled?: boolean
    usageLimit?: number | null
    includedUsage?: number
    overageRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutPlanFeaturesInput
    featureFlag: FeatureFlagCreateNestedOneWithoutPlanFeaturesInput
  }

  export type PlanFeatureMatrixUncheckedCreateInput = {
    id?: string
    planId: string
    featureFlagId: string
    isEnabled?: boolean
    usageLimit?: number | null
    includedUsage?: number
    overageRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PlanFeatureMatrixUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    includedUsage?: IntFieldUpdateOperationsInput | number
    overageRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutPlanFeaturesNestedInput
    featureFlag?: FeatureFlagUpdateOneRequiredWithoutPlanFeaturesNestedInput
  }

  export type PlanFeatureMatrixUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    featureFlagId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    includedUsage?: IntFieldUpdateOperationsInput | number
    overageRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureMatrixCreateManyInput = {
    id?: string
    planId: string
    featureFlagId: string
    isEnabled?: boolean
    usageLimit?: number | null
    includedUsage?: number
    overageRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PlanFeatureMatrixUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    includedUsage?: IntFieldUpdateOperationsInput | number
    overageRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureMatrixUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    featureFlagId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    includedUsage?: IntFieldUpdateOperationsInput | number
    overageRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayCustomerCreateInput = {
    id?: string
    ewayCustomerToken: string
    firstName: string
    lastName: string
    email: string
    companyName?: string | null
    country?: string
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    cardLastFour?: string | null
    cardType?: string | null
    cardExpiryMonth?: number | null
    cardExpiryYear?: number | null
    ewayReference?: string | null
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEwayCustomersInput
    transactions?: EwayTransactionCreateNestedManyWithoutEwayCustomerInput
    recurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerUncheckedCreateInput = {
    id?: string
    userId: string
    ewayCustomerToken: string
    firstName: string
    lastName: string
    email: string
    companyName?: string | null
    country?: string
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    cardLastFour?: string | null
    cardType?: string | null
    cardExpiryMonth?: number | null
    cardExpiryYear?: number | null
    ewayReference?: string | null
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: EwayTransactionUncheckedCreateNestedManyWithoutEwayCustomerInput
    recurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ewayCustomerToken?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardLastFour?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    ewayReference?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEwayCustomersNestedInput
    transactions?: EwayTransactionUpdateManyWithoutEwayCustomerNestedInput
    recurringSchedules?: EwayRecurringScheduleUpdateManyWithoutEwayCustomerNestedInput
  }

  export type EwayCustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ewayCustomerToken?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardLastFour?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    ewayReference?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: EwayTransactionUncheckedUpdateManyWithoutEwayCustomerNestedInput
    recurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutEwayCustomerNestedInput
  }

  export type EwayCustomerCreateManyInput = {
    id?: string
    userId: string
    ewayCustomerToken: string
    firstName: string
    lastName: string
    email: string
    companyName?: string | null
    country?: string
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    cardLastFour?: string | null
    cardType?: string | null
    cardExpiryMonth?: number | null
    cardExpiryYear?: number | null
    ewayReference?: string | null
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayCustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ewayCustomerToken?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardLastFour?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    ewayReference?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayCustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ewayCustomerToken?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardLastFour?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    ewayReference?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayTransactionCreateInput = {
    id?: string
    workspaceId?: string | null
    subscriptionId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    ewayTransactionId?: bigint | number | null
    ewayAccessCode?: string | null
    ewayAuthCode?: string | null
    responseCode?: string | null
    responseMessage?: string | null
    transactionStatus: string
    isRecurring?: boolean
    ewayInvoiceNumber?: string | null
    ewayInvoiceReference?: string | null
    fraudAction?: string | null
    verificationStatus?: string | null
    beagleScore?: number | null
    errorCode?: string | null
    errorMessage?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutEwayTransactionsInput
    ewayCustomer: EwayCustomerCreateNestedOneWithoutTransactionsInput
  }

  export type EwayTransactionUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    ewayCustomerId: string
    subscriptionId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    ewayTransactionId?: bigint | number | null
    ewayAccessCode?: string | null
    ewayAuthCode?: string | null
    responseCode?: string | null
    responseMessage?: string | null
    transactionStatus: string
    isRecurring?: boolean
    ewayInvoiceNumber?: string | null
    ewayInvoiceReference?: string | null
    fraudAction?: string | null
    verificationStatus?: string | null
    beagleScore?: number | null
    errorCode?: string | null
    errorMessage?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    ewayAuthCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionStatus?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    ewayInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ewayInvoiceReference?: NullableStringFieldUpdateOperationsInput | string | null
    fraudAction?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutEwayTransactionsNestedInput
    ewayCustomer?: EwayCustomerUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type EwayTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayCustomerId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    ewayAuthCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionStatus?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    ewayInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ewayInvoiceReference?: NullableStringFieldUpdateOperationsInput | string | null
    fraudAction?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayTransactionCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    ewayCustomerId: string
    subscriptionId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    ewayTransactionId?: bigint | number | null
    ewayAccessCode?: string | null
    ewayAuthCode?: string | null
    responseCode?: string | null
    responseMessage?: string | null
    transactionStatus: string
    isRecurring?: boolean
    ewayInvoiceNumber?: string | null
    ewayInvoiceReference?: string | null
    fraudAction?: string | null
    verificationStatus?: string | null
    beagleScore?: number | null
    errorCode?: string | null
    errorMessage?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    ewayAuthCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionStatus?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    ewayInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ewayInvoiceReference?: NullableStringFieldUpdateOperationsInput | string | null
    fraudAction?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayCustomerId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    ewayAuthCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionStatus?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    ewayInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ewayInvoiceReference?: NullableStringFieldUpdateOperationsInput | string | null
    fraudAction?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayRecurringScheduleCreateInput = {
    id?: string
    workspaceId?: string | null
    subscriptionId: string
    scheduleType: string
    billingAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    startDate: Date | string
    nextBillingDate: Date | string
    lastProcessedAt?: Date | string | null
    status?: string
    failedAttempts?: number
    lastTransactionId?: string | null
    cancelledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEwayRecurringSchedulesInput
    ewayCustomer: EwayCustomerCreateNestedOneWithoutRecurringSchedulesInput
  }

  export type EwayRecurringScheduleUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    ewayCustomerId: string
    subscriptionId: string
    scheduleType: string
    billingAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    startDate: Date | string
    nextBillingDate: Date | string
    lastProcessedAt?: Date | string | null
    status?: string
    failedAttempts?: number
    lastTransactionId?: string | null
    cancelledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayRecurringScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    billingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lastTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEwayRecurringSchedulesNestedInput
    ewayCustomer?: EwayCustomerUpdateOneRequiredWithoutRecurringSchedulesNestedInput
  }

  export type EwayRecurringScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayCustomerId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    billingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lastTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayRecurringScheduleCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    ewayCustomerId: string
    subscriptionId: string
    scheduleType: string
    billingAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    startDate: Date | string
    nextBillingDate: Date | string
    lastProcessedAt?: Date | string | null
    status?: string
    failedAttempts?: number
    lastTransactionId?: string | null
    cancelledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayRecurringScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    billingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lastTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayRecurringScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayCustomerId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    billingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lastTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayWebhookEventCreateInput = {
    id?: string
    eventType: string
    ewayTransactionId?: bigint | number | null
    ewayCustomerToken?: string | null
    eventData: JsonNullValueInput | InputJsonValue
    rawPayload: string
    processed?: boolean
    processedAt?: Date | string | null
    sourceIp?: string | null
    createdAt?: Date | string
  }

  export type EwayWebhookEventUncheckedCreateInput = {
    id?: string
    eventType: string
    ewayTransactionId?: bigint | number | null
    ewayCustomerToken?: string | null
    eventData: JsonNullValueInput | InputJsonValue
    rawPayload: string
    processed?: boolean
    processedAt?: Date | string | null
    sourceIp?: string | null
    createdAt?: Date | string
  }

  export type EwayWebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayCustomerToken?: NullableStringFieldUpdateOperationsInput | string | null
    eventData?: JsonNullValueInput | InputJsonValue
    rawPayload?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceIp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayWebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayCustomerToken?: NullableStringFieldUpdateOperationsInput | string | null
    eventData?: JsonNullValueInput | InputJsonValue
    rawPayload?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceIp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayWebhookEventCreateManyInput = {
    id?: string
    eventType: string
    ewayTransactionId?: bigint | number | null
    ewayCustomerToken?: string | null
    eventData: JsonNullValueInput | InputJsonValue
    rawPayload: string
    processed?: boolean
    processedAt?: Date | string | null
    sourceIp?: string | null
    createdAt?: Date | string
  }

  export type EwayWebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayCustomerToken?: NullableStringFieldUpdateOperationsInput | string | null
    eventData?: JsonNullValueInput | InputJsonValue
    rawPayload?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceIp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayWebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayCustomerToken?: NullableStringFieldUpdateOperationsInput | string | null
    eventData?: JsonNullValueInput | InputJsonValue
    rawPayload?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceIp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportHistoryCreateInput = {
    id?: string
    exportType: string
    dataType: string
    dateFrom?: Date | string | null
    dateTo?: Date | string | null
    workspaceIds?: ExportHistoryCreateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename: string
    fileSize: bigint | number
    storagePath?: string | null
    downloadUrl?: string | null
    expiresAt?: Date | string | null
    status?: string
    downloadCount?: number
    createdAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutExportsInput
  }

  export type ExportHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    exportType: string
    dataType: string
    dateFrom?: Date | string | null
    dateTo?: Date | string | null
    workspaceIds?: ExportHistoryCreateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename: string
    fileSize: bigint | number
    storagePath?: string | null
    downloadUrl?: string | null
    expiresAt?: Date | string | null
    status?: string
    downloadCount?: number
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ExportHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    dateFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaceIds?: ExportHistoryUpdateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutExportsNestedInput
  }

  export type ExportHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    dateFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaceIds?: ExportHistoryUpdateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExportHistoryCreateManyInput = {
    id?: string
    userId: string
    exportType: string
    dataType: string
    dateFrom?: Date | string | null
    dateTo?: Date | string | null
    workspaceIds?: ExportHistoryCreateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename: string
    fileSize: bigint | number
    storagePath?: string | null
    downloadUrl?: string | null
    expiresAt?: Date | string | null
    status?: string
    downloadCount?: number
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ExportHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    dateFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaceIds?: ExportHistoryUpdateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExportHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    dateFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaceIds?: ExportHistoryUpdateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: string
    category?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
    workspace?: WorkspaceCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    workspaceId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: string
    category?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    workspace?: WorkspaceUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    workspaceId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: string
    category?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRetentionPolicyCreateInput = {
    id?: string
    name: string
    description?: string | null
    dataType: string
    retentionDays: number
    autoDelete?: boolean
    archiveBeforeDelete?: boolean
    appliesToWorkspaces?: DataRetentionPolicyCreateappliesToWorkspacesInput | string[]
    excludeWorkspaces?: DataRetentionPolicyCreateexcludeWorkspacesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
  }

  export type DataRetentionPolicyUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    dataType: string
    retentionDays: number
    autoDelete?: boolean
    archiveBeforeDelete?: boolean
    appliesToWorkspaces?: DataRetentionPolicyCreateappliesToWorkspacesInput | string[]
    excludeWorkspaces?: DataRetentionPolicyCreateexcludeWorkspacesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
  }

  export type DataRetentionPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: StringFieldUpdateOperationsInput | string
    retentionDays?: IntFieldUpdateOperationsInput | number
    autoDelete?: BoolFieldUpdateOperationsInput | boolean
    archiveBeforeDelete?: BoolFieldUpdateOperationsInput | boolean
    appliesToWorkspaces?: DataRetentionPolicyUpdateappliesToWorkspacesInput | string[]
    excludeWorkspaces?: DataRetentionPolicyUpdateexcludeWorkspacesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRetentionPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: StringFieldUpdateOperationsInput | string
    retentionDays?: IntFieldUpdateOperationsInput | number
    autoDelete?: BoolFieldUpdateOperationsInput | boolean
    archiveBeforeDelete?: BoolFieldUpdateOperationsInput | boolean
    appliesToWorkspaces?: DataRetentionPolicyUpdateappliesToWorkspacesInput | string[]
    excludeWorkspaces?: DataRetentionPolicyUpdateexcludeWorkspacesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRetentionPolicyCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    dataType: string
    retentionDays: number
    autoDelete?: boolean
    archiveBeforeDelete?: boolean
    appliesToWorkspaces?: DataRetentionPolicyCreateappliesToWorkspacesInput | string[]
    excludeWorkspaces?: DataRetentionPolicyCreateexcludeWorkspacesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
  }

  export type DataRetentionPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: StringFieldUpdateOperationsInput | string
    retentionDays?: IntFieldUpdateOperationsInput | number
    autoDelete?: BoolFieldUpdateOperationsInput | boolean
    archiveBeforeDelete?: BoolFieldUpdateOperationsInput | boolean
    appliesToWorkspaces?: DataRetentionPolicyUpdateappliesToWorkspacesInput | string[]
    excludeWorkspaces?: DataRetentionPolicyUpdateexcludeWorkspacesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRetentionPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: StringFieldUpdateOperationsInput | string
    retentionDays?: IntFieldUpdateOperationsInput | number
    autoDelete?: BoolFieldUpdateOperationsInput | boolean
    archiveBeforeDelete?: BoolFieldUpdateOperationsInput | boolean
    appliesToWorkspaces?: DataRetentionPolicyUpdateappliesToWorkspacesInput | string[]
    excludeWorkspaces?: DataRetentionPolicyUpdateexcludeWorkspacesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentMethodCreateInput = {
    id?: string
    workspaceId: string
    provider: string
    providerMethodId: string
    type: string
    last4?: string | null
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    workspaceId: string
    provider: string
    providerMethodId: string
    type: string
    last4?: string | null
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerMethodId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerMethodId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    workspaceId: string
    provider: string
    providerMethodId: string
    type: string
    last4?: string | null
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerMethodId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerMethodId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateInput = {
    id?: string
    customerName: string
    customerRole?: string | null
    companyName?: string | null
    avatarUrl?: string | null
    content: string
    rating?: number
    featuredOn?: string | null
    useCase?: string | null
    isVerified?: boolean
    verificationMethod?: string | null
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTestimonialsInput
  }

  export type TestimonialUncheckedCreateInput = {
    id?: string
    customerName: string
    customerRole?: string | null
    companyName?: string | null
    avatarUrl?: string | null
    content: string
    rating?: number
    featuredOn?: string | null
    useCase?: string | null
    isVerified?: boolean
    verificationMethod?: string | null
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type TestimonialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    featuredOn?: NullableStringFieldUpdateOperationsInput | string | null
    useCase?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTestimonialsNestedInput
  }

  export type TestimonialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    featuredOn?: NullableStringFieldUpdateOperationsInput | string | null
    useCase?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestimonialCreateManyInput = {
    id?: string
    customerName: string
    customerRole?: string | null
    companyName?: string | null
    avatarUrl?: string | null
    content: string
    rating?: number
    featuredOn?: string | null
    useCase?: string | null
    isVerified?: boolean
    verificationMethod?: string | null
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type TestimonialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    featuredOn?: NullableStringFieldUpdateOperationsInput | string | null
    useCase?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    featuredOn?: NullableStringFieldUpdateOperationsInput | string | null
    useCase?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebsiteContentCreateInput = {
    id?: string
    contentKey: string
    contentType: string
    contentValue: string
    contentMetadata?: NullableJsonNullValueInput | InputJsonValue
    section?: string | null
    page?: string
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteContentUncheckedCreateInput = {
    id?: string
    contentKey: string
    contentType: string
    contentValue: string
    contentMetadata?: NullableJsonNullValueInput | InputJsonValue
    section?: string | null
    page?: string
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentKey?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentValue?: StringFieldUpdateOperationsInput | string
    contentMetadata?: NullableJsonNullValueInput | InputJsonValue
    section?: NullableStringFieldUpdateOperationsInput | string | null
    page?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentKey?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentValue?: StringFieldUpdateOperationsInput | string
    contentMetadata?: NullableJsonNullValueInput | InputJsonValue
    section?: NullableStringFieldUpdateOperationsInput | string | null
    page?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteContentCreateManyInput = {
    id?: string
    contentKey: string
    contentType: string
    contentValue: string
    contentMetadata?: NullableJsonNullValueInput | InputJsonValue
    section?: string | null
    page?: string
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentKey?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentValue?: StringFieldUpdateOperationsInput | string
    contentMetadata?: NullableJsonNullValueInput | InputJsonValue
    section?: NullableStringFieldUpdateOperationsInput | string | null
    page?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentKey?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentValue?: StringFieldUpdateOperationsInput | string
    contentMetadata?: NullableJsonNullValueInput | InputJsonValue
    section?: NullableStringFieldUpdateOperationsInput | string | null
    page?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    isSystemRole?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    isSystemRole?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    isSystemRole?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    resource: string
    action: string
    isSystemPermission?: boolean
    createdAt?: Date | string
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    resource: string
    action: string
    isSystemPermission?: boolean
    createdAt?: Date | string
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isSystemPermission?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isSystemPermission?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    resource: string
    action: string
    isSystemPermission?: boolean
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isSystemPermission?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isSystemPermission?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    id?: string
    assignedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutUserRolesInput
    role: RoleCreateNestedOneWithoutUsersInput
    assignedByUser?: UserCreateNestedOneWithoutAssignedRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
    assignedBy?: string | null
    assignedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    assignedByUser?: UserUpdateOneWithoutAssignedRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    roleId: string
    assignedBy?: string | null
    assignedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type WorkspaceUserListRelationFilter = {
    every?: WorkspaceUserWhereInput
    some?: WorkspaceUserWhereInput
    none?: WorkspaceUserWhereInput
  }

  export type WorkspaceInvitationListRelationFilter = {
    every?: WorkspaceInvitationWhereInput
    some?: WorkspaceInvitationWhereInput
    none?: WorkspaceInvitationWhereInput
  }

  export type AudioHistoryListRelationFilter = {
    every?: AudioHistoryWhereInput
    some?: AudioHistoryWhereInput
    none?: AudioHistoryWhereInput
  }

  export type AudioUploadListRelationFilter = {
    every?: AudioUploadWhereInput
    some?: AudioUploadWhereInput
    none?: AudioUploadWhereInput
  }

  export type AudioProjectListRelationFilter = {
    every?: AudioProjectWhereInput
    some?: AudioProjectWhereInput
    none?: AudioProjectWhereInput
  }

  export type WorkspaceSettingsNullableRelationFilter = {
    is?: WorkspaceSettingsWhereInput | null
    isNot?: WorkspaceSettingsWhereInput | null
  }

  export type UsageMetricListRelationFilter = {
    every?: UsageMetricWhereInput
    some?: UsageMetricWhereInput
    none?: UsageMetricWhereInput
  }

  export type StorageQuotaNullableRelationFilter = {
    is?: StorageQuotaWhereInput | null
    isNot?: StorageQuotaWhereInput | null
  }

  export type WorkspaceSubscriptionListRelationFilter = {
    every?: WorkspaceSubscriptionWhereInput
    some?: WorkspaceSubscriptionWhereInput
    none?: WorkspaceSubscriptionWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type WorkspaceUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioUploadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type WorkspaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type UserSettingsNullableRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type ProcessingJobListRelationFilter = {
    every?: ProcessingJobWhereInput
    some?: ProcessingJobWhereInput
    none?: ProcessingJobWhereInput
  }

  export type ExportHistoryListRelationFilter = {
    every?: ExportHistoryWhereInput
    some?: ExportHistoryWhereInput
    none?: ExportHistoryWhereInput
  }

  export type ApiKeyManagementListRelationFilter = {
    every?: ApiKeyManagementWhereInput
    some?: ApiKeyManagementWhereInput
    none?: ApiKeyManagementWhereInput
  }

  export type UserQuotaNullableRelationFilter = {
    is?: UserQuotaWhereInput | null
    isNot?: UserQuotaWhereInput | null
  }

  export type SecurityEventListRelationFilter = {
    every?: SecurityEventWhereInput
    some?: SecurityEventWhereInput
    none?: SecurityEventWhereInput
  }

  export type ProcessingTemplateListRelationFilter = {
    every?: ProcessingTemplateWhereInput
    some?: ProcessingTemplateWhereInput
    none?: ProcessingTemplateWhereInput
  }

  export type CustomPlanListRelationFilter = {
    every?: CustomPlanWhereInput
    some?: CustomPlanWhereInput
    none?: CustomPlanWhereInput
  }

  export type PlanRecommendationListRelationFilter = {
    every?: PlanRecommendationWhereInput
    some?: PlanRecommendationWhereInput
    none?: PlanRecommendationWhereInput
  }

  export type UsageCounterListRelationFilter = {
    every?: UsageCounterWhereInput
    some?: UsageCounterWhereInput
    none?: UsageCounterWhereInput
  }

  export type EwayCustomerListRelationFilter = {
    every?: EwayCustomerWhereInput
    some?: EwayCustomerWhereInput
    none?: EwayCustomerWhereInput
  }

  export type EwayTransactionListRelationFilter = {
    every?: EwayTransactionWhereInput
    some?: EwayTransactionWhereInput
    none?: EwayTransactionWhereInput
  }

  export type EwayRecurringScheduleListRelationFilter = {
    every?: EwayRecurringScheduleWhereInput
    some?: EwayRecurringScheduleWhereInput
    none?: EwayRecurringScheduleWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type TestimonialListRelationFilter = {
    every?: TestimonialWhereInput
    some?: TestimonialWhereInput
    none?: TestimonialWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessingJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExportHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyManagementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessingTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageCounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EwayCustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EwayTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EwayRecurringScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestimonialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    isActive?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    businessName?: SortOrder
    mobileNumber?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    businessAddress?: SortOrder
    businessPhone?: SortOrder
    taxNumber?: SortOrder
    companySize?: SortOrder
    industry?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    isActive?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    businessName?: SortOrder
    mobileNumber?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    businessAddress?: SortOrder
    businessPhone?: SortOrder
    taxNumber?: SortOrder
    companySize?: SortOrder
    industry?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    isActive?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    businessName?: SortOrder
    mobileNumber?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    businessAddress?: SortOrder
    businessPhone?: SortOrder
    taxNumber?: SortOrder
    companySize?: SortOrder
    industry?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WorkspaceRelationFilter = {
    is?: WorkspaceWhereInput
    isNot?: WorkspaceWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type WorkspaceUserWorkspaceIdUserIdCompoundUniqueInput = {
    workspaceId: string
    userId: string
  }

  export type WorkspaceUserCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    permissions?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type WorkspaceUserMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type WorkspaceUserMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type WorkspaceInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrder
    invitedById?: SortOrder
  }

  export type WorkspaceInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrder
    invitedById?: SortOrder
  }

  export type WorkspaceInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrder
    invitedById?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SecurityEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type SecurityEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type SecurityEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserSettingsCountOrderByAggregateInput = {
    userId?: SortOrder
    openaiApiKeyEncrypted?: SortOrder
    elevenlabsApiKeyEncrypted?: SortOrder
    preferredLanguage?: SortOrder
    summaryQuality?: SortOrder
    defaultSummaryStyle?: SortOrder
    defaultTemperature?: SortOrder
    defaultMaxTokens?: SortOrder
    showCostEstimates?: SortOrder
    emailNotifications?: SortOrder
    processingNotifications?: SortOrder
    settingsJson?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsAvgOrderByAggregateInput = {
    defaultTemperature?: SortOrder
    defaultMaxTokens?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    userId?: SortOrder
    openaiApiKeyEncrypted?: SortOrder
    elevenlabsApiKeyEncrypted?: SortOrder
    preferredLanguage?: SortOrder
    summaryQuality?: SortOrder
    defaultSummaryStyle?: SortOrder
    defaultTemperature?: SortOrder
    defaultMaxTokens?: SortOrder
    showCostEstimates?: SortOrder
    emailNotifications?: SortOrder
    processingNotifications?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    userId?: SortOrder
    openaiApiKeyEncrypted?: SortOrder
    elevenlabsApiKeyEncrypted?: SortOrder
    preferredLanguage?: SortOrder
    summaryQuality?: SortOrder
    defaultSummaryStyle?: SortOrder
    defaultTemperature?: SortOrder
    defaultMaxTokens?: SortOrder
    showCostEstimates?: SortOrder
    emailNotifications?: SortOrder
    processingNotifications?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsSumOrderByAggregateInput = {
    defaultTemperature?: SortOrder
    defaultMaxTokens?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type WorkspaceSettingsCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    defaultProcessingOptions?: SortOrder
    allowedFileTypes?: SortOrder
    maxFileSize?: SortOrder
    maxProcessingTime?: SortOrder
    allowPublicSharing?: SortOrder
    allowGuestAccess?: SortOrder
    requireApprovalForUploads?: SortOrder
    webhookUrl?: SortOrder
    webhookSecret?: SortOrder
    settingsJson?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceSettingsAvgOrderByAggregateInput = {
    maxFileSize?: SortOrder
    maxProcessingTime?: SortOrder
  }

  export type WorkspaceSettingsMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    maxFileSize?: SortOrder
    maxProcessingTime?: SortOrder
    allowPublicSharing?: SortOrder
    allowGuestAccess?: SortOrder
    requireApprovalForUploads?: SortOrder
    webhookUrl?: SortOrder
    webhookSecret?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceSettingsMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    maxFileSize?: SortOrder
    maxProcessingTime?: SortOrder
    allowPublicSharing?: SortOrder
    allowGuestAccess?: SortOrder
    requireApprovalForUploads?: SortOrder
    webhookUrl?: SortOrder
    webhookSecret?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceSettingsSumOrderByAggregateInput = {
    maxFileSize?: SortOrder
    maxProcessingTime?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type ProcessingTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    summaryStyle?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    language?: SortOrder
    configJson?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessingTemplateAvgOrderByAggregateInput = {
    temperature?: SortOrder
    maxTokens?: SortOrder
  }

  export type ProcessingTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    summaryStyle?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    language?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessingTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    summaryStyle?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    language?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessingTemplateSumOrderByAggregateInput = {
    temperature?: SortOrder
    maxTokens?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ApiKeyManagementUserIdProviderKeyNameCompoundUniqueInput = {
    userId: string
    provider: string
    keyName: string
  }

  export type ApiKeyManagementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    keyName?: SortOrder
    encryptedKey?: SortOrder
    keyHash?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    totalRequests?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyManagementAvgOrderByAggregateInput = {
    totalRequests?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
  }

  export type ApiKeyManagementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    keyName?: SortOrder
    encryptedKey?: SortOrder
    keyHash?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    totalRequests?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyManagementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    keyName?: SortOrder
    encryptedKey?: SortOrder
    keyHash?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    totalRequests?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyManagementSumOrderByAggregateInput = {
    totalRequests?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type WorkspaceNullableRelationFilter = {
    is?: WorkspaceWhereInput | null
    isNot?: WorkspaceWhereInput | null
  }

  export type AudioChunkListRelationFilter = {
    every?: AudioChunkWhereInput
    some?: AudioChunkWhereInput
    none?: AudioChunkWhereInput
  }

  export type AudioChunkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioUploadCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrder
    duration?: SortOrder
    sampleRate?: SortOrder
    channels?: SortOrder
    bitrate?: SortOrder
    storageProvider?: SortOrder
    storagePath?: SortOrder
    storageUrl?: SortOrder
    cdnUrl?: SortOrder
    checksumMd5?: SortOrder
    checksumSha256?: SortOrder
    status?: SortOrder
    uploadedAt?: SortOrder
    processingStartedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AudioUploadAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    duration?: SortOrder
    sampleRate?: SortOrder
    channels?: SortOrder
    bitrate?: SortOrder
  }

  export type AudioUploadMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrder
    duration?: SortOrder
    sampleRate?: SortOrder
    channels?: SortOrder
    bitrate?: SortOrder
    storageProvider?: SortOrder
    storagePath?: SortOrder
    storageUrl?: SortOrder
    cdnUrl?: SortOrder
    checksumMd5?: SortOrder
    checksumSha256?: SortOrder
    status?: SortOrder
    uploadedAt?: SortOrder
    processingStartedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AudioUploadMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    mimeType?: SortOrder
    duration?: SortOrder
    sampleRate?: SortOrder
    channels?: SortOrder
    bitrate?: SortOrder
    storageProvider?: SortOrder
    storagePath?: SortOrder
    storageUrl?: SortOrder
    cdnUrl?: SortOrder
    checksumMd5?: SortOrder
    checksumSha256?: SortOrder
    status?: SortOrder
    uploadedAt?: SortOrder
    processingStartedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AudioUploadSumOrderByAggregateInput = {
    fileSize?: SortOrder
    duration?: SortOrder
    sampleRate?: SortOrder
    channels?: SortOrder
    bitrate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type AudioUploadRelationFilter = {
    is?: AudioUploadWhereInput
    isNot?: AudioUploadWhereInput
  }

  export type ProcessingJobCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    uploadId?: SortOrder
    jobType?: SortOrder
    priority?: SortOrder
    processingOptions?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    cpuTimeMs?: SortOrder
    memoryUsageMb?: SortOrder
    queuedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type ProcessingJobAvgOrderByAggregateInput = {
    priority?: SortOrder
    progress?: SortOrder
    cpuTimeMs?: SortOrder
    memoryUsageMb?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type ProcessingJobMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    uploadId?: SortOrder
    jobType?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    cpuTimeMs?: SortOrder
    memoryUsageMb?: SortOrder
    queuedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type ProcessingJobMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    uploadId?: SortOrder
    jobType?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    cpuTimeMs?: SortOrder
    memoryUsageMb?: SortOrder
    queuedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type ProcessingJobSumOrderByAggregateInput = {
    priority?: SortOrder
    progress?: SortOrder
    cpuTimeMs?: SortOrder
    memoryUsageMb?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AudioUploadNullableRelationFilter = {
    is?: AudioUploadWhereInput | null
    isNot?: AudioUploadWhereInput | null
  }

  export type AudioSegmentListRelationFilter = {
    every?: AudioSegmentWhereInput
    some?: AudioSegmentWhereInput
    none?: AudioSegmentWhereInput
  }

  export type AudioSegmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    uploadId?: SortOrder
    title?: SortOrder
    audioUrl?: SortOrder
    cdnUrl?: SortOrder
    fileSizeBytes?: SortOrder
    durationSeconds?: SortOrder
    transcript?: SortOrder
    summary?: SortOrder
    keyMoments?: SortOrder
    language?: SortOrder
    confidence?: SortOrder
    wordCount?: SortOrder
    speakerCount?: SortOrder
    processingOptions?: SortOrder
    processingTime?: SortOrder
    apiProvider?: SortOrder
    modelVersion?: SortOrder
    transcriptionCost?: SortOrder
    summarizationCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AudioHistoryAvgOrderByAggregateInput = {
    fileSizeBytes?: SortOrder
    durationSeconds?: SortOrder
    confidence?: SortOrder
    wordCount?: SortOrder
    speakerCount?: SortOrder
    processingTime?: SortOrder
    transcriptionCost?: SortOrder
    summarizationCost?: SortOrder
    totalCost?: SortOrder
  }

  export type AudioHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    uploadId?: SortOrder
    title?: SortOrder
    audioUrl?: SortOrder
    cdnUrl?: SortOrder
    fileSizeBytes?: SortOrder
    durationSeconds?: SortOrder
    transcript?: SortOrder
    summary?: SortOrder
    language?: SortOrder
    confidence?: SortOrder
    wordCount?: SortOrder
    speakerCount?: SortOrder
    processingTime?: SortOrder
    apiProvider?: SortOrder
    modelVersion?: SortOrder
    transcriptionCost?: SortOrder
    summarizationCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AudioHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    uploadId?: SortOrder
    title?: SortOrder
    audioUrl?: SortOrder
    cdnUrl?: SortOrder
    fileSizeBytes?: SortOrder
    durationSeconds?: SortOrder
    transcript?: SortOrder
    summary?: SortOrder
    language?: SortOrder
    confidence?: SortOrder
    wordCount?: SortOrder
    speakerCount?: SortOrder
    processingTime?: SortOrder
    apiProvider?: SortOrder
    modelVersion?: SortOrder
    transcriptionCost?: SortOrder
    summarizationCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AudioHistorySumOrderByAggregateInput = {
    fileSizeBytes?: SortOrder
    durationSeconds?: SortOrder
    confidence?: SortOrder
    wordCount?: SortOrder
    speakerCount?: SortOrder
    processingTime?: SortOrder
    transcriptionCost?: SortOrder
    summarizationCost?: SortOrder
    totalCost?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    has?: number | FloatFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListFloatFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListFloatFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AudioHistoryRelationFilter = {
    is?: AudioHistoryWhereInput
    isNot?: AudioHistoryWhereInput
  }

  export type AudioSegmentCountOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
    segmentIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    text?: SortOrder
    confidence?: SortOrder
    language?: SortOrder
    speakerId?: SortOrder
    emotion?: SortOrder
    sentiment?: SortOrder
    tokens?: SortOrder
    logprobs?: SortOrder
    temperature?: SortOrder
    avgLogprob?: SortOrder
    compressionRatio?: SortOrder
    noSpeechProb?: SortOrder
  }

  export type AudioSegmentAvgOrderByAggregateInput = {
    segmentIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    confidence?: SortOrder
    tokens?: SortOrder
    logprobs?: SortOrder
    temperature?: SortOrder
    avgLogprob?: SortOrder
    compressionRatio?: SortOrder
    noSpeechProb?: SortOrder
  }

  export type AudioSegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
    segmentIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    text?: SortOrder
    confidence?: SortOrder
    language?: SortOrder
    speakerId?: SortOrder
    emotion?: SortOrder
    sentiment?: SortOrder
    temperature?: SortOrder
    avgLogprob?: SortOrder
    compressionRatio?: SortOrder
    noSpeechProb?: SortOrder
  }

  export type AudioSegmentMinOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
    segmentIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    text?: SortOrder
    confidence?: SortOrder
    language?: SortOrder
    speakerId?: SortOrder
    emotion?: SortOrder
    sentiment?: SortOrder
    temperature?: SortOrder
    avgLogprob?: SortOrder
    compressionRatio?: SortOrder
    noSpeechProb?: SortOrder
  }

  export type AudioSegmentSumOrderByAggregateInput = {
    segmentIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    confidence?: SortOrder
    tokens?: SortOrder
    logprobs?: SortOrder
    temperature?: SortOrder
    avgLogprob?: SortOrder
    compressionRatio?: SortOrder
    noSpeechProb?: SortOrder
  }

  export type AudioChunkCountOrderByAggregateInput = {
    id?: SortOrder
    uploadId?: SortOrder
    chunkIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    checksumMd5?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
  }

  export type AudioChunkAvgOrderByAggregateInput = {
    chunkIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    fileSize?: SortOrder
  }

  export type AudioChunkMaxOrderByAggregateInput = {
    id?: SortOrder
    uploadId?: SortOrder
    chunkIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    checksumMd5?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
  }

  export type AudioChunkMinOrderByAggregateInput = {
    id?: SortOrder
    uploadId?: SortOrder
    chunkIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    checksumMd5?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
  }

  export type AudioChunkSumOrderByAggregateInput = {
    chunkIndex?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    fileSize?: SortOrder
  }

  export type AudioProjectCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AudioProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AudioProjectMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageMetricCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    metricType?: SortOrder
    provider?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    currency?: SortOrder
    metadata?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    recordedAt?: SortOrder
  }

  export type UsageMetricAvgOrderByAggregateInput = {
    quantity?: SortOrder
    cost?: SortOrder
  }

  export type UsageMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    metricType?: SortOrder
    provider?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    recordedAt?: SortOrder
  }

  export type UsageMetricMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    metricType?: SortOrder
    provider?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    recordedAt?: SortOrder
  }

  export type UsageMetricSumOrderByAggregateInput = {
    quantity?: SortOrder
    cost?: SortOrder
  }

  export type UserQuotaCountOrderByAggregateInput = {
    userId?: SortOrder
    monthlyApiCalls?: SortOrder
    monthlyTokens?: SortOrder
    monthlyStorageMb?: SortOrder
    monthlyProcessingMin?: SortOrder
    currentApiCalls?: SortOrder
    currentTokens?: SortOrder
    currentStorageMb?: SortOrder
    currentProcessingMin?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    lastResetAt?: SortOrder
    allowOverages?: SortOrder
    overageCostPerToken?: SortOrder
  }

  export type UserQuotaAvgOrderByAggregateInput = {
    monthlyApiCalls?: SortOrder
    monthlyTokens?: SortOrder
    monthlyStorageMb?: SortOrder
    monthlyProcessingMin?: SortOrder
    currentApiCalls?: SortOrder
    currentTokens?: SortOrder
    currentStorageMb?: SortOrder
    currentProcessingMin?: SortOrder
    overageCostPerToken?: SortOrder
  }

  export type UserQuotaMaxOrderByAggregateInput = {
    userId?: SortOrder
    monthlyApiCalls?: SortOrder
    monthlyTokens?: SortOrder
    monthlyStorageMb?: SortOrder
    monthlyProcessingMin?: SortOrder
    currentApiCalls?: SortOrder
    currentTokens?: SortOrder
    currentStorageMb?: SortOrder
    currentProcessingMin?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    lastResetAt?: SortOrder
    allowOverages?: SortOrder
    overageCostPerToken?: SortOrder
  }

  export type UserQuotaMinOrderByAggregateInput = {
    userId?: SortOrder
    monthlyApiCalls?: SortOrder
    monthlyTokens?: SortOrder
    monthlyStorageMb?: SortOrder
    monthlyProcessingMin?: SortOrder
    currentApiCalls?: SortOrder
    currentTokens?: SortOrder
    currentStorageMb?: SortOrder
    currentProcessingMin?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    lastResetAt?: SortOrder
    allowOverages?: SortOrder
    overageCostPerToken?: SortOrder
  }

  export type UserQuotaSumOrderByAggregateInput = {
    monthlyApiCalls?: SortOrder
    monthlyTokens?: SortOrder
    monthlyStorageMb?: SortOrder
    monthlyProcessingMin?: SortOrder
    currentApiCalls?: SortOrder
    currentTokens?: SortOrder
    currentStorageMb?: SortOrder
    currentProcessingMin?: SortOrder
    overageCostPerToken?: SortOrder
  }

  export type StorageQuotaCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    maxStorageBytes?: SortOrder
    maxFileCount?: SortOrder
    maxFileSize?: SortOrder
    currentStorageBytes?: SortOrder
    currentFileCount?: SortOrder
    retentionDays?: SortOrder
    autoCleanup?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageQuotaAvgOrderByAggregateInput = {
    maxStorageBytes?: SortOrder
    maxFileCount?: SortOrder
    maxFileSize?: SortOrder
    currentStorageBytes?: SortOrder
    currentFileCount?: SortOrder
    retentionDays?: SortOrder
  }

  export type StorageQuotaMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    maxStorageBytes?: SortOrder
    maxFileCount?: SortOrder
    maxFileSize?: SortOrder
    currentStorageBytes?: SortOrder
    currentFileCount?: SortOrder
    retentionDays?: SortOrder
    autoCleanup?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageQuotaMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    maxStorageBytes?: SortOrder
    maxFileCount?: SortOrder
    maxFileSize?: SortOrder
    currentStorageBytes?: SortOrder
    currentFileCount?: SortOrder
    retentionDays?: SortOrder
    autoCleanup?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageQuotaSumOrderByAggregateInput = {
    maxStorageBytes?: SortOrder
    maxFileCount?: SortOrder
    maxFileSize?: SortOrder
    currentStorageBytes?: SortOrder
    currentFileCount?: SortOrder
    retentionDays?: SortOrder
  }

  export type PlanPricingListRelationFilter = {
    every?: PlanPricingWhereInput
    some?: PlanPricingWhereInput
    none?: PlanPricingWhereInput
  }

  export type PlanFeatureMatrixListRelationFilter = {
    every?: PlanFeatureMatrixWhereInput
    some?: PlanFeatureMatrixWhereInput
    none?: PlanFeatureMatrixWhereInput
  }

  export type PlanPricingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanFeatureMatrixOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    planCode?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingInterval?: SortOrder
    tier?: SortOrder
    sortOrder?: SortOrder
    maxApiCalls?: SortOrder
    maxTokens?: SortOrder
    maxStorageMb?: SortOrder
    maxProcessingMin?: SortOrder
    maxWorkspaces?: SortOrder
    maxUsers?: SortOrder
    maxFileSize?: SortOrder
    maxTranscriptionsMonthly?: SortOrder
    maxFilesDaily?: SortOrder
    maxFilesMonthly?: SortOrder
    maxConcurrentJobs?: SortOrder
    maxVoiceSynthesisMonthly?: SortOrder
    maxExportOperationsMonthly?: SortOrder
    maxAudioDurationMinutes?: SortOrder
    priorityLevel?: SortOrder
    planCategory?: SortOrder
    trialDays?: SortOrder
    isCustom?: SortOrder
    isEnterprise?: SortOrder
    features?: SortOrder
    recommendedFor?: SortOrder
    allowedFileTypes?: SortOrder
    analysisFeatures?: SortOrder
    collaborationFeatures?: SortOrder
    integrationFeatures?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    price?: SortOrder
    sortOrder?: SortOrder
    maxApiCalls?: SortOrder
    maxTokens?: SortOrder
    maxStorageMb?: SortOrder
    maxProcessingMin?: SortOrder
    maxWorkspaces?: SortOrder
    maxUsers?: SortOrder
    maxFileSize?: SortOrder
    maxTranscriptionsMonthly?: SortOrder
    maxFilesDaily?: SortOrder
    maxFilesMonthly?: SortOrder
    maxConcurrentJobs?: SortOrder
    maxVoiceSynthesisMonthly?: SortOrder
    maxExportOperationsMonthly?: SortOrder
    maxAudioDurationMinutes?: SortOrder
    priorityLevel?: SortOrder
    trialDays?: SortOrder
  }

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    planCode?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingInterval?: SortOrder
    tier?: SortOrder
    sortOrder?: SortOrder
    maxApiCalls?: SortOrder
    maxTokens?: SortOrder
    maxStorageMb?: SortOrder
    maxProcessingMin?: SortOrder
    maxWorkspaces?: SortOrder
    maxUsers?: SortOrder
    maxFileSize?: SortOrder
    maxTranscriptionsMonthly?: SortOrder
    maxFilesDaily?: SortOrder
    maxFilesMonthly?: SortOrder
    maxConcurrentJobs?: SortOrder
    maxVoiceSynthesisMonthly?: SortOrder
    maxExportOperationsMonthly?: SortOrder
    maxAudioDurationMinutes?: SortOrder
    priorityLevel?: SortOrder
    planCategory?: SortOrder
    trialDays?: SortOrder
    isCustom?: SortOrder
    isEnterprise?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    planCode?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingInterval?: SortOrder
    tier?: SortOrder
    sortOrder?: SortOrder
    maxApiCalls?: SortOrder
    maxTokens?: SortOrder
    maxStorageMb?: SortOrder
    maxProcessingMin?: SortOrder
    maxWorkspaces?: SortOrder
    maxUsers?: SortOrder
    maxFileSize?: SortOrder
    maxTranscriptionsMonthly?: SortOrder
    maxFilesDaily?: SortOrder
    maxFilesMonthly?: SortOrder
    maxConcurrentJobs?: SortOrder
    maxVoiceSynthesisMonthly?: SortOrder
    maxExportOperationsMonthly?: SortOrder
    maxAudioDurationMinutes?: SortOrder
    priorityLevel?: SortOrder
    planCategory?: SortOrder
    trialDays?: SortOrder
    isCustom?: SortOrder
    isEnterprise?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanSumOrderByAggregateInput = {
    price?: SortOrder
    sortOrder?: SortOrder
    maxApiCalls?: SortOrder
    maxTokens?: SortOrder
    maxStorageMb?: SortOrder
    maxProcessingMin?: SortOrder
    maxWorkspaces?: SortOrder
    maxUsers?: SortOrder
    maxFileSize?: SortOrder
    maxTranscriptionsMonthly?: SortOrder
    maxFilesDaily?: SortOrder
    maxFilesMonthly?: SortOrder
    maxConcurrentJobs?: SortOrder
    maxVoiceSynthesisMonthly?: SortOrder
    maxExportOperationsMonthly?: SortOrder
    maxAudioDurationMinutes?: SortOrder
    priorityLevel?: SortOrder
    trialDays?: SortOrder
  }

  export type SubscriptionPlanRelationFilter = {
    is?: SubscriptionPlanWhereInput
    isNot?: SubscriptionPlanWhereInput
  }

  export type PlanPricingPlanIdCurrencyBillingPeriodRegionCompoundUniqueInput = {
    planId: string
    currency: string
    billingPeriod: string
    region: string
  }

  export type PlanPricingCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    price?: SortOrder
    billingPeriod?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPricingAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PlanPricingMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    price?: SortOrder
    billingPeriod?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPricingMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    price?: SortOrder
    billingPeriod?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPricingSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    exchangeRate?: SortOrder
    lastUpdated?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyAvgOrderByAggregateInput = {
    exchangeRate?: SortOrder
  }

  export type CurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    exchangeRate?: SortOrder
    lastUpdated?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    exchangeRate?: SortOrder
    lastUpdated?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencySumOrderByAggregateInput = {
    exchangeRate?: SortOrder
  }

  export type BillingRecordListRelationFilter = {
    every?: BillingRecordWhereInput
    some?: BillingRecordWhereInput
    none?: BillingRecordWhereInput
  }

  export type UsageRecordListRelationFilter = {
    every?: UsageRecordWhereInput
    some?: UsageRecordWhereInput
    none?: UsageRecordWhereInput
  }

  export type BillingRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrder
    trialEnd?: SortOrder
    paymentGateway?: SortOrder
    paymentMethodId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    ewayCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeCustomerId?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceSubscriptionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WorkspaceSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrder
    trialEnd?: SortOrder
    paymentGateway?: SortOrder
    paymentMethodId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    ewayCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeCustomerId?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrder
    trialEnd?: SortOrder
    paymentGateway?: SortOrder
    paymentMethodId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    ewayCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeCustomerId?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceSubscriptionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WorkspaceSubscriptionRelationFilter = {
    is?: WorkspaceSubscriptionWhereInput
    isNot?: WorkspaceSubscriptionWhereInput
  }

  export type BillingRecordCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    stripeInvoiceId?: SortOrder
    ewayTransactionId?: SortOrder
    invoiceUrl?: SortOrder
    failureReason?: SortOrder
    usageDetails?: SortOrder
    createdAt?: SortOrder
  }

  export type BillingRecordAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    stripeInvoiceId?: SortOrder
    ewayTransactionId?: SortOrder
    invoiceUrl?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
  }

  export type BillingRecordMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    stripeInvoiceId?: SortOrder
    ewayTransactionId?: SortOrder
    invoiceUrl?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
  }

  export type BillingRecordSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type UsageRecordCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    recordType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageRecordAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
  }

  export type UsageRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    recordType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageRecordMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    recordType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageRecordSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
  }

  export type UsageCounterUserIdWorkspaceIdPeriodTypePeriodStartCompoundUniqueInput = {
    userId: string
    workspaceId: string
    periodType: string
    periodStart: Date | string
  }

  export type UsageCounterCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    periodType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    transcriptionsUsed?: SortOrder
    filesUploaded?: SortOrder
    voiceSynthesisUsed?: SortOrder
    exportOperationsUsed?: SortOrder
    totalProcessingMinutes?: SortOrder
    concurrentJobsPeak?: SortOrder
    featureUsage?: SortOrder
    lastResetAt?: SortOrder
    autoReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageCounterAvgOrderByAggregateInput = {
    transcriptionsUsed?: SortOrder
    filesUploaded?: SortOrder
    voiceSynthesisUsed?: SortOrder
    exportOperationsUsed?: SortOrder
    totalProcessingMinutes?: SortOrder
    concurrentJobsPeak?: SortOrder
  }

  export type UsageCounterMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    periodType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    transcriptionsUsed?: SortOrder
    filesUploaded?: SortOrder
    voiceSynthesisUsed?: SortOrder
    exportOperationsUsed?: SortOrder
    totalProcessingMinutes?: SortOrder
    concurrentJobsPeak?: SortOrder
    lastResetAt?: SortOrder
    autoReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageCounterMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    periodType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    transcriptionsUsed?: SortOrder
    filesUploaded?: SortOrder
    voiceSynthesisUsed?: SortOrder
    exportOperationsUsed?: SortOrder
    totalProcessingMinutes?: SortOrder
    concurrentJobsPeak?: SortOrder
    lastResetAt?: SortOrder
    autoReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageCounterSumOrderByAggregateInput = {
    transcriptionsUsed?: SortOrder
    filesUploaded?: SortOrder
    voiceSynthesisUsed?: SortOrder
    exportOperationsUsed?: SortOrder
    totalProcessingMinutes?: SortOrder
    concurrentJobsPeak?: SortOrder
  }

  export type PlanRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    currentPlanId?: SortOrder
    recommendedPlanId?: SortOrder
    recommendationReason?: SortOrder
    confidenceScore?: SortOrder
    usagePattern?: SortOrder
    projectedSavings?: SortOrder
    roiMonths?: SortOrder
    triggeredBy?: SortOrder
    benefits?: SortOrder
    limitationsRemoved?: SortOrder
    status?: SortOrder
    viewedAt?: SortOrder
    dismissedAt?: SortOrder
    acceptedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanRecommendationAvgOrderByAggregateInput = {
    confidenceScore?: SortOrder
    projectedSavings?: SortOrder
    roiMonths?: SortOrder
  }

  export type PlanRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    currentPlanId?: SortOrder
    recommendedPlanId?: SortOrder
    recommendationReason?: SortOrder
    confidenceScore?: SortOrder
    projectedSavings?: SortOrder
    roiMonths?: SortOrder
    triggeredBy?: SortOrder
    status?: SortOrder
    viewedAt?: SortOrder
    dismissedAt?: SortOrder
    acceptedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    currentPlanId?: SortOrder
    recommendedPlanId?: SortOrder
    recommendationReason?: SortOrder
    confidenceScore?: SortOrder
    projectedSavings?: SortOrder
    roiMonths?: SortOrder
    triggeredBy?: SortOrder
    status?: SortOrder
    viewedAt?: SortOrder
    dismissedAt?: SortOrder
    acceptedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanRecommendationSumOrderByAggregateInput = {
    confidenceScore?: SortOrder
    projectedSavings?: SortOrder
    roiMonths?: SortOrder
  }

  export type SubscriptionPlanNullableRelationFilter = {
    is?: SubscriptionPlanWhereInput | null
    isNot?: SubscriptionPlanWhereInput | null
  }

  export type CustomPlanCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    basePlanId?: SortOrder
    planName?: SortOrder
    description?: SortOrder
    customMaxTranscriptionsMonthly?: SortOrder
    customMaxFilesDaily?: SortOrder
    customMaxFilesMonthly?: SortOrder
    customMaxConcurrentJobs?: SortOrder
    customMaxVoiceSynthesisMonthly?: SortOrder
    customMaxExportOperationsMonthly?: SortOrder
    customMaxAudioDurationMinutes?: SortOrder
    customPriorityLevel?: SortOrder
    customFeatures?: SortOrder
    excludedFeatures?: SortOrder
    additionalFeatures?: SortOrder
    customPrice?: SortOrder
    pricingModel?: SortOrder
    billingInterval?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    autoRenew?: SortOrder
    noticePeriodDays?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    approvalStatus?: SortOrder
    approvalNotes?: SortOrder
    isActive?: SortOrder
    activatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomPlanAvgOrderByAggregateInput = {
    customMaxTranscriptionsMonthly?: SortOrder
    customMaxFilesDaily?: SortOrder
    customMaxFilesMonthly?: SortOrder
    customMaxConcurrentJobs?: SortOrder
    customMaxVoiceSynthesisMonthly?: SortOrder
    customMaxExportOperationsMonthly?: SortOrder
    customMaxAudioDurationMinutes?: SortOrder
    customPriorityLevel?: SortOrder
    customPrice?: SortOrder
    noticePeriodDays?: SortOrder
  }

  export type CustomPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    basePlanId?: SortOrder
    planName?: SortOrder
    description?: SortOrder
    customMaxTranscriptionsMonthly?: SortOrder
    customMaxFilesDaily?: SortOrder
    customMaxFilesMonthly?: SortOrder
    customMaxConcurrentJobs?: SortOrder
    customMaxVoiceSynthesisMonthly?: SortOrder
    customMaxExportOperationsMonthly?: SortOrder
    customMaxAudioDurationMinutes?: SortOrder
    customPriorityLevel?: SortOrder
    customPrice?: SortOrder
    pricingModel?: SortOrder
    billingInterval?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    autoRenew?: SortOrder
    noticePeriodDays?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    approvalStatus?: SortOrder
    approvalNotes?: SortOrder
    isActive?: SortOrder
    activatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomPlanMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    basePlanId?: SortOrder
    planName?: SortOrder
    description?: SortOrder
    customMaxTranscriptionsMonthly?: SortOrder
    customMaxFilesDaily?: SortOrder
    customMaxFilesMonthly?: SortOrder
    customMaxConcurrentJobs?: SortOrder
    customMaxVoiceSynthesisMonthly?: SortOrder
    customMaxExportOperationsMonthly?: SortOrder
    customMaxAudioDurationMinutes?: SortOrder
    customPriorityLevel?: SortOrder
    customPrice?: SortOrder
    pricingModel?: SortOrder
    billingInterval?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    autoRenew?: SortOrder
    noticePeriodDays?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    approvalStatus?: SortOrder
    approvalNotes?: SortOrder
    isActive?: SortOrder
    activatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomPlanSumOrderByAggregateInput = {
    customMaxTranscriptionsMonthly?: SortOrder
    customMaxFilesDaily?: SortOrder
    customMaxFilesMonthly?: SortOrder
    customMaxConcurrentJobs?: SortOrder
    customMaxVoiceSynthesisMonthly?: SortOrder
    customMaxExportOperationsMonthly?: SortOrder
    customMaxAudioDurationMinutes?: SortOrder
    customPriorityLevel?: SortOrder
    customPrice?: SortOrder
    noticePeriodDays?: SortOrder
  }

  export type FeatureFlagCountOrderByAggregateInput = {
    id?: SortOrder
    featureName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    featureType?: SortOrder
    minPlanLevel?: SortOrder
    requiredPlans?: SortOrder
    excludedPlans?: SortOrder
    isEnabled?: SortOrder
    isBeta?: SortOrder
    isDeprecated?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagAvgOrderByAggregateInput = {
    minPlanLevel?: SortOrder
    usageCount?: SortOrder
  }

  export type FeatureFlagMaxOrderByAggregateInput = {
    id?: SortOrder
    featureName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    featureType?: SortOrder
    minPlanLevel?: SortOrder
    isEnabled?: SortOrder
    isBeta?: SortOrder
    isDeprecated?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagMinOrderByAggregateInput = {
    id?: SortOrder
    featureName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    featureType?: SortOrder
    minPlanLevel?: SortOrder
    isEnabled?: SortOrder
    isBeta?: SortOrder
    isDeprecated?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagSumOrderByAggregateInput = {
    minPlanLevel?: SortOrder
    usageCount?: SortOrder
  }

  export type FeatureFlagRelationFilter = {
    is?: FeatureFlagWhereInput
    isNot?: FeatureFlagWhereInput
  }

  export type PlanFeatureMatrixPlanIdFeatureFlagIdCompoundUniqueInput = {
    planId: string
    featureFlagId: string
  }

  export type PlanFeatureMatrixCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    featureFlagId?: SortOrder
    isEnabled?: SortOrder
    usageLimit?: SortOrder
    includedUsage?: SortOrder
    overageRate?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanFeatureMatrixAvgOrderByAggregateInput = {
    usageLimit?: SortOrder
    includedUsage?: SortOrder
    overageRate?: SortOrder
  }

  export type PlanFeatureMatrixMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    featureFlagId?: SortOrder
    isEnabled?: SortOrder
    usageLimit?: SortOrder
    includedUsage?: SortOrder
    overageRate?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanFeatureMatrixMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    featureFlagId?: SortOrder
    isEnabled?: SortOrder
    usageLimit?: SortOrder
    includedUsage?: SortOrder
    overageRate?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanFeatureMatrixSumOrderByAggregateInput = {
    usageLimit?: SortOrder
    includedUsage?: SortOrder
    overageRate?: SortOrder
  }

  export type EwayCustomerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ewayCustomerToken?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    companyName?: SortOrder
    country?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    phoneNumber?: SortOrder
    cardLastFour?: SortOrder
    cardType?: SortOrder
    cardExpiryMonth?: SortOrder
    cardExpiryYear?: SortOrder
    ewayReference?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayCustomerAvgOrderByAggregateInput = {
    cardExpiryMonth?: SortOrder
    cardExpiryYear?: SortOrder
  }

  export type EwayCustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ewayCustomerToken?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    companyName?: SortOrder
    country?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    phoneNumber?: SortOrder
    cardLastFour?: SortOrder
    cardType?: SortOrder
    cardExpiryMonth?: SortOrder
    cardExpiryYear?: SortOrder
    ewayReference?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayCustomerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ewayCustomerToken?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    companyName?: SortOrder
    country?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    phoneNumber?: SortOrder
    cardLastFour?: SortOrder
    cardType?: SortOrder
    cardExpiryMonth?: SortOrder
    cardExpiryYear?: SortOrder
    ewayReference?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayCustomerSumOrderByAggregateInput = {
    cardExpiryMonth?: SortOrder
    cardExpiryYear?: SortOrder
  }

  export type EwayCustomerRelationFilter = {
    is?: EwayCustomerWhereInput
    isNot?: EwayCustomerWhereInput
  }

  export type EwayTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    ewayCustomerId?: SortOrder
    subscriptionId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    ewayTransactionId?: SortOrder
    ewayAccessCode?: SortOrder
    ewayAuthCode?: SortOrder
    responseCode?: SortOrder
    responseMessage?: SortOrder
    transactionStatus?: SortOrder
    isRecurring?: SortOrder
    ewayInvoiceNumber?: SortOrder
    ewayInvoiceReference?: SortOrder
    fraudAction?: SortOrder
    verificationStatus?: SortOrder
    beagleScore?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    ewayRawResponse?: SortOrder
  }

  export type EwayTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    ewayTransactionId?: SortOrder
    beagleScore?: SortOrder
  }

  export type EwayTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    ewayCustomerId?: SortOrder
    subscriptionId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    ewayTransactionId?: SortOrder
    ewayAccessCode?: SortOrder
    ewayAuthCode?: SortOrder
    responseCode?: SortOrder
    responseMessage?: SortOrder
    transactionStatus?: SortOrder
    isRecurring?: SortOrder
    ewayInvoiceNumber?: SortOrder
    ewayInvoiceReference?: SortOrder
    fraudAction?: SortOrder
    verificationStatus?: SortOrder
    beagleScore?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EwayTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    ewayCustomerId?: SortOrder
    subscriptionId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    ewayTransactionId?: SortOrder
    ewayAccessCode?: SortOrder
    ewayAuthCode?: SortOrder
    responseCode?: SortOrder
    responseMessage?: SortOrder
    transactionStatus?: SortOrder
    isRecurring?: SortOrder
    ewayInvoiceNumber?: SortOrder
    ewayInvoiceReference?: SortOrder
    fraudAction?: SortOrder
    verificationStatus?: SortOrder
    beagleScore?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EwayTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    ewayTransactionId?: SortOrder
    beagleScore?: SortOrder
  }

  export type EwayRecurringScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    ewayCustomerId?: SortOrder
    subscriptionId?: SortOrder
    scheduleType?: SortOrder
    billingAmount?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrder
    lastProcessedAt?: SortOrder
    status?: SortOrder
    failedAttempts?: SortOrder
    lastTransactionId?: SortOrder
    cancelledAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayRecurringScheduleAvgOrderByAggregateInput = {
    billingAmount?: SortOrder
    failedAttempts?: SortOrder
  }

  export type EwayRecurringScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    ewayCustomerId?: SortOrder
    subscriptionId?: SortOrder
    scheduleType?: SortOrder
    billingAmount?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrder
    lastProcessedAt?: SortOrder
    status?: SortOrder
    failedAttempts?: SortOrder
    lastTransactionId?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayRecurringScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    ewayCustomerId?: SortOrder
    subscriptionId?: SortOrder
    scheduleType?: SortOrder
    billingAmount?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrder
    lastProcessedAt?: SortOrder
    status?: SortOrder
    failedAttempts?: SortOrder
    lastTransactionId?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayRecurringScheduleSumOrderByAggregateInput = {
    billingAmount?: SortOrder
    failedAttempts?: SortOrder
  }

  export type EwayWebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    ewayTransactionId?: SortOrder
    ewayCustomerToken?: SortOrder
    eventData?: SortOrder
    rawPayload?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    sourceIp?: SortOrder
    createdAt?: SortOrder
  }

  export type EwayWebhookEventAvgOrderByAggregateInput = {
    ewayTransactionId?: SortOrder
  }

  export type EwayWebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    ewayTransactionId?: SortOrder
    ewayCustomerToken?: SortOrder
    rawPayload?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    sourceIp?: SortOrder
    createdAt?: SortOrder
  }

  export type EwayWebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    ewayTransactionId?: SortOrder
    ewayCustomerToken?: SortOrder
    rawPayload?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    sourceIp?: SortOrder
    createdAt?: SortOrder
  }

  export type EwayWebhookEventSumOrderByAggregateInput = {
    ewayTransactionId?: SortOrder
  }

  export type ExportHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exportType?: SortOrder
    dataType?: SortOrder
    dateFrom?: SortOrder
    dateTo?: SortOrder
    workspaceIds?: SortOrder
    filters?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    downloadUrl?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ExportHistoryAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    downloadCount?: SortOrder
  }

  export type ExportHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exportType?: SortOrder
    dataType?: SortOrder
    dateFrom?: SortOrder
    dateTo?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    downloadUrl?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ExportHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exportType?: SortOrder
    dataType?: SortOrder
    dateFrom?: SortOrder
    dateTo?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    downloadUrl?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ExportHistorySumOrderByAggregateInput = {
    fileSize?: SortOrder
    downloadCount?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    requestId?: SortOrder
    details?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    severity?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    requestId?: SortOrder
    severity?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    requestId?: SortOrder
    severity?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type DataRetentionPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    retentionDays?: SortOrder
    autoDelete?: SortOrder
    archiveBeforeDelete?: SortOrder
    appliesToWorkspaces?: SortOrder
    excludeWorkspaces?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrder
  }

  export type DataRetentionPolicyAvgOrderByAggregateInput = {
    retentionDays?: SortOrder
  }

  export type DataRetentionPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    retentionDays?: SortOrder
    autoDelete?: SortOrder
    archiveBeforeDelete?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrder
  }

  export type DataRetentionPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    retentionDays?: SortOrder
    autoDelete?: SortOrder
    archiveBeforeDelete?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrder
  }

  export type DataRetentionPolicySumOrderByAggregateInput = {
    retentionDays?: SortOrder
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    providerMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    providerMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    providerMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
  }

  export type TestimonialCountOrderByAggregateInput = {
    id?: SortOrder
    customerName?: SortOrder
    customerRole?: SortOrder
    companyName?: SortOrder
    avatarUrl?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    featuredOn?: SortOrder
    useCase?: SortOrder
    isVerified?: SortOrder
    verificationMethod?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type TestimonialAvgOrderByAggregateInput = {
    rating?: SortOrder
    displayOrder?: SortOrder
  }

  export type TestimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    customerName?: SortOrder
    customerRole?: SortOrder
    companyName?: SortOrder
    avatarUrl?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    featuredOn?: SortOrder
    useCase?: SortOrder
    isVerified?: SortOrder
    verificationMethod?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type TestimonialMinOrderByAggregateInput = {
    id?: SortOrder
    customerName?: SortOrder
    customerRole?: SortOrder
    companyName?: SortOrder
    avatarUrl?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    featuredOn?: SortOrder
    useCase?: SortOrder
    isVerified?: SortOrder
    verificationMethod?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type TestimonialSumOrderByAggregateInput = {
    rating?: SortOrder
    displayOrder?: SortOrder
  }

  export type WebsiteContentCountOrderByAggregateInput = {
    id?: SortOrder
    contentKey?: SortOrder
    contentType?: SortOrder
    contentValue?: SortOrder
    contentMetadata?: SortOrder
    section?: SortOrder
    page?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteContentAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type WebsiteContentMaxOrderByAggregateInput = {
    id?: SortOrder
    contentKey?: SortOrder
    contentType?: SortOrder
    contentValue?: SortOrder
    section?: SortOrder
    page?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteContentMinOrderByAggregateInput = {
    id?: SortOrder
    contentKey?: SortOrder
    contentType?: SortOrder
    contentValue?: SortOrder
    section?: SortOrder
    page?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteContentSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    isSystemRole?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    isSystemRole?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    isSystemRole?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    isSystemPermission?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    isSystemPermission?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    isSystemPermission?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedBy?: SortOrder
    assignedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedBy?: SortOrder
    assignedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedBy?: SortOrder
    assignedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type WorkspaceUserCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type AudioHistoryCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AudioHistoryCreateWithoutWorkspaceInput, AudioHistoryUncheckedCreateWithoutWorkspaceInput> | AudioHistoryCreateWithoutWorkspaceInput[] | AudioHistoryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutWorkspaceInput | AudioHistoryCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AudioHistoryCreateManyWorkspaceInputEnvelope
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
  }

  export type AudioUploadCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AudioUploadCreateWithoutWorkspaceInput, AudioUploadUncheckedCreateWithoutWorkspaceInput> | AudioUploadCreateWithoutWorkspaceInput[] | AudioUploadUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutWorkspaceInput | AudioUploadCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AudioUploadCreateManyWorkspaceInputEnvelope
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
  }

  export type AudioProjectCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AudioProjectCreateWithoutWorkspaceInput, AudioProjectUncheckedCreateWithoutWorkspaceInput> | AudioProjectCreateWithoutWorkspaceInput[] | AudioProjectUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioProjectCreateOrConnectWithoutWorkspaceInput | AudioProjectCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AudioProjectCreateManyWorkspaceInputEnvelope
    connect?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
  }

  export type WorkspaceSettingsCreateNestedOneWithoutWorkspaceInput = {
    create?: XOR<WorkspaceSettingsCreateWithoutWorkspaceInput, WorkspaceSettingsUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: WorkspaceSettingsCreateOrConnectWithoutWorkspaceInput
    connect?: WorkspaceSettingsWhereUniqueInput
  }

  export type UsageMetricCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<UsageMetricCreateWithoutWorkspaceInput, UsageMetricUncheckedCreateWithoutWorkspaceInput> | UsageMetricCreateWithoutWorkspaceInput[] | UsageMetricUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: UsageMetricCreateOrConnectWithoutWorkspaceInput | UsageMetricCreateOrConnectWithoutWorkspaceInput[]
    createMany?: UsageMetricCreateManyWorkspaceInputEnvelope
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
  }

  export type StorageQuotaCreateNestedOneWithoutWorkspaceInput = {
    create?: XOR<StorageQuotaCreateWithoutWorkspaceInput, StorageQuotaUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: StorageQuotaCreateOrConnectWithoutWorkspaceInput
    connect?: StorageQuotaWhereUniqueInput
  }

  export type WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput> | WorkspaceSubscriptionCreateWithoutWorkspaceInput[] | WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput | WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceSubscriptionCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput> | AuditLogCreateWithoutWorkspaceInput[] | AuditLogUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutWorkspaceInput | AuditLogCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AuditLogCreateManyWorkspaceInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AudioHistoryCreateWithoutWorkspaceInput, AudioHistoryUncheckedCreateWithoutWorkspaceInput> | AudioHistoryCreateWithoutWorkspaceInput[] | AudioHistoryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutWorkspaceInput | AudioHistoryCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AudioHistoryCreateManyWorkspaceInputEnvelope
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
  }

  export type AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AudioUploadCreateWithoutWorkspaceInput, AudioUploadUncheckedCreateWithoutWorkspaceInput> | AudioUploadCreateWithoutWorkspaceInput[] | AudioUploadUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutWorkspaceInput | AudioUploadCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AudioUploadCreateManyWorkspaceInputEnvelope
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
  }

  export type AudioProjectUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AudioProjectCreateWithoutWorkspaceInput, AudioProjectUncheckedCreateWithoutWorkspaceInput> | AudioProjectCreateWithoutWorkspaceInput[] | AudioProjectUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioProjectCreateOrConnectWithoutWorkspaceInput | AudioProjectCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AudioProjectCreateManyWorkspaceInputEnvelope
    connect?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
  }

  export type WorkspaceSettingsUncheckedCreateNestedOneWithoutWorkspaceInput = {
    create?: XOR<WorkspaceSettingsCreateWithoutWorkspaceInput, WorkspaceSettingsUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: WorkspaceSettingsCreateOrConnectWithoutWorkspaceInput
    connect?: WorkspaceSettingsWhereUniqueInput
  }

  export type UsageMetricUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<UsageMetricCreateWithoutWorkspaceInput, UsageMetricUncheckedCreateWithoutWorkspaceInput> | UsageMetricCreateWithoutWorkspaceInput[] | UsageMetricUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: UsageMetricCreateOrConnectWithoutWorkspaceInput | UsageMetricCreateOrConnectWithoutWorkspaceInput[]
    createMany?: UsageMetricCreateManyWorkspaceInputEnvelope
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
  }

  export type StorageQuotaUncheckedCreateNestedOneWithoutWorkspaceInput = {
    create?: XOR<StorageQuotaCreateWithoutWorkspaceInput, StorageQuotaUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: StorageQuotaCreateOrConnectWithoutWorkspaceInput
    connect?: StorageQuotaWhereUniqueInput
  }

  export type WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput> | WorkspaceSubscriptionCreateWithoutWorkspaceInput[] | WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput | WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceSubscriptionCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput> | AuditLogCreateWithoutWorkspaceInput[] | AuditLogUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutWorkspaceInput | AuditLogCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AuditLogCreateManyWorkspaceInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type WorkspaceUserUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type AudioHistoryUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutWorkspaceInput, AudioHistoryUncheckedCreateWithoutWorkspaceInput> | AudioHistoryCreateWithoutWorkspaceInput[] | AudioHistoryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutWorkspaceInput | AudioHistoryCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AudioHistoryUpsertWithWhereUniqueWithoutWorkspaceInput | AudioHistoryUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AudioHistoryCreateManyWorkspaceInputEnvelope
    set?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    disconnect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    delete?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    update?: AudioHistoryUpdateWithWhereUniqueWithoutWorkspaceInput | AudioHistoryUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AudioHistoryUpdateManyWithWhereWithoutWorkspaceInput | AudioHistoryUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
  }

  export type AudioUploadUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AudioUploadCreateWithoutWorkspaceInput, AudioUploadUncheckedCreateWithoutWorkspaceInput> | AudioUploadCreateWithoutWorkspaceInput[] | AudioUploadUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutWorkspaceInput | AudioUploadCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AudioUploadUpsertWithWhereUniqueWithoutWorkspaceInput | AudioUploadUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AudioUploadCreateManyWorkspaceInputEnvelope
    set?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    disconnect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    delete?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    update?: AudioUploadUpdateWithWhereUniqueWithoutWorkspaceInput | AudioUploadUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AudioUploadUpdateManyWithWhereWithoutWorkspaceInput | AudioUploadUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AudioUploadScalarWhereInput | AudioUploadScalarWhereInput[]
  }

  export type AudioProjectUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AudioProjectCreateWithoutWorkspaceInput, AudioProjectUncheckedCreateWithoutWorkspaceInput> | AudioProjectCreateWithoutWorkspaceInput[] | AudioProjectUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioProjectCreateOrConnectWithoutWorkspaceInput | AudioProjectCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AudioProjectUpsertWithWhereUniqueWithoutWorkspaceInput | AudioProjectUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AudioProjectCreateManyWorkspaceInputEnvelope
    set?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    disconnect?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    delete?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    connect?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    update?: AudioProjectUpdateWithWhereUniqueWithoutWorkspaceInput | AudioProjectUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AudioProjectUpdateManyWithWhereWithoutWorkspaceInput | AudioProjectUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AudioProjectScalarWhereInput | AudioProjectScalarWhereInput[]
  }

  export type WorkspaceSettingsUpdateOneWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceSettingsCreateWithoutWorkspaceInput, WorkspaceSettingsUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: WorkspaceSettingsCreateOrConnectWithoutWorkspaceInput
    upsert?: WorkspaceSettingsUpsertWithoutWorkspaceInput
    disconnect?: WorkspaceSettingsWhereInput | boolean
    delete?: WorkspaceSettingsWhereInput | boolean
    connect?: WorkspaceSettingsWhereUniqueInput
    update?: XOR<XOR<WorkspaceSettingsUpdateToOneWithWhereWithoutWorkspaceInput, WorkspaceSettingsUpdateWithoutWorkspaceInput>, WorkspaceSettingsUncheckedUpdateWithoutWorkspaceInput>
  }

  export type UsageMetricUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<UsageMetricCreateWithoutWorkspaceInput, UsageMetricUncheckedCreateWithoutWorkspaceInput> | UsageMetricCreateWithoutWorkspaceInput[] | UsageMetricUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: UsageMetricCreateOrConnectWithoutWorkspaceInput | UsageMetricCreateOrConnectWithoutWorkspaceInput[]
    upsert?: UsageMetricUpsertWithWhereUniqueWithoutWorkspaceInput | UsageMetricUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: UsageMetricCreateManyWorkspaceInputEnvelope
    set?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    disconnect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    delete?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    update?: UsageMetricUpdateWithWhereUniqueWithoutWorkspaceInput | UsageMetricUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: UsageMetricUpdateManyWithWhereWithoutWorkspaceInput | UsageMetricUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: UsageMetricScalarWhereInput | UsageMetricScalarWhereInput[]
  }

  export type StorageQuotaUpdateOneWithoutWorkspaceNestedInput = {
    create?: XOR<StorageQuotaCreateWithoutWorkspaceInput, StorageQuotaUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: StorageQuotaCreateOrConnectWithoutWorkspaceInput
    upsert?: StorageQuotaUpsertWithoutWorkspaceInput
    disconnect?: StorageQuotaWhereInput | boolean
    delete?: StorageQuotaWhereInput | boolean
    connect?: StorageQuotaWhereUniqueInput
    update?: XOR<XOR<StorageQuotaUpdateToOneWithWhereWithoutWorkspaceInput, StorageQuotaUpdateWithoutWorkspaceInput>, StorageQuotaUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput> | WorkspaceSubscriptionCreateWithoutWorkspaceInput[] | WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput | WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceSubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceSubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceSubscriptionCreateManyWorkspaceInputEnvelope
    set?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    disconnect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    delete?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    update?: WorkspaceSubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceSubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceSubscriptionUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceSubscriptionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceSubscriptionScalarWhereInput | WorkspaceSubscriptionScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput> | AuditLogCreateWithoutWorkspaceInput[] | AuditLogUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutWorkspaceInput | AuditLogCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput | AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AuditLogCreateManyWorkspaceInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput | AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutWorkspaceInput | AuditLogUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutWorkspaceInput, AudioHistoryUncheckedCreateWithoutWorkspaceInput> | AudioHistoryCreateWithoutWorkspaceInput[] | AudioHistoryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutWorkspaceInput | AudioHistoryCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AudioHistoryUpsertWithWhereUniqueWithoutWorkspaceInput | AudioHistoryUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AudioHistoryCreateManyWorkspaceInputEnvelope
    set?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    disconnect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    delete?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    update?: AudioHistoryUpdateWithWhereUniqueWithoutWorkspaceInput | AudioHistoryUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AudioHistoryUpdateManyWithWhereWithoutWorkspaceInput | AudioHistoryUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
  }

  export type AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AudioUploadCreateWithoutWorkspaceInput, AudioUploadUncheckedCreateWithoutWorkspaceInput> | AudioUploadCreateWithoutWorkspaceInput[] | AudioUploadUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutWorkspaceInput | AudioUploadCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AudioUploadUpsertWithWhereUniqueWithoutWorkspaceInput | AudioUploadUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AudioUploadCreateManyWorkspaceInputEnvelope
    set?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    disconnect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    delete?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    update?: AudioUploadUpdateWithWhereUniqueWithoutWorkspaceInput | AudioUploadUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AudioUploadUpdateManyWithWhereWithoutWorkspaceInput | AudioUploadUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AudioUploadScalarWhereInput | AudioUploadScalarWhereInput[]
  }

  export type AudioProjectUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AudioProjectCreateWithoutWorkspaceInput, AudioProjectUncheckedCreateWithoutWorkspaceInput> | AudioProjectCreateWithoutWorkspaceInput[] | AudioProjectUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioProjectCreateOrConnectWithoutWorkspaceInput | AudioProjectCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AudioProjectUpsertWithWhereUniqueWithoutWorkspaceInput | AudioProjectUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AudioProjectCreateManyWorkspaceInputEnvelope
    set?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    disconnect?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    delete?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    connect?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    update?: AudioProjectUpdateWithWhereUniqueWithoutWorkspaceInput | AudioProjectUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AudioProjectUpdateManyWithWhereWithoutWorkspaceInput | AudioProjectUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AudioProjectScalarWhereInput | AudioProjectScalarWhereInput[]
  }

  export type WorkspaceSettingsUncheckedUpdateOneWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceSettingsCreateWithoutWorkspaceInput, WorkspaceSettingsUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: WorkspaceSettingsCreateOrConnectWithoutWorkspaceInput
    upsert?: WorkspaceSettingsUpsertWithoutWorkspaceInput
    disconnect?: WorkspaceSettingsWhereInput | boolean
    delete?: WorkspaceSettingsWhereInput | boolean
    connect?: WorkspaceSettingsWhereUniqueInput
    update?: XOR<XOR<WorkspaceSettingsUpdateToOneWithWhereWithoutWorkspaceInput, WorkspaceSettingsUpdateWithoutWorkspaceInput>, WorkspaceSettingsUncheckedUpdateWithoutWorkspaceInput>
  }

  export type UsageMetricUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<UsageMetricCreateWithoutWorkspaceInput, UsageMetricUncheckedCreateWithoutWorkspaceInput> | UsageMetricCreateWithoutWorkspaceInput[] | UsageMetricUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: UsageMetricCreateOrConnectWithoutWorkspaceInput | UsageMetricCreateOrConnectWithoutWorkspaceInput[]
    upsert?: UsageMetricUpsertWithWhereUniqueWithoutWorkspaceInput | UsageMetricUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: UsageMetricCreateManyWorkspaceInputEnvelope
    set?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    disconnect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    delete?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    update?: UsageMetricUpdateWithWhereUniqueWithoutWorkspaceInput | UsageMetricUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: UsageMetricUpdateManyWithWhereWithoutWorkspaceInput | UsageMetricUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: UsageMetricScalarWhereInput | UsageMetricScalarWhereInput[]
  }

  export type StorageQuotaUncheckedUpdateOneWithoutWorkspaceNestedInput = {
    create?: XOR<StorageQuotaCreateWithoutWorkspaceInput, StorageQuotaUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: StorageQuotaCreateOrConnectWithoutWorkspaceInput
    upsert?: StorageQuotaUpsertWithoutWorkspaceInput
    disconnect?: StorageQuotaWhereInput | boolean
    delete?: StorageQuotaWhereInput | boolean
    connect?: StorageQuotaWhereUniqueInput
    update?: XOR<XOR<StorageQuotaUpdateToOneWithWhereWithoutWorkspaceInput, StorageQuotaUpdateWithoutWorkspaceInput>, StorageQuotaUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput> | WorkspaceSubscriptionCreateWithoutWorkspaceInput[] | WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput | WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceSubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceSubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceSubscriptionCreateManyWorkspaceInputEnvelope
    set?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    disconnect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    delete?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    update?: WorkspaceSubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceSubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceSubscriptionUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceSubscriptionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceSubscriptionScalarWhereInput | WorkspaceSubscriptionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput> | AuditLogCreateWithoutWorkspaceInput[] | AuditLogUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutWorkspaceInput | AuditLogCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput | AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AuditLogCreateManyWorkspaceInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput | AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutWorkspaceInput | AuditLogUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AudioHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioHistoryCreateWithoutUserInput, AudioHistoryUncheckedCreateWithoutUserInput> | AudioHistoryCreateWithoutUserInput[] | AudioHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutUserInput | AudioHistoryCreateOrConnectWithoutUserInput[]
    createMany?: AudioHistoryCreateManyUserInputEnvelope
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type WorkspaceUserCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AudioUploadCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioUploadCreateWithoutUserInput, AudioUploadUncheckedCreateWithoutUserInput> | AudioUploadCreateWithoutUserInput[] | AudioUploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutUserInput | AudioUploadCreateOrConnectWithoutUserInput[]
    createMany?: AudioUploadCreateManyUserInputEnvelope
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
  }

  export type AudioProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioProjectCreateWithoutUserInput, AudioProjectUncheckedCreateWithoutUserInput> | AudioProjectCreateWithoutUserInput[] | AudioProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioProjectCreateOrConnectWithoutUserInput | AudioProjectCreateOrConnectWithoutUserInput[]
    createMany?: AudioProjectCreateManyUserInputEnvelope
    connect?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
  }

  export type ProcessingJobCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessingJobCreateWithoutUserInput, ProcessingJobUncheckedCreateWithoutUserInput> | ProcessingJobCreateWithoutUserInput[] | ProcessingJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutUserInput | ProcessingJobCreateOrConnectWithoutUserInput[]
    createMany?: ProcessingJobCreateManyUserInputEnvelope
    connect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
  }

  export type UsageMetricCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageMetricCreateWithoutUserInput, UsageMetricUncheckedCreateWithoutUserInput> | UsageMetricCreateWithoutUserInput[] | UsageMetricUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageMetricCreateOrConnectWithoutUserInput | UsageMetricCreateOrConnectWithoutUserInput[]
    createMany?: UsageMetricCreateManyUserInputEnvelope
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
  }

  export type ExportHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<ExportHistoryCreateWithoutUserInput, ExportHistoryUncheckedCreateWithoutUserInput> | ExportHistoryCreateWithoutUserInput[] | ExportHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExportHistoryCreateOrConnectWithoutUserInput | ExportHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ExportHistoryCreateManyUserInputEnvelope
    connect?: ExportHistoryWhereUniqueInput | ExportHistoryWhereUniqueInput[]
  }

  export type ApiKeyManagementCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyManagementCreateWithoutUserInput, ApiKeyManagementUncheckedCreateWithoutUserInput> | ApiKeyManagementCreateWithoutUserInput[] | ApiKeyManagementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyManagementCreateOrConnectWithoutUserInput | ApiKeyManagementCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyManagementCreateManyUserInputEnvelope
    connect?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
  }

  export type UserQuotaCreateNestedOneWithoutUserInput = {
    create?: XOR<UserQuotaCreateWithoutUserInput, UserQuotaUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserQuotaCreateOrConnectWithoutUserInput
    connect?: UserQuotaWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SecurityEventCreateNestedManyWithoutUserInput = {
    create?: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput> | SecurityEventCreateWithoutUserInput[] | SecurityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityEventCreateOrConnectWithoutUserInput | SecurityEventCreateOrConnectWithoutUserInput[]
    createMany?: SecurityEventCreateManyUserInputEnvelope
    connect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
  }

  export type ProcessingTemplateCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessingTemplateCreateWithoutUserInput, ProcessingTemplateUncheckedCreateWithoutUserInput> | ProcessingTemplateCreateWithoutUserInput[] | ProcessingTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessingTemplateCreateOrConnectWithoutUserInput | ProcessingTemplateCreateOrConnectWithoutUserInput[]
    createMany?: ProcessingTemplateCreateManyUserInputEnvelope
    connect?: ProcessingTemplateWhereUniqueInput | ProcessingTemplateWhereUniqueInput[]
  }

  export type CustomPlanCreateNestedManyWithoutRequestedByUserInput = {
    create?: XOR<CustomPlanCreateWithoutRequestedByUserInput, CustomPlanUncheckedCreateWithoutRequestedByUserInput> | CustomPlanCreateWithoutRequestedByUserInput[] | CustomPlanUncheckedCreateWithoutRequestedByUserInput[]
    connectOrCreate?: CustomPlanCreateOrConnectWithoutRequestedByUserInput | CustomPlanCreateOrConnectWithoutRequestedByUserInput[]
    createMany?: CustomPlanCreateManyRequestedByUserInputEnvelope
    connect?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
  }

  export type PlanRecommendationCreateNestedManyWithoutUserInput = {
    create?: XOR<PlanRecommendationCreateWithoutUserInput, PlanRecommendationUncheckedCreateWithoutUserInput> | PlanRecommendationCreateWithoutUserInput[] | PlanRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanRecommendationCreateOrConnectWithoutUserInput | PlanRecommendationCreateOrConnectWithoutUserInput[]
    createMany?: PlanRecommendationCreateManyUserInputEnvelope
    connect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
  }

  export type UsageCounterCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageCounterCreateWithoutUserInput, UsageCounterUncheckedCreateWithoutUserInput> | UsageCounterCreateWithoutUserInput[] | UsageCounterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageCounterCreateOrConnectWithoutUserInput | UsageCounterCreateOrConnectWithoutUserInput[]
    createMany?: UsageCounterCreateManyUserInputEnvelope
    connect?: UsageCounterWhereUniqueInput | UsageCounterWhereUniqueInput[]
  }

  export type EwayCustomerCreateNestedManyWithoutUserInput = {
    create?: XOR<EwayCustomerCreateWithoutUserInput, EwayCustomerUncheckedCreateWithoutUserInput> | EwayCustomerCreateWithoutUserInput[] | EwayCustomerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EwayCustomerCreateOrConnectWithoutUserInput | EwayCustomerCreateOrConnectWithoutUserInput[]
    createMany?: EwayCustomerCreateManyUserInputEnvelope
    connect?: EwayCustomerWhereUniqueInput | EwayCustomerWhereUniqueInput[]
  }

  export type EwayTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<EwayTransactionCreateWithoutUserInput, EwayTransactionUncheckedCreateWithoutUserInput> | EwayTransactionCreateWithoutUserInput[] | EwayTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EwayTransactionCreateOrConnectWithoutUserInput | EwayTransactionCreateOrConnectWithoutUserInput[]
    createMany?: EwayTransactionCreateManyUserInputEnvelope
    connect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
  }

  export type EwayRecurringScheduleCreateNestedManyWithoutUserInput = {
    create?: XOR<EwayRecurringScheduleCreateWithoutUserInput, EwayRecurringScheduleUncheckedCreateWithoutUserInput> | EwayRecurringScheduleCreateWithoutUserInput[] | EwayRecurringScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EwayRecurringScheduleCreateOrConnectWithoutUserInput | EwayRecurringScheduleCreateOrConnectWithoutUserInput[]
    createMany?: EwayRecurringScheduleCreateManyUserInputEnvelope
    connect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutAssignedByUserInput = {
    create?: XOR<UserRoleCreateWithoutAssignedByUserInput, UserRoleUncheckedCreateWithoutAssignedByUserInput> | UserRoleCreateWithoutAssignedByUserInput[] | UserRoleUncheckedCreateWithoutAssignedByUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutAssignedByUserInput | UserRoleCreateOrConnectWithoutAssignedByUserInput[]
    createMany?: UserRoleCreateManyAssignedByUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type TestimonialCreateNestedManyWithoutUserInput = {
    create?: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput> | TestimonialCreateWithoutUserInput[] | TestimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutUserInput | TestimonialCreateOrConnectWithoutUserInput[]
    createMany?: TestimonialCreateManyUserInputEnvelope
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
  }

  export type AudioHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioHistoryCreateWithoutUserInput, AudioHistoryUncheckedCreateWithoutUserInput> | AudioHistoryCreateWithoutUserInput[] | AudioHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutUserInput | AudioHistoryCreateOrConnectWithoutUserInput[]
    createMany?: AudioHistoryCreateManyUserInputEnvelope
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type WorkspaceUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AudioUploadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioUploadCreateWithoutUserInput, AudioUploadUncheckedCreateWithoutUserInput> | AudioUploadCreateWithoutUserInput[] | AudioUploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutUserInput | AudioUploadCreateOrConnectWithoutUserInput[]
    createMany?: AudioUploadCreateManyUserInputEnvelope
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
  }

  export type AudioProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioProjectCreateWithoutUserInput, AudioProjectUncheckedCreateWithoutUserInput> | AudioProjectCreateWithoutUserInput[] | AudioProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioProjectCreateOrConnectWithoutUserInput | AudioProjectCreateOrConnectWithoutUserInput[]
    createMany?: AudioProjectCreateManyUserInputEnvelope
    connect?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
  }

  export type ProcessingJobUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessingJobCreateWithoutUserInput, ProcessingJobUncheckedCreateWithoutUserInput> | ProcessingJobCreateWithoutUserInput[] | ProcessingJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutUserInput | ProcessingJobCreateOrConnectWithoutUserInput[]
    createMany?: ProcessingJobCreateManyUserInputEnvelope
    connect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
  }

  export type UsageMetricUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageMetricCreateWithoutUserInput, UsageMetricUncheckedCreateWithoutUserInput> | UsageMetricCreateWithoutUserInput[] | UsageMetricUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageMetricCreateOrConnectWithoutUserInput | UsageMetricCreateOrConnectWithoutUserInput[]
    createMany?: UsageMetricCreateManyUserInputEnvelope
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
  }

  export type ExportHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExportHistoryCreateWithoutUserInput, ExportHistoryUncheckedCreateWithoutUserInput> | ExportHistoryCreateWithoutUserInput[] | ExportHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExportHistoryCreateOrConnectWithoutUserInput | ExportHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ExportHistoryCreateManyUserInputEnvelope
    connect?: ExportHistoryWhereUniqueInput | ExportHistoryWhereUniqueInput[]
  }

  export type ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyManagementCreateWithoutUserInput, ApiKeyManagementUncheckedCreateWithoutUserInput> | ApiKeyManagementCreateWithoutUserInput[] | ApiKeyManagementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyManagementCreateOrConnectWithoutUserInput | ApiKeyManagementCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyManagementCreateManyUserInputEnvelope
    connect?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
  }

  export type UserQuotaUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserQuotaCreateWithoutUserInput, UserQuotaUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserQuotaCreateOrConnectWithoutUserInput
    connect?: UserQuotaWhereUniqueInput
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SecurityEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput> | SecurityEventCreateWithoutUserInput[] | SecurityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityEventCreateOrConnectWithoutUserInput | SecurityEventCreateOrConnectWithoutUserInput[]
    createMany?: SecurityEventCreateManyUserInputEnvelope
    connect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
  }

  export type ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessingTemplateCreateWithoutUserInput, ProcessingTemplateUncheckedCreateWithoutUserInput> | ProcessingTemplateCreateWithoutUserInput[] | ProcessingTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessingTemplateCreateOrConnectWithoutUserInput | ProcessingTemplateCreateOrConnectWithoutUserInput[]
    createMany?: ProcessingTemplateCreateManyUserInputEnvelope
    connect?: ProcessingTemplateWhereUniqueInput | ProcessingTemplateWhereUniqueInput[]
  }

  export type CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput = {
    create?: XOR<CustomPlanCreateWithoutRequestedByUserInput, CustomPlanUncheckedCreateWithoutRequestedByUserInput> | CustomPlanCreateWithoutRequestedByUserInput[] | CustomPlanUncheckedCreateWithoutRequestedByUserInput[]
    connectOrCreate?: CustomPlanCreateOrConnectWithoutRequestedByUserInput | CustomPlanCreateOrConnectWithoutRequestedByUserInput[]
    createMany?: CustomPlanCreateManyRequestedByUserInputEnvelope
    connect?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
  }

  export type PlanRecommendationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlanRecommendationCreateWithoutUserInput, PlanRecommendationUncheckedCreateWithoutUserInput> | PlanRecommendationCreateWithoutUserInput[] | PlanRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanRecommendationCreateOrConnectWithoutUserInput | PlanRecommendationCreateOrConnectWithoutUserInput[]
    createMany?: PlanRecommendationCreateManyUserInputEnvelope
    connect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
  }

  export type UsageCounterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageCounterCreateWithoutUserInput, UsageCounterUncheckedCreateWithoutUserInput> | UsageCounterCreateWithoutUserInput[] | UsageCounterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageCounterCreateOrConnectWithoutUserInput | UsageCounterCreateOrConnectWithoutUserInput[]
    createMany?: UsageCounterCreateManyUserInputEnvelope
    connect?: UsageCounterWhereUniqueInput | UsageCounterWhereUniqueInput[]
  }

  export type EwayCustomerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EwayCustomerCreateWithoutUserInput, EwayCustomerUncheckedCreateWithoutUserInput> | EwayCustomerCreateWithoutUserInput[] | EwayCustomerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EwayCustomerCreateOrConnectWithoutUserInput | EwayCustomerCreateOrConnectWithoutUserInput[]
    createMany?: EwayCustomerCreateManyUserInputEnvelope
    connect?: EwayCustomerWhereUniqueInput | EwayCustomerWhereUniqueInput[]
  }

  export type EwayTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EwayTransactionCreateWithoutUserInput, EwayTransactionUncheckedCreateWithoutUserInput> | EwayTransactionCreateWithoutUserInput[] | EwayTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EwayTransactionCreateOrConnectWithoutUserInput | EwayTransactionCreateOrConnectWithoutUserInput[]
    createMany?: EwayTransactionCreateManyUserInputEnvelope
    connect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
  }

  export type EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EwayRecurringScheduleCreateWithoutUserInput, EwayRecurringScheduleUncheckedCreateWithoutUserInput> | EwayRecurringScheduleCreateWithoutUserInput[] | EwayRecurringScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EwayRecurringScheduleCreateOrConnectWithoutUserInput | EwayRecurringScheduleCreateOrConnectWithoutUserInput[]
    createMany?: EwayRecurringScheduleCreateManyUserInputEnvelope
    connect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput = {
    create?: XOR<UserRoleCreateWithoutAssignedByUserInput, UserRoleUncheckedCreateWithoutAssignedByUserInput> | UserRoleCreateWithoutAssignedByUserInput[] | UserRoleUncheckedCreateWithoutAssignedByUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutAssignedByUserInput | UserRoleCreateOrConnectWithoutAssignedByUserInput[]
    createMany?: UserRoleCreateManyAssignedByUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type TestimonialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput> | TestimonialCreateWithoutUserInput[] | TestimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutUserInput | TestimonialCreateOrConnectWithoutUserInput[]
    createMany?: TestimonialCreateManyUserInputEnvelope
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AudioHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutUserInput, AudioHistoryUncheckedCreateWithoutUserInput> | AudioHistoryCreateWithoutUserInput[] | AudioHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutUserInput | AudioHistoryCreateOrConnectWithoutUserInput[]
    upsert?: AudioHistoryUpsertWithWhereUniqueWithoutUserInput | AudioHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioHistoryCreateManyUserInputEnvelope
    set?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    disconnect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    delete?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    update?: AudioHistoryUpdateWithWhereUniqueWithoutUserInput | AudioHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioHistoryUpdateManyWithWhereWithoutUserInput | AudioHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutUserInput | WorkspaceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutUserInput | WorkspaceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutUserInput | WorkspaceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AudioUploadUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioUploadCreateWithoutUserInput, AudioUploadUncheckedCreateWithoutUserInput> | AudioUploadCreateWithoutUserInput[] | AudioUploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutUserInput | AudioUploadCreateOrConnectWithoutUserInput[]
    upsert?: AudioUploadUpsertWithWhereUniqueWithoutUserInput | AudioUploadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioUploadCreateManyUserInputEnvelope
    set?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    disconnect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    delete?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    update?: AudioUploadUpdateWithWhereUniqueWithoutUserInput | AudioUploadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioUploadUpdateManyWithWhereWithoutUserInput | AudioUploadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioUploadScalarWhereInput | AudioUploadScalarWhereInput[]
  }

  export type AudioProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioProjectCreateWithoutUserInput, AudioProjectUncheckedCreateWithoutUserInput> | AudioProjectCreateWithoutUserInput[] | AudioProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioProjectCreateOrConnectWithoutUserInput | AudioProjectCreateOrConnectWithoutUserInput[]
    upsert?: AudioProjectUpsertWithWhereUniqueWithoutUserInput | AudioProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioProjectCreateManyUserInputEnvelope
    set?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    disconnect?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    delete?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    connect?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    update?: AudioProjectUpdateWithWhereUniqueWithoutUserInput | AudioProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioProjectUpdateManyWithWhereWithoutUserInput | AudioProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioProjectScalarWhereInput | AudioProjectScalarWhereInput[]
  }

  export type ProcessingJobUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessingJobCreateWithoutUserInput, ProcessingJobUncheckedCreateWithoutUserInput> | ProcessingJobCreateWithoutUserInput[] | ProcessingJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutUserInput | ProcessingJobCreateOrConnectWithoutUserInput[]
    upsert?: ProcessingJobUpsertWithWhereUniqueWithoutUserInput | ProcessingJobUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessingJobCreateManyUserInputEnvelope
    set?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    disconnect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    delete?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    connect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    update?: ProcessingJobUpdateWithWhereUniqueWithoutUserInput | ProcessingJobUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessingJobUpdateManyWithWhereWithoutUserInput | ProcessingJobUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessingJobScalarWhereInput | ProcessingJobScalarWhereInput[]
  }

  export type UsageMetricUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageMetricCreateWithoutUserInput, UsageMetricUncheckedCreateWithoutUserInput> | UsageMetricCreateWithoutUserInput[] | UsageMetricUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageMetricCreateOrConnectWithoutUserInput | UsageMetricCreateOrConnectWithoutUserInput[]
    upsert?: UsageMetricUpsertWithWhereUniqueWithoutUserInput | UsageMetricUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageMetricCreateManyUserInputEnvelope
    set?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    disconnect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    delete?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    update?: UsageMetricUpdateWithWhereUniqueWithoutUserInput | UsageMetricUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageMetricUpdateManyWithWhereWithoutUserInput | UsageMetricUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageMetricScalarWhereInput | UsageMetricScalarWhereInput[]
  }

  export type ExportHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExportHistoryCreateWithoutUserInput, ExportHistoryUncheckedCreateWithoutUserInput> | ExportHistoryCreateWithoutUserInput[] | ExportHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExportHistoryCreateOrConnectWithoutUserInput | ExportHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ExportHistoryUpsertWithWhereUniqueWithoutUserInput | ExportHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExportHistoryCreateManyUserInputEnvelope
    set?: ExportHistoryWhereUniqueInput | ExportHistoryWhereUniqueInput[]
    disconnect?: ExportHistoryWhereUniqueInput | ExportHistoryWhereUniqueInput[]
    delete?: ExportHistoryWhereUniqueInput | ExportHistoryWhereUniqueInput[]
    connect?: ExportHistoryWhereUniqueInput | ExportHistoryWhereUniqueInput[]
    update?: ExportHistoryUpdateWithWhereUniqueWithoutUserInput | ExportHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExportHistoryUpdateManyWithWhereWithoutUserInput | ExportHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExportHistoryScalarWhereInput | ExportHistoryScalarWhereInput[]
  }

  export type ApiKeyManagementUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyManagementCreateWithoutUserInput, ApiKeyManagementUncheckedCreateWithoutUserInput> | ApiKeyManagementCreateWithoutUserInput[] | ApiKeyManagementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyManagementCreateOrConnectWithoutUserInput | ApiKeyManagementCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyManagementUpsertWithWhereUniqueWithoutUserInput | ApiKeyManagementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyManagementCreateManyUserInputEnvelope
    set?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    disconnect?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    delete?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    connect?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    update?: ApiKeyManagementUpdateWithWhereUniqueWithoutUserInput | ApiKeyManagementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyManagementUpdateManyWithWhereWithoutUserInput | ApiKeyManagementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyManagementScalarWhereInput | ApiKeyManagementScalarWhereInput[]
  }

  export type UserQuotaUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserQuotaCreateWithoutUserInput, UserQuotaUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserQuotaCreateOrConnectWithoutUserInput
    upsert?: UserQuotaUpsertWithoutUserInput
    disconnect?: UserQuotaWhereInput | boolean
    delete?: UserQuotaWhereInput | boolean
    connect?: UserQuotaWhereUniqueInput
    update?: XOR<XOR<UserQuotaUpdateToOneWithWhereWithoutUserInput, UserQuotaUpdateWithoutUserInput>, UserQuotaUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SecurityEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput> | SecurityEventCreateWithoutUserInput[] | SecurityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityEventCreateOrConnectWithoutUserInput | SecurityEventCreateOrConnectWithoutUserInput[]
    upsert?: SecurityEventUpsertWithWhereUniqueWithoutUserInput | SecurityEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SecurityEventCreateManyUserInputEnvelope
    set?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    disconnect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    delete?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    connect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    update?: SecurityEventUpdateWithWhereUniqueWithoutUserInput | SecurityEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SecurityEventUpdateManyWithWhereWithoutUserInput | SecurityEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SecurityEventScalarWhereInput | SecurityEventScalarWhereInput[]
  }

  export type ProcessingTemplateUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessingTemplateCreateWithoutUserInput, ProcessingTemplateUncheckedCreateWithoutUserInput> | ProcessingTemplateCreateWithoutUserInput[] | ProcessingTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessingTemplateCreateOrConnectWithoutUserInput | ProcessingTemplateCreateOrConnectWithoutUserInput[]
    upsert?: ProcessingTemplateUpsertWithWhereUniqueWithoutUserInput | ProcessingTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessingTemplateCreateManyUserInputEnvelope
    set?: ProcessingTemplateWhereUniqueInput | ProcessingTemplateWhereUniqueInput[]
    disconnect?: ProcessingTemplateWhereUniqueInput | ProcessingTemplateWhereUniqueInput[]
    delete?: ProcessingTemplateWhereUniqueInput | ProcessingTemplateWhereUniqueInput[]
    connect?: ProcessingTemplateWhereUniqueInput | ProcessingTemplateWhereUniqueInput[]
    update?: ProcessingTemplateUpdateWithWhereUniqueWithoutUserInput | ProcessingTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessingTemplateUpdateManyWithWhereWithoutUserInput | ProcessingTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessingTemplateScalarWhereInput | ProcessingTemplateScalarWhereInput[]
  }

  export type CustomPlanUpdateManyWithoutRequestedByUserNestedInput = {
    create?: XOR<CustomPlanCreateWithoutRequestedByUserInput, CustomPlanUncheckedCreateWithoutRequestedByUserInput> | CustomPlanCreateWithoutRequestedByUserInput[] | CustomPlanUncheckedCreateWithoutRequestedByUserInput[]
    connectOrCreate?: CustomPlanCreateOrConnectWithoutRequestedByUserInput | CustomPlanCreateOrConnectWithoutRequestedByUserInput[]
    upsert?: CustomPlanUpsertWithWhereUniqueWithoutRequestedByUserInput | CustomPlanUpsertWithWhereUniqueWithoutRequestedByUserInput[]
    createMany?: CustomPlanCreateManyRequestedByUserInputEnvelope
    set?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    disconnect?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    delete?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    connect?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    update?: CustomPlanUpdateWithWhereUniqueWithoutRequestedByUserInput | CustomPlanUpdateWithWhereUniqueWithoutRequestedByUserInput[]
    updateMany?: CustomPlanUpdateManyWithWhereWithoutRequestedByUserInput | CustomPlanUpdateManyWithWhereWithoutRequestedByUserInput[]
    deleteMany?: CustomPlanScalarWhereInput | CustomPlanScalarWhereInput[]
  }

  export type PlanRecommendationUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlanRecommendationCreateWithoutUserInput, PlanRecommendationUncheckedCreateWithoutUserInput> | PlanRecommendationCreateWithoutUserInput[] | PlanRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanRecommendationCreateOrConnectWithoutUserInput | PlanRecommendationCreateOrConnectWithoutUserInput[]
    upsert?: PlanRecommendationUpsertWithWhereUniqueWithoutUserInput | PlanRecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlanRecommendationCreateManyUserInputEnvelope
    set?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    disconnect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    delete?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    connect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    update?: PlanRecommendationUpdateWithWhereUniqueWithoutUserInput | PlanRecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlanRecommendationUpdateManyWithWhereWithoutUserInput | PlanRecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlanRecommendationScalarWhereInput | PlanRecommendationScalarWhereInput[]
  }

  export type UsageCounterUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageCounterCreateWithoutUserInput, UsageCounterUncheckedCreateWithoutUserInput> | UsageCounterCreateWithoutUserInput[] | UsageCounterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageCounterCreateOrConnectWithoutUserInput | UsageCounterCreateOrConnectWithoutUserInput[]
    upsert?: UsageCounterUpsertWithWhereUniqueWithoutUserInput | UsageCounterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageCounterCreateManyUserInputEnvelope
    set?: UsageCounterWhereUniqueInput | UsageCounterWhereUniqueInput[]
    disconnect?: UsageCounterWhereUniqueInput | UsageCounterWhereUniqueInput[]
    delete?: UsageCounterWhereUniqueInput | UsageCounterWhereUniqueInput[]
    connect?: UsageCounterWhereUniqueInput | UsageCounterWhereUniqueInput[]
    update?: UsageCounterUpdateWithWhereUniqueWithoutUserInput | UsageCounterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageCounterUpdateManyWithWhereWithoutUserInput | UsageCounterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageCounterScalarWhereInput | UsageCounterScalarWhereInput[]
  }

  export type EwayCustomerUpdateManyWithoutUserNestedInput = {
    create?: XOR<EwayCustomerCreateWithoutUserInput, EwayCustomerUncheckedCreateWithoutUserInput> | EwayCustomerCreateWithoutUserInput[] | EwayCustomerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EwayCustomerCreateOrConnectWithoutUserInput | EwayCustomerCreateOrConnectWithoutUserInput[]
    upsert?: EwayCustomerUpsertWithWhereUniqueWithoutUserInput | EwayCustomerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EwayCustomerCreateManyUserInputEnvelope
    set?: EwayCustomerWhereUniqueInput | EwayCustomerWhereUniqueInput[]
    disconnect?: EwayCustomerWhereUniqueInput | EwayCustomerWhereUniqueInput[]
    delete?: EwayCustomerWhereUniqueInput | EwayCustomerWhereUniqueInput[]
    connect?: EwayCustomerWhereUniqueInput | EwayCustomerWhereUniqueInput[]
    update?: EwayCustomerUpdateWithWhereUniqueWithoutUserInput | EwayCustomerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EwayCustomerUpdateManyWithWhereWithoutUserInput | EwayCustomerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EwayCustomerScalarWhereInput | EwayCustomerScalarWhereInput[]
  }

  export type EwayTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<EwayTransactionCreateWithoutUserInput, EwayTransactionUncheckedCreateWithoutUserInput> | EwayTransactionCreateWithoutUserInput[] | EwayTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EwayTransactionCreateOrConnectWithoutUserInput | EwayTransactionCreateOrConnectWithoutUserInput[]
    upsert?: EwayTransactionUpsertWithWhereUniqueWithoutUserInput | EwayTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EwayTransactionCreateManyUserInputEnvelope
    set?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    disconnect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    delete?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    connect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    update?: EwayTransactionUpdateWithWhereUniqueWithoutUserInput | EwayTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EwayTransactionUpdateManyWithWhereWithoutUserInput | EwayTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EwayTransactionScalarWhereInput | EwayTransactionScalarWhereInput[]
  }

  export type EwayRecurringScheduleUpdateManyWithoutUserNestedInput = {
    create?: XOR<EwayRecurringScheduleCreateWithoutUserInput, EwayRecurringScheduleUncheckedCreateWithoutUserInput> | EwayRecurringScheduleCreateWithoutUserInput[] | EwayRecurringScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EwayRecurringScheduleCreateOrConnectWithoutUserInput | EwayRecurringScheduleCreateOrConnectWithoutUserInput[]
    upsert?: EwayRecurringScheduleUpsertWithWhereUniqueWithoutUserInput | EwayRecurringScheduleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EwayRecurringScheduleCreateManyUserInputEnvelope
    set?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    disconnect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    delete?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    connect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    update?: EwayRecurringScheduleUpdateWithWhereUniqueWithoutUserInput | EwayRecurringScheduleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EwayRecurringScheduleUpdateManyWithWhereWithoutUserInput | EwayRecurringScheduleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EwayRecurringScheduleScalarWhereInput | EwayRecurringScheduleScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutAssignedByUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutAssignedByUserInput, UserRoleUncheckedCreateWithoutAssignedByUserInput> | UserRoleCreateWithoutAssignedByUserInput[] | UserRoleUncheckedCreateWithoutAssignedByUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutAssignedByUserInput | UserRoleCreateOrConnectWithoutAssignedByUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutAssignedByUserInput | UserRoleUpsertWithWhereUniqueWithoutAssignedByUserInput[]
    createMany?: UserRoleCreateManyAssignedByUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutAssignedByUserInput | UserRoleUpdateWithWhereUniqueWithoutAssignedByUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutAssignedByUserInput | UserRoleUpdateManyWithWhereWithoutAssignedByUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type TestimonialUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput> | TestimonialCreateWithoutUserInput[] | TestimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutUserInput | TestimonialCreateOrConnectWithoutUserInput[]
    upsert?: TestimonialUpsertWithWhereUniqueWithoutUserInput | TestimonialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestimonialCreateManyUserInputEnvelope
    set?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    disconnect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    delete?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    update?: TestimonialUpdateWithWhereUniqueWithoutUserInput | TestimonialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestimonialUpdateManyWithWhereWithoutUserInput | TestimonialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
  }

  export type AudioHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutUserInput, AudioHistoryUncheckedCreateWithoutUserInput> | AudioHistoryCreateWithoutUserInput[] | AudioHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutUserInput | AudioHistoryCreateOrConnectWithoutUserInput[]
    upsert?: AudioHistoryUpsertWithWhereUniqueWithoutUserInput | AudioHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioHistoryCreateManyUserInputEnvelope
    set?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    disconnect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    delete?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    update?: AudioHistoryUpdateWithWhereUniqueWithoutUserInput | AudioHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioHistoryUpdateManyWithWhereWithoutUserInput | AudioHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutUserInput | WorkspaceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutUserInput | WorkspaceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutUserInput | WorkspaceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AudioUploadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioUploadCreateWithoutUserInput, AudioUploadUncheckedCreateWithoutUserInput> | AudioUploadCreateWithoutUserInput[] | AudioUploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutUserInput | AudioUploadCreateOrConnectWithoutUserInput[]
    upsert?: AudioUploadUpsertWithWhereUniqueWithoutUserInput | AudioUploadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioUploadCreateManyUserInputEnvelope
    set?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    disconnect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    delete?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    update?: AudioUploadUpdateWithWhereUniqueWithoutUserInput | AudioUploadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioUploadUpdateManyWithWhereWithoutUserInput | AudioUploadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioUploadScalarWhereInput | AudioUploadScalarWhereInput[]
  }

  export type AudioProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioProjectCreateWithoutUserInput, AudioProjectUncheckedCreateWithoutUserInput> | AudioProjectCreateWithoutUserInput[] | AudioProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioProjectCreateOrConnectWithoutUserInput | AudioProjectCreateOrConnectWithoutUserInput[]
    upsert?: AudioProjectUpsertWithWhereUniqueWithoutUserInput | AudioProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioProjectCreateManyUserInputEnvelope
    set?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    disconnect?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    delete?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    connect?: AudioProjectWhereUniqueInput | AudioProjectWhereUniqueInput[]
    update?: AudioProjectUpdateWithWhereUniqueWithoutUserInput | AudioProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioProjectUpdateManyWithWhereWithoutUserInput | AudioProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioProjectScalarWhereInput | AudioProjectScalarWhereInput[]
  }

  export type ProcessingJobUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessingJobCreateWithoutUserInput, ProcessingJobUncheckedCreateWithoutUserInput> | ProcessingJobCreateWithoutUserInput[] | ProcessingJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutUserInput | ProcessingJobCreateOrConnectWithoutUserInput[]
    upsert?: ProcessingJobUpsertWithWhereUniqueWithoutUserInput | ProcessingJobUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessingJobCreateManyUserInputEnvelope
    set?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    disconnect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    delete?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    connect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    update?: ProcessingJobUpdateWithWhereUniqueWithoutUserInput | ProcessingJobUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessingJobUpdateManyWithWhereWithoutUserInput | ProcessingJobUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessingJobScalarWhereInput | ProcessingJobScalarWhereInput[]
  }

  export type UsageMetricUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageMetricCreateWithoutUserInput, UsageMetricUncheckedCreateWithoutUserInput> | UsageMetricCreateWithoutUserInput[] | UsageMetricUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageMetricCreateOrConnectWithoutUserInput | UsageMetricCreateOrConnectWithoutUserInput[]
    upsert?: UsageMetricUpsertWithWhereUniqueWithoutUserInput | UsageMetricUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageMetricCreateManyUserInputEnvelope
    set?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    disconnect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    delete?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[]
    update?: UsageMetricUpdateWithWhereUniqueWithoutUserInput | UsageMetricUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageMetricUpdateManyWithWhereWithoutUserInput | UsageMetricUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageMetricScalarWhereInput | UsageMetricScalarWhereInput[]
  }

  export type ExportHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExportHistoryCreateWithoutUserInput, ExportHistoryUncheckedCreateWithoutUserInput> | ExportHistoryCreateWithoutUserInput[] | ExportHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExportHistoryCreateOrConnectWithoutUserInput | ExportHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ExportHistoryUpsertWithWhereUniqueWithoutUserInput | ExportHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExportHistoryCreateManyUserInputEnvelope
    set?: ExportHistoryWhereUniqueInput | ExportHistoryWhereUniqueInput[]
    disconnect?: ExportHistoryWhereUniqueInput | ExportHistoryWhereUniqueInput[]
    delete?: ExportHistoryWhereUniqueInput | ExportHistoryWhereUniqueInput[]
    connect?: ExportHistoryWhereUniqueInput | ExportHistoryWhereUniqueInput[]
    update?: ExportHistoryUpdateWithWhereUniqueWithoutUserInput | ExportHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExportHistoryUpdateManyWithWhereWithoutUserInput | ExportHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExportHistoryScalarWhereInput | ExportHistoryScalarWhereInput[]
  }

  export type ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyManagementCreateWithoutUserInput, ApiKeyManagementUncheckedCreateWithoutUserInput> | ApiKeyManagementCreateWithoutUserInput[] | ApiKeyManagementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyManagementCreateOrConnectWithoutUserInput | ApiKeyManagementCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyManagementUpsertWithWhereUniqueWithoutUserInput | ApiKeyManagementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyManagementCreateManyUserInputEnvelope
    set?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    disconnect?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    delete?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    connect?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    update?: ApiKeyManagementUpdateWithWhereUniqueWithoutUserInput | ApiKeyManagementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyManagementUpdateManyWithWhereWithoutUserInput | ApiKeyManagementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyManagementScalarWhereInput | ApiKeyManagementScalarWhereInput[]
  }

  export type UserQuotaUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserQuotaCreateWithoutUserInput, UserQuotaUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserQuotaCreateOrConnectWithoutUserInput
    upsert?: UserQuotaUpsertWithoutUserInput
    disconnect?: UserQuotaWhereInput | boolean
    delete?: UserQuotaWhereInput | boolean
    connect?: UserQuotaWhereUniqueInput
    update?: XOR<XOR<UserQuotaUpdateToOneWithWhereWithoutUserInput, UserQuotaUpdateWithoutUserInput>, UserQuotaUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SecurityEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput> | SecurityEventCreateWithoutUserInput[] | SecurityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityEventCreateOrConnectWithoutUserInput | SecurityEventCreateOrConnectWithoutUserInput[]
    upsert?: SecurityEventUpsertWithWhereUniqueWithoutUserInput | SecurityEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SecurityEventCreateManyUserInputEnvelope
    set?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    disconnect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    delete?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    connect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    update?: SecurityEventUpdateWithWhereUniqueWithoutUserInput | SecurityEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SecurityEventUpdateManyWithWhereWithoutUserInput | SecurityEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SecurityEventScalarWhereInput | SecurityEventScalarWhereInput[]
  }

  export type ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessingTemplateCreateWithoutUserInput, ProcessingTemplateUncheckedCreateWithoutUserInput> | ProcessingTemplateCreateWithoutUserInput[] | ProcessingTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessingTemplateCreateOrConnectWithoutUserInput | ProcessingTemplateCreateOrConnectWithoutUserInput[]
    upsert?: ProcessingTemplateUpsertWithWhereUniqueWithoutUserInput | ProcessingTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessingTemplateCreateManyUserInputEnvelope
    set?: ProcessingTemplateWhereUniqueInput | ProcessingTemplateWhereUniqueInput[]
    disconnect?: ProcessingTemplateWhereUniqueInput | ProcessingTemplateWhereUniqueInput[]
    delete?: ProcessingTemplateWhereUniqueInput | ProcessingTemplateWhereUniqueInput[]
    connect?: ProcessingTemplateWhereUniqueInput | ProcessingTemplateWhereUniqueInput[]
    update?: ProcessingTemplateUpdateWithWhereUniqueWithoutUserInput | ProcessingTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessingTemplateUpdateManyWithWhereWithoutUserInput | ProcessingTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessingTemplateScalarWhereInput | ProcessingTemplateScalarWhereInput[]
  }

  export type CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput = {
    create?: XOR<CustomPlanCreateWithoutRequestedByUserInput, CustomPlanUncheckedCreateWithoutRequestedByUserInput> | CustomPlanCreateWithoutRequestedByUserInput[] | CustomPlanUncheckedCreateWithoutRequestedByUserInput[]
    connectOrCreate?: CustomPlanCreateOrConnectWithoutRequestedByUserInput | CustomPlanCreateOrConnectWithoutRequestedByUserInput[]
    upsert?: CustomPlanUpsertWithWhereUniqueWithoutRequestedByUserInput | CustomPlanUpsertWithWhereUniqueWithoutRequestedByUserInput[]
    createMany?: CustomPlanCreateManyRequestedByUserInputEnvelope
    set?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    disconnect?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    delete?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    connect?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    update?: CustomPlanUpdateWithWhereUniqueWithoutRequestedByUserInput | CustomPlanUpdateWithWhereUniqueWithoutRequestedByUserInput[]
    updateMany?: CustomPlanUpdateManyWithWhereWithoutRequestedByUserInput | CustomPlanUpdateManyWithWhereWithoutRequestedByUserInput[]
    deleteMany?: CustomPlanScalarWhereInput | CustomPlanScalarWhereInput[]
  }

  export type PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlanRecommendationCreateWithoutUserInput, PlanRecommendationUncheckedCreateWithoutUserInput> | PlanRecommendationCreateWithoutUserInput[] | PlanRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanRecommendationCreateOrConnectWithoutUserInput | PlanRecommendationCreateOrConnectWithoutUserInput[]
    upsert?: PlanRecommendationUpsertWithWhereUniqueWithoutUserInput | PlanRecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlanRecommendationCreateManyUserInputEnvelope
    set?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    disconnect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    delete?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    connect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    update?: PlanRecommendationUpdateWithWhereUniqueWithoutUserInput | PlanRecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlanRecommendationUpdateManyWithWhereWithoutUserInput | PlanRecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlanRecommendationScalarWhereInput | PlanRecommendationScalarWhereInput[]
  }

  export type UsageCounterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageCounterCreateWithoutUserInput, UsageCounterUncheckedCreateWithoutUserInput> | UsageCounterCreateWithoutUserInput[] | UsageCounterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageCounterCreateOrConnectWithoutUserInput | UsageCounterCreateOrConnectWithoutUserInput[]
    upsert?: UsageCounterUpsertWithWhereUniqueWithoutUserInput | UsageCounterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageCounterCreateManyUserInputEnvelope
    set?: UsageCounterWhereUniqueInput | UsageCounterWhereUniqueInput[]
    disconnect?: UsageCounterWhereUniqueInput | UsageCounterWhereUniqueInput[]
    delete?: UsageCounterWhereUniqueInput | UsageCounterWhereUniqueInput[]
    connect?: UsageCounterWhereUniqueInput | UsageCounterWhereUniqueInput[]
    update?: UsageCounterUpdateWithWhereUniqueWithoutUserInput | UsageCounterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageCounterUpdateManyWithWhereWithoutUserInput | UsageCounterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageCounterScalarWhereInput | UsageCounterScalarWhereInput[]
  }

  export type EwayCustomerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EwayCustomerCreateWithoutUserInput, EwayCustomerUncheckedCreateWithoutUserInput> | EwayCustomerCreateWithoutUserInput[] | EwayCustomerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EwayCustomerCreateOrConnectWithoutUserInput | EwayCustomerCreateOrConnectWithoutUserInput[]
    upsert?: EwayCustomerUpsertWithWhereUniqueWithoutUserInput | EwayCustomerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EwayCustomerCreateManyUserInputEnvelope
    set?: EwayCustomerWhereUniqueInput | EwayCustomerWhereUniqueInput[]
    disconnect?: EwayCustomerWhereUniqueInput | EwayCustomerWhereUniqueInput[]
    delete?: EwayCustomerWhereUniqueInput | EwayCustomerWhereUniqueInput[]
    connect?: EwayCustomerWhereUniqueInput | EwayCustomerWhereUniqueInput[]
    update?: EwayCustomerUpdateWithWhereUniqueWithoutUserInput | EwayCustomerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EwayCustomerUpdateManyWithWhereWithoutUserInput | EwayCustomerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EwayCustomerScalarWhereInput | EwayCustomerScalarWhereInput[]
  }

  export type EwayTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EwayTransactionCreateWithoutUserInput, EwayTransactionUncheckedCreateWithoutUserInput> | EwayTransactionCreateWithoutUserInput[] | EwayTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EwayTransactionCreateOrConnectWithoutUserInput | EwayTransactionCreateOrConnectWithoutUserInput[]
    upsert?: EwayTransactionUpsertWithWhereUniqueWithoutUserInput | EwayTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EwayTransactionCreateManyUserInputEnvelope
    set?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    disconnect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    delete?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    connect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    update?: EwayTransactionUpdateWithWhereUniqueWithoutUserInput | EwayTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EwayTransactionUpdateManyWithWhereWithoutUserInput | EwayTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EwayTransactionScalarWhereInput | EwayTransactionScalarWhereInput[]
  }

  export type EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EwayRecurringScheduleCreateWithoutUserInput, EwayRecurringScheduleUncheckedCreateWithoutUserInput> | EwayRecurringScheduleCreateWithoutUserInput[] | EwayRecurringScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EwayRecurringScheduleCreateOrConnectWithoutUserInput | EwayRecurringScheduleCreateOrConnectWithoutUserInput[]
    upsert?: EwayRecurringScheduleUpsertWithWhereUniqueWithoutUserInput | EwayRecurringScheduleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EwayRecurringScheduleCreateManyUserInputEnvelope
    set?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    disconnect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    delete?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    connect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    update?: EwayRecurringScheduleUpdateWithWhereUniqueWithoutUserInput | EwayRecurringScheduleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EwayRecurringScheduleUpdateManyWithWhereWithoutUserInput | EwayRecurringScheduleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EwayRecurringScheduleScalarWhereInput | EwayRecurringScheduleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutAssignedByUserInput, UserRoleUncheckedCreateWithoutAssignedByUserInput> | UserRoleCreateWithoutAssignedByUserInput[] | UserRoleUncheckedCreateWithoutAssignedByUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutAssignedByUserInput | UserRoleCreateOrConnectWithoutAssignedByUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutAssignedByUserInput | UserRoleUpsertWithWhereUniqueWithoutAssignedByUserInput[]
    createMany?: UserRoleCreateManyAssignedByUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutAssignedByUserInput | UserRoleUpdateWithWhereUniqueWithoutAssignedByUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutAssignedByUserInput | UserRoleUpdateManyWithWhereWithoutAssignedByUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type TestimonialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput> | TestimonialCreateWithoutUserInput[] | TestimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutUserInput | TestimonialCreateOrConnectWithoutUserInput[]
    upsert?: TestimonialUpsertWithWhereUniqueWithoutUserInput | TestimonialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestimonialCreateManyUserInputEnvelope
    set?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    disconnect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    delete?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    update?: TestimonialUpdateWithWhereUniqueWithoutUserInput | TestimonialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestimonialUpdateManyWithWhereWithoutUserInput | TestimonialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutUsersInput = {
    create?: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUsersInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkspacesInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUsersInput
    upsert?: WorkspaceUpsertWithoutUsersInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutUsersInput, WorkspaceUpdateWithoutUsersInput>, WorkspaceUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutWorkspacesNestedInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    upsert?: UserUpsertWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspacesInput, UserUpdateWithoutWorkspacesInput>, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type WorkspaceCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
    upsert?: WorkspaceUpsertWithoutInvitationsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutInvitationsInput, WorkspaceUpdateWithoutInvitationsInput>, WorkspaceUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutSecurityEventsInput = {
    create?: XOR<UserCreateWithoutSecurityEventsInput, UserUncheckedCreateWithoutSecurityEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutSecurityEventsNestedInput = {
    create?: XOR<UserCreateWithoutSecurityEventsInput, UserUncheckedCreateWithoutSecurityEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityEventsInput
    upsert?: UserUpsertWithoutSecurityEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSecurityEventsInput, UserUpdateWithoutSecurityEventsInput>, UserUncheckedUpdateWithoutSecurityEventsInput>
  }

  export type UserCreateNestedOneWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    upsert?: UserUpsertWithoutSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsInput, UserUpdateWithoutSettingsInput>, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type WorkspaceSettingsCreateallowedFileTypesInput = {
    set: string[]
  }

  export type WorkspaceCreateNestedOneWithoutSettingsInput = {
    create?: XOR<WorkspaceCreateWithoutSettingsInput, WorkspaceUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSettingsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceSettingsUpdateallowedFileTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type WorkspaceUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutSettingsInput, WorkspaceUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSettingsInput
    upsert?: WorkspaceUpsertWithoutSettingsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutSettingsInput, WorkspaceUpdateWithoutSettingsInput>, WorkspaceUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutProcessingTemplatesInput = {
    create?: XOR<UserCreateWithoutProcessingTemplatesInput, UserUncheckedCreateWithoutProcessingTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessingTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProcessingTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutProcessingTemplatesInput, UserUncheckedCreateWithoutProcessingTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessingTemplatesInput
    upsert?: UserUpsertWithoutProcessingTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessingTemplatesInput, UserUpdateWithoutProcessingTemplatesInput>, UserUncheckedUpdateWithoutProcessingTemplatesInput>
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserCreateNestedOneWithoutAudioUploadsInput = {
    create?: XOR<UserCreateWithoutAudioUploadsInput, UserUncheckedCreateWithoutAudioUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudioUploadsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutAudioUploadsInput = {
    create?: XOR<WorkspaceCreateWithoutAudioUploadsInput, WorkspaceUncheckedCreateWithoutAudioUploadsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAudioUploadsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type AudioHistoryCreateNestedManyWithoutUploadInput = {
    create?: XOR<AudioHistoryCreateWithoutUploadInput, AudioHistoryUncheckedCreateWithoutUploadInput> | AudioHistoryCreateWithoutUploadInput[] | AudioHistoryUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutUploadInput | AudioHistoryCreateOrConnectWithoutUploadInput[]
    createMany?: AudioHistoryCreateManyUploadInputEnvelope
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
  }

  export type ProcessingJobCreateNestedManyWithoutUploadInput = {
    create?: XOR<ProcessingJobCreateWithoutUploadInput, ProcessingJobUncheckedCreateWithoutUploadInput> | ProcessingJobCreateWithoutUploadInput[] | ProcessingJobUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutUploadInput | ProcessingJobCreateOrConnectWithoutUploadInput[]
    createMany?: ProcessingJobCreateManyUploadInputEnvelope
    connect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
  }

  export type AudioChunkCreateNestedManyWithoutUploadInput = {
    create?: XOR<AudioChunkCreateWithoutUploadInput, AudioChunkUncheckedCreateWithoutUploadInput> | AudioChunkCreateWithoutUploadInput[] | AudioChunkUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: AudioChunkCreateOrConnectWithoutUploadInput | AudioChunkCreateOrConnectWithoutUploadInput[]
    createMany?: AudioChunkCreateManyUploadInputEnvelope
    connect?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
  }

  export type AudioHistoryUncheckedCreateNestedManyWithoutUploadInput = {
    create?: XOR<AudioHistoryCreateWithoutUploadInput, AudioHistoryUncheckedCreateWithoutUploadInput> | AudioHistoryCreateWithoutUploadInput[] | AudioHistoryUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutUploadInput | AudioHistoryCreateOrConnectWithoutUploadInput[]
    createMany?: AudioHistoryCreateManyUploadInputEnvelope
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
  }

  export type ProcessingJobUncheckedCreateNestedManyWithoutUploadInput = {
    create?: XOR<ProcessingJobCreateWithoutUploadInput, ProcessingJobUncheckedCreateWithoutUploadInput> | ProcessingJobCreateWithoutUploadInput[] | ProcessingJobUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutUploadInput | ProcessingJobCreateOrConnectWithoutUploadInput[]
    createMany?: ProcessingJobCreateManyUploadInputEnvelope
    connect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
  }

  export type AudioChunkUncheckedCreateNestedManyWithoutUploadInput = {
    create?: XOR<AudioChunkCreateWithoutUploadInput, AudioChunkUncheckedCreateWithoutUploadInput> | AudioChunkCreateWithoutUploadInput[] | AudioChunkUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: AudioChunkCreateOrConnectWithoutUploadInput | AudioChunkCreateOrConnectWithoutUploadInput[]
    createMany?: AudioChunkCreateManyUploadInputEnvelope
    connect?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAudioUploadsNestedInput = {
    create?: XOR<UserCreateWithoutAudioUploadsInput, UserUncheckedCreateWithoutAudioUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudioUploadsInput
    upsert?: UserUpsertWithoutAudioUploadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAudioUploadsInput, UserUpdateWithoutAudioUploadsInput>, UserUncheckedUpdateWithoutAudioUploadsInput>
  }

  export type WorkspaceUpdateOneWithoutAudioUploadsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAudioUploadsInput, WorkspaceUncheckedCreateWithoutAudioUploadsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAudioUploadsInput
    upsert?: WorkspaceUpsertWithoutAudioUploadsInput
    disconnect?: WorkspaceWhereInput | boolean
    delete?: WorkspaceWhereInput | boolean
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAudioUploadsInput, WorkspaceUpdateWithoutAudioUploadsInput>, WorkspaceUncheckedUpdateWithoutAudioUploadsInput>
  }

  export type AudioHistoryUpdateManyWithoutUploadNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutUploadInput, AudioHistoryUncheckedCreateWithoutUploadInput> | AudioHistoryCreateWithoutUploadInput[] | AudioHistoryUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutUploadInput | AudioHistoryCreateOrConnectWithoutUploadInput[]
    upsert?: AudioHistoryUpsertWithWhereUniqueWithoutUploadInput | AudioHistoryUpsertWithWhereUniqueWithoutUploadInput[]
    createMany?: AudioHistoryCreateManyUploadInputEnvelope
    set?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    disconnect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    delete?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    update?: AudioHistoryUpdateWithWhereUniqueWithoutUploadInput | AudioHistoryUpdateWithWhereUniqueWithoutUploadInput[]
    updateMany?: AudioHistoryUpdateManyWithWhereWithoutUploadInput | AudioHistoryUpdateManyWithWhereWithoutUploadInput[]
    deleteMany?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
  }

  export type ProcessingJobUpdateManyWithoutUploadNestedInput = {
    create?: XOR<ProcessingJobCreateWithoutUploadInput, ProcessingJobUncheckedCreateWithoutUploadInput> | ProcessingJobCreateWithoutUploadInput[] | ProcessingJobUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutUploadInput | ProcessingJobCreateOrConnectWithoutUploadInput[]
    upsert?: ProcessingJobUpsertWithWhereUniqueWithoutUploadInput | ProcessingJobUpsertWithWhereUniqueWithoutUploadInput[]
    createMany?: ProcessingJobCreateManyUploadInputEnvelope
    set?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    disconnect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    delete?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    connect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    update?: ProcessingJobUpdateWithWhereUniqueWithoutUploadInput | ProcessingJobUpdateWithWhereUniqueWithoutUploadInput[]
    updateMany?: ProcessingJobUpdateManyWithWhereWithoutUploadInput | ProcessingJobUpdateManyWithWhereWithoutUploadInput[]
    deleteMany?: ProcessingJobScalarWhereInput | ProcessingJobScalarWhereInput[]
  }

  export type AudioChunkUpdateManyWithoutUploadNestedInput = {
    create?: XOR<AudioChunkCreateWithoutUploadInput, AudioChunkUncheckedCreateWithoutUploadInput> | AudioChunkCreateWithoutUploadInput[] | AudioChunkUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: AudioChunkCreateOrConnectWithoutUploadInput | AudioChunkCreateOrConnectWithoutUploadInput[]
    upsert?: AudioChunkUpsertWithWhereUniqueWithoutUploadInput | AudioChunkUpsertWithWhereUniqueWithoutUploadInput[]
    createMany?: AudioChunkCreateManyUploadInputEnvelope
    set?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    disconnect?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    delete?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    connect?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    update?: AudioChunkUpdateWithWhereUniqueWithoutUploadInput | AudioChunkUpdateWithWhereUniqueWithoutUploadInput[]
    updateMany?: AudioChunkUpdateManyWithWhereWithoutUploadInput | AudioChunkUpdateManyWithWhereWithoutUploadInput[]
    deleteMany?: AudioChunkScalarWhereInput | AudioChunkScalarWhereInput[]
  }

  export type AudioHistoryUncheckedUpdateManyWithoutUploadNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutUploadInput, AudioHistoryUncheckedCreateWithoutUploadInput> | AudioHistoryCreateWithoutUploadInput[] | AudioHistoryUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutUploadInput | AudioHistoryCreateOrConnectWithoutUploadInput[]
    upsert?: AudioHistoryUpsertWithWhereUniqueWithoutUploadInput | AudioHistoryUpsertWithWhereUniqueWithoutUploadInput[]
    createMany?: AudioHistoryCreateManyUploadInputEnvelope
    set?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    disconnect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    delete?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    update?: AudioHistoryUpdateWithWhereUniqueWithoutUploadInput | AudioHistoryUpdateWithWhereUniqueWithoutUploadInput[]
    updateMany?: AudioHistoryUpdateManyWithWhereWithoutUploadInput | AudioHistoryUpdateManyWithWhereWithoutUploadInput[]
    deleteMany?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
  }

  export type ProcessingJobUncheckedUpdateManyWithoutUploadNestedInput = {
    create?: XOR<ProcessingJobCreateWithoutUploadInput, ProcessingJobUncheckedCreateWithoutUploadInput> | ProcessingJobCreateWithoutUploadInput[] | ProcessingJobUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutUploadInput | ProcessingJobCreateOrConnectWithoutUploadInput[]
    upsert?: ProcessingJobUpsertWithWhereUniqueWithoutUploadInput | ProcessingJobUpsertWithWhereUniqueWithoutUploadInput[]
    createMany?: ProcessingJobCreateManyUploadInputEnvelope
    set?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    disconnect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    delete?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    connect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    update?: ProcessingJobUpdateWithWhereUniqueWithoutUploadInput | ProcessingJobUpdateWithWhereUniqueWithoutUploadInput[]
    updateMany?: ProcessingJobUpdateManyWithWhereWithoutUploadInput | ProcessingJobUpdateManyWithWhereWithoutUploadInput[]
    deleteMany?: ProcessingJobScalarWhereInput | ProcessingJobScalarWhereInput[]
  }

  export type AudioChunkUncheckedUpdateManyWithoutUploadNestedInput = {
    create?: XOR<AudioChunkCreateWithoutUploadInput, AudioChunkUncheckedCreateWithoutUploadInput> | AudioChunkCreateWithoutUploadInput[] | AudioChunkUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: AudioChunkCreateOrConnectWithoutUploadInput | AudioChunkCreateOrConnectWithoutUploadInput[]
    upsert?: AudioChunkUpsertWithWhereUniqueWithoutUploadInput | AudioChunkUpsertWithWhereUniqueWithoutUploadInput[]
    createMany?: AudioChunkCreateManyUploadInputEnvelope
    set?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    disconnect?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    delete?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    connect?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    update?: AudioChunkUpdateWithWhereUniqueWithoutUploadInput | AudioChunkUpdateWithWhereUniqueWithoutUploadInput[]
    updateMany?: AudioChunkUpdateManyWithWhereWithoutUploadInput | AudioChunkUpdateManyWithWhereWithoutUploadInput[]
    deleteMany?: AudioChunkScalarWhereInput | AudioChunkScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProcessingJobsInput = {
    create?: XOR<UserCreateWithoutProcessingJobsInput, UserUncheckedCreateWithoutProcessingJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessingJobsInput
    connect?: UserWhereUniqueInput
  }

  export type AudioUploadCreateNestedOneWithoutProcessingJobsInput = {
    create?: XOR<AudioUploadCreateWithoutProcessingJobsInput, AudioUploadUncheckedCreateWithoutProcessingJobsInput>
    connectOrCreate?: AudioUploadCreateOrConnectWithoutProcessingJobsInput
    connect?: AudioUploadWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneRequiredWithoutProcessingJobsNestedInput = {
    create?: XOR<UserCreateWithoutProcessingJobsInput, UserUncheckedCreateWithoutProcessingJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessingJobsInput
    upsert?: UserUpsertWithoutProcessingJobsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessingJobsInput, UserUpdateWithoutProcessingJobsInput>, UserUncheckedUpdateWithoutProcessingJobsInput>
  }

  export type AudioUploadUpdateOneRequiredWithoutProcessingJobsNestedInput = {
    create?: XOR<AudioUploadCreateWithoutProcessingJobsInput, AudioUploadUncheckedCreateWithoutProcessingJobsInput>
    connectOrCreate?: AudioUploadCreateOrConnectWithoutProcessingJobsInput
    upsert?: AudioUploadUpsertWithoutProcessingJobsInput
    connect?: AudioUploadWhereUniqueInput
    update?: XOR<XOR<AudioUploadUpdateToOneWithWhereWithoutProcessingJobsInput, AudioUploadUpdateWithoutProcessingJobsInput>, AudioUploadUncheckedUpdateWithoutProcessingJobsInput>
  }

  export type UserCreateNestedOneWithoutAudioHistoryInput = {
    create?: XOR<UserCreateWithoutAudioHistoryInput, UserUncheckedCreateWithoutAudioHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudioHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutAudioHistoryInput = {
    create?: XOR<WorkspaceCreateWithoutAudioHistoryInput, WorkspaceUncheckedCreateWithoutAudioHistoryInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAudioHistoryInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type AudioUploadCreateNestedOneWithoutAudioHistoryInput = {
    create?: XOR<AudioUploadCreateWithoutAudioHistoryInput, AudioUploadUncheckedCreateWithoutAudioHistoryInput>
    connectOrCreate?: AudioUploadCreateOrConnectWithoutAudioHistoryInput
    connect?: AudioUploadWhereUniqueInput
  }

  export type AudioSegmentCreateNestedManyWithoutHistoryInput = {
    create?: XOR<AudioSegmentCreateWithoutHistoryInput, AudioSegmentUncheckedCreateWithoutHistoryInput> | AudioSegmentCreateWithoutHistoryInput[] | AudioSegmentUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: AudioSegmentCreateOrConnectWithoutHistoryInput | AudioSegmentCreateOrConnectWithoutHistoryInput[]
    createMany?: AudioSegmentCreateManyHistoryInputEnvelope
    connect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
  }

  export type AudioSegmentUncheckedCreateNestedManyWithoutHistoryInput = {
    create?: XOR<AudioSegmentCreateWithoutHistoryInput, AudioSegmentUncheckedCreateWithoutHistoryInput> | AudioSegmentCreateWithoutHistoryInput[] | AudioSegmentUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: AudioSegmentCreateOrConnectWithoutHistoryInput | AudioSegmentCreateOrConnectWithoutHistoryInput[]
    createMany?: AudioSegmentCreateManyHistoryInputEnvelope
    connect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutAudioHistoryNestedInput = {
    create?: XOR<UserCreateWithoutAudioHistoryInput, UserUncheckedCreateWithoutAudioHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudioHistoryInput
    upsert?: UserUpsertWithoutAudioHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAudioHistoryInput, UserUpdateWithoutAudioHistoryInput>, UserUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type WorkspaceUpdateOneWithoutAudioHistoryNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAudioHistoryInput, WorkspaceUncheckedCreateWithoutAudioHistoryInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAudioHistoryInput
    upsert?: WorkspaceUpsertWithoutAudioHistoryInput
    disconnect?: WorkspaceWhereInput | boolean
    delete?: WorkspaceWhereInput | boolean
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAudioHistoryInput, WorkspaceUpdateWithoutAudioHistoryInput>, WorkspaceUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type AudioUploadUpdateOneWithoutAudioHistoryNestedInput = {
    create?: XOR<AudioUploadCreateWithoutAudioHistoryInput, AudioUploadUncheckedCreateWithoutAudioHistoryInput>
    connectOrCreate?: AudioUploadCreateOrConnectWithoutAudioHistoryInput
    upsert?: AudioUploadUpsertWithoutAudioHistoryInput
    disconnect?: AudioUploadWhereInput | boolean
    delete?: AudioUploadWhereInput | boolean
    connect?: AudioUploadWhereUniqueInput
    update?: XOR<XOR<AudioUploadUpdateToOneWithWhereWithoutAudioHistoryInput, AudioUploadUpdateWithoutAudioHistoryInput>, AudioUploadUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type AudioSegmentUpdateManyWithoutHistoryNestedInput = {
    create?: XOR<AudioSegmentCreateWithoutHistoryInput, AudioSegmentUncheckedCreateWithoutHistoryInput> | AudioSegmentCreateWithoutHistoryInput[] | AudioSegmentUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: AudioSegmentCreateOrConnectWithoutHistoryInput | AudioSegmentCreateOrConnectWithoutHistoryInput[]
    upsert?: AudioSegmentUpsertWithWhereUniqueWithoutHistoryInput | AudioSegmentUpsertWithWhereUniqueWithoutHistoryInput[]
    createMany?: AudioSegmentCreateManyHistoryInputEnvelope
    set?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    disconnect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    delete?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    connect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    update?: AudioSegmentUpdateWithWhereUniqueWithoutHistoryInput | AudioSegmentUpdateWithWhereUniqueWithoutHistoryInput[]
    updateMany?: AudioSegmentUpdateManyWithWhereWithoutHistoryInput | AudioSegmentUpdateManyWithWhereWithoutHistoryInput[]
    deleteMany?: AudioSegmentScalarWhereInput | AudioSegmentScalarWhereInput[]
  }

  export type AudioSegmentUncheckedUpdateManyWithoutHistoryNestedInput = {
    create?: XOR<AudioSegmentCreateWithoutHistoryInput, AudioSegmentUncheckedCreateWithoutHistoryInput> | AudioSegmentCreateWithoutHistoryInput[] | AudioSegmentUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: AudioSegmentCreateOrConnectWithoutHistoryInput | AudioSegmentCreateOrConnectWithoutHistoryInput[]
    upsert?: AudioSegmentUpsertWithWhereUniqueWithoutHistoryInput | AudioSegmentUpsertWithWhereUniqueWithoutHistoryInput[]
    createMany?: AudioSegmentCreateManyHistoryInputEnvelope
    set?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    disconnect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    delete?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    connect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    update?: AudioSegmentUpdateWithWhereUniqueWithoutHistoryInput | AudioSegmentUpdateWithWhereUniqueWithoutHistoryInput[]
    updateMany?: AudioSegmentUpdateManyWithWhereWithoutHistoryInput | AudioSegmentUpdateManyWithWhereWithoutHistoryInput[]
    deleteMany?: AudioSegmentScalarWhereInput | AudioSegmentScalarWhereInput[]
  }

  export type AudioSegmentCreatetokensInput = {
    set: number[]
  }

  export type AudioSegmentCreatelogprobsInput = {
    set: number[]
  }

  export type AudioHistoryCreateNestedOneWithoutSegmentsInput = {
    create?: XOR<AudioHistoryCreateWithoutSegmentsInput, AudioHistoryUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutSegmentsInput
    connect?: AudioHistoryWhereUniqueInput
  }

  export type AudioSegmentUpdatetokensInput = {
    set?: number[]
    push?: number | number[]
  }

  export type AudioSegmentUpdatelogprobsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type AudioHistoryUpdateOneRequiredWithoutSegmentsNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutSegmentsInput, AudioHistoryUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutSegmentsInput
    upsert?: AudioHistoryUpsertWithoutSegmentsInput
    connect?: AudioHistoryWhereUniqueInput
    update?: XOR<XOR<AudioHistoryUpdateToOneWithWhereWithoutSegmentsInput, AudioHistoryUpdateWithoutSegmentsInput>, AudioHistoryUncheckedUpdateWithoutSegmentsInput>
  }

  export type AudioUploadCreateNestedOneWithoutAudioChunksInput = {
    create?: XOR<AudioUploadCreateWithoutAudioChunksInput, AudioUploadUncheckedCreateWithoutAudioChunksInput>
    connectOrCreate?: AudioUploadCreateOrConnectWithoutAudioChunksInput
    connect?: AudioUploadWhereUniqueInput
  }

  export type AudioUploadUpdateOneRequiredWithoutAudioChunksNestedInput = {
    create?: XOR<AudioUploadCreateWithoutAudioChunksInput, AudioUploadUncheckedCreateWithoutAudioChunksInput>
    connectOrCreate?: AudioUploadCreateOrConnectWithoutAudioChunksInput
    upsert?: AudioUploadUpsertWithoutAudioChunksInput
    connect?: AudioUploadWhereUniqueInput
    update?: XOR<XOR<AudioUploadUpdateToOneWithWhereWithoutAudioChunksInput, AudioUploadUpdateWithoutAudioChunksInput>, AudioUploadUncheckedUpdateWithoutAudioChunksInput>
  }

  export type AudioProjectCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutProjectsInput = {
    create?: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type AudioProjectUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type WorkspaceUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectsInput
    upsert?: WorkspaceUpsertWithoutProjectsInput
    disconnect?: WorkspaceWhereInput | boolean
    delete?: WorkspaceWhereInput | boolean
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutProjectsInput, WorkspaceUpdateWithoutProjectsInput>, WorkspaceUncheckedUpdateWithoutProjectsInput>
  }

  export type UserCreateNestedOneWithoutUsageMetricsInput = {
    create?: XOR<UserCreateWithoutUsageMetricsInput, UserUncheckedCreateWithoutUsageMetricsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageMetricsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutUsageMetricsInput = {
    create?: XOR<WorkspaceCreateWithoutUsageMetricsInput, WorkspaceUncheckedCreateWithoutUsageMetricsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUsageMetricsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsageMetricsNestedInput = {
    create?: XOR<UserCreateWithoutUsageMetricsInput, UserUncheckedCreateWithoutUsageMetricsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageMetricsInput
    upsert?: UserUpsertWithoutUsageMetricsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsageMetricsInput, UserUpdateWithoutUsageMetricsInput>, UserUncheckedUpdateWithoutUsageMetricsInput>
  }

  export type WorkspaceUpdateOneWithoutUsageMetricsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutUsageMetricsInput, WorkspaceUncheckedCreateWithoutUsageMetricsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUsageMetricsInput
    upsert?: WorkspaceUpsertWithoutUsageMetricsInput
    disconnect?: WorkspaceWhereInput | boolean
    delete?: WorkspaceWhereInput | boolean
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutUsageMetricsInput, WorkspaceUpdateWithoutUsageMetricsInput>, WorkspaceUncheckedUpdateWithoutUsageMetricsInput>
  }

  export type UserCreateNestedOneWithoutQuotaInput = {
    create?: XOR<UserCreateWithoutQuotaInput, UserUncheckedCreateWithoutQuotaInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuotaInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutQuotaNestedInput = {
    create?: XOR<UserCreateWithoutQuotaInput, UserUncheckedCreateWithoutQuotaInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuotaInput
    upsert?: UserUpsertWithoutQuotaInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuotaInput, UserUpdateWithoutQuotaInput>, UserUncheckedUpdateWithoutQuotaInput>
  }

  export type WorkspaceCreateNestedOneWithoutStorageQuotaInput = {
    create?: XOR<WorkspaceCreateWithoutStorageQuotaInput, WorkspaceUncheckedCreateWithoutStorageQuotaInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutStorageQuotaInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutStorageQuotaNestedInput = {
    create?: XOR<WorkspaceCreateWithoutStorageQuotaInput, WorkspaceUncheckedCreateWithoutStorageQuotaInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutStorageQuotaInput
    upsert?: WorkspaceUpsertWithoutStorageQuotaInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutStorageQuotaInput, WorkspaceUpdateWithoutStorageQuotaInput>, WorkspaceUncheckedUpdateWithoutStorageQuotaInput>
  }

  export type SubscriptionPlanCreaterecommendedForInput = {
    set: string[]
  }

  export type SubscriptionPlanCreateallowedFileTypesInput = {
    set: string[]
  }

  export type SubscriptionPlanCreateanalysisFeaturesInput = {
    set: string[]
  }

  export type SubscriptionPlanCreatecollaborationFeaturesInput = {
    set: string[]
  }

  export type SubscriptionPlanCreateintegrationFeaturesInput = {
    set: string[]
  }

  export type WorkspaceSubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutPlanInput, WorkspaceSubscriptionUncheckedCreateWithoutPlanInput> | WorkspaceSubscriptionCreateWithoutPlanInput[] | WorkspaceSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutPlanInput | WorkspaceSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: WorkspaceSubscriptionCreateManyPlanInputEnvelope
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
  }

  export type PlanPricingCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanPricingCreateWithoutPlanInput, PlanPricingUncheckedCreateWithoutPlanInput> | PlanPricingCreateWithoutPlanInput[] | PlanPricingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPricingCreateOrConnectWithoutPlanInput | PlanPricingCreateOrConnectWithoutPlanInput[]
    createMany?: PlanPricingCreateManyPlanInputEnvelope
    connect?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
  }

  export type PlanFeatureMatrixCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanFeatureMatrixCreateWithoutPlanInput, PlanFeatureMatrixUncheckedCreateWithoutPlanInput> | PlanFeatureMatrixCreateWithoutPlanInput[] | PlanFeatureMatrixUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanFeatureMatrixCreateOrConnectWithoutPlanInput | PlanFeatureMatrixCreateOrConnectWithoutPlanInput[]
    createMany?: PlanFeatureMatrixCreateManyPlanInputEnvelope
    connect?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
  }

  export type PlanRecommendationCreateNestedManyWithoutCurrentPlanInput = {
    create?: XOR<PlanRecommendationCreateWithoutCurrentPlanInput, PlanRecommendationUncheckedCreateWithoutCurrentPlanInput> | PlanRecommendationCreateWithoutCurrentPlanInput[] | PlanRecommendationUncheckedCreateWithoutCurrentPlanInput[]
    connectOrCreate?: PlanRecommendationCreateOrConnectWithoutCurrentPlanInput | PlanRecommendationCreateOrConnectWithoutCurrentPlanInput[]
    createMany?: PlanRecommendationCreateManyCurrentPlanInputEnvelope
    connect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
  }

  export type PlanRecommendationCreateNestedManyWithoutRecommendedPlanInput = {
    create?: XOR<PlanRecommendationCreateWithoutRecommendedPlanInput, PlanRecommendationUncheckedCreateWithoutRecommendedPlanInput> | PlanRecommendationCreateWithoutRecommendedPlanInput[] | PlanRecommendationUncheckedCreateWithoutRecommendedPlanInput[]
    connectOrCreate?: PlanRecommendationCreateOrConnectWithoutRecommendedPlanInput | PlanRecommendationCreateOrConnectWithoutRecommendedPlanInput[]
    createMany?: PlanRecommendationCreateManyRecommendedPlanInputEnvelope
    connect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
  }

  export type CustomPlanCreateNestedManyWithoutBasePlanInput = {
    create?: XOR<CustomPlanCreateWithoutBasePlanInput, CustomPlanUncheckedCreateWithoutBasePlanInput> | CustomPlanCreateWithoutBasePlanInput[] | CustomPlanUncheckedCreateWithoutBasePlanInput[]
    connectOrCreate?: CustomPlanCreateOrConnectWithoutBasePlanInput | CustomPlanCreateOrConnectWithoutBasePlanInput[]
    createMany?: CustomPlanCreateManyBasePlanInputEnvelope
    connect?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
  }

  export type WorkspaceSubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutPlanInput, WorkspaceSubscriptionUncheckedCreateWithoutPlanInput> | WorkspaceSubscriptionCreateWithoutPlanInput[] | WorkspaceSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutPlanInput | WorkspaceSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: WorkspaceSubscriptionCreateManyPlanInputEnvelope
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
  }

  export type PlanPricingUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanPricingCreateWithoutPlanInput, PlanPricingUncheckedCreateWithoutPlanInput> | PlanPricingCreateWithoutPlanInput[] | PlanPricingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPricingCreateOrConnectWithoutPlanInput | PlanPricingCreateOrConnectWithoutPlanInput[]
    createMany?: PlanPricingCreateManyPlanInputEnvelope
    connect?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
  }

  export type PlanFeatureMatrixUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanFeatureMatrixCreateWithoutPlanInput, PlanFeatureMatrixUncheckedCreateWithoutPlanInput> | PlanFeatureMatrixCreateWithoutPlanInput[] | PlanFeatureMatrixUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanFeatureMatrixCreateOrConnectWithoutPlanInput | PlanFeatureMatrixCreateOrConnectWithoutPlanInput[]
    createMany?: PlanFeatureMatrixCreateManyPlanInputEnvelope
    connect?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
  }

  export type PlanRecommendationUncheckedCreateNestedManyWithoutCurrentPlanInput = {
    create?: XOR<PlanRecommendationCreateWithoutCurrentPlanInput, PlanRecommendationUncheckedCreateWithoutCurrentPlanInput> | PlanRecommendationCreateWithoutCurrentPlanInput[] | PlanRecommendationUncheckedCreateWithoutCurrentPlanInput[]
    connectOrCreate?: PlanRecommendationCreateOrConnectWithoutCurrentPlanInput | PlanRecommendationCreateOrConnectWithoutCurrentPlanInput[]
    createMany?: PlanRecommendationCreateManyCurrentPlanInputEnvelope
    connect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
  }

  export type PlanRecommendationUncheckedCreateNestedManyWithoutRecommendedPlanInput = {
    create?: XOR<PlanRecommendationCreateWithoutRecommendedPlanInput, PlanRecommendationUncheckedCreateWithoutRecommendedPlanInput> | PlanRecommendationCreateWithoutRecommendedPlanInput[] | PlanRecommendationUncheckedCreateWithoutRecommendedPlanInput[]
    connectOrCreate?: PlanRecommendationCreateOrConnectWithoutRecommendedPlanInput | PlanRecommendationCreateOrConnectWithoutRecommendedPlanInput[]
    createMany?: PlanRecommendationCreateManyRecommendedPlanInputEnvelope
    connect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
  }

  export type CustomPlanUncheckedCreateNestedManyWithoutBasePlanInput = {
    create?: XOR<CustomPlanCreateWithoutBasePlanInput, CustomPlanUncheckedCreateWithoutBasePlanInput> | CustomPlanCreateWithoutBasePlanInput[] | CustomPlanUncheckedCreateWithoutBasePlanInput[]
    connectOrCreate?: CustomPlanCreateOrConnectWithoutBasePlanInput | CustomPlanCreateOrConnectWithoutBasePlanInput[]
    createMany?: CustomPlanCreateManyBasePlanInputEnvelope
    connect?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
  }

  export type SubscriptionPlanUpdaterecommendedForInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SubscriptionPlanUpdateallowedFileTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SubscriptionPlanUpdateanalysisFeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SubscriptionPlanUpdatecollaborationFeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SubscriptionPlanUpdateintegrationFeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WorkspaceSubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutPlanInput, WorkspaceSubscriptionUncheckedCreateWithoutPlanInput> | WorkspaceSubscriptionCreateWithoutPlanInput[] | WorkspaceSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutPlanInput | WorkspaceSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: WorkspaceSubscriptionUpsertWithWhereUniqueWithoutPlanInput | WorkspaceSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: WorkspaceSubscriptionCreateManyPlanInputEnvelope
    set?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    disconnect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    delete?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    update?: WorkspaceSubscriptionUpdateWithWhereUniqueWithoutPlanInput | WorkspaceSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: WorkspaceSubscriptionUpdateManyWithWhereWithoutPlanInput | WorkspaceSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: WorkspaceSubscriptionScalarWhereInput | WorkspaceSubscriptionScalarWhereInput[]
  }

  export type PlanPricingUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanPricingCreateWithoutPlanInput, PlanPricingUncheckedCreateWithoutPlanInput> | PlanPricingCreateWithoutPlanInput[] | PlanPricingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPricingCreateOrConnectWithoutPlanInput | PlanPricingCreateOrConnectWithoutPlanInput[]
    upsert?: PlanPricingUpsertWithWhereUniqueWithoutPlanInput | PlanPricingUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanPricingCreateManyPlanInputEnvelope
    set?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    disconnect?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    delete?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    connect?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    update?: PlanPricingUpdateWithWhereUniqueWithoutPlanInput | PlanPricingUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanPricingUpdateManyWithWhereWithoutPlanInput | PlanPricingUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanPricingScalarWhereInput | PlanPricingScalarWhereInput[]
  }

  export type PlanFeatureMatrixUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanFeatureMatrixCreateWithoutPlanInput, PlanFeatureMatrixUncheckedCreateWithoutPlanInput> | PlanFeatureMatrixCreateWithoutPlanInput[] | PlanFeatureMatrixUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanFeatureMatrixCreateOrConnectWithoutPlanInput | PlanFeatureMatrixCreateOrConnectWithoutPlanInput[]
    upsert?: PlanFeatureMatrixUpsertWithWhereUniqueWithoutPlanInput | PlanFeatureMatrixUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanFeatureMatrixCreateManyPlanInputEnvelope
    set?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    disconnect?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    delete?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    connect?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    update?: PlanFeatureMatrixUpdateWithWhereUniqueWithoutPlanInput | PlanFeatureMatrixUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanFeatureMatrixUpdateManyWithWhereWithoutPlanInput | PlanFeatureMatrixUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanFeatureMatrixScalarWhereInput | PlanFeatureMatrixScalarWhereInput[]
  }

  export type PlanRecommendationUpdateManyWithoutCurrentPlanNestedInput = {
    create?: XOR<PlanRecommendationCreateWithoutCurrentPlanInput, PlanRecommendationUncheckedCreateWithoutCurrentPlanInput> | PlanRecommendationCreateWithoutCurrentPlanInput[] | PlanRecommendationUncheckedCreateWithoutCurrentPlanInput[]
    connectOrCreate?: PlanRecommendationCreateOrConnectWithoutCurrentPlanInput | PlanRecommendationCreateOrConnectWithoutCurrentPlanInput[]
    upsert?: PlanRecommendationUpsertWithWhereUniqueWithoutCurrentPlanInput | PlanRecommendationUpsertWithWhereUniqueWithoutCurrentPlanInput[]
    createMany?: PlanRecommendationCreateManyCurrentPlanInputEnvelope
    set?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    disconnect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    delete?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    connect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    update?: PlanRecommendationUpdateWithWhereUniqueWithoutCurrentPlanInput | PlanRecommendationUpdateWithWhereUniqueWithoutCurrentPlanInput[]
    updateMany?: PlanRecommendationUpdateManyWithWhereWithoutCurrentPlanInput | PlanRecommendationUpdateManyWithWhereWithoutCurrentPlanInput[]
    deleteMany?: PlanRecommendationScalarWhereInput | PlanRecommendationScalarWhereInput[]
  }

  export type PlanRecommendationUpdateManyWithoutRecommendedPlanNestedInput = {
    create?: XOR<PlanRecommendationCreateWithoutRecommendedPlanInput, PlanRecommendationUncheckedCreateWithoutRecommendedPlanInput> | PlanRecommendationCreateWithoutRecommendedPlanInput[] | PlanRecommendationUncheckedCreateWithoutRecommendedPlanInput[]
    connectOrCreate?: PlanRecommendationCreateOrConnectWithoutRecommendedPlanInput | PlanRecommendationCreateOrConnectWithoutRecommendedPlanInput[]
    upsert?: PlanRecommendationUpsertWithWhereUniqueWithoutRecommendedPlanInput | PlanRecommendationUpsertWithWhereUniqueWithoutRecommendedPlanInput[]
    createMany?: PlanRecommendationCreateManyRecommendedPlanInputEnvelope
    set?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    disconnect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    delete?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    connect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    update?: PlanRecommendationUpdateWithWhereUniqueWithoutRecommendedPlanInput | PlanRecommendationUpdateWithWhereUniqueWithoutRecommendedPlanInput[]
    updateMany?: PlanRecommendationUpdateManyWithWhereWithoutRecommendedPlanInput | PlanRecommendationUpdateManyWithWhereWithoutRecommendedPlanInput[]
    deleteMany?: PlanRecommendationScalarWhereInput | PlanRecommendationScalarWhereInput[]
  }

  export type CustomPlanUpdateManyWithoutBasePlanNestedInput = {
    create?: XOR<CustomPlanCreateWithoutBasePlanInput, CustomPlanUncheckedCreateWithoutBasePlanInput> | CustomPlanCreateWithoutBasePlanInput[] | CustomPlanUncheckedCreateWithoutBasePlanInput[]
    connectOrCreate?: CustomPlanCreateOrConnectWithoutBasePlanInput | CustomPlanCreateOrConnectWithoutBasePlanInput[]
    upsert?: CustomPlanUpsertWithWhereUniqueWithoutBasePlanInput | CustomPlanUpsertWithWhereUniqueWithoutBasePlanInput[]
    createMany?: CustomPlanCreateManyBasePlanInputEnvelope
    set?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    disconnect?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    delete?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    connect?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    update?: CustomPlanUpdateWithWhereUniqueWithoutBasePlanInput | CustomPlanUpdateWithWhereUniqueWithoutBasePlanInput[]
    updateMany?: CustomPlanUpdateManyWithWhereWithoutBasePlanInput | CustomPlanUpdateManyWithWhereWithoutBasePlanInput[]
    deleteMany?: CustomPlanScalarWhereInput | CustomPlanScalarWhereInput[]
  }

  export type WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutPlanInput, WorkspaceSubscriptionUncheckedCreateWithoutPlanInput> | WorkspaceSubscriptionCreateWithoutPlanInput[] | WorkspaceSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutPlanInput | WorkspaceSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: WorkspaceSubscriptionUpsertWithWhereUniqueWithoutPlanInput | WorkspaceSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: WorkspaceSubscriptionCreateManyPlanInputEnvelope
    set?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    disconnect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    delete?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    update?: WorkspaceSubscriptionUpdateWithWhereUniqueWithoutPlanInput | WorkspaceSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: WorkspaceSubscriptionUpdateManyWithWhereWithoutPlanInput | WorkspaceSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: WorkspaceSubscriptionScalarWhereInput | WorkspaceSubscriptionScalarWhereInput[]
  }

  export type PlanPricingUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanPricingCreateWithoutPlanInput, PlanPricingUncheckedCreateWithoutPlanInput> | PlanPricingCreateWithoutPlanInput[] | PlanPricingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPricingCreateOrConnectWithoutPlanInput | PlanPricingCreateOrConnectWithoutPlanInput[]
    upsert?: PlanPricingUpsertWithWhereUniqueWithoutPlanInput | PlanPricingUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanPricingCreateManyPlanInputEnvelope
    set?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    disconnect?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    delete?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    connect?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    update?: PlanPricingUpdateWithWhereUniqueWithoutPlanInput | PlanPricingUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanPricingUpdateManyWithWhereWithoutPlanInput | PlanPricingUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanPricingScalarWhereInput | PlanPricingScalarWhereInput[]
  }

  export type PlanFeatureMatrixUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanFeatureMatrixCreateWithoutPlanInput, PlanFeatureMatrixUncheckedCreateWithoutPlanInput> | PlanFeatureMatrixCreateWithoutPlanInput[] | PlanFeatureMatrixUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanFeatureMatrixCreateOrConnectWithoutPlanInput | PlanFeatureMatrixCreateOrConnectWithoutPlanInput[]
    upsert?: PlanFeatureMatrixUpsertWithWhereUniqueWithoutPlanInput | PlanFeatureMatrixUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanFeatureMatrixCreateManyPlanInputEnvelope
    set?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    disconnect?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    delete?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    connect?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    update?: PlanFeatureMatrixUpdateWithWhereUniqueWithoutPlanInput | PlanFeatureMatrixUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanFeatureMatrixUpdateManyWithWhereWithoutPlanInput | PlanFeatureMatrixUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanFeatureMatrixScalarWhereInput | PlanFeatureMatrixScalarWhereInput[]
  }

  export type PlanRecommendationUncheckedUpdateManyWithoutCurrentPlanNestedInput = {
    create?: XOR<PlanRecommendationCreateWithoutCurrentPlanInput, PlanRecommendationUncheckedCreateWithoutCurrentPlanInput> | PlanRecommendationCreateWithoutCurrentPlanInput[] | PlanRecommendationUncheckedCreateWithoutCurrentPlanInput[]
    connectOrCreate?: PlanRecommendationCreateOrConnectWithoutCurrentPlanInput | PlanRecommendationCreateOrConnectWithoutCurrentPlanInput[]
    upsert?: PlanRecommendationUpsertWithWhereUniqueWithoutCurrentPlanInput | PlanRecommendationUpsertWithWhereUniqueWithoutCurrentPlanInput[]
    createMany?: PlanRecommendationCreateManyCurrentPlanInputEnvelope
    set?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    disconnect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    delete?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    connect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    update?: PlanRecommendationUpdateWithWhereUniqueWithoutCurrentPlanInput | PlanRecommendationUpdateWithWhereUniqueWithoutCurrentPlanInput[]
    updateMany?: PlanRecommendationUpdateManyWithWhereWithoutCurrentPlanInput | PlanRecommendationUpdateManyWithWhereWithoutCurrentPlanInput[]
    deleteMany?: PlanRecommendationScalarWhereInput | PlanRecommendationScalarWhereInput[]
  }

  export type PlanRecommendationUncheckedUpdateManyWithoutRecommendedPlanNestedInput = {
    create?: XOR<PlanRecommendationCreateWithoutRecommendedPlanInput, PlanRecommendationUncheckedCreateWithoutRecommendedPlanInput> | PlanRecommendationCreateWithoutRecommendedPlanInput[] | PlanRecommendationUncheckedCreateWithoutRecommendedPlanInput[]
    connectOrCreate?: PlanRecommendationCreateOrConnectWithoutRecommendedPlanInput | PlanRecommendationCreateOrConnectWithoutRecommendedPlanInput[]
    upsert?: PlanRecommendationUpsertWithWhereUniqueWithoutRecommendedPlanInput | PlanRecommendationUpsertWithWhereUniqueWithoutRecommendedPlanInput[]
    createMany?: PlanRecommendationCreateManyRecommendedPlanInputEnvelope
    set?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    disconnect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    delete?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    connect?: PlanRecommendationWhereUniqueInput | PlanRecommendationWhereUniqueInput[]
    update?: PlanRecommendationUpdateWithWhereUniqueWithoutRecommendedPlanInput | PlanRecommendationUpdateWithWhereUniqueWithoutRecommendedPlanInput[]
    updateMany?: PlanRecommendationUpdateManyWithWhereWithoutRecommendedPlanInput | PlanRecommendationUpdateManyWithWhereWithoutRecommendedPlanInput[]
    deleteMany?: PlanRecommendationScalarWhereInput | PlanRecommendationScalarWhereInput[]
  }

  export type CustomPlanUncheckedUpdateManyWithoutBasePlanNestedInput = {
    create?: XOR<CustomPlanCreateWithoutBasePlanInput, CustomPlanUncheckedCreateWithoutBasePlanInput> | CustomPlanCreateWithoutBasePlanInput[] | CustomPlanUncheckedCreateWithoutBasePlanInput[]
    connectOrCreate?: CustomPlanCreateOrConnectWithoutBasePlanInput | CustomPlanCreateOrConnectWithoutBasePlanInput[]
    upsert?: CustomPlanUpsertWithWhereUniqueWithoutBasePlanInput | CustomPlanUpsertWithWhereUniqueWithoutBasePlanInput[]
    createMany?: CustomPlanCreateManyBasePlanInputEnvelope
    set?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    disconnect?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    delete?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    connect?: CustomPlanWhereUniqueInput | CustomPlanWhereUniqueInput[]
    update?: CustomPlanUpdateWithWhereUniqueWithoutBasePlanInput | CustomPlanUpdateWithWhereUniqueWithoutBasePlanInput[]
    updateMany?: CustomPlanUpdateManyWithWhereWithoutBasePlanInput | CustomPlanUpdateManyWithWhereWithoutBasePlanInput[]
    deleteMany?: CustomPlanScalarWhereInput | CustomPlanScalarWhereInput[]
  }

  export type SubscriptionPlanCreateNestedOneWithoutPlanPricingInput = {
    create?: XOR<SubscriptionPlanCreateWithoutPlanPricingInput, SubscriptionPlanUncheckedCreateWithoutPlanPricingInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutPlanPricingInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutPlanPricingNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutPlanPricingInput, SubscriptionPlanUncheckedCreateWithoutPlanPricingInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutPlanPricingInput
    upsert?: SubscriptionPlanUpsertWithoutPlanPricingInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutPlanPricingInput, SubscriptionPlanUpdateWithoutPlanPricingInput>, SubscriptionPlanUncheckedUpdateWithoutPlanPricingInput>
  }

  export type WorkspaceCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<WorkspaceCreateWithoutSubscriptionsInput, WorkspaceUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSubscriptionsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type BillingRecordCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<BillingRecordCreateWithoutSubscriptionInput, BillingRecordUncheckedCreateWithoutSubscriptionInput> | BillingRecordCreateWithoutSubscriptionInput[] | BillingRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BillingRecordCreateOrConnectWithoutSubscriptionInput | BillingRecordCreateOrConnectWithoutSubscriptionInput[]
    createMany?: BillingRecordCreateManySubscriptionInputEnvelope
    connect?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
  }

  export type UsageRecordCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
  }

  export type BillingRecordUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<BillingRecordCreateWithoutSubscriptionInput, BillingRecordUncheckedCreateWithoutSubscriptionInput> | BillingRecordCreateWithoutSubscriptionInput[] | BillingRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BillingRecordCreateOrConnectWithoutSubscriptionInput | BillingRecordCreateOrConnectWithoutSubscriptionInput[]
    createMany?: BillingRecordCreateManySubscriptionInputEnvelope
    connect?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
  }

  export type UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutSubscriptionsInput, WorkspaceUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSubscriptionsInput
    upsert?: WorkspaceUpsertWithoutSubscriptionsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutSubscriptionsInput, WorkspaceUpdateWithoutSubscriptionsInput>, WorkspaceUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: SubscriptionPlanUpsertWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput, SubscriptionPlanUpdateWithoutSubscriptionsInput>, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type BillingRecordUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<BillingRecordCreateWithoutSubscriptionInput, BillingRecordUncheckedCreateWithoutSubscriptionInput> | BillingRecordCreateWithoutSubscriptionInput[] | BillingRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BillingRecordCreateOrConnectWithoutSubscriptionInput | BillingRecordCreateOrConnectWithoutSubscriptionInput[]
    upsert?: BillingRecordUpsertWithWhereUniqueWithoutSubscriptionInput | BillingRecordUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: BillingRecordCreateManySubscriptionInputEnvelope
    set?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    disconnect?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    delete?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    connect?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    update?: BillingRecordUpdateWithWhereUniqueWithoutSubscriptionInput | BillingRecordUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: BillingRecordUpdateManyWithWhereWithoutSubscriptionInput | BillingRecordUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: BillingRecordScalarWhereInput | BillingRecordScalarWhereInput[]
  }

  export type UsageRecordUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    set?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    disconnect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    delete?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    update?: UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UsageRecordUpdateManyWithWhereWithoutSubscriptionInput | UsageRecordUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
  }

  export type BillingRecordUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<BillingRecordCreateWithoutSubscriptionInput, BillingRecordUncheckedCreateWithoutSubscriptionInput> | BillingRecordCreateWithoutSubscriptionInput[] | BillingRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BillingRecordCreateOrConnectWithoutSubscriptionInput | BillingRecordCreateOrConnectWithoutSubscriptionInput[]
    upsert?: BillingRecordUpsertWithWhereUniqueWithoutSubscriptionInput | BillingRecordUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: BillingRecordCreateManySubscriptionInputEnvelope
    set?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    disconnect?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    delete?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    connect?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    update?: BillingRecordUpdateWithWhereUniqueWithoutSubscriptionInput | BillingRecordUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: BillingRecordUpdateManyWithWhereWithoutSubscriptionInput | BillingRecordUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: BillingRecordScalarWhereInput | BillingRecordScalarWhereInput[]
  }

  export type UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    set?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    disconnect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    delete?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    update?: UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UsageRecordUpdateManyWithWhereWithoutSubscriptionInput | UsageRecordUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
  }

  export type WorkspaceSubscriptionCreateNestedOneWithoutBillingRecordsInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutBillingRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutBillingRecordsInput>
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutBillingRecordsInput
    connect?: WorkspaceSubscriptionWhereUniqueInput
  }

  export type WorkspaceSubscriptionUpdateOneRequiredWithoutBillingRecordsNestedInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutBillingRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutBillingRecordsInput>
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutBillingRecordsInput
    upsert?: WorkspaceSubscriptionUpsertWithoutBillingRecordsInput
    connect?: WorkspaceSubscriptionWhereUniqueInput
    update?: XOR<XOR<WorkspaceSubscriptionUpdateToOneWithWhereWithoutBillingRecordsInput, WorkspaceSubscriptionUpdateWithoutBillingRecordsInput>, WorkspaceSubscriptionUncheckedUpdateWithoutBillingRecordsInput>
  }

  export type WorkspaceSubscriptionCreateNestedOneWithoutUsageRecordsInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutUsageRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutUsageRecordsInput
    connect?: WorkspaceSubscriptionWhereUniqueInput
  }

  export type WorkspaceSubscriptionUpdateOneRequiredWithoutUsageRecordsNestedInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutUsageRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutUsageRecordsInput
    upsert?: WorkspaceSubscriptionUpsertWithoutUsageRecordsInput
    connect?: WorkspaceSubscriptionWhereUniqueInput
    update?: XOR<XOR<WorkspaceSubscriptionUpdateToOneWithWhereWithoutUsageRecordsInput, WorkspaceSubscriptionUpdateWithoutUsageRecordsInput>, WorkspaceSubscriptionUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type UserCreateNestedOneWithoutUsageCountersInput = {
    create?: XOR<UserCreateWithoutUsageCountersInput, UserUncheckedCreateWithoutUsageCountersInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageCountersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsageCountersNestedInput = {
    create?: XOR<UserCreateWithoutUsageCountersInput, UserUncheckedCreateWithoutUsageCountersInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageCountersInput
    upsert?: UserUpsertWithoutUsageCountersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsageCountersInput, UserUpdateWithoutUsageCountersInput>, UserUncheckedUpdateWithoutUsageCountersInput>
  }

  export type PlanRecommendationCreatebenefitsInput = {
    set: string[]
  }

  export type PlanRecommendationCreatelimitationsRemovedInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutPlanRecommendationsInput = {
    create?: XOR<UserCreateWithoutPlanRecommendationsInput, UserUncheckedCreateWithoutPlanRecommendationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlanRecommendationsInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutCurrentPlanRecommendationsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutCurrentPlanRecommendationsInput, SubscriptionPlanUncheckedCreateWithoutCurrentPlanRecommendationsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutCurrentPlanRecommendationsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutRecommendedPlanRecommendationsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutRecommendedPlanRecommendationsInput, SubscriptionPlanUncheckedCreateWithoutRecommendedPlanRecommendationsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutRecommendedPlanRecommendationsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type PlanRecommendationUpdatebenefitsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlanRecommendationUpdatelimitationsRemovedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutPlanRecommendationsNestedInput = {
    create?: XOR<UserCreateWithoutPlanRecommendationsInput, UserUncheckedCreateWithoutPlanRecommendationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlanRecommendationsInput
    upsert?: UserUpsertWithoutPlanRecommendationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlanRecommendationsInput, UserUpdateWithoutPlanRecommendationsInput>, UserUncheckedUpdateWithoutPlanRecommendationsInput>
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutCurrentPlanRecommendationsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutCurrentPlanRecommendationsInput, SubscriptionPlanUncheckedCreateWithoutCurrentPlanRecommendationsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutCurrentPlanRecommendationsInput
    upsert?: SubscriptionPlanUpsertWithoutCurrentPlanRecommendationsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutCurrentPlanRecommendationsInput, SubscriptionPlanUpdateWithoutCurrentPlanRecommendationsInput>, SubscriptionPlanUncheckedUpdateWithoutCurrentPlanRecommendationsInput>
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutRecommendedPlanRecommendationsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutRecommendedPlanRecommendationsInput, SubscriptionPlanUncheckedCreateWithoutRecommendedPlanRecommendationsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutRecommendedPlanRecommendationsInput
    upsert?: SubscriptionPlanUpsertWithoutRecommendedPlanRecommendationsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutRecommendedPlanRecommendationsInput, SubscriptionPlanUpdateWithoutRecommendedPlanRecommendationsInput>, SubscriptionPlanUncheckedUpdateWithoutRecommendedPlanRecommendationsInput>
  }

  export type CustomPlanCreatecustomFeaturesInput = {
    set: string[]
  }

  export type CustomPlanCreateexcludedFeaturesInput = {
    set: string[]
  }

  export type CustomPlanCreateadditionalFeaturesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCustomPlansInput = {
    create?: XOR<UserCreateWithoutCustomPlansInput, UserUncheckedCreateWithoutCustomPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomPlansInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutCustomPlansInput = {
    create?: XOR<SubscriptionPlanCreateWithoutCustomPlansInput, SubscriptionPlanUncheckedCreateWithoutCustomPlansInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutCustomPlansInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type CustomPlanUpdatecustomFeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CustomPlanUpdateexcludedFeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CustomPlanUpdateadditionalFeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutCustomPlansNestedInput = {
    create?: XOR<UserCreateWithoutCustomPlansInput, UserUncheckedCreateWithoutCustomPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomPlansInput
    upsert?: UserUpsertWithoutCustomPlansInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomPlansInput, UserUpdateWithoutCustomPlansInput>, UserUncheckedUpdateWithoutCustomPlansInput>
  }

  export type SubscriptionPlanUpdateOneWithoutCustomPlansNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutCustomPlansInput, SubscriptionPlanUncheckedCreateWithoutCustomPlansInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutCustomPlansInput
    upsert?: SubscriptionPlanUpsertWithoutCustomPlansInput
    disconnect?: SubscriptionPlanWhereInput | boolean
    delete?: SubscriptionPlanWhereInput | boolean
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutCustomPlansInput, SubscriptionPlanUpdateWithoutCustomPlansInput>, SubscriptionPlanUncheckedUpdateWithoutCustomPlansInput>
  }

  export type FeatureFlagCreaterequiredPlansInput = {
    set: string[]
  }

  export type FeatureFlagCreateexcludedPlansInput = {
    set: string[]
  }

  export type PlanFeatureMatrixCreateNestedManyWithoutFeatureFlagInput = {
    create?: XOR<PlanFeatureMatrixCreateWithoutFeatureFlagInput, PlanFeatureMatrixUncheckedCreateWithoutFeatureFlagInput> | PlanFeatureMatrixCreateWithoutFeatureFlagInput[] | PlanFeatureMatrixUncheckedCreateWithoutFeatureFlagInput[]
    connectOrCreate?: PlanFeatureMatrixCreateOrConnectWithoutFeatureFlagInput | PlanFeatureMatrixCreateOrConnectWithoutFeatureFlagInput[]
    createMany?: PlanFeatureMatrixCreateManyFeatureFlagInputEnvelope
    connect?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
  }

  export type PlanFeatureMatrixUncheckedCreateNestedManyWithoutFeatureFlagInput = {
    create?: XOR<PlanFeatureMatrixCreateWithoutFeatureFlagInput, PlanFeatureMatrixUncheckedCreateWithoutFeatureFlagInput> | PlanFeatureMatrixCreateWithoutFeatureFlagInput[] | PlanFeatureMatrixUncheckedCreateWithoutFeatureFlagInput[]
    connectOrCreate?: PlanFeatureMatrixCreateOrConnectWithoutFeatureFlagInput | PlanFeatureMatrixCreateOrConnectWithoutFeatureFlagInput[]
    createMany?: PlanFeatureMatrixCreateManyFeatureFlagInputEnvelope
    connect?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
  }

  export type FeatureFlagUpdaterequiredPlansInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FeatureFlagUpdateexcludedPlansInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlanFeatureMatrixUpdateManyWithoutFeatureFlagNestedInput = {
    create?: XOR<PlanFeatureMatrixCreateWithoutFeatureFlagInput, PlanFeatureMatrixUncheckedCreateWithoutFeatureFlagInput> | PlanFeatureMatrixCreateWithoutFeatureFlagInput[] | PlanFeatureMatrixUncheckedCreateWithoutFeatureFlagInput[]
    connectOrCreate?: PlanFeatureMatrixCreateOrConnectWithoutFeatureFlagInput | PlanFeatureMatrixCreateOrConnectWithoutFeatureFlagInput[]
    upsert?: PlanFeatureMatrixUpsertWithWhereUniqueWithoutFeatureFlagInput | PlanFeatureMatrixUpsertWithWhereUniqueWithoutFeatureFlagInput[]
    createMany?: PlanFeatureMatrixCreateManyFeatureFlagInputEnvelope
    set?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    disconnect?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    delete?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    connect?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    update?: PlanFeatureMatrixUpdateWithWhereUniqueWithoutFeatureFlagInput | PlanFeatureMatrixUpdateWithWhereUniqueWithoutFeatureFlagInput[]
    updateMany?: PlanFeatureMatrixUpdateManyWithWhereWithoutFeatureFlagInput | PlanFeatureMatrixUpdateManyWithWhereWithoutFeatureFlagInput[]
    deleteMany?: PlanFeatureMatrixScalarWhereInput | PlanFeatureMatrixScalarWhereInput[]
  }

  export type PlanFeatureMatrixUncheckedUpdateManyWithoutFeatureFlagNestedInput = {
    create?: XOR<PlanFeatureMatrixCreateWithoutFeatureFlagInput, PlanFeatureMatrixUncheckedCreateWithoutFeatureFlagInput> | PlanFeatureMatrixCreateWithoutFeatureFlagInput[] | PlanFeatureMatrixUncheckedCreateWithoutFeatureFlagInput[]
    connectOrCreate?: PlanFeatureMatrixCreateOrConnectWithoutFeatureFlagInput | PlanFeatureMatrixCreateOrConnectWithoutFeatureFlagInput[]
    upsert?: PlanFeatureMatrixUpsertWithWhereUniqueWithoutFeatureFlagInput | PlanFeatureMatrixUpsertWithWhereUniqueWithoutFeatureFlagInput[]
    createMany?: PlanFeatureMatrixCreateManyFeatureFlagInputEnvelope
    set?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    disconnect?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    delete?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    connect?: PlanFeatureMatrixWhereUniqueInput | PlanFeatureMatrixWhereUniqueInput[]
    update?: PlanFeatureMatrixUpdateWithWhereUniqueWithoutFeatureFlagInput | PlanFeatureMatrixUpdateWithWhereUniqueWithoutFeatureFlagInput[]
    updateMany?: PlanFeatureMatrixUpdateManyWithWhereWithoutFeatureFlagInput | PlanFeatureMatrixUpdateManyWithWhereWithoutFeatureFlagInput[]
    deleteMany?: PlanFeatureMatrixScalarWhereInput | PlanFeatureMatrixScalarWhereInput[]
  }

  export type SubscriptionPlanCreateNestedOneWithoutPlanFeaturesInput = {
    create?: XOR<SubscriptionPlanCreateWithoutPlanFeaturesInput, SubscriptionPlanUncheckedCreateWithoutPlanFeaturesInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutPlanFeaturesInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type FeatureFlagCreateNestedOneWithoutPlanFeaturesInput = {
    create?: XOR<FeatureFlagCreateWithoutPlanFeaturesInput, FeatureFlagUncheckedCreateWithoutPlanFeaturesInput>
    connectOrCreate?: FeatureFlagCreateOrConnectWithoutPlanFeaturesInput
    connect?: FeatureFlagWhereUniqueInput
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutPlanFeaturesNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutPlanFeaturesInput, SubscriptionPlanUncheckedCreateWithoutPlanFeaturesInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutPlanFeaturesInput
    upsert?: SubscriptionPlanUpsertWithoutPlanFeaturesInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutPlanFeaturesInput, SubscriptionPlanUpdateWithoutPlanFeaturesInput>, SubscriptionPlanUncheckedUpdateWithoutPlanFeaturesInput>
  }

  export type FeatureFlagUpdateOneRequiredWithoutPlanFeaturesNestedInput = {
    create?: XOR<FeatureFlagCreateWithoutPlanFeaturesInput, FeatureFlagUncheckedCreateWithoutPlanFeaturesInput>
    connectOrCreate?: FeatureFlagCreateOrConnectWithoutPlanFeaturesInput
    upsert?: FeatureFlagUpsertWithoutPlanFeaturesInput
    connect?: FeatureFlagWhereUniqueInput
    update?: XOR<XOR<FeatureFlagUpdateToOneWithWhereWithoutPlanFeaturesInput, FeatureFlagUpdateWithoutPlanFeaturesInput>, FeatureFlagUncheckedUpdateWithoutPlanFeaturesInput>
  }

  export type UserCreateNestedOneWithoutEwayCustomersInput = {
    create?: XOR<UserCreateWithoutEwayCustomersInput, UserUncheckedCreateWithoutEwayCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutEwayCustomersInput
    connect?: UserWhereUniqueInput
  }

  export type EwayTransactionCreateNestedManyWithoutEwayCustomerInput = {
    create?: XOR<EwayTransactionCreateWithoutEwayCustomerInput, EwayTransactionUncheckedCreateWithoutEwayCustomerInput> | EwayTransactionCreateWithoutEwayCustomerInput[] | EwayTransactionUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayTransactionCreateOrConnectWithoutEwayCustomerInput | EwayTransactionCreateOrConnectWithoutEwayCustomerInput[]
    createMany?: EwayTransactionCreateManyEwayCustomerInputEnvelope
    connect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
  }

  export type EwayRecurringScheduleCreateNestedManyWithoutEwayCustomerInput = {
    create?: XOR<EwayRecurringScheduleCreateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput> | EwayRecurringScheduleCreateWithoutEwayCustomerInput[] | EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput | EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput[]
    createMany?: EwayRecurringScheduleCreateManyEwayCustomerInputEnvelope
    connect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
  }

  export type EwayTransactionUncheckedCreateNestedManyWithoutEwayCustomerInput = {
    create?: XOR<EwayTransactionCreateWithoutEwayCustomerInput, EwayTransactionUncheckedCreateWithoutEwayCustomerInput> | EwayTransactionCreateWithoutEwayCustomerInput[] | EwayTransactionUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayTransactionCreateOrConnectWithoutEwayCustomerInput | EwayTransactionCreateOrConnectWithoutEwayCustomerInput[]
    createMany?: EwayTransactionCreateManyEwayCustomerInputEnvelope
    connect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
  }

  export type EwayRecurringScheduleUncheckedCreateNestedManyWithoutEwayCustomerInput = {
    create?: XOR<EwayRecurringScheduleCreateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput> | EwayRecurringScheduleCreateWithoutEwayCustomerInput[] | EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput | EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput[]
    createMany?: EwayRecurringScheduleCreateManyEwayCustomerInputEnvelope
    connect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutEwayCustomersNestedInput = {
    create?: XOR<UserCreateWithoutEwayCustomersInput, UserUncheckedCreateWithoutEwayCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutEwayCustomersInput
    upsert?: UserUpsertWithoutEwayCustomersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEwayCustomersInput, UserUpdateWithoutEwayCustomersInput>, UserUncheckedUpdateWithoutEwayCustomersInput>
  }

  export type EwayTransactionUpdateManyWithoutEwayCustomerNestedInput = {
    create?: XOR<EwayTransactionCreateWithoutEwayCustomerInput, EwayTransactionUncheckedCreateWithoutEwayCustomerInput> | EwayTransactionCreateWithoutEwayCustomerInput[] | EwayTransactionUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayTransactionCreateOrConnectWithoutEwayCustomerInput | EwayTransactionCreateOrConnectWithoutEwayCustomerInput[]
    upsert?: EwayTransactionUpsertWithWhereUniqueWithoutEwayCustomerInput | EwayTransactionUpsertWithWhereUniqueWithoutEwayCustomerInput[]
    createMany?: EwayTransactionCreateManyEwayCustomerInputEnvelope
    set?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    disconnect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    delete?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    connect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    update?: EwayTransactionUpdateWithWhereUniqueWithoutEwayCustomerInput | EwayTransactionUpdateWithWhereUniqueWithoutEwayCustomerInput[]
    updateMany?: EwayTransactionUpdateManyWithWhereWithoutEwayCustomerInput | EwayTransactionUpdateManyWithWhereWithoutEwayCustomerInput[]
    deleteMany?: EwayTransactionScalarWhereInput | EwayTransactionScalarWhereInput[]
  }

  export type EwayRecurringScheduleUpdateManyWithoutEwayCustomerNestedInput = {
    create?: XOR<EwayRecurringScheduleCreateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput> | EwayRecurringScheduleCreateWithoutEwayCustomerInput[] | EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput | EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput[]
    upsert?: EwayRecurringScheduleUpsertWithWhereUniqueWithoutEwayCustomerInput | EwayRecurringScheduleUpsertWithWhereUniqueWithoutEwayCustomerInput[]
    createMany?: EwayRecurringScheduleCreateManyEwayCustomerInputEnvelope
    set?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    disconnect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    delete?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    connect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    update?: EwayRecurringScheduleUpdateWithWhereUniqueWithoutEwayCustomerInput | EwayRecurringScheduleUpdateWithWhereUniqueWithoutEwayCustomerInput[]
    updateMany?: EwayRecurringScheduleUpdateManyWithWhereWithoutEwayCustomerInput | EwayRecurringScheduleUpdateManyWithWhereWithoutEwayCustomerInput[]
    deleteMany?: EwayRecurringScheduleScalarWhereInput | EwayRecurringScheduleScalarWhereInput[]
  }

  export type EwayTransactionUncheckedUpdateManyWithoutEwayCustomerNestedInput = {
    create?: XOR<EwayTransactionCreateWithoutEwayCustomerInput, EwayTransactionUncheckedCreateWithoutEwayCustomerInput> | EwayTransactionCreateWithoutEwayCustomerInput[] | EwayTransactionUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayTransactionCreateOrConnectWithoutEwayCustomerInput | EwayTransactionCreateOrConnectWithoutEwayCustomerInput[]
    upsert?: EwayTransactionUpsertWithWhereUniqueWithoutEwayCustomerInput | EwayTransactionUpsertWithWhereUniqueWithoutEwayCustomerInput[]
    createMany?: EwayTransactionCreateManyEwayCustomerInputEnvelope
    set?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    disconnect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    delete?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    connect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    update?: EwayTransactionUpdateWithWhereUniqueWithoutEwayCustomerInput | EwayTransactionUpdateWithWhereUniqueWithoutEwayCustomerInput[]
    updateMany?: EwayTransactionUpdateManyWithWhereWithoutEwayCustomerInput | EwayTransactionUpdateManyWithWhereWithoutEwayCustomerInput[]
    deleteMany?: EwayTransactionScalarWhereInput | EwayTransactionScalarWhereInput[]
  }

  export type EwayRecurringScheduleUncheckedUpdateManyWithoutEwayCustomerNestedInput = {
    create?: XOR<EwayRecurringScheduleCreateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput> | EwayRecurringScheduleCreateWithoutEwayCustomerInput[] | EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput | EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput[]
    upsert?: EwayRecurringScheduleUpsertWithWhereUniqueWithoutEwayCustomerInput | EwayRecurringScheduleUpsertWithWhereUniqueWithoutEwayCustomerInput[]
    createMany?: EwayRecurringScheduleCreateManyEwayCustomerInputEnvelope
    set?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    disconnect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    delete?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    connect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    update?: EwayRecurringScheduleUpdateWithWhereUniqueWithoutEwayCustomerInput | EwayRecurringScheduleUpdateWithWhereUniqueWithoutEwayCustomerInput[]
    updateMany?: EwayRecurringScheduleUpdateManyWithWhereWithoutEwayCustomerInput | EwayRecurringScheduleUpdateManyWithWhereWithoutEwayCustomerInput[]
    deleteMany?: EwayRecurringScheduleScalarWhereInput | EwayRecurringScheduleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEwayTransactionsInput = {
    create?: XOR<UserCreateWithoutEwayTransactionsInput, UserUncheckedCreateWithoutEwayTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEwayTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EwayCustomerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<EwayCustomerCreateWithoutTransactionsInput, EwayCustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: EwayCustomerCreateOrConnectWithoutTransactionsInput
    connect?: EwayCustomerWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEwayTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutEwayTransactionsInput, UserUncheckedCreateWithoutEwayTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEwayTransactionsInput
    upsert?: UserUpsertWithoutEwayTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEwayTransactionsInput, UserUpdateWithoutEwayTransactionsInput>, UserUncheckedUpdateWithoutEwayTransactionsInput>
  }

  export type EwayCustomerUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<EwayCustomerCreateWithoutTransactionsInput, EwayCustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: EwayCustomerCreateOrConnectWithoutTransactionsInput
    upsert?: EwayCustomerUpsertWithoutTransactionsInput
    connect?: EwayCustomerWhereUniqueInput
    update?: XOR<XOR<EwayCustomerUpdateToOneWithWhereWithoutTransactionsInput, EwayCustomerUpdateWithoutTransactionsInput>, EwayCustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutEwayRecurringSchedulesInput = {
    create?: XOR<UserCreateWithoutEwayRecurringSchedulesInput, UserUncheckedCreateWithoutEwayRecurringSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEwayRecurringSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type EwayCustomerCreateNestedOneWithoutRecurringSchedulesInput = {
    create?: XOR<EwayCustomerCreateWithoutRecurringSchedulesInput, EwayCustomerUncheckedCreateWithoutRecurringSchedulesInput>
    connectOrCreate?: EwayCustomerCreateOrConnectWithoutRecurringSchedulesInput
    connect?: EwayCustomerWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEwayRecurringSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutEwayRecurringSchedulesInput, UserUncheckedCreateWithoutEwayRecurringSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEwayRecurringSchedulesInput
    upsert?: UserUpsertWithoutEwayRecurringSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEwayRecurringSchedulesInput, UserUpdateWithoutEwayRecurringSchedulesInput>, UserUncheckedUpdateWithoutEwayRecurringSchedulesInput>
  }

  export type EwayCustomerUpdateOneRequiredWithoutRecurringSchedulesNestedInput = {
    create?: XOR<EwayCustomerCreateWithoutRecurringSchedulesInput, EwayCustomerUncheckedCreateWithoutRecurringSchedulesInput>
    connectOrCreate?: EwayCustomerCreateOrConnectWithoutRecurringSchedulesInput
    upsert?: EwayCustomerUpsertWithoutRecurringSchedulesInput
    connect?: EwayCustomerWhereUniqueInput
    update?: XOR<XOR<EwayCustomerUpdateToOneWithWhereWithoutRecurringSchedulesInput, EwayCustomerUpdateWithoutRecurringSchedulesInput>, EwayCustomerUncheckedUpdateWithoutRecurringSchedulesInput>
  }

  export type ExportHistoryCreateworkspaceIdsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutExportsInput = {
    create?: XOR<UserCreateWithoutExportsInput, UserUncheckedCreateWithoutExportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExportsInput
    connect?: UserWhereUniqueInput
  }

  export type ExportHistoryUpdateworkspaceIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutExportsNestedInput = {
    create?: XOR<UserCreateWithoutExportsInput, UserUncheckedCreateWithoutExportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExportsInput
    upsert?: UserUpsertWithoutExportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExportsInput, UserUpdateWithoutExportsInput>, UserUncheckedUpdateWithoutExportsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<WorkspaceCreateWithoutAuditLogsInput, WorkspaceUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAuditLogsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type WorkspaceUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAuditLogsInput, WorkspaceUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAuditLogsInput
    upsert?: WorkspaceUpsertWithoutAuditLogsInput
    disconnect?: WorkspaceWhereInput | boolean
    delete?: WorkspaceWhereInput | boolean
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAuditLogsInput, WorkspaceUpdateWithoutAuditLogsInput>, WorkspaceUncheckedUpdateWithoutAuditLogsInput>
  }

  export type DataRetentionPolicyCreateappliesToWorkspacesInput = {
    set: string[]
  }

  export type DataRetentionPolicyCreateexcludeWorkspacesInput = {
    set: string[]
  }

  export type DataRetentionPolicyUpdateappliesToWorkspacesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DataRetentionPolicyUpdateexcludeWorkspacesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserCreateNestedOneWithoutTestimonialsInput = {
    create?: XOR<UserCreateWithoutTestimonialsInput, UserUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestimonialsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutTestimonialsNestedInput = {
    create?: XOR<UserCreateWithoutTestimonialsInput, UserUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestimonialsInput
    upsert?: UserUpsertWithoutTestimonialsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestimonialsInput, UserUpdateWithoutTestimonialsInput>, UserUncheckedUpdateWithoutTestimonialsInput>
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedRolesInput = {
    create?: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedRolesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneWithoutAssignedRolesNestedInput = {
    create?: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedRolesInput
    upsert?: UserUpsertWithoutAssignedRolesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedRolesInput, UserUpdateWithoutAssignedRolesInput>, UserUncheckedUpdateWithoutAssignedRolesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type WorkspaceUserCreateWithoutWorkspaceInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: Date | string | null
    user: UserCreateNestedOneWithoutWorkspacesInput
  }

  export type WorkspaceUserUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: Date | string | null
  }

  export type WorkspaceUserCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    create: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceUserCreateManyWorkspaceInput | WorkspaceUserCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceInvitationCreateWithoutWorkspaceInput = {
    id?: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    invitedById?: string | null
  }

  export type WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    invitedById?: string | null
  }

  export type WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    create: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceInvitationCreateManyWorkspaceInput | WorkspaceInvitationCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type AudioHistoryCreateWithoutWorkspaceInput = {
    id?: string
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAudioHistoryInput
    upload?: AudioUploadCreateNestedOneWithoutAudioHistoryInput
    segments?: AudioSegmentCreateNestedManyWithoutHistoryInput
  }

  export type AudioHistoryUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    uploadId?: string | null
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    segments?: AudioSegmentUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type AudioHistoryCreateOrConnectWithoutWorkspaceInput = {
    where: AudioHistoryWhereUniqueInput
    create: XOR<AudioHistoryCreateWithoutWorkspaceInput, AudioHistoryUncheckedCreateWithoutWorkspaceInput>
  }

  export type AudioHistoryCreateManyWorkspaceInputEnvelope = {
    data: AudioHistoryCreateManyWorkspaceInput | AudioHistoryCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type AudioUploadCreateWithoutWorkspaceInput = {
    id?: string
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAudioUploadsInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUploadInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUploadInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkUncheckedCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadCreateOrConnectWithoutWorkspaceInput = {
    where: AudioUploadWhereUniqueInput
    create: XOR<AudioUploadCreateWithoutWorkspaceInput, AudioUploadUncheckedCreateWithoutWorkspaceInput>
  }

  export type AudioUploadCreateManyWorkspaceInputEnvelope = {
    data: AudioUploadCreateManyWorkspaceInput | AudioUploadCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type AudioProjectCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    status?: string
    isPublic?: boolean
    tags?: AudioProjectCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
  }

  export type AudioProjectUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    color?: string | null
    status?: string
    isPublic?: boolean
    tags?: AudioProjectCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioProjectCreateOrConnectWithoutWorkspaceInput = {
    where: AudioProjectWhereUniqueInput
    create: XOR<AudioProjectCreateWithoutWorkspaceInput, AudioProjectUncheckedCreateWithoutWorkspaceInput>
  }

  export type AudioProjectCreateManyWorkspaceInputEnvelope = {
    data: AudioProjectCreateManyWorkspaceInput | AudioProjectCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceSettingsCreateWithoutWorkspaceInput = {
    defaultProcessingOptions?: JsonNullValueInput | InputJsonValue
    allowedFileTypes?: WorkspaceSettingsCreateallowedFileTypesInput | string[]
    maxFileSize?: bigint | number
    maxProcessingTime?: number
    allowPublicSharing?: boolean
    allowGuestAccess?: boolean
    requireApprovalForUploads?: boolean
    webhookUrl?: string | null
    webhookSecret?: string | null
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type WorkspaceSettingsUncheckedCreateWithoutWorkspaceInput = {
    defaultProcessingOptions?: JsonNullValueInput | InputJsonValue
    allowedFileTypes?: WorkspaceSettingsCreateallowedFileTypesInput | string[]
    maxFileSize?: bigint | number
    maxProcessingTime?: number
    allowPublicSharing?: boolean
    allowGuestAccess?: boolean
    requireApprovalForUploads?: boolean
    webhookUrl?: string | null
    webhookSecret?: string | null
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type WorkspaceSettingsCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceSettingsWhereUniqueInput
    create: XOR<WorkspaceSettingsCreateWithoutWorkspaceInput, WorkspaceSettingsUncheckedCreateWithoutWorkspaceInput>
  }

  export type UsageMetricCreateWithoutWorkspaceInput = {
    id?: string
    metricType: string
    provider?: string | null
    quantity: bigint | number
    cost: Decimal | DecimalJsLike | number | string
    currency?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
    recordedAt?: Date | string
    user: UserCreateNestedOneWithoutUsageMetricsInput
  }

  export type UsageMetricUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    metricType: string
    provider?: string | null
    quantity: bigint | number
    cost: Decimal | DecimalJsLike | number | string
    currency?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
    recordedAt?: Date | string
  }

  export type UsageMetricCreateOrConnectWithoutWorkspaceInput = {
    where: UsageMetricWhereUniqueInput
    create: XOR<UsageMetricCreateWithoutWorkspaceInput, UsageMetricUncheckedCreateWithoutWorkspaceInput>
  }

  export type UsageMetricCreateManyWorkspaceInputEnvelope = {
    data: UsageMetricCreateManyWorkspaceInput | UsageMetricCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type StorageQuotaCreateWithoutWorkspaceInput = {
    maxStorageBytes: bigint | number
    maxFileCount: number
    maxFileSize: bigint | number
    currentStorageBytes?: bigint | number
    currentFileCount?: number
    retentionDays?: number | null
    autoCleanup?: boolean
    updatedAt?: Date | string
  }

  export type StorageQuotaUncheckedCreateWithoutWorkspaceInput = {
    maxStorageBytes: bigint | number
    maxFileCount: number
    maxFileSize: bigint | number
    currentStorageBytes?: bigint | number
    currentFileCount?: number
    retentionDays?: number | null
    autoCleanup?: boolean
    updatedAt?: Date | string
  }

  export type StorageQuotaCreateOrConnectWithoutWorkspaceInput = {
    where: StorageQuotaWhereUniqueInput
    create: XOR<StorageQuotaCreateWithoutWorkspaceInput, StorageQuotaUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceSubscriptionCreateWithoutWorkspaceInput = {
    id?: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    billingRecords?: BillingRecordCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    planId: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingRecords?: BillingRecordUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    create: XOR<WorkspaceSubscriptionCreateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceSubscriptionCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceSubscriptionCreateManyWorkspaceInput | WorkspaceSubscriptionCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutWorkspaceInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: string
    category?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: string
    category?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutWorkspaceInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput>
  }

  export type AuditLogCreateManyWorkspaceInputEnvelope = {
    data: AuditLogCreateManyWorkspaceInput | AuditLogCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    update: XOR<WorkspaceUserUpdateWithoutWorkspaceInput, WorkspaceUserUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    data: XOR<WorkspaceUserUpdateWithoutWorkspaceInput, WorkspaceUserUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceUserScalarWhereInput
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceUserScalarWhereInput = {
    AND?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
    OR?: WorkspaceUserScalarWhereInput[]
    NOT?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
    id?: StringFilter<"WorkspaceUser"> | string
    workspaceId?: StringFilter<"WorkspaceUser"> | string
    userId?: StringFilter<"WorkspaceUser"> | string
    role?: StringFilter<"WorkspaceUser"> | string
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    permissions?: JsonNullableFilter<"WorkspaceUser">
    lastActiveAt?: DateTimeNullableFilter<"WorkspaceUser"> | Date | string | null
  }

  export type WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    update: XOR<WorkspaceInvitationUpdateWithoutWorkspaceInput, WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    data: XOR<WorkspaceInvitationUpdateWithoutWorkspaceInput, WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceInvitationScalarWhereInput
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationScalarWhereInput = {
    AND?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
    OR?: WorkspaceInvitationScalarWhereInput[]
    NOT?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
    id?: StringFilter<"WorkspaceInvitation"> | string
    workspaceId?: StringFilter<"WorkspaceInvitation"> | string
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: StringFilter<"WorkspaceInvitation"> | string
    token?: StringFilter<"WorkspaceInvitation"> | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"WorkspaceInvitation"> | Date | string | null
    invitedById?: StringNullableFilter<"WorkspaceInvitation"> | string | null
  }

  export type AudioHistoryUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AudioHistoryWhereUniqueInput
    update: XOR<AudioHistoryUpdateWithoutWorkspaceInput, AudioHistoryUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AudioHistoryCreateWithoutWorkspaceInput, AudioHistoryUncheckedCreateWithoutWorkspaceInput>
  }

  export type AudioHistoryUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AudioHistoryWhereUniqueInput
    data: XOR<AudioHistoryUpdateWithoutWorkspaceInput, AudioHistoryUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AudioHistoryUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AudioHistoryScalarWhereInput
    data: XOR<AudioHistoryUpdateManyMutationInput, AudioHistoryUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type AudioHistoryScalarWhereInput = {
    AND?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
    OR?: AudioHistoryScalarWhereInput[]
    NOT?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
    id?: StringFilter<"AudioHistory"> | string
    userId?: StringFilter<"AudioHistory"> | string
    workspaceId?: StringNullableFilter<"AudioHistory"> | string | null
    uploadId?: StringNullableFilter<"AudioHistory"> | string | null
    title?: StringNullableFilter<"AudioHistory"> | string | null
    audioUrl?: StringNullableFilter<"AudioHistory"> | string | null
    cdnUrl?: StringNullableFilter<"AudioHistory"> | string | null
    fileSizeBytes?: BigIntNullableFilter<"AudioHistory"> | bigint | number | null
    durationSeconds?: IntNullableFilter<"AudioHistory"> | number | null
    transcript?: StringNullableFilter<"AudioHistory"> | string | null
    summary?: StringNullableFilter<"AudioHistory"> | string | null
    keyMoments?: JsonNullableFilter<"AudioHistory">
    language?: StringNullableFilter<"AudioHistory"> | string | null
    confidence?: FloatNullableFilter<"AudioHistory"> | number | null
    wordCount?: IntNullableFilter<"AudioHistory"> | number | null
    speakerCount?: IntNullableFilter<"AudioHistory"> | number | null
    processingOptions?: JsonNullableFilter<"AudioHistory">
    processingTime?: FloatNullableFilter<"AudioHistory"> | number | null
    apiProvider?: StringNullableFilter<"AudioHistory"> | string | null
    modelVersion?: StringNullableFilter<"AudioHistory"> | string | null
    transcriptionCost?: DecimalNullableFilter<"AudioHistory"> | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: DecimalNullableFilter<"AudioHistory"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"AudioHistory"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AudioHistory"> | Date | string
    updatedAt?: DateTimeFilter<"AudioHistory"> | Date | string
  }

  export type AudioUploadUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AudioUploadWhereUniqueInput
    update: XOR<AudioUploadUpdateWithoutWorkspaceInput, AudioUploadUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AudioUploadCreateWithoutWorkspaceInput, AudioUploadUncheckedCreateWithoutWorkspaceInput>
  }

  export type AudioUploadUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AudioUploadWhereUniqueInput
    data: XOR<AudioUploadUpdateWithoutWorkspaceInput, AudioUploadUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AudioUploadUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AudioUploadScalarWhereInput
    data: XOR<AudioUploadUpdateManyMutationInput, AudioUploadUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type AudioUploadScalarWhereInput = {
    AND?: AudioUploadScalarWhereInput | AudioUploadScalarWhereInput[]
    OR?: AudioUploadScalarWhereInput[]
    NOT?: AudioUploadScalarWhereInput | AudioUploadScalarWhereInput[]
    id?: StringFilter<"AudioUpload"> | string
    userId?: StringFilter<"AudioUpload"> | string
    workspaceId?: StringNullableFilter<"AudioUpload"> | string | null
    originalFilename?: StringFilter<"AudioUpload"> | string
    fileSize?: BigIntFilter<"AudioUpload"> | bigint | number
    fileType?: StringFilter<"AudioUpload"> | string
    mimeType?: StringFilter<"AudioUpload"> | string
    duration?: FloatNullableFilter<"AudioUpload"> | number | null
    sampleRate?: IntNullableFilter<"AudioUpload"> | number | null
    channels?: IntNullableFilter<"AudioUpload"> | number | null
    bitrate?: IntNullableFilter<"AudioUpload"> | number | null
    storageProvider?: StringFilter<"AudioUpload"> | string
    storagePath?: StringFilter<"AudioUpload"> | string
    storageUrl?: StringNullableFilter<"AudioUpload"> | string | null
    cdnUrl?: StringNullableFilter<"AudioUpload"> | string | null
    checksumMd5?: StringNullableFilter<"AudioUpload"> | string | null
    checksumSha256?: StringNullableFilter<"AudioUpload"> | string | null
    status?: StringFilter<"AudioUpload"> | string
    uploadedAt?: DateTimeFilter<"AudioUpload"> | Date | string
    processingStartedAt?: DateTimeNullableFilter<"AudioUpload"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AudioUpload"> | Date | string | null
  }

  export type AudioProjectUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AudioProjectWhereUniqueInput
    update: XOR<AudioProjectUpdateWithoutWorkspaceInput, AudioProjectUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AudioProjectCreateWithoutWorkspaceInput, AudioProjectUncheckedCreateWithoutWorkspaceInput>
  }

  export type AudioProjectUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AudioProjectWhereUniqueInput
    data: XOR<AudioProjectUpdateWithoutWorkspaceInput, AudioProjectUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AudioProjectUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AudioProjectScalarWhereInput
    data: XOR<AudioProjectUpdateManyMutationInput, AudioProjectUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type AudioProjectScalarWhereInput = {
    AND?: AudioProjectScalarWhereInput | AudioProjectScalarWhereInput[]
    OR?: AudioProjectScalarWhereInput[]
    NOT?: AudioProjectScalarWhereInput | AudioProjectScalarWhereInput[]
    id?: StringFilter<"AudioProject"> | string
    userId?: StringFilter<"AudioProject"> | string
    workspaceId?: StringNullableFilter<"AudioProject"> | string | null
    name?: StringFilter<"AudioProject"> | string
    description?: StringNullableFilter<"AudioProject"> | string | null
    color?: StringNullableFilter<"AudioProject"> | string | null
    status?: StringFilter<"AudioProject"> | string
    isPublic?: BoolFilter<"AudioProject"> | boolean
    tags?: StringNullableListFilter<"AudioProject">
    metadata?: JsonNullableFilter<"AudioProject">
    createdAt?: DateTimeFilter<"AudioProject"> | Date | string
    updatedAt?: DateTimeFilter<"AudioProject"> | Date | string
  }

  export type WorkspaceSettingsUpsertWithoutWorkspaceInput = {
    update: XOR<WorkspaceSettingsUpdateWithoutWorkspaceInput, WorkspaceSettingsUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceSettingsCreateWithoutWorkspaceInput, WorkspaceSettingsUncheckedCreateWithoutWorkspaceInput>
    where?: WorkspaceSettingsWhereInput
  }

  export type WorkspaceSettingsUpdateToOneWithWhereWithoutWorkspaceInput = {
    where?: WorkspaceSettingsWhereInput
    data: XOR<WorkspaceSettingsUpdateWithoutWorkspaceInput, WorkspaceSettingsUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceSettingsUpdateWithoutWorkspaceInput = {
    defaultProcessingOptions?: JsonNullValueInput | InputJsonValue
    allowedFileTypes?: WorkspaceSettingsUpdateallowedFileTypesInput | string[]
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingTime?: IntFieldUpdateOperationsInput | number
    allowPublicSharing?: BoolFieldUpdateOperationsInput | boolean
    allowGuestAccess?: BoolFieldUpdateOperationsInput | boolean
    requireApprovalForUploads?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceSettingsUncheckedUpdateWithoutWorkspaceInput = {
    defaultProcessingOptions?: JsonNullValueInput | InputJsonValue
    allowedFileTypes?: WorkspaceSettingsUpdateallowedFileTypesInput | string[]
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingTime?: IntFieldUpdateOperationsInput | number
    allowPublicSharing?: BoolFieldUpdateOperationsInput | boolean
    allowGuestAccess?: BoolFieldUpdateOperationsInput | boolean
    requireApprovalForUploads?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: UsageMetricWhereUniqueInput
    update: XOR<UsageMetricUpdateWithoutWorkspaceInput, UsageMetricUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<UsageMetricCreateWithoutWorkspaceInput, UsageMetricUncheckedCreateWithoutWorkspaceInput>
  }

  export type UsageMetricUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: UsageMetricWhereUniqueInput
    data: XOR<UsageMetricUpdateWithoutWorkspaceInput, UsageMetricUncheckedUpdateWithoutWorkspaceInput>
  }

  export type UsageMetricUpdateManyWithWhereWithoutWorkspaceInput = {
    where: UsageMetricScalarWhereInput
    data: XOR<UsageMetricUpdateManyMutationInput, UsageMetricUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type UsageMetricScalarWhereInput = {
    AND?: UsageMetricScalarWhereInput | UsageMetricScalarWhereInput[]
    OR?: UsageMetricScalarWhereInput[]
    NOT?: UsageMetricScalarWhereInput | UsageMetricScalarWhereInput[]
    id?: StringFilter<"UsageMetric"> | string
    userId?: StringFilter<"UsageMetric"> | string
    workspaceId?: StringNullableFilter<"UsageMetric"> | string | null
    metricType?: StringFilter<"UsageMetric"> | string
    provider?: StringNullableFilter<"UsageMetric"> | string | null
    quantity?: BigIntFilter<"UsageMetric"> | bigint | number
    cost?: DecimalFilter<"UsageMetric"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"UsageMetric"> | string
    metadata?: JsonNullableFilter<"UsageMetric">
    periodStart?: DateTimeFilter<"UsageMetric"> | Date | string
    periodEnd?: DateTimeFilter<"UsageMetric"> | Date | string
    recordedAt?: DateTimeFilter<"UsageMetric"> | Date | string
  }

  export type StorageQuotaUpsertWithoutWorkspaceInput = {
    update: XOR<StorageQuotaUpdateWithoutWorkspaceInput, StorageQuotaUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<StorageQuotaCreateWithoutWorkspaceInput, StorageQuotaUncheckedCreateWithoutWorkspaceInput>
    where?: StorageQuotaWhereInput
  }

  export type StorageQuotaUpdateToOneWithWhereWithoutWorkspaceInput = {
    where?: StorageQuotaWhereInput
    data: XOR<StorageQuotaUpdateWithoutWorkspaceInput, StorageQuotaUncheckedUpdateWithoutWorkspaceInput>
  }

  export type StorageQuotaUpdateWithoutWorkspaceInput = {
    maxStorageBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    currentStorageBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    currentFileCount?: IntFieldUpdateOperationsInput | number
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    autoCleanup?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaUncheckedUpdateWithoutWorkspaceInput = {
    maxStorageBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    currentStorageBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    currentFileCount?: IntFieldUpdateOperationsInput | number
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    autoCleanup?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceSubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    update: XOR<WorkspaceSubscriptionUpdateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceSubscriptionCreateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceSubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    data: XOR<WorkspaceSubscriptionUpdateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceSubscriptionUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceSubscriptionScalarWhereInput
    data: XOR<WorkspaceSubscriptionUpdateManyMutationInput, WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceSubscriptionScalarWhereInput = {
    AND?: WorkspaceSubscriptionScalarWhereInput | WorkspaceSubscriptionScalarWhereInput[]
    OR?: WorkspaceSubscriptionScalarWhereInput[]
    NOT?: WorkspaceSubscriptionScalarWhereInput | WorkspaceSubscriptionScalarWhereInput[]
    id?: StringFilter<"WorkspaceSubscription"> | string
    workspaceId?: StringFilter<"WorkspaceSubscription"> | string
    planId?: StringFilter<"WorkspaceSubscription"> | string
    status?: StringFilter<"WorkspaceSubscription"> | string
    currentPeriodStart?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    nextBillingDate?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    paymentGateway?: StringFilter<"WorkspaceSubscription"> | string
    paymentMethodId?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    currency?: StringFilter<"WorkspaceSubscription"> | string
    amount?: DecimalFilter<"WorkspaceSubscription"> | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    cancelledAt?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    createdAt?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutWorkspaceInput, AuditLogUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutWorkspaceInput, AuditLogUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    workspaceId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    requestId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    severity?: StringFilter<"AuditLog"> | string
    category?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AudioHistoryCreateWithoutUserInput = {
    id?: string
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace?: WorkspaceCreateNestedOneWithoutAudioHistoryInput
    upload?: AudioUploadCreateNestedOneWithoutAudioHistoryInput
    segments?: AudioSegmentCreateNestedManyWithoutHistoryInput
  }

  export type AudioHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    uploadId?: string | null
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    segments?: AudioSegmentUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type AudioHistoryCreateOrConnectWithoutUserInput = {
    where: AudioHistoryWhereUniqueInput
    create: XOR<AudioHistoryCreateWithoutUserInput, AudioHistoryUncheckedCreateWithoutUserInput>
  }

  export type AudioHistoryCreateManyUserInputEnvelope = {
    data: AudioHistoryCreateManyUserInput | AudioHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    createdAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    createdAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsCreateWithoutUserInput = {
    openaiApiKeyEncrypted?: string | null
    elevenlabsApiKeyEncrypted?: string | null
    preferredLanguage?: string
    summaryQuality?: string
    defaultSummaryStyle?: string
    defaultTemperature?: number
    defaultMaxTokens?: number
    showCostEstimates?: boolean
    emailNotifications?: boolean
    processingNotifications?: boolean
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    openaiApiKeyEncrypted?: string | null
    elevenlabsApiKeyEncrypted?: string | null
    preferredLanguage?: string
    summaryQuality?: string
    defaultSummaryStyle?: string
    defaultTemperature?: number
    defaultMaxTokens?: number
    showCostEstimates?: boolean
    emailNotifications?: boolean
    processingNotifications?: boolean
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserCreateWithoutUserInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutUsersInput
  }

  export type WorkspaceUserUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    role?: string
    joinedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: Date | string | null
  }

  export type WorkspaceUserCreateOrConnectWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    create: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserCreateManyUserInputEnvelope = {
    data: WorkspaceUserCreateManyUserInput | WorkspaceUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AudioUploadCreateWithoutUserInput = {
    id?: string
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
    workspace?: WorkspaceCreateNestedOneWithoutAudioUploadsInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUploadInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUploadInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkUncheckedCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadCreateOrConnectWithoutUserInput = {
    where: AudioUploadWhereUniqueInput
    create: XOR<AudioUploadCreateWithoutUserInput, AudioUploadUncheckedCreateWithoutUserInput>
  }

  export type AudioUploadCreateManyUserInputEnvelope = {
    data: AudioUploadCreateManyUserInput | AudioUploadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AudioProjectCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    status?: string
    isPublic?: boolean
    tags?: AudioProjectCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace?: WorkspaceCreateNestedOneWithoutProjectsInput
  }

  export type AudioProjectUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    name: string
    description?: string | null
    color?: string | null
    status?: string
    isPublic?: boolean
    tags?: AudioProjectCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioProjectCreateOrConnectWithoutUserInput = {
    where: AudioProjectWhereUniqueInput
    create: XOR<AudioProjectCreateWithoutUserInput, AudioProjectUncheckedCreateWithoutUserInput>
  }

  export type AudioProjectCreateManyUserInputEnvelope = {
    data: AudioProjectCreateManyUserInput | AudioProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProcessingJobCreateWithoutUserInput = {
    id?: string
    jobType: string
    priority?: number
    processingOptions: JsonNullValueInput | InputJsonValue
    status?: string
    progress?: number
    cpuTimeMs?: bigint | number | null
    memoryUsageMb?: number | null
    queuedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    maxRetries?: number
    upload: AudioUploadCreateNestedOneWithoutProcessingJobsInput
  }

  export type ProcessingJobUncheckedCreateWithoutUserInput = {
    id?: string
    uploadId: string
    jobType: string
    priority?: number
    processingOptions: JsonNullValueInput | InputJsonValue
    status?: string
    progress?: number
    cpuTimeMs?: bigint | number | null
    memoryUsageMb?: number | null
    queuedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    maxRetries?: number
  }

  export type ProcessingJobCreateOrConnectWithoutUserInput = {
    where: ProcessingJobWhereUniqueInput
    create: XOR<ProcessingJobCreateWithoutUserInput, ProcessingJobUncheckedCreateWithoutUserInput>
  }

  export type ProcessingJobCreateManyUserInputEnvelope = {
    data: ProcessingJobCreateManyUserInput | ProcessingJobCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UsageMetricCreateWithoutUserInput = {
    id?: string
    metricType: string
    provider?: string | null
    quantity: bigint | number
    cost: Decimal | DecimalJsLike | number | string
    currency?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
    recordedAt?: Date | string
    workspace?: WorkspaceCreateNestedOneWithoutUsageMetricsInput
  }

  export type UsageMetricUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    metricType: string
    provider?: string | null
    quantity: bigint | number
    cost: Decimal | DecimalJsLike | number | string
    currency?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
    recordedAt?: Date | string
  }

  export type UsageMetricCreateOrConnectWithoutUserInput = {
    where: UsageMetricWhereUniqueInput
    create: XOR<UsageMetricCreateWithoutUserInput, UsageMetricUncheckedCreateWithoutUserInput>
  }

  export type UsageMetricCreateManyUserInputEnvelope = {
    data: UsageMetricCreateManyUserInput | UsageMetricCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExportHistoryCreateWithoutUserInput = {
    id?: string
    exportType: string
    dataType: string
    dateFrom?: Date | string | null
    dateTo?: Date | string | null
    workspaceIds?: ExportHistoryCreateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename: string
    fileSize: bigint | number
    storagePath?: string | null
    downloadUrl?: string | null
    expiresAt?: Date | string | null
    status?: string
    downloadCount?: number
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ExportHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    exportType: string
    dataType: string
    dateFrom?: Date | string | null
    dateTo?: Date | string | null
    workspaceIds?: ExportHistoryCreateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename: string
    fileSize: bigint | number
    storagePath?: string | null
    downloadUrl?: string | null
    expiresAt?: Date | string | null
    status?: string
    downloadCount?: number
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ExportHistoryCreateOrConnectWithoutUserInput = {
    where: ExportHistoryWhereUniqueInput
    create: XOR<ExportHistoryCreateWithoutUserInput, ExportHistoryUncheckedCreateWithoutUserInput>
  }

  export type ExportHistoryCreateManyUserInputEnvelope = {
    data: ExportHistoryCreateManyUserInput | ExportHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyManagementCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    provider: string
    keyName: string
    encryptedKey: string
    keyHash: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    totalRequests?: bigint | number
    totalTokens?: bigint | number
    totalCost?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyManagementUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    provider: string
    keyName: string
    encryptedKey: string
    keyHash: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    totalRequests?: bigint | number
    totalTokens?: bigint | number
    totalCost?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyManagementCreateOrConnectWithoutUserInput = {
    where: ApiKeyManagementWhereUniqueInput
    create: XOR<ApiKeyManagementCreateWithoutUserInput, ApiKeyManagementUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyManagementCreateManyUserInputEnvelope = {
    data: ApiKeyManagementCreateManyUserInput | ApiKeyManagementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserQuotaCreateWithoutUserInput = {
    monthlyApiCalls?: bigint | number
    monthlyTokens?: bigint | number
    monthlyStorageMb?: bigint | number
    monthlyProcessingMin?: bigint | number
    currentApiCalls?: bigint | number
    currentTokens?: bigint | number
    currentStorageMb?: bigint | number
    currentProcessingMin?: bigint | number
    periodStart: Date | string
    periodEnd: Date | string
    lastResetAt?: Date | string
    allowOverages?: boolean
    overageCostPerToken?: Decimal | DecimalJsLike | number | string
  }

  export type UserQuotaUncheckedCreateWithoutUserInput = {
    monthlyApiCalls?: bigint | number
    monthlyTokens?: bigint | number
    monthlyStorageMb?: bigint | number
    monthlyProcessingMin?: bigint | number
    currentApiCalls?: bigint | number
    currentTokens?: bigint | number
    currentStorageMb?: bigint | number
    currentProcessingMin?: bigint | number
    periodStart: Date | string
    periodEnd: Date | string
    lastResetAt?: Date | string
    allowOverages?: boolean
    overageCostPerToken?: Decimal | DecimalJsLike | number | string
  }

  export type UserQuotaCreateOrConnectWithoutUserInput = {
    where: UserQuotaWhereUniqueInput
    create: XOR<UserQuotaCreateWithoutUserInput, UserQuotaUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: string
    category?: string | null
    createdAt?: Date | string
    workspace?: WorkspaceCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: string
    category?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SecurityEventCreateWithoutUserInput = {
    id?: string
    eventType: string
    severity?: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SecurityEventUncheckedCreateWithoutUserInput = {
    id?: string
    eventType: string
    severity?: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SecurityEventCreateOrConnectWithoutUserInput = {
    where: SecurityEventWhereUniqueInput
    create: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput>
  }

  export type SecurityEventCreateManyUserInputEnvelope = {
    data: SecurityEventCreateManyUserInput | SecurityEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProcessingTemplateCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    name: string
    description?: string | null
    summaryStyle?: string
    temperature?: number
    maxTokens?: number
    language?: string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessingTemplateUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    name: string
    description?: string | null
    summaryStyle?: string
    temperature?: number
    maxTokens?: number
    language?: string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessingTemplateCreateOrConnectWithoutUserInput = {
    where: ProcessingTemplateWhereUniqueInput
    create: XOR<ProcessingTemplateCreateWithoutUserInput, ProcessingTemplateUncheckedCreateWithoutUserInput>
  }

  export type ProcessingTemplateCreateManyUserInputEnvelope = {
    data: ProcessingTemplateCreateManyUserInput | ProcessingTemplateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomPlanCreateWithoutRequestedByUserInput = {
    id?: string
    workspaceId: string
    planName: string
    description?: string | null
    customMaxTranscriptionsMonthly?: bigint | number | null
    customMaxFilesDaily?: number | null
    customMaxFilesMonthly?: number | null
    customMaxConcurrentJobs?: number | null
    customMaxVoiceSynthesisMonthly?: bigint | number | null
    customMaxExportOperationsMonthly?: number | null
    customMaxAudioDurationMinutes?: number | null
    customPriorityLevel?: number | null
    customFeatures?: CustomPlanCreatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanCreateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanCreateadditionalFeaturesInput | string[]
    customPrice?: Decimal | DecimalJsLike | number | string | null
    pricingModel?: string
    billingInterval?: string
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenew?: boolean
    noticePeriodDays?: number
    approvedBy?: string | null
    approvalStatus?: string
    approvalNotes?: string | null
    isActive?: boolean
    activatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    basePlan?: SubscriptionPlanCreateNestedOneWithoutCustomPlansInput
  }

  export type CustomPlanUncheckedCreateWithoutRequestedByUserInput = {
    id?: string
    workspaceId: string
    basePlanId?: string | null
    planName: string
    description?: string | null
    customMaxTranscriptionsMonthly?: bigint | number | null
    customMaxFilesDaily?: number | null
    customMaxFilesMonthly?: number | null
    customMaxConcurrentJobs?: number | null
    customMaxVoiceSynthesisMonthly?: bigint | number | null
    customMaxExportOperationsMonthly?: number | null
    customMaxAudioDurationMinutes?: number | null
    customPriorityLevel?: number | null
    customFeatures?: CustomPlanCreatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanCreateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanCreateadditionalFeaturesInput | string[]
    customPrice?: Decimal | DecimalJsLike | number | string | null
    pricingModel?: string
    billingInterval?: string
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenew?: boolean
    noticePeriodDays?: number
    approvedBy?: string | null
    approvalStatus?: string
    approvalNotes?: string | null
    isActive?: boolean
    activatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomPlanCreateOrConnectWithoutRequestedByUserInput = {
    where: CustomPlanWhereUniqueInput
    create: XOR<CustomPlanCreateWithoutRequestedByUserInput, CustomPlanUncheckedCreateWithoutRequestedByUserInput>
  }

  export type CustomPlanCreateManyRequestedByUserInputEnvelope = {
    data: CustomPlanCreateManyRequestedByUserInput | CustomPlanCreateManyRequestedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PlanRecommendationCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    recommendationReason: string
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: Decimal | DecimalJsLike | number | string | null
    roiMonths?: number | null
    triggeredBy?: string | null
    benefits?: PlanRecommendationCreatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationCreatelimitationsRemovedInput | string[]
    status?: string
    viewedAt?: Date | string | null
    dismissedAt?: Date | string | null
    acceptedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentPlan: SubscriptionPlanCreateNestedOneWithoutCurrentPlanRecommendationsInput
    recommendedPlan: SubscriptionPlanCreateNestedOneWithoutRecommendedPlanRecommendationsInput
  }

  export type PlanRecommendationUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    currentPlanId: string
    recommendedPlanId: string
    recommendationReason: string
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: Decimal | DecimalJsLike | number | string | null
    roiMonths?: number | null
    triggeredBy?: string | null
    benefits?: PlanRecommendationCreatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationCreatelimitationsRemovedInput | string[]
    status?: string
    viewedAt?: Date | string | null
    dismissedAt?: Date | string | null
    acceptedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanRecommendationCreateOrConnectWithoutUserInput = {
    where: PlanRecommendationWhereUniqueInput
    create: XOR<PlanRecommendationCreateWithoutUserInput, PlanRecommendationUncheckedCreateWithoutUserInput>
  }

  export type PlanRecommendationCreateManyUserInputEnvelope = {
    data: PlanRecommendationCreateManyUserInput | PlanRecommendationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UsageCounterCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    periodType: string
    periodStart: Date | string
    periodEnd: Date | string
    transcriptionsUsed?: number
    filesUploaded?: number
    voiceSynthesisUsed?: number
    exportOperationsUsed?: number
    totalProcessingMinutes?: Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: Date | string
    autoReset?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageCounterUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    periodType: string
    periodStart: Date | string
    periodEnd: Date | string
    transcriptionsUsed?: number
    filesUploaded?: number
    voiceSynthesisUsed?: number
    exportOperationsUsed?: number
    totalProcessingMinutes?: Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: Date | string
    autoReset?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageCounterCreateOrConnectWithoutUserInput = {
    where: UsageCounterWhereUniqueInput
    create: XOR<UsageCounterCreateWithoutUserInput, UsageCounterUncheckedCreateWithoutUserInput>
  }

  export type UsageCounterCreateManyUserInputEnvelope = {
    data: UsageCounterCreateManyUserInput | UsageCounterCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EwayCustomerCreateWithoutUserInput = {
    id?: string
    ewayCustomerToken: string
    firstName: string
    lastName: string
    email: string
    companyName?: string | null
    country?: string
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    cardLastFour?: string | null
    cardType?: string | null
    cardExpiryMonth?: number | null
    cardExpiryYear?: number | null
    ewayReference?: string | null
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: EwayTransactionCreateNestedManyWithoutEwayCustomerInput
    recurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerUncheckedCreateWithoutUserInput = {
    id?: string
    ewayCustomerToken: string
    firstName: string
    lastName: string
    email: string
    companyName?: string | null
    country?: string
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    cardLastFour?: string | null
    cardType?: string | null
    cardExpiryMonth?: number | null
    cardExpiryYear?: number | null
    ewayReference?: string | null
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: EwayTransactionUncheckedCreateNestedManyWithoutEwayCustomerInput
    recurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerCreateOrConnectWithoutUserInput = {
    where: EwayCustomerWhereUniqueInput
    create: XOR<EwayCustomerCreateWithoutUserInput, EwayCustomerUncheckedCreateWithoutUserInput>
  }

  export type EwayCustomerCreateManyUserInputEnvelope = {
    data: EwayCustomerCreateManyUserInput | EwayCustomerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EwayTransactionCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    subscriptionId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    ewayTransactionId?: bigint | number | null
    ewayAccessCode?: string | null
    ewayAuthCode?: string | null
    responseCode?: string | null
    responseMessage?: string | null
    transactionStatus: string
    isRecurring?: boolean
    ewayInvoiceNumber?: string | null
    ewayInvoiceReference?: string | null
    fraudAction?: string | null
    verificationStatus?: string | null
    beagleScore?: number | null
    errorCode?: string | null
    errorMessage?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
    ewayCustomer: EwayCustomerCreateNestedOneWithoutTransactionsInput
  }

  export type EwayTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    ewayCustomerId: string
    subscriptionId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    ewayTransactionId?: bigint | number | null
    ewayAccessCode?: string | null
    ewayAuthCode?: string | null
    responseCode?: string | null
    responseMessage?: string | null
    transactionStatus: string
    isRecurring?: boolean
    ewayInvoiceNumber?: string | null
    ewayInvoiceReference?: string | null
    fraudAction?: string | null
    verificationStatus?: string | null
    beagleScore?: number | null
    errorCode?: string | null
    errorMessage?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayTransactionCreateOrConnectWithoutUserInput = {
    where: EwayTransactionWhereUniqueInput
    create: XOR<EwayTransactionCreateWithoutUserInput, EwayTransactionUncheckedCreateWithoutUserInput>
  }

  export type EwayTransactionCreateManyUserInputEnvelope = {
    data: EwayTransactionCreateManyUserInput | EwayTransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EwayRecurringScheduleCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    subscriptionId: string
    scheduleType: string
    billingAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    startDate: Date | string
    nextBillingDate: Date | string
    lastProcessedAt?: Date | string | null
    status?: string
    failedAttempts?: number
    lastTransactionId?: string | null
    cancelledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ewayCustomer: EwayCustomerCreateNestedOneWithoutRecurringSchedulesInput
  }

  export type EwayRecurringScheduleUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    ewayCustomerId: string
    subscriptionId: string
    scheduleType: string
    billingAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    startDate: Date | string
    nextBillingDate: Date | string
    lastProcessedAt?: Date | string | null
    status?: string
    failedAttempts?: number
    lastTransactionId?: string | null
    cancelledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayRecurringScheduleCreateOrConnectWithoutUserInput = {
    where: EwayRecurringScheduleWhereUniqueInput
    create: XOR<EwayRecurringScheduleCreateWithoutUserInput, EwayRecurringScheduleUncheckedCreateWithoutUserInput>
  }

  export type EwayRecurringScheduleCreateManyUserInputEnvelope = {
    data: EwayRecurringScheduleCreateManyUserInput | EwayRecurringScheduleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: string
    assignedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
    role: RoleCreateNestedOneWithoutUsersInput
    assignedByUser?: UserCreateNestedOneWithoutAssignedRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    roleId: string
    assignedBy?: string | null
    assignedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutAssignedByUserInput = {
    id?: string
    assignedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutUserRolesInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutAssignedByUserInput = {
    id?: string
    userId: string
    roleId: string
    assignedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type UserRoleCreateOrConnectWithoutAssignedByUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutAssignedByUserInput, UserRoleUncheckedCreateWithoutAssignedByUserInput>
  }

  export type UserRoleCreateManyAssignedByUserInputEnvelope = {
    data: UserRoleCreateManyAssignedByUserInput | UserRoleCreateManyAssignedByUserInput[]
    skipDuplicates?: boolean
  }

  export type TestimonialCreateWithoutUserInput = {
    id?: string
    customerName: string
    customerRole?: string | null
    companyName?: string | null
    avatarUrl?: string | null
    content: string
    rating?: number
    featuredOn?: string | null
    useCase?: string | null
    isVerified?: boolean
    verificationMethod?: string | null
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialUncheckedCreateWithoutUserInput = {
    id?: string
    customerName: string
    customerRole?: string | null
    companyName?: string | null
    avatarUrl?: string | null
    content: string
    rating?: number
    featuredOn?: string | null
    useCase?: string | null
    isVerified?: boolean
    verificationMethod?: string | null
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialCreateOrConnectWithoutUserInput = {
    where: TestimonialWhereUniqueInput
    create: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput>
  }

  export type TestimonialCreateManyUserInputEnvelope = {
    data: TestimonialCreateManyUserInput | TestimonialCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AudioHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: AudioHistoryWhereUniqueInput
    update: XOR<AudioHistoryUpdateWithoutUserInput, AudioHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<AudioHistoryCreateWithoutUserInput, AudioHistoryUncheckedCreateWithoutUserInput>
  }

  export type AudioHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: AudioHistoryWhereUniqueInput
    data: XOR<AudioHistoryUpdateWithoutUserInput, AudioHistoryUncheckedUpdateWithoutUserInput>
  }

  export type AudioHistoryUpdateManyWithWhereWithoutUserInput = {
    where: AudioHistoryScalarWhereInput
    data: XOR<AudioHistoryUpdateManyMutationInput, AudioHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    tokenHash?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    openaiApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    elevenlabsApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    summaryQuality?: StringFieldUpdateOperationsInput | string
    defaultSummaryStyle?: StringFieldUpdateOperationsInput | string
    defaultTemperature?: FloatFieldUpdateOperationsInput | number
    defaultMaxTokens?: IntFieldUpdateOperationsInput | number
    showCostEstimates?: BoolFieldUpdateOperationsInput | boolean
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    processingNotifications?: BoolFieldUpdateOperationsInput | boolean
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    openaiApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    elevenlabsApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    summaryQuality?: StringFieldUpdateOperationsInput | string
    defaultSummaryStyle?: StringFieldUpdateOperationsInput | string
    defaultTemperature?: FloatFieldUpdateOperationsInput | number
    defaultMaxTokens?: IntFieldUpdateOperationsInput | number
    showCostEstimates?: BoolFieldUpdateOperationsInput | boolean
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    processingNotifications?: BoolFieldUpdateOperationsInput | boolean
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    update: XOR<WorkspaceUserUpdateWithoutUserInput, WorkspaceUserUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    data: XOR<WorkspaceUserUpdateWithoutUserInput, WorkspaceUserUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceUserUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceUserScalarWhereInput
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
  }

  export type AudioUploadUpsertWithWhereUniqueWithoutUserInput = {
    where: AudioUploadWhereUniqueInput
    update: XOR<AudioUploadUpdateWithoutUserInput, AudioUploadUncheckedUpdateWithoutUserInput>
    create: XOR<AudioUploadCreateWithoutUserInput, AudioUploadUncheckedCreateWithoutUserInput>
  }

  export type AudioUploadUpdateWithWhereUniqueWithoutUserInput = {
    where: AudioUploadWhereUniqueInput
    data: XOR<AudioUploadUpdateWithoutUserInput, AudioUploadUncheckedUpdateWithoutUserInput>
  }

  export type AudioUploadUpdateManyWithWhereWithoutUserInput = {
    where: AudioUploadScalarWhereInput
    data: XOR<AudioUploadUpdateManyMutationInput, AudioUploadUncheckedUpdateManyWithoutUserInput>
  }

  export type AudioProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: AudioProjectWhereUniqueInput
    update: XOR<AudioProjectUpdateWithoutUserInput, AudioProjectUncheckedUpdateWithoutUserInput>
    create: XOR<AudioProjectCreateWithoutUserInput, AudioProjectUncheckedCreateWithoutUserInput>
  }

  export type AudioProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: AudioProjectWhereUniqueInput
    data: XOR<AudioProjectUpdateWithoutUserInput, AudioProjectUncheckedUpdateWithoutUserInput>
  }

  export type AudioProjectUpdateManyWithWhereWithoutUserInput = {
    where: AudioProjectScalarWhereInput
    data: XOR<AudioProjectUpdateManyMutationInput, AudioProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type ProcessingJobUpsertWithWhereUniqueWithoutUserInput = {
    where: ProcessingJobWhereUniqueInput
    update: XOR<ProcessingJobUpdateWithoutUserInput, ProcessingJobUncheckedUpdateWithoutUserInput>
    create: XOR<ProcessingJobCreateWithoutUserInput, ProcessingJobUncheckedCreateWithoutUserInput>
  }

  export type ProcessingJobUpdateWithWhereUniqueWithoutUserInput = {
    where: ProcessingJobWhereUniqueInput
    data: XOR<ProcessingJobUpdateWithoutUserInput, ProcessingJobUncheckedUpdateWithoutUserInput>
  }

  export type ProcessingJobUpdateManyWithWhereWithoutUserInput = {
    where: ProcessingJobScalarWhereInput
    data: XOR<ProcessingJobUpdateManyMutationInput, ProcessingJobUncheckedUpdateManyWithoutUserInput>
  }

  export type ProcessingJobScalarWhereInput = {
    AND?: ProcessingJobScalarWhereInput | ProcessingJobScalarWhereInput[]
    OR?: ProcessingJobScalarWhereInput[]
    NOT?: ProcessingJobScalarWhereInput | ProcessingJobScalarWhereInput[]
    id?: StringFilter<"ProcessingJob"> | string
    userId?: StringFilter<"ProcessingJob"> | string
    uploadId?: StringFilter<"ProcessingJob"> | string
    jobType?: StringFilter<"ProcessingJob"> | string
    priority?: IntFilter<"ProcessingJob"> | number
    processingOptions?: JsonFilter<"ProcessingJob">
    status?: StringFilter<"ProcessingJob"> | string
    progress?: FloatFilter<"ProcessingJob"> | number
    cpuTimeMs?: BigIntNullableFilter<"ProcessingJob"> | bigint | number | null
    memoryUsageMb?: IntNullableFilter<"ProcessingJob"> | number | null
    queuedAt?: DateTimeFilter<"ProcessingJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"ProcessingJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProcessingJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"ProcessingJob"> | string | null
    retryCount?: IntFilter<"ProcessingJob"> | number
    maxRetries?: IntFilter<"ProcessingJob"> | number
  }

  export type UsageMetricUpsertWithWhereUniqueWithoutUserInput = {
    where: UsageMetricWhereUniqueInput
    update: XOR<UsageMetricUpdateWithoutUserInput, UsageMetricUncheckedUpdateWithoutUserInput>
    create: XOR<UsageMetricCreateWithoutUserInput, UsageMetricUncheckedCreateWithoutUserInput>
  }

  export type UsageMetricUpdateWithWhereUniqueWithoutUserInput = {
    where: UsageMetricWhereUniqueInput
    data: XOR<UsageMetricUpdateWithoutUserInput, UsageMetricUncheckedUpdateWithoutUserInput>
  }

  export type UsageMetricUpdateManyWithWhereWithoutUserInput = {
    where: UsageMetricScalarWhereInput
    data: XOR<UsageMetricUpdateManyMutationInput, UsageMetricUncheckedUpdateManyWithoutUserInput>
  }

  export type ExportHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: ExportHistoryWhereUniqueInput
    update: XOR<ExportHistoryUpdateWithoutUserInput, ExportHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<ExportHistoryCreateWithoutUserInput, ExportHistoryUncheckedCreateWithoutUserInput>
  }

  export type ExportHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: ExportHistoryWhereUniqueInput
    data: XOR<ExportHistoryUpdateWithoutUserInput, ExportHistoryUncheckedUpdateWithoutUserInput>
  }

  export type ExportHistoryUpdateManyWithWhereWithoutUserInput = {
    where: ExportHistoryScalarWhereInput
    data: XOR<ExportHistoryUpdateManyMutationInput, ExportHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type ExportHistoryScalarWhereInput = {
    AND?: ExportHistoryScalarWhereInput | ExportHistoryScalarWhereInput[]
    OR?: ExportHistoryScalarWhereInput[]
    NOT?: ExportHistoryScalarWhereInput | ExportHistoryScalarWhereInput[]
    id?: StringFilter<"ExportHistory"> | string
    userId?: StringFilter<"ExportHistory"> | string
    exportType?: StringFilter<"ExportHistory"> | string
    dataType?: StringFilter<"ExportHistory"> | string
    dateFrom?: DateTimeNullableFilter<"ExportHistory"> | Date | string | null
    dateTo?: DateTimeNullableFilter<"ExportHistory"> | Date | string | null
    workspaceIds?: StringNullableListFilter<"ExportHistory">
    filters?: JsonNullableFilter<"ExportHistory">
    filename?: StringFilter<"ExportHistory"> | string
    fileSize?: BigIntFilter<"ExportHistory"> | bigint | number
    storagePath?: StringNullableFilter<"ExportHistory"> | string | null
    downloadUrl?: StringNullableFilter<"ExportHistory"> | string | null
    expiresAt?: DateTimeNullableFilter<"ExportHistory"> | Date | string | null
    status?: StringFilter<"ExportHistory"> | string
    downloadCount?: IntFilter<"ExportHistory"> | number
    createdAt?: DateTimeFilter<"ExportHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"ExportHistory"> | Date | string | null
  }

  export type ApiKeyManagementUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyManagementWhereUniqueInput
    update: XOR<ApiKeyManagementUpdateWithoutUserInput, ApiKeyManagementUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyManagementCreateWithoutUserInput, ApiKeyManagementUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyManagementUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyManagementWhereUniqueInput
    data: XOR<ApiKeyManagementUpdateWithoutUserInput, ApiKeyManagementUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyManagementUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyManagementScalarWhereInput
    data: XOR<ApiKeyManagementUpdateManyMutationInput, ApiKeyManagementUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyManagementScalarWhereInput = {
    AND?: ApiKeyManagementScalarWhereInput | ApiKeyManagementScalarWhereInput[]
    OR?: ApiKeyManagementScalarWhereInput[]
    NOT?: ApiKeyManagementScalarWhereInput | ApiKeyManagementScalarWhereInput[]
    id?: StringFilter<"ApiKeyManagement"> | string
    userId?: StringFilter<"ApiKeyManagement"> | string
    workspaceId?: StringNullableFilter<"ApiKeyManagement"> | string | null
    provider?: StringFilter<"ApiKeyManagement"> | string
    keyName?: StringFilter<"ApiKeyManagement"> | string
    encryptedKey?: StringFilter<"ApiKeyManagement"> | string
    keyHash?: StringFilter<"ApiKeyManagement"> | string
    isActive?: BoolFilter<"ApiKeyManagement"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"ApiKeyManagement"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKeyManagement"> | Date | string | null
    totalRequests?: BigIntFilter<"ApiKeyManagement"> | bigint | number
    totalTokens?: BigIntFilter<"ApiKeyManagement"> | bigint | number
    totalCost?: DecimalFilter<"ApiKeyManagement"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ApiKeyManagement"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKeyManagement"> | Date | string
  }

  export type UserQuotaUpsertWithoutUserInput = {
    update: XOR<UserQuotaUpdateWithoutUserInput, UserQuotaUncheckedUpdateWithoutUserInput>
    create: XOR<UserQuotaCreateWithoutUserInput, UserQuotaUncheckedCreateWithoutUserInput>
    where?: UserQuotaWhereInput
  }

  export type UserQuotaUpdateToOneWithWhereWithoutUserInput = {
    where?: UserQuotaWhereInput
    data: XOR<UserQuotaUpdateWithoutUserInput, UserQuotaUncheckedUpdateWithoutUserInput>
  }

  export type UserQuotaUpdateWithoutUserInput = {
    monthlyApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    currentApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    currentTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    currentStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    currentProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowOverages?: BoolFieldUpdateOperationsInput | boolean
    overageCostPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserQuotaUncheckedUpdateWithoutUserInput = {
    monthlyApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    monthlyProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    currentApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    currentTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    currentStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    currentProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowOverages?: BoolFieldUpdateOperationsInput | boolean
    overageCostPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type SecurityEventUpsertWithWhereUniqueWithoutUserInput = {
    where: SecurityEventWhereUniqueInput
    update: XOR<SecurityEventUpdateWithoutUserInput, SecurityEventUncheckedUpdateWithoutUserInput>
    create: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput>
  }

  export type SecurityEventUpdateWithWhereUniqueWithoutUserInput = {
    where: SecurityEventWhereUniqueInput
    data: XOR<SecurityEventUpdateWithoutUserInput, SecurityEventUncheckedUpdateWithoutUserInput>
  }

  export type SecurityEventUpdateManyWithWhereWithoutUserInput = {
    where: SecurityEventScalarWhereInput
    data: XOR<SecurityEventUpdateManyMutationInput, SecurityEventUncheckedUpdateManyWithoutUserInput>
  }

  export type SecurityEventScalarWhereInput = {
    AND?: SecurityEventScalarWhereInput | SecurityEventScalarWhereInput[]
    OR?: SecurityEventScalarWhereInput[]
    NOT?: SecurityEventScalarWhereInput | SecurityEventScalarWhereInput[]
    id?: StringFilter<"SecurityEvent"> | string
    userId?: StringNullableFilter<"SecurityEvent"> | string | null
    eventType?: StringFilter<"SecurityEvent"> | string
    severity?: StringFilter<"SecurityEvent"> | string
    description?: StringNullableFilter<"SecurityEvent"> | string | null
    metadata?: JsonNullableFilter<"SecurityEvent">
    ipAddress?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"SecurityEvent"> | Date | string | null
  }

  export type ProcessingTemplateUpsertWithWhereUniqueWithoutUserInput = {
    where: ProcessingTemplateWhereUniqueInput
    update: XOR<ProcessingTemplateUpdateWithoutUserInput, ProcessingTemplateUncheckedUpdateWithoutUserInput>
    create: XOR<ProcessingTemplateCreateWithoutUserInput, ProcessingTemplateUncheckedCreateWithoutUserInput>
  }

  export type ProcessingTemplateUpdateWithWhereUniqueWithoutUserInput = {
    where: ProcessingTemplateWhereUniqueInput
    data: XOR<ProcessingTemplateUpdateWithoutUserInput, ProcessingTemplateUncheckedUpdateWithoutUserInput>
  }

  export type ProcessingTemplateUpdateManyWithWhereWithoutUserInput = {
    where: ProcessingTemplateScalarWhereInput
    data: XOR<ProcessingTemplateUpdateManyMutationInput, ProcessingTemplateUncheckedUpdateManyWithoutUserInput>
  }

  export type ProcessingTemplateScalarWhereInput = {
    AND?: ProcessingTemplateScalarWhereInput | ProcessingTemplateScalarWhereInput[]
    OR?: ProcessingTemplateScalarWhereInput[]
    NOT?: ProcessingTemplateScalarWhereInput | ProcessingTemplateScalarWhereInput[]
    id?: StringFilter<"ProcessingTemplate"> | string
    userId?: StringFilter<"ProcessingTemplate"> | string
    workspaceId?: StringNullableFilter<"ProcessingTemplate"> | string | null
    name?: StringFilter<"ProcessingTemplate"> | string
    description?: StringNullableFilter<"ProcessingTemplate"> | string | null
    summaryStyle?: StringFilter<"ProcessingTemplate"> | string
    temperature?: FloatFilter<"ProcessingTemplate"> | number
    maxTokens?: IntFilter<"ProcessingTemplate"> | number
    language?: StringFilter<"ProcessingTemplate"> | string
    configJson?: JsonFilter<"ProcessingTemplate">
    isPublic?: BoolFilter<"ProcessingTemplate"> | boolean
    createdAt?: DateTimeFilter<"ProcessingTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessingTemplate"> | Date | string
  }

  export type CustomPlanUpsertWithWhereUniqueWithoutRequestedByUserInput = {
    where: CustomPlanWhereUniqueInput
    update: XOR<CustomPlanUpdateWithoutRequestedByUserInput, CustomPlanUncheckedUpdateWithoutRequestedByUserInput>
    create: XOR<CustomPlanCreateWithoutRequestedByUserInput, CustomPlanUncheckedCreateWithoutRequestedByUserInput>
  }

  export type CustomPlanUpdateWithWhereUniqueWithoutRequestedByUserInput = {
    where: CustomPlanWhereUniqueInput
    data: XOR<CustomPlanUpdateWithoutRequestedByUserInput, CustomPlanUncheckedUpdateWithoutRequestedByUserInput>
  }

  export type CustomPlanUpdateManyWithWhereWithoutRequestedByUserInput = {
    where: CustomPlanScalarWhereInput
    data: XOR<CustomPlanUpdateManyMutationInput, CustomPlanUncheckedUpdateManyWithoutRequestedByUserInput>
  }

  export type CustomPlanScalarWhereInput = {
    AND?: CustomPlanScalarWhereInput | CustomPlanScalarWhereInput[]
    OR?: CustomPlanScalarWhereInput[]
    NOT?: CustomPlanScalarWhereInput | CustomPlanScalarWhereInput[]
    id?: StringFilter<"CustomPlan"> | string
    workspaceId?: StringFilter<"CustomPlan"> | string
    basePlanId?: StringNullableFilter<"CustomPlan"> | string | null
    planName?: StringFilter<"CustomPlan"> | string
    description?: StringNullableFilter<"CustomPlan"> | string | null
    customMaxTranscriptionsMonthly?: BigIntNullableFilter<"CustomPlan"> | bigint | number | null
    customMaxFilesDaily?: IntNullableFilter<"CustomPlan"> | number | null
    customMaxFilesMonthly?: IntNullableFilter<"CustomPlan"> | number | null
    customMaxConcurrentJobs?: IntNullableFilter<"CustomPlan"> | number | null
    customMaxVoiceSynthesisMonthly?: BigIntNullableFilter<"CustomPlan"> | bigint | number | null
    customMaxExportOperationsMonthly?: IntNullableFilter<"CustomPlan"> | number | null
    customMaxAudioDurationMinutes?: IntNullableFilter<"CustomPlan"> | number | null
    customPriorityLevel?: IntNullableFilter<"CustomPlan"> | number | null
    customFeatures?: StringNullableListFilter<"CustomPlan">
    excludedFeatures?: StringNullableListFilter<"CustomPlan">
    additionalFeatures?: StringNullableListFilter<"CustomPlan">
    customPrice?: DecimalNullableFilter<"CustomPlan"> | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFilter<"CustomPlan"> | string
    billingInterval?: StringFilter<"CustomPlan"> | string
    contractStartDate?: DateTimeNullableFilter<"CustomPlan"> | Date | string | null
    contractEndDate?: DateTimeNullableFilter<"CustomPlan"> | Date | string | null
    autoRenew?: BoolFilter<"CustomPlan"> | boolean
    noticePeriodDays?: IntFilter<"CustomPlan"> | number
    requestedBy?: StringNullableFilter<"CustomPlan"> | string | null
    approvedBy?: StringNullableFilter<"CustomPlan"> | string | null
    approvalStatus?: StringFilter<"CustomPlan"> | string
    approvalNotes?: StringNullableFilter<"CustomPlan"> | string | null
    isActive?: BoolFilter<"CustomPlan"> | boolean
    activatedAt?: DateTimeNullableFilter<"CustomPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"CustomPlan"> | Date | string
    updatedAt?: DateTimeFilter<"CustomPlan"> | Date | string
  }

  export type PlanRecommendationUpsertWithWhereUniqueWithoutUserInput = {
    where: PlanRecommendationWhereUniqueInput
    update: XOR<PlanRecommendationUpdateWithoutUserInput, PlanRecommendationUncheckedUpdateWithoutUserInput>
    create: XOR<PlanRecommendationCreateWithoutUserInput, PlanRecommendationUncheckedCreateWithoutUserInput>
  }

  export type PlanRecommendationUpdateWithWhereUniqueWithoutUserInput = {
    where: PlanRecommendationWhereUniqueInput
    data: XOR<PlanRecommendationUpdateWithoutUserInput, PlanRecommendationUncheckedUpdateWithoutUserInput>
  }

  export type PlanRecommendationUpdateManyWithWhereWithoutUserInput = {
    where: PlanRecommendationScalarWhereInput
    data: XOR<PlanRecommendationUpdateManyMutationInput, PlanRecommendationUncheckedUpdateManyWithoutUserInput>
  }

  export type PlanRecommendationScalarWhereInput = {
    AND?: PlanRecommendationScalarWhereInput | PlanRecommendationScalarWhereInput[]
    OR?: PlanRecommendationScalarWhereInput[]
    NOT?: PlanRecommendationScalarWhereInput | PlanRecommendationScalarWhereInput[]
    id?: StringFilter<"PlanRecommendation"> | string
    userId?: StringFilter<"PlanRecommendation"> | string
    workspaceId?: StringNullableFilter<"PlanRecommendation"> | string | null
    currentPlanId?: StringFilter<"PlanRecommendation"> | string
    recommendedPlanId?: StringFilter<"PlanRecommendation"> | string
    recommendationReason?: StringFilter<"PlanRecommendation"> | string
    confidenceScore?: DecimalNullableFilter<"PlanRecommendation"> | Decimal | DecimalJsLike | number | string | null
    usagePattern?: JsonNullableFilter<"PlanRecommendation">
    projectedSavings?: DecimalNullableFilter<"PlanRecommendation"> | Decimal | DecimalJsLike | number | string | null
    roiMonths?: IntNullableFilter<"PlanRecommendation"> | number | null
    triggeredBy?: StringNullableFilter<"PlanRecommendation"> | string | null
    benefits?: StringNullableListFilter<"PlanRecommendation">
    limitationsRemoved?: StringNullableListFilter<"PlanRecommendation">
    status?: StringFilter<"PlanRecommendation"> | string
    viewedAt?: DateTimeNullableFilter<"PlanRecommendation"> | Date | string | null
    dismissedAt?: DateTimeNullableFilter<"PlanRecommendation"> | Date | string | null
    acceptedAt?: DateTimeNullableFilter<"PlanRecommendation"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"PlanRecommendation"> | Date | string | null
    createdAt?: DateTimeFilter<"PlanRecommendation"> | Date | string
    updatedAt?: DateTimeFilter<"PlanRecommendation"> | Date | string
  }

  export type UsageCounterUpsertWithWhereUniqueWithoutUserInput = {
    where: UsageCounterWhereUniqueInput
    update: XOR<UsageCounterUpdateWithoutUserInput, UsageCounterUncheckedUpdateWithoutUserInput>
    create: XOR<UsageCounterCreateWithoutUserInput, UsageCounterUncheckedCreateWithoutUserInput>
  }

  export type UsageCounterUpdateWithWhereUniqueWithoutUserInput = {
    where: UsageCounterWhereUniqueInput
    data: XOR<UsageCounterUpdateWithoutUserInput, UsageCounterUncheckedUpdateWithoutUserInput>
  }

  export type UsageCounterUpdateManyWithWhereWithoutUserInput = {
    where: UsageCounterScalarWhereInput
    data: XOR<UsageCounterUpdateManyMutationInput, UsageCounterUncheckedUpdateManyWithoutUserInput>
  }

  export type UsageCounterScalarWhereInput = {
    AND?: UsageCounterScalarWhereInput | UsageCounterScalarWhereInput[]
    OR?: UsageCounterScalarWhereInput[]
    NOT?: UsageCounterScalarWhereInput | UsageCounterScalarWhereInput[]
    id?: StringFilter<"UsageCounter"> | string
    userId?: StringFilter<"UsageCounter"> | string
    workspaceId?: StringNullableFilter<"UsageCounter"> | string | null
    periodType?: StringFilter<"UsageCounter"> | string
    periodStart?: DateTimeFilter<"UsageCounter"> | Date | string
    periodEnd?: DateTimeFilter<"UsageCounter"> | Date | string
    transcriptionsUsed?: IntFilter<"UsageCounter"> | number
    filesUploaded?: IntFilter<"UsageCounter"> | number
    voiceSynthesisUsed?: IntFilter<"UsageCounter"> | number
    exportOperationsUsed?: IntFilter<"UsageCounter"> | number
    totalProcessingMinutes?: DecimalFilter<"UsageCounter"> | Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: IntFilter<"UsageCounter"> | number
    featureUsage?: JsonFilter<"UsageCounter">
    lastResetAt?: DateTimeFilter<"UsageCounter"> | Date | string
    autoReset?: BoolFilter<"UsageCounter"> | boolean
    createdAt?: DateTimeFilter<"UsageCounter"> | Date | string
    updatedAt?: DateTimeFilter<"UsageCounter"> | Date | string
  }

  export type EwayCustomerUpsertWithWhereUniqueWithoutUserInput = {
    where: EwayCustomerWhereUniqueInput
    update: XOR<EwayCustomerUpdateWithoutUserInput, EwayCustomerUncheckedUpdateWithoutUserInput>
    create: XOR<EwayCustomerCreateWithoutUserInput, EwayCustomerUncheckedCreateWithoutUserInput>
  }

  export type EwayCustomerUpdateWithWhereUniqueWithoutUserInput = {
    where: EwayCustomerWhereUniqueInput
    data: XOR<EwayCustomerUpdateWithoutUserInput, EwayCustomerUncheckedUpdateWithoutUserInput>
  }

  export type EwayCustomerUpdateManyWithWhereWithoutUserInput = {
    where: EwayCustomerScalarWhereInput
    data: XOR<EwayCustomerUpdateManyMutationInput, EwayCustomerUncheckedUpdateManyWithoutUserInput>
  }

  export type EwayCustomerScalarWhereInput = {
    AND?: EwayCustomerScalarWhereInput | EwayCustomerScalarWhereInput[]
    OR?: EwayCustomerScalarWhereInput[]
    NOT?: EwayCustomerScalarWhereInput | EwayCustomerScalarWhereInput[]
    id?: StringFilter<"EwayCustomer"> | string
    userId?: StringFilter<"EwayCustomer"> | string
    ewayCustomerToken?: StringFilter<"EwayCustomer"> | string
    firstName?: StringFilter<"EwayCustomer"> | string
    lastName?: StringFilter<"EwayCustomer"> | string
    email?: StringFilter<"EwayCustomer"> | string
    companyName?: StringNullableFilter<"EwayCustomer"> | string | null
    country?: StringFilter<"EwayCustomer"> | string
    streetAddress?: StringNullableFilter<"EwayCustomer"> | string | null
    city?: StringNullableFilter<"EwayCustomer"> | string | null
    state?: StringNullableFilter<"EwayCustomer"> | string | null
    postalCode?: StringNullableFilter<"EwayCustomer"> | string | null
    phoneNumber?: StringNullableFilter<"EwayCustomer"> | string | null
    cardLastFour?: StringNullableFilter<"EwayCustomer"> | string | null
    cardType?: StringNullableFilter<"EwayCustomer"> | string | null
    cardExpiryMonth?: IntNullableFilter<"EwayCustomer"> | number | null
    cardExpiryYear?: IntNullableFilter<"EwayCustomer"> | number | null
    ewayReference?: StringNullableFilter<"EwayCustomer"> | string | null
    isActive?: BoolFilter<"EwayCustomer"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"EwayCustomer"> | Date | string | null
    createdAt?: DateTimeFilter<"EwayCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"EwayCustomer"> | Date | string
  }

  export type EwayTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: EwayTransactionWhereUniqueInput
    update: XOR<EwayTransactionUpdateWithoutUserInput, EwayTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<EwayTransactionCreateWithoutUserInput, EwayTransactionUncheckedCreateWithoutUserInput>
  }

  export type EwayTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: EwayTransactionWhereUniqueInput
    data: XOR<EwayTransactionUpdateWithoutUserInput, EwayTransactionUncheckedUpdateWithoutUserInput>
  }

  export type EwayTransactionUpdateManyWithWhereWithoutUserInput = {
    where: EwayTransactionScalarWhereInput
    data: XOR<EwayTransactionUpdateManyMutationInput, EwayTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type EwayTransactionScalarWhereInput = {
    AND?: EwayTransactionScalarWhereInput | EwayTransactionScalarWhereInput[]
    OR?: EwayTransactionScalarWhereInput[]
    NOT?: EwayTransactionScalarWhereInput | EwayTransactionScalarWhereInput[]
    id?: StringFilter<"EwayTransaction"> | string
    userId?: StringFilter<"EwayTransaction"> | string
    workspaceId?: StringNullableFilter<"EwayTransaction"> | string | null
    ewayCustomerId?: StringFilter<"EwayTransaction"> | string
    subscriptionId?: StringNullableFilter<"EwayTransaction"> | string | null
    transactionType?: StringFilter<"EwayTransaction"> | string
    amount?: DecimalFilter<"EwayTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"EwayTransaction"> | string
    ewayTransactionId?: BigIntNullableFilter<"EwayTransaction"> | bigint | number | null
    ewayAccessCode?: StringNullableFilter<"EwayTransaction"> | string | null
    ewayAuthCode?: StringNullableFilter<"EwayTransaction"> | string | null
    responseCode?: StringNullableFilter<"EwayTransaction"> | string | null
    responseMessage?: StringNullableFilter<"EwayTransaction"> | string | null
    transactionStatus?: StringFilter<"EwayTransaction"> | string
    isRecurring?: BoolFilter<"EwayTransaction"> | boolean
    ewayInvoiceNumber?: StringNullableFilter<"EwayTransaction"> | string | null
    ewayInvoiceReference?: StringNullableFilter<"EwayTransaction"> | string | null
    fraudAction?: StringNullableFilter<"EwayTransaction"> | string | null
    verificationStatus?: StringNullableFilter<"EwayTransaction"> | string | null
    beagleScore?: FloatNullableFilter<"EwayTransaction"> | number | null
    errorCode?: StringNullableFilter<"EwayTransaction"> | string | null
    errorMessage?: StringNullableFilter<"EwayTransaction"> | string | null
    processedAt?: DateTimeNullableFilter<"EwayTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"EwayTransaction"> | Date | string
    ewayRawResponse?: JsonNullableFilter<"EwayTransaction">
  }

  export type EwayRecurringScheduleUpsertWithWhereUniqueWithoutUserInput = {
    where: EwayRecurringScheduleWhereUniqueInput
    update: XOR<EwayRecurringScheduleUpdateWithoutUserInput, EwayRecurringScheduleUncheckedUpdateWithoutUserInput>
    create: XOR<EwayRecurringScheduleCreateWithoutUserInput, EwayRecurringScheduleUncheckedCreateWithoutUserInput>
  }

  export type EwayRecurringScheduleUpdateWithWhereUniqueWithoutUserInput = {
    where: EwayRecurringScheduleWhereUniqueInput
    data: XOR<EwayRecurringScheduleUpdateWithoutUserInput, EwayRecurringScheduleUncheckedUpdateWithoutUserInput>
  }

  export type EwayRecurringScheduleUpdateManyWithWhereWithoutUserInput = {
    where: EwayRecurringScheduleScalarWhereInput
    data: XOR<EwayRecurringScheduleUpdateManyMutationInput, EwayRecurringScheduleUncheckedUpdateManyWithoutUserInput>
  }

  export type EwayRecurringScheduleScalarWhereInput = {
    AND?: EwayRecurringScheduleScalarWhereInput | EwayRecurringScheduleScalarWhereInput[]
    OR?: EwayRecurringScheduleScalarWhereInput[]
    NOT?: EwayRecurringScheduleScalarWhereInput | EwayRecurringScheduleScalarWhereInput[]
    id?: StringFilter<"EwayRecurringSchedule"> | string
    userId?: StringFilter<"EwayRecurringSchedule"> | string
    workspaceId?: StringNullableFilter<"EwayRecurringSchedule"> | string | null
    ewayCustomerId?: StringFilter<"EwayRecurringSchedule"> | string
    subscriptionId?: StringFilter<"EwayRecurringSchedule"> | string
    scheduleType?: StringFilter<"EwayRecurringSchedule"> | string
    billingAmount?: DecimalFilter<"EwayRecurringSchedule"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"EwayRecurringSchedule"> | string
    startDate?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    nextBillingDate?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    lastProcessedAt?: DateTimeNullableFilter<"EwayRecurringSchedule"> | Date | string | null
    status?: StringFilter<"EwayRecurringSchedule"> | string
    failedAttempts?: IntFilter<"EwayRecurringSchedule"> | number
    lastTransactionId?: StringNullableFilter<"EwayRecurringSchedule"> | string | null
    cancelledAt?: DateTimeNullableFilter<"EwayRecurringSchedule"> | Date | string | null
    metadata?: JsonNullableFilter<"EwayRecurringSchedule">
    createdAt?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedBy?: StringNullableFilter<"UserRole"> | string | null
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    expiresAt?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    isActive?: BoolFilter<"UserRole"> | boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutAssignedByUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutAssignedByUserInput, UserRoleUncheckedUpdateWithoutAssignedByUserInput>
    create: XOR<UserRoleCreateWithoutAssignedByUserInput, UserRoleUncheckedCreateWithoutAssignedByUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutAssignedByUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutAssignedByUserInput, UserRoleUncheckedUpdateWithoutAssignedByUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutAssignedByUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutAssignedByUserInput>
  }

  export type TestimonialUpsertWithWhereUniqueWithoutUserInput = {
    where: TestimonialWhereUniqueInput
    update: XOR<TestimonialUpdateWithoutUserInput, TestimonialUncheckedUpdateWithoutUserInput>
    create: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput>
  }

  export type TestimonialUpdateWithWhereUniqueWithoutUserInput = {
    where: TestimonialWhereUniqueInput
    data: XOR<TestimonialUpdateWithoutUserInput, TestimonialUncheckedUpdateWithoutUserInput>
  }

  export type TestimonialUpdateManyWithWhereWithoutUserInput = {
    where: TestimonialScalarWhereInput
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyWithoutUserInput>
  }

  export type TestimonialScalarWhereInput = {
    AND?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
    OR?: TestimonialScalarWhereInput[]
    NOT?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
    id?: StringFilter<"Testimonial"> | string
    customerName?: StringFilter<"Testimonial"> | string
    customerRole?: StringNullableFilter<"Testimonial"> | string | null
    companyName?: StringNullableFilter<"Testimonial"> | string | null
    avatarUrl?: StringNullableFilter<"Testimonial"> | string | null
    content?: StringFilter<"Testimonial"> | string
    rating?: IntFilter<"Testimonial"> | number
    featuredOn?: StringNullableFilter<"Testimonial"> | string | null
    useCase?: StringNullableFilter<"Testimonial"> | string | null
    isVerified?: BoolFilter<"Testimonial"> | boolean
    verificationMethod?: StringNullableFilter<"Testimonial"> | string | null
    isActive?: BoolFilter<"Testimonial"> | boolean
    displayOrder?: IntFilter<"Testimonial"> | number
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
    userId?: StringNullableFilter<"Testimonial"> | string | null
  }

  export type WorkspaceCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsUncheckedCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaUncheckedCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutUsersInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutWorkspacesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkspacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
  }

  export type WorkspaceUpsertWithoutUsersInput = {
    update: XOR<WorkspaceUpdateWithoutUsersInput, WorkspaceUncheckedUpdateWithoutUsersInput>
    create: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutUsersInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutUsersInput, WorkspaceUncheckedUpdateWithoutUsersInput>
  }

  export type WorkspaceUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUncheckedUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUncheckedUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutWorkspacesInput = {
    update: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type UserUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutInvitationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsUncheckedCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaUncheckedCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutInvitationsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
  }

  export type WorkspaceUpsertWithoutInvitationsInput = {
    update: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
    create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
  }

  export type WorkspaceUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUncheckedUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUncheckedUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSecurityEventsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSecurityEventsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSecurityEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSecurityEventsInput, UserUncheckedCreateWithoutSecurityEventsInput>
  }

  export type UserUpsertWithoutSecurityEventsInput = {
    update: XOR<UserUpdateWithoutSecurityEventsInput, UserUncheckedUpdateWithoutSecurityEventsInput>
    create: XOR<UserCreateWithoutSecurityEventsInput, UserUncheckedCreateWithoutSecurityEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSecurityEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSecurityEventsInput, UserUncheckedUpdateWithoutSecurityEventsInput>
  }

  export type UserUpdateWithoutSecurityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSecurityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSettingsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpsertWithoutSettingsInput = {
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutSettingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectCreateNestedManyWithoutWorkspaceInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutSettingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaUncheckedCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutSettingsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutSettingsInput, WorkspaceUncheckedCreateWithoutSettingsInput>
  }

  export type WorkspaceUpsertWithoutSettingsInput = {
    update: XOR<WorkspaceUpdateWithoutSettingsInput, WorkspaceUncheckedUpdateWithoutSettingsInput>
    create: XOR<WorkspaceCreateWithoutSettingsInput, WorkspaceUncheckedCreateWithoutSettingsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutSettingsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutSettingsInput, WorkspaceUncheckedUpdateWithoutSettingsInput>
  }

  export type WorkspaceUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUpdateManyWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUncheckedUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutProcessingTemplatesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProcessingTemplatesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProcessingTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessingTemplatesInput, UserUncheckedCreateWithoutProcessingTemplatesInput>
  }

  export type UserUpsertWithoutProcessingTemplatesInput = {
    update: XOR<UserUpdateWithoutProcessingTemplatesInput, UserUncheckedUpdateWithoutProcessingTemplatesInput>
    create: XOR<UserCreateWithoutProcessingTemplatesInput, UserUncheckedCreateWithoutProcessingTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessingTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessingTemplatesInput, UserUncheckedUpdateWithoutProcessingTemplatesInput>
  }

  export type UserUpdateWithoutProcessingTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessingTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutApiKeysInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAudioUploadsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAudioUploadsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAudioUploadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAudioUploadsInput, UserUncheckedCreateWithoutAudioUploadsInput>
  }

  export type WorkspaceCreateWithoutAudioUploadsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAudioUploadsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsUncheckedCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaUncheckedCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAudioUploadsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAudioUploadsInput, WorkspaceUncheckedCreateWithoutAudioUploadsInput>
  }

  export type AudioHistoryCreateWithoutUploadInput = {
    id?: string
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAudioHistoryInput
    workspace?: WorkspaceCreateNestedOneWithoutAudioHistoryInput
    segments?: AudioSegmentCreateNestedManyWithoutHistoryInput
  }

  export type AudioHistoryUncheckedCreateWithoutUploadInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    segments?: AudioSegmentUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type AudioHistoryCreateOrConnectWithoutUploadInput = {
    where: AudioHistoryWhereUniqueInput
    create: XOR<AudioHistoryCreateWithoutUploadInput, AudioHistoryUncheckedCreateWithoutUploadInput>
  }

  export type AudioHistoryCreateManyUploadInputEnvelope = {
    data: AudioHistoryCreateManyUploadInput | AudioHistoryCreateManyUploadInput[]
    skipDuplicates?: boolean
  }

  export type ProcessingJobCreateWithoutUploadInput = {
    id?: string
    jobType: string
    priority?: number
    processingOptions: JsonNullValueInput | InputJsonValue
    status?: string
    progress?: number
    cpuTimeMs?: bigint | number | null
    memoryUsageMb?: number | null
    queuedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    maxRetries?: number
    user: UserCreateNestedOneWithoutProcessingJobsInput
  }

  export type ProcessingJobUncheckedCreateWithoutUploadInput = {
    id?: string
    userId: string
    jobType: string
    priority?: number
    processingOptions: JsonNullValueInput | InputJsonValue
    status?: string
    progress?: number
    cpuTimeMs?: bigint | number | null
    memoryUsageMb?: number | null
    queuedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    maxRetries?: number
  }

  export type ProcessingJobCreateOrConnectWithoutUploadInput = {
    where: ProcessingJobWhereUniqueInput
    create: XOR<ProcessingJobCreateWithoutUploadInput, ProcessingJobUncheckedCreateWithoutUploadInput>
  }

  export type ProcessingJobCreateManyUploadInputEnvelope = {
    data: ProcessingJobCreateManyUploadInput | ProcessingJobCreateManyUploadInput[]
    skipDuplicates?: boolean
  }

  export type AudioChunkCreateWithoutUploadInput = {
    id?: string
    chunkIndex: number
    startTime: number
    endTime: number
    fileSize: bigint | number
    storagePath: string
    checksumMd5?: string | null
    status?: string
    processedAt?: Date | string | null
  }

  export type AudioChunkUncheckedCreateWithoutUploadInput = {
    id?: string
    chunkIndex: number
    startTime: number
    endTime: number
    fileSize: bigint | number
    storagePath: string
    checksumMd5?: string | null
    status?: string
    processedAt?: Date | string | null
  }

  export type AudioChunkCreateOrConnectWithoutUploadInput = {
    where: AudioChunkWhereUniqueInput
    create: XOR<AudioChunkCreateWithoutUploadInput, AudioChunkUncheckedCreateWithoutUploadInput>
  }

  export type AudioChunkCreateManyUploadInputEnvelope = {
    data: AudioChunkCreateManyUploadInput | AudioChunkCreateManyUploadInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAudioUploadsInput = {
    update: XOR<UserUpdateWithoutAudioUploadsInput, UserUncheckedUpdateWithoutAudioUploadsInput>
    create: XOR<UserCreateWithoutAudioUploadsInput, UserUncheckedCreateWithoutAudioUploadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAudioUploadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAudioUploadsInput, UserUncheckedUpdateWithoutAudioUploadsInput>
  }

  export type UserUpdateWithoutAudioUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAudioUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutAudioUploadsInput = {
    update: XOR<WorkspaceUpdateWithoutAudioUploadsInput, WorkspaceUncheckedUpdateWithoutAudioUploadsInput>
    create: XOR<WorkspaceCreateWithoutAudioUploadsInput, WorkspaceUncheckedCreateWithoutAudioUploadsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAudioUploadsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAudioUploadsInput, WorkspaceUncheckedUpdateWithoutAudioUploadsInput>
  }

  export type WorkspaceUpdateWithoutAudioUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAudioUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUncheckedUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUncheckedUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type AudioHistoryUpsertWithWhereUniqueWithoutUploadInput = {
    where: AudioHistoryWhereUniqueInput
    update: XOR<AudioHistoryUpdateWithoutUploadInput, AudioHistoryUncheckedUpdateWithoutUploadInput>
    create: XOR<AudioHistoryCreateWithoutUploadInput, AudioHistoryUncheckedCreateWithoutUploadInput>
  }

  export type AudioHistoryUpdateWithWhereUniqueWithoutUploadInput = {
    where: AudioHistoryWhereUniqueInput
    data: XOR<AudioHistoryUpdateWithoutUploadInput, AudioHistoryUncheckedUpdateWithoutUploadInput>
  }

  export type AudioHistoryUpdateManyWithWhereWithoutUploadInput = {
    where: AudioHistoryScalarWhereInput
    data: XOR<AudioHistoryUpdateManyMutationInput, AudioHistoryUncheckedUpdateManyWithoutUploadInput>
  }

  export type ProcessingJobUpsertWithWhereUniqueWithoutUploadInput = {
    where: ProcessingJobWhereUniqueInput
    update: XOR<ProcessingJobUpdateWithoutUploadInput, ProcessingJobUncheckedUpdateWithoutUploadInput>
    create: XOR<ProcessingJobCreateWithoutUploadInput, ProcessingJobUncheckedCreateWithoutUploadInput>
  }

  export type ProcessingJobUpdateWithWhereUniqueWithoutUploadInput = {
    where: ProcessingJobWhereUniqueInput
    data: XOR<ProcessingJobUpdateWithoutUploadInput, ProcessingJobUncheckedUpdateWithoutUploadInput>
  }

  export type ProcessingJobUpdateManyWithWhereWithoutUploadInput = {
    where: ProcessingJobScalarWhereInput
    data: XOR<ProcessingJobUpdateManyMutationInput, ProcessingJobUncheckedUpdateManyWithoutUploadInput>
  }

  export type AudioChunkUpsertWithWhereUniqueWithoutUploadInput = {
    where: AudioChunkWhereUniqueInput
    update: XOR<AudioChunkUpdateWithoutUploadInput, AudioChunkUncheckedUpdateWithoutUploadInput>
    create: XOR<AudioChunkCreateWithoutUploadInput, AudioChunkUncheckedCreateWithoutUploadInput>
  }

  export type AudioChunkUpdateWithWhereUniqueWithoutUploadInput = {
    where: AudioChunkWhereUniqueInput
    data: XOR<AudioChunkUpdateWithoutUploadInput, AudioChunkUncheckedUpdateWithoutUploadInput>
  }

  export type AudioChunkUpdateManyWithWhereWithoutUploadInput = {
    where: AudioChunkScalarWhereInput
    data: XOR<AudioChunkUpdateManyMutationInput, AudioChunkUncheckedUpdateManyWithoutUploadInput>
  }

  export type AudioChunkScalarWhereInput = {
    AND?: AudioChunkScalarWhereInput | AudioChunkScalarWhereInput[]
    OR?: AudioChunkScalarWhereInput[]
    NOT?: AudioChunkScalarWhereInput | AudioChunkScalarWhereInput[]
    id?: StringFilter<"AudioChunk"> | string
    uploadId?: StringFilter<"AudioChunk"> | string
    chunkIndex?: IntFilter<"AudioChunk"> | number
    startTime?: FloatFilter<"AudioChunk"> | number
    endTime?: FloatFilter<"AudioChunk"> | number
    fileSize?: BigIntFilter<"AudioChunk"> | bigint | number
    storagePath?: StringFilter<"AudioChunk"> | string
    checksumMd5?: StringNullableFilter<"AudioChunk"> | string | null
    status?: StringFilter<"AudioChunk"> | string
    processedAt?: DateTimeNullableFilter<"AudioChunk"> | Date | string | null
  }

  export type UserCreateWithoutProcessingJobsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProcessingJobsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProcessingJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessingJobsInput, UserUncheckedCreateWithoutProcessingJobsInput>
  }

  export type AudioUploadCreateWithoutProcessingJobsInput = {
    id?: string
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAudioUploadsInput
    workspace?: WorkspaceCreateNestedOneWithoutAudioUploadsInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadUncheckedCreateWithoutProcessingJobsInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkUncheckedCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadCreateOrConnectWithoutProcessingJobsInput = {
    where: AudioUploadWhereUniqueInput
    create: XOR<AudioUploadCreateWithoutProcessingJobsInput, AudioUploadUncheckedCreateWithoutProcessingJobsInput>
  }

  export type UserUpsertWithoutProcessingJobsInput = {
    update: XOR<UserUpdateWithoutProcessingJobsInput, UserUncheckedUpdateWithoutProcessingJobsInput>
    create: XOR<UserCreateWithoutProcessingJobsInput, UserUncheckedCreateWithoutProcessingJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessingJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessingJobsInput, UserUncheckedUpdateWithoutProcessingJobsInput>
  }

  export type UserUpdateWithoutProcessingJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessingJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AudioUploadUpsertWithoutProcessingJobsInput = {
    update: XOR<AudioUploadUpdateWithoutProcessingJobsInput, AudioUploadUncheckedUpdateWithoutProcessingJobsInput>
    create: XOR<AudioUploadCreateWithoutProcessingJobsInput, AudioUploadUncheckedCreateWithoutProcessingJobsInput>
    where?: AudioUploadWhereInput
  }

  export type AudioUploadUpdateToOneWithWhereWithoutProcessingJobsInput = {
    where?: AudioUploadWhereInput
    data: XOR<AudioUploadUpdateWithoutProcessingJobsInput, AudioUploadUncheckedUpdateWithoutProcessingJobsInput>
  }

  export type AudioUploadUpdateWithoutProcessingJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAudioUploadsNestedInput
    workspace?: WorkspaceUpdateOneWithoutAudioUploadsNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUpdateManyWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateWithoutProcessingJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUncheckedUpdateManyWithoutUploadNestedInput
  }

  export type UserCreateWithoutAudioHistoryInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAudioHistoryInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAudioHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAudioHistoryInput, UserUncheckedCreateWithoutAudioHistoryInput>
  }

  export type WorkspaceCreateWithoutAudioHistoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAudioHistoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsUncheckedCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaUncheckedCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAudioHistoryInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAudioHistoryInput, WorkspaceUncheckedCreateWithoutAudioHistoryInput>
  }

  export type AudioUploadCreateWithoutAudioHistoryInput = {
    id?: string
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAudioUploadsInput
    workspace?: WorkspaceCreateNestedOneWithoutAudioUploadsInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadUncheckedCreateWithoutAudioHistoryInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkUncheckedCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadCreateOrConnectWithoutAudioHistoryInput = {
    where: AudioUploadWhereUniqueInput
    create: XOR<AudioUploadCreateWithoutAudioHistoryInput, AudioUploadUncheckedCreateWithoutAudioHistoryInput>
  }

  export type AudioSegmentCreateWithoutHistoryInput = {
    id?: string
    segmentIndex: number
    startTime: number
    endTime: number
    text: string
    confidence?: number | null
    language?: string | null
    speakerId?: string | null
    emotion?: string | null
    sentiment?: string | null
    tokens?: AudioSegmentCreatetokensInput | number[]
    logprobs?: AudioSegmentCreatelogprobsInput | number[]
    temperature?: number | null
    avgLogprob?: number | null
    compressionRatio?: number | null
    noSpeechProb?: number | null
  }

  export type AudioSegmentUncheckedCreateWithoutHistoryInput = {
    id?: string
    segmentIndex: number
    startTime: number
    endTime: number
    text: string
    confidence?: number | null
    language?: string | null
    speakerId?: string | null
    emotion?: string | null
    sentiment?: string | null
    tokens?: AudioSegmentCreatetokensInput | number[]
    logprobs?: AudioSegmentCreatelogprobsInput | number[]
    temperature?: number | null
    avgLogprob?: number | null
    compressionRatio?: number | null
    noSpeechProb?: number | null
  }

  export type AudioSegmentCreateOrConnectWithoutHistoryInput = {
    where: AudioSegmentWhereUniqueInput
    create: XOR<AudioSegmentCreateWithoutHistoryInput, AudioSegmentUncheckedCreateWithoutHistoryInput>
  }

  export type AudioSegmentCreateManyHistoryInputEnvelope = {
    data: AudioSegmentCreateManyHistoryInput | AudioSegmentCreateManyHistoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAudioHistoryInput = {
    update: XOR<UserUpdateWithoutAudioHistoryInput, UserUncheckedUpdateWithoutAudioHistoryInput>
    create: XOR<UserCreateWithoutAudioHistoryInput, UserUncheckedCreateWithoutAudioHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAudioHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAudioHistoryInput, UserUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type UserUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutAudioHistoryInput = {
    update: XOR<WorkspaceUpdateWithoutAudioHistoryInput, WorkspaceUncheckedUpdateWithoutAudioHistoryInput>
    create: XOR<WorkspaceCreateWithoutAudioHistoryInput, WorkspaceUncheckedCreateWithoutAudioHistoryInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAudioHistoryInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAudioHistoryInput, WorkspaceUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type WorkspaceUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUncheckedUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUncheckedUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type AudioUploadUpsertWithoutAudioHistoryInput = {
    update: XOR<AudioUploadUpdateWithoutAudioHistoryInput, AudioUploadUncheckedUpdateWithoutAudioHistoryInput>
    create: XOR<AudioUploadCreateWithoutAudioHistoryInput, AudioUploadUncheckedCreateWithoutAudioHistoryInput>
    where?: AudioUploadWhereInput
  }

  export type AudioUploadUpdateToOneWithWhereWithoutAudioHistoryInput = {
    where?: AudioUploadWhereInput
    data: XOR<AudioUploadUpdateWithoutAudioHistoryInput, AudioUploadUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type AudioUploadUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAudioUploadsNestedInput
    workspace?: WorkspaceUpdateOneWithoutAudioUploadsNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUpdateManyWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUncheckedUpdateManyWithoutUploadNestedInput
  }

  export type AudioSegmentUpsertWithWhereUniqueWithoutHistoryInput = {
    where: AudioSegmentWhereUniqueInput
    update: XOR<AudioSegmentUpdateWithoutHistoryInput, AudioSegmentUncheckedUpdateWithoutHistoryInput>
    create: XOR<AudioSegmentCreateWithoutHistoryInput, AudioSegmentUncheckedCreateWithoutHistoryInput>
  }

  export type AudioSegmentUpdateWithWhereUniqueWithoutHistoryInput = {
    where: AudioSegmentWhereUniqueInput
    data: XOR<AudioSegmentUpdateWithoutHistoryInput, AudioSegmentUncheckedUpdateWithoutHistoryInput>
  }

  export type AudioSegmentUpdateManyWithWhereWithoutHistoryInput = {
    where: AudioSegmentScalarWhereInput
    data: XOR<AudioSegmentUpdateManyMutationInput, AudioSegmentUncheckedUpdateManyWithoutHistoryInput>
  }

  export type AudioSegmentScalarWhereInput = {
    AND?: AudioSegmentScalarWhereInput | AudioSegmentScalarWhereInput[]
    OR?: AudioSegmentScalarWhereInput[]
    NOT?: AudioSegmentScalarWhereInput | AudioSegmentScalarWhereInput[]
    id?: StringFilter<"AudioSegment"> | string
    historyId?: StringFilter<"AudioSegment"> | string
    segmentIndex?: IntFilter<"AudioSegment"> | number
    startTime?: FloatFilter<"AudioSegment"> | number
    endTime?: FloatFilter<"AudioSegment"> | number
    text?: StringFilter<"AudioSegment"> | string
    confidence?: FloatNullableFilter<"AudioSegment"> | number | null
    language?: StringNullableFilter<"AudioSegment"> | string | null
    speakerId?: StringNullableFilter<"AudioSegment"> | string | null
    emotion?: StringNullableFilter<"AudioSegment"> | string | null
    sentiment?: StringNullableFilter<"AudioSegment"> | string | null
    tokens?: IntNullableListFilter<"AudioSegment">
    logprobs?: FloatNullableListFilter<"AudioSegment">
    temperature?: FloatNullableFilter<"AudioSegment"> | number | null
    avgLogprob?: FloatNullableFilter<"AudioSegment"> | number | null
    compressionRatio?: FloatNullableFilter<"AudioSegment"> | number | null
    noSpeechProb?: FloatNullableFilter<"AudioSegment"> | number | null
  }

  export type AudioHistoryCreateWithoutSegmentsInput = {
    id?: string
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAudioHistoryInput
    workspace?: WorkspaceCreateNestedOneWithoutAudioHistoryInput
    upload?: AudioUploadCreateNestedOneWithoutAudioHistoryInput
  }

  export type AudioHistoryUncheckedCreateWithoutSegmentsInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    uploadId?: string | null
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioHistoryCreateOrConnectWithoutSegmentsInput = {
    where: AudioHistoryWhereUniqueInput
    create: XOR<AudioHistoryCreateWithoutSegmentsInput, AudioHistoryUncheckedCreateWithoutSegmentsInput>
  }

  export type AudioHistoryUpsertWithoutSegmentsInput = {
    update: XOR<AudioHistoryUpdateWithoutSegmentsInput, AudioHistoryUncheckedUpdateWithoutSegmentsInput>
    create: XOR<AudioHistoryCreateWithoutSegmentsInput, AudioHistoryUncheckedCreateWithoutSegmentsInput>
    where?: AudioHistoryWhereInput
  }

  export type AudioHistoryUpdateToOneWithWhereWithoutSegmentsInput = {
    where?: AudioHistoryWhereInput
    data: XOR<AudioHistoryUpdateWithoutSegmentsInput, AudioHistoryUncheckedUpdateWithoutSegmentsInput>
  }

  export type AudioHistoryUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioHistoryNestedInput
    workspace?: WorkspaceUpdateOneWithoutAudioHistoryNestedInput
    upload?: AudioUploadUpdateOneWithoutAudioHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioUploadCreateWithoutAudioChunksInput = {
    id?: string
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAudioUploadsInput
    workspace?: WorkspaceCreateNestedOneWithoutAudioUploadsInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUploadInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadUncheckedCreateWithoutAudioChunksInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUploadInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadCreateOrConnectWithoutAudioChunksInput = {
    where: AudioUploadWhereUniqueInput
    create: XOR<AudioUploadCreateWithoutAudioChunksInput, AudioUploadUncheckedCreateWithoutAudioChunksInput>
  }

  export type AudioUploadUpsertWithoutAudioChunksInput = {
    update: XOR<AudioUploadUpdateWithoutAudioChunksInput, AudioUploadUncheckedUpdateWithoutAudioChunksInput>
    create: XOR<AudioUploadCreateWithoutAudioChunksInput, AudioUploadUncheckedCreateWithoutAudioChunksInput>
    where?: AudioUploadWhereInput
  }

  export type AudioUploadUpdateToOneWithWhereWithoutAudioChunksInput = {
    where?: AudioUploadWhereInput
    data: XOR<AudioUploadUpdateWithoutAudioChunksInput, AudioUploadUncheckedUpdateWithoutAudioChunksInput>
  }

  export type AudioUploadUpdateWithoutAudioChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAudioUploadsNestedInput
    workspace?: WorkspaceUpdateOneWithoutAudioUploadsNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUploadNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateWithoutAudioChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUploadNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUploadNestedInput
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type WorkspaceCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsUncheckedCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaUncheckedCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutProjectsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutProjectsInput = {
    update: XOR<WorkspaceUpdateWithoutProjectsInput, WorkspaceUncheckedUpdateWithoutProjectsInput>
    create: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutProjectsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutProjectsInput, WorkspaceUncheckedUpdateWithoutProjectsInput>
  }

  export type WorkspaceUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUncheckedUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUncheckedUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutUsageMetricsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsageMetricsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsageMetricsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsageMetricsInput, UserUncheckedCreateWithoutUsageMetricsInput>
  }

  export type WorkspaceCreateWithoutUsageMetricsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsCreateNestedOneWithoutWorkspaceInput
    storageQuota?: StorageQuotaCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutUsageMetricsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsUncheckedCreateNestedOneWithoutWorkspaceInput
    storageQuota?: StorageQuotaUncheckedCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutUsageMetricsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutUsageMetricsInput, WorkspaceUncheckedCreateWithoutUsageMetricsInput>
  }

  export type UserUpsertWithoutUsageMetricsInput = {
    update: XOR<UserUpdateWithoutUsageMetricsInput, UserUncheckedUpdateWithoutUsageMetricsInput>
    create: XOR<UserCreateWithoutUsageMetricsInput, UserUncheckedCreateWithoutUsageMetricsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsageMetricsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsageMetricsInput, UserUncheckedUpdateWithoutUsageMetricsInput>
  }

  export type UserUpdateWithoutUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutUsageMetricsInput = {
    update: XOR<WorkspaceUpdateWithoutUsageMetricsInput, WorkspaceUncheckedUpdateWithoutUsageMetricsInput>
    create: XOR<WorkspaceCreateWithoutUsageMetricsInput, WorkspaceUncheckedCreateWithoutUsageMetricsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutUsageMetricsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutUsageMetricsInput, WorkspaceUncheckedUpdateWithoutUsageMetricsInput>
  }

  export type WorkspaceUpdateWithoutUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUpdateOneWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUncheckedUpdateOneWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUncheckedUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutQuotaInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuotaInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuotaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuotaInput, UserUncheckedCreateWithoutQuotaInput>
  }

  export type UserUpsertWithoutQuotaInput = {
    update: XOR<UserUpdateWithoutQuotaInput, UserUncheckedUpdateWithoutQuotaInput>
    create: XOR<UserCreateWithoutQuotaInput, UserUncheckedCreateWithoutQuotaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuotaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuotaInput, UserUncheckedUpdateWithoutQuotaInput>
  }

  export type UserUpdateWithoutQuotaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuotaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutStorageQuotaInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutStorageQuotaInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsUncheckedCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutStorageQuotaInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutStorageQuotaInput, WorkspaceUncheckedCreateWithoutStorageQuotaInput>
  }

  export type WorkspaceUpsertWithoutStorageQuotaInput = {
    update: XOR<WorkspaceUpdateWithoutStorageQuotaInput, WorkspaceUncheckedUpdateWithoutStorageQuotaInput>
    create: XOR<WorkspaceCreateWithoutStorageQuotaInput, WorkspaceUncheckedCreateWithoutStorageQuotaInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutStorageQuotaInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutStorageQuotaInput, WorkspaceUncheckedUpdateWithoutStorageQuotaInput>
  }

  export type WorkspaceUpdateWithoutStorageQuotaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutStorageQuotaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUncheckedUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceSubscriptionCreateWithoutPlanInput = {
    id?: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionsInput
    billingRecords?: BillingRecordCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    workspaceId: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingRecords?: BillingRecordUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionCreateOrConnectWithoutPlanInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    create: XOR<WorkspaceSubscriptionCreateWithoutPlanInput, WorkspaceSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type WorkspaceSubscriptionCreateManyPlanInputEnvelope = {
    data: WorkspaceSubscriptionCreateManyPlanInput | WorkspaceSubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanPricingCreateWithoutPlanInput = {
    id?: string
    currency: string
    price: Decimal | DecimalJsLike | number | string
    billingPeriod: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPricingUncheckedCreateWithoutPlanInput = {
    id?: string
    currency: string
    price: Decimal | DecimalJsLike | number | string
    billingPeriod: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPricingCreateOrConnectWithoutPlanInput = {
    where: PlanPricingWhereUniqueInput
    create: XOR<PlanPricingCreateWithoutPlanInput, PlanPricingUncheckedCreateWithoutPlanInput>
  }

  export type PlanPricingCreateManyPlanInputEnvelope = {
    data: PlanPricingCreateManyPlanInput | PlanPricingCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanFeatureMatrixCreateWithoutPlanInput = {
    id?: string
    isEnabled?: boolean
    usageLimit?: number | null
    includedUsage?: number
    overageRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    featureFlag: FeatureFlagCreateNestedOneWithoutPlanFeaturesInput
  }

  export type PlanFeatureMatrixUncheckedCreateWithoutPlanInput = {
    id?: string
    featureFlagId: string
    isEnabled?: boolean
    usageLimit?: number | null
    includedUsage?: number
    overageRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PlanFeatureMatrixCreateOrConnectWithoutPlanInput = {
    where: PlanFeatureMatrixWhereUniqueInput
    create: XOR<PlanFeatureMatrixCreateWithoutPlanInput, PlanFeatureMatrixUncheckedCreateWithoutPlanInput>
  }

  export type PlanFeatureMatrixCreateManyPlanInputEnvelope = {
    data: PlanFeatureMatrixCreateManyPlanInput | PlanFeatureMatrixCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanRecommendationCreateWithoutCurrentPlanInput = {
    id?: string
    workspaceId?: string | null
    recommendationReason: string
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: Decimal | DecimalJsLike | number | string | null
    roiMonths?: number | null
    triggeredBy?: string | null
    benefits?: PlanRecommendationCreatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationCreatelimitationsRemovedInput | string[]
    status?: string
    viewedAt?: Date | string | null
    dismissedAt?: Date | string | null
    acceptedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlanRecommendationsInput
    recommendedPlan: SubscriptionPlanCreateNestedOneWithoutRecommendedPlanRecommendationsInput
  }

  export type PlanRecommendationUncheckedCreateWithoutCurrentPlanInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    recommendedPlanId: string
    recommendationReason: string
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: Decimal | DecimalJsLike | number | string | null
    roiMonths?: number | null
    triggeredBy?: string | null
    benefits?: PlanRecommendationCreatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationCreatelimitationsRemovedInput | string[]
    status?: string
    viewedAt?: Date | string | null
    dismissedAt?: Date | string | null
    acceptedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanRecommendationCreateOrConnectWithoutCurrentPlanInput = {
    where: PlanRecommendationWhereUniqueInput
    create: XOR<PlanRecommendationCreateWithoutCurrentPlanInput, PlanRecommendationUncheckedCreateWithoutCurrentPlanInput>
  }

  export type PlanRecommendationCreateManyCurrentPlanInputEnvelope = {
    data: PlanRecommendationCreateManyCurrentPlanInput | PlanRecommendationCreateManyCurrentPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanRecommendationCreateWithoutRecommendedPlanInput = {
    id?: string
    workspaceId?: string | null
    recommendationReason: string
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: Decimal | DecimalJsLike | number | string | null
    roiMonths?: number | null
    triggeredBy?: string | null
    benefits?: PlanRecommendationCreatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationCreatelimitationsRemovedInput | string[]
    status?: string
    viewedAt?: Date | string | null
    dismissedAt?: Date | string | null
    acceptedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlanRecommendationsInput
    currentPlan: SubscriptionPlanCreateNestedOneWithoutCurrentPlanRecommendationsInput
  }

  export type PlanRecommendationUncheckedCreateWithoutRecommendedPlanInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    currentPlanId: string
    recommendationReason: string
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: Decimal | DecimalJsLike | number | string | null
    roiMonths?: number | null
    triggeredBy?: string | null
    benefits?: PlanRecommendationCreatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationCreatelimitationsRemovedInput | string[]
    status?: string
    viewedAt?: Date | string | null
    dismissedAt?: Date | string | null
    acceptedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanRecommendationCreateOrConnectWithoutRecommendedPlanInput = {
    where: PlanRecommendationWhereUniqueInput
    create: XOR<PlanRecommendationCreateWithoutRecommendedPlanInput, PlanRecommendationUncheckedCreateWithoutRecommendedPlanInput>
  }

  export type PlanRecommendationCreateManyRecommendedPlanInputEnvelope = {
    data: PlanRecommendationCreateManyRecommendedPlanInput | PlanRecommendationCreateManyRecommendedPlanInput[]
    skipDuplicates?: boolean
  }

  export type CustomPlanCreateWithoutBasePlanInput = {
    id?: string
    workspaceId: string
    planName: string
    description?: string | null
    customMaxTranscriptionsMonthly?: bigint | number | null
    customMaxFilesDaily?: number | null
    customMaxFilesMonthly?: number | null
    customMaxConcurrentJobs?: number | null
    customMaxVoiceSynthesisMonthly?: bigint | number | null
    customMaxExportOperationsMonthly?: number | null
    customMaxAudioDurationMinutes?: number | null
    customPriorityLevel?: number | null
    customFeatures?: CustomPlanCreatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanCreateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanCreateadditionalFeaturesInput | string[]
    customPrice?: Decimal | DecimalJsLike | number | string | null
    pricingModel?: string
    billingInterval?: string
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenew?: boolean
    noticePeriodDays?: number
    approvedBy?: string | null
    approvalStatus?: string
    approvalNotes?: string | null
    isActive?: boolean
    activatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedByUser?: UserCreateNestedOneWithoutCustomPlansInput
  }

  export type CustomPlanUncheckedCreateWithoutBasePlanInput = {
    id?: string
    workspaceId: string
    planName: string
    description?: string | null
    customMaxTranscriptionsMonthly?: bigint | number | null
    customMaxFilesDaily?: number | null
    customMaxFilesMonthly?: number | null
    customMaxConcurrentJobs?: number | null
    customMaxVoiceSynthesisMonthly?: bigint | number | null
    customMaxExportOperationsMonthly?: number | null
    customMaxAudioDurationMinutes?: number | null
    customPriorityLevel?: number | null
    customFeatures?: CustomPlanCreatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanCreateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanCreateadditionalFeaturesInput | string[]
    customPrice?: Decimal | DecimalJsLike | number | string | null
    pricingModel?: string
    billingInterval?: string
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenew?: boolean
    noticePeriodDays?: number
    requestedBy?: string | null
    approvedBy?: string | null
    approvalStatus?: string
    approvalNotes?: string | null
    isActive?: boolean
    activatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomPlanCreateOrConnectWithoutBasePlanInput = {
    where: CustomPlanWhereUniqueInput
    create: XOR<CustomPlanCreateWithoutBasePlanInput, CustomPlanUncheckedCreateWithoutBasePlanInput>
  }

  export type CustomPlanCreateManyBasePlanInputEnvelope = {
    data: CustomPlanCreateManyBasePlanInput | CustomPlanCreateManyBasePlanInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceSubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    update: XOR<WorkspaceSubscriptionUpdateWithoutPlanInput, WorkspaceSubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<WorkspaceSubscriptionCreateWithoutPlanInput, WorkspaceSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type WorkspaceSubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    data: XOR<WorkspaceSubscriptionUpdateWithoutPlanInput, WorkspaceSubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type WorkspaceSubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: WorkspaceSubscriptionScalarWhereInput
    data: XOR<WorkspaceSubscriptionUpdateManyMutationInput, WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanPricingUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanPricingWhereUniqueInput
    update: XOR<PlanPricingUpdateWithoutPlanInput, PlanPricingUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanPricingCreateWithoutPlanInput, PlanPricingUncheckedCreateWithoutPlanInput>
  }

  export type PlanPricingUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanPricingWhereUniqueInput
    data: XOR<PlanPricingUpdateWithoutPlanInput, PlanPricingUncheckedUpdateWithoutPlanInput>
  }

  export type PlanPricingUpdateManyWithWhereWithoutPlanInput = {
    where: PlanPricingScalarWhereInput
    data: XOR<PlanPricingUpdateManyMutationInput, PlanPricingUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanPricingScalarWhereInput = {
    AND?: PlanPricingScalarWhereInput | PlanPricingScalarWhereInput[]
    OR?: PlanPricingScalarWhereInput[]
    NOT?: PlanPricingScalarWhereInput | PlanPricingScalarWhereInput[]
    id?: StringFilter<"PlanPricing"> | string
    planId?: StringFilter<"PlanPricing"> | string
    currency?: StringFilter<"PlanPricing"> | string
    price?: DecimalFilter<"PlanPricing"> | Decimal | DecimalJsLike | number | string
    billingPeriod?: StringFilter<"PlanPricing"> | string
    region?: StringNullableFilter<"PlanPricing"> | string | null
    isActive?: BoolFilter<"PlanPricing"> | boolean
    createdAt?: DateTimeFilter<"PlanPricing"> | Date | string
    updatedAt?: DateTimeFilter<"PlanPricing"> | Date | string
  }

  export type PlanFeatureMatrixUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanFeatureMatrixWhereUniqueInput
    update: XOR<PlanFeatureMatrixUpdateWithoutPlanInput, PlanFeatureMatrixUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanFeatureMatrixCreateWithoutPlanInput, PlanFeatureMatrixUncheckedCreateWithoutPlanInput>
  }

  export type PlanFeatureMatrixUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanFeatureMatrixWhereUniqueInput
    data: XOR<PlanFeatureMatrixUpdateWithoutPlanInput, PlanFeatureMatrixUncheckedUpdateWithoutPlanInput>
  }

  export type PlanFeatureMatrixUpdateManyWithWhereWithoutPlanInput = {
    where: PlanFeatureMatrixScalarWhereInput
    data: XOR<PlanFeatureMatrixUpdateManyMutationInput, PlanFeatureMatrixUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanFeatureMatrixScalarWhereInput = {
    AND?: PlanFeatureMatrixScalarWhereInput | PlanFeatureMatrixScalarWhereInput[]
    OR?: PlanFeatureMatrixScalarWhereInput[]
    NOT?: PlanFeatureMatrixScalarWhereInput | PlanFeatureMatrixScalarWhereInput[]
    id?: StringFilter<"PlanFeatureMatrix"> | string
    planId?: StringFilter<"PlanFeatureMatrix"> | string
    featureFlagId?: StringFilter<"PlanFeatureMatrix"> | string
    isEnabled?: BoolFilter<"PlanFeatureMatrix"> | boolean
    usageLimit?: IntNullableFilter<"PlanFeatureMatrix"> | number | null
    includedUsage?: IntFilter<"PlanFeatureMatrix"> | number
    overageRate?: DecimalNullableFilter<"PlanFeatureMatrix"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PlanFeatureMatrix"> | Date | string
  }

  export type PlanRecommendationUpsertWithWhereUniqueWithoutCurrentPlanInput = {
    where: PlanRecommendationWhereUniqueInput
    update: XOR<PlanRecommendationUpdateWithoutCurrentPlanInput, PlanRecommendationUncheckedUpdateWithoutCurrentPlanInput>
    create: XOR<PlanRecommendationCreateWithoutCurrentPlanInput, PlanRecommendationUncheckedCreateWithoutCurrentPlanInput>
  }

  export type PlanRecommendationUpdateWithWhereUniqueWithoutCurrentPlanInput = {
    where: PlanRecommendationWhereUniqueInput
    data: XOR<PlanRecommendationUpdateWithoutCurrentPlanInput, PlanRecommendationUncheckedUpdateWithoutCurrentPlanInput>
  }

  export type PlanRecommendationUpdateManyWithWhereWithoutCurrentPlanInput = {
    where: PlanRecommendationScalarWhereInput
    data: XOR<PlanRecommendationUpdateManyMutationInput, PlanRecommendationUncheckedUpdateManyWithoutCurrentPlanInput>
  }

  export type PlanRecommendationUpsertWithWhereUniqueWithoutRecommendedPlanInput = {
    where: PlanRecommendationWhereUniqueInput
    update: XOR<PlanRecommendationUpdateWithoutRecommendedPlanInput, PlanRecommendationUncheckedUpdateWithoutRecommendedPlanInput>
    create: XOR<PlanRecommendationCreateWithoutRecommendedPlanInput, PlanRecommendationUncheckedCreateWithoutRecommendedPlanInput>
  }

  export type PlanRecommendationUpdateWithWhereUniqueWithoutRecommendedPlanInput = {
    where: PlanRecommendationWhereUniqueInput
    data: XOR<PlanRecommendationUpdateWithoutRecommendedPlanInput, PlanRecommendationUncheckedUpdateWithoutRecommendedPlanInput>
  }

  export type PlanRecommendationUpdateManyWithWhereWithoutRecommendedPlanInput = {
    where: PlanRecommendationScalarWhereInput
    data: XOR<PlanRecommendationUpdateManyMutationInput, PlanRecommendationUncheckedUpdateManyWithoutRecommendedPlanInput>
  }

  export type CustomPlanUpsertWithWhereUniqueWithoutBasePlanInput = {
    where: CustomPlanWhereUniqueInput
    update: XOR<CustomPlanUpdateWithoutBasePlanInput, CustomPlanUncheckedUpdateWithoutBasePlanInput>
    create: XOR<CustomPlanCreateWithoutBasePlanInput, CustomPlanUncheckedCreateWithoutBasePlanInput>
  }

  export type CustomPlanUpdateWithWhereUniqueWithoutBasePlanInput = {
    where: CustomPlanWhereUniqueInput
    data: XOR<CustomPlanUpdateWithoutBasePlanInput, CustomPlanUncheckedUpdateWithoutBasePlanInput>
  }

  export type CustomPlanUpdateManyWithWhereWithoutBasePlanInput = {
    where: CustomPlanScalarWhereInput
    data: XOR<CustomPlanUpdateManyMutationInput, CustomPlanUncheckedUpdateManyWithoutBasePlanInput>
  }

  export type SubscriptionPlanCreateWithoutPlanPricingInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutPlanInput
    planFeatures?: PlanFeatureMatrixCreateNestedManyWithoutPlanInput
    currentPlanRecommendations?: PlanRecommendationCreateNestedManyWithoutCurrentPlanInput
    recommendedPlanRecommendations?: PlanRecommendationCreateNestedManyWithoutRecommendedPlanInput
    customPlans?: CustomPlanCreateNestedManyWithoutBasePlanInput
  }

  export type SubscriptionPlanUncheckedCreateWithoutPlanPricingInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutPlanInput
    planFeatures?: PlanFeatureMatrixUncheckedCreateNestedManyWithoutPlanInput
    currentPlanRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutCurrentPlanInput
    recommendedPlanRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutRecommendedPlanInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutBasePlanInput
  }

  export type SubscriptionPlanCreateOrConnectWithoutPlanPricingInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutPlanPricingInput, SubscriptionPlanUncheckedCreateWithoutPlanPricingInput>
  }

  export type SubscriptionPlanUpsertWithoutPlanPricingInput = {
    update: XOR<SubscriptionPlanUpdateWithoutPlanPricingInput, SubscriptionPlanUncheckedUpdateWithoutPlanPricingInput>
    create: XOR<SubscriptionPlanCreateWithoutPlanPricingInput, SubscriptionPlanUncheckedCreateWithoutPlanPricingInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutPlanPricingInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutPlanPricingInput, SubscriptionPlanUncheckedUpdateWithoutPlanPricingInput>
  }

  export type SubscriptionPlanUpdateWithoutPlanPricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutPlanNestedInput
    planFeatures?: PlanFeatureMatrixUpdateManyWithoutPlanNestedInput
    currentPlanRecommendations?: PlanRecommendationUpdateManyWithoutCurrentPlanNestedInput
    recommendedPlanRecommendations?: PlanRecommendationUpdateManyWithoutRecommendedPlanNestedInput
    customPlans?: CustomPlanUpdateManyWithoutBasePlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateWithoutPlanPricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    planFeatures?: PlanFeatureMatrixUncheckedUpdateManyWithoutPlanNestedInput
    currentPlanRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutCurrentPlanNestedInput
    recommendedPlanRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutRecommendedPlanNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutBasePlanNestedInput
  }

  export type WorkspaceCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaCreateNestedOneWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsUncheckedCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaUncheckedCreateNestedOneWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutSubscriptionsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutSubscriptionsInput, WorkspaceUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planPricing?: PlanPricingCreateNestedManyWithoutPlanInput
    planFeatures?: PlanFeatureMatrixCreateNestedManyWithoutPlanInput
    currentPlanRecommendations?: PlanRecommendationCreateNestedManyWithoutCurrentPlanInput
    recommendedPlanRecommendations?: PlanRecommendationCreateNestedManyWithoutRecommendedPlanInput
    customPlans?: CustomPlanCreateNestedManyWithoutBasePlanInput
  }

  export type SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    planPricing?: PlanPricingUncheckedCreateNestedManyWithoutPlanInput
    planFeatures?: PlanFeatureMatrixUncheckedCreateNestedManyWithoutPlanInput
    currentPlanRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutCurrentPlanInput
    recommendedPlanRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutRecommendedPlanInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutBasePlanInput
  }

  export type SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type BillingRecordCreateWithoutSubscriptionInput = {
    id?: string
    invoiceNumber: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    paymentMethod?: string | null
    invoiceDate: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    stripeInvoiceId?: string | null
    ewayTransactionId?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingRecordUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    invoiceNumber: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    paymentMethod?: string | null
    invoiceDate: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    stripeInvoiceId?: string | null
    ewayTransactionId?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingRecordCreateOrConnectWithoutSubscriptionInput = {
    where: BillingRecordWhereUniqueInput
    create: XOR<BillingRecordCreateWithoutSubscriptionInput, BillingRecordUncheckedCreateWithoutSubscriptionInput>
  }

  export type BillingRecordCreateManySubscriptionInputEnvelope = {
    data: BillingRecordCreateManySubscriptionInput | BillingRecordCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UsageRecordCreateWithoutSubscriptionInput = {
    id?: string
    recordType: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageRecordUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    recordType: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageRecordCreateOrConnectWithoutSubscriptionInput = {
    where: UsageRecordWhereUniqueInput
    create: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput>
  }

  export type UsageRecordCreateManySubscriptionInputEnvelope = {
    data: UsageRecordCreateManySubscriptionInput | UsageRecordCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutSubscriptionsInput = {
    update: XOR<WorkspaceUpdateWithoutSubscriptionsInput, WorkspaceUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<WorkspaceCreateWithoutSubscriptionsInput, WorkspaceUncheckedCreateWithoutSubscriptionsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutSubscriptionsInput, WorkspaceUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type WorkspaceUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUpdateOneWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUncheckedUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUncheckedUpdateOneWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type SubscriptionPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planPricing?: PlanPricingUpdateManyWithoutPlanNestedInput
    planFeatures?: PlanFeatureMatrixUpdateManyWithoutPlanNestedInput
    currentPlanRecommendations?: PlanRecommendationUpdateManyWithoutCurrentPlanNestedInput
    recommendedPlanRecommendations?: PlanRecommendationUpdateManyWithoutRecommendedPlanNestedInput
    customPlans?: CustomPlanUpdateManyWithoutBasePlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planPricing?: PlanPricingUncheckedUpdateManyWithoutPlanNestedInput
    planFeatures?: PlanFeatureMatrixUncheckedUpdateManyWithoutPlanNestedInput
    currentPlanRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutCurrentPlanNestedInput
    recommendedPlanRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutRecommendedPlanNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutBasePlanNestedInput
  }

  export type BillingRecordUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: BillingRecordWhereUniqueInput
    update: XOR<BillingRecordUpdateWithoutSubscriptionInput, BillingRecordUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<BillingRecordCreateWithoutSubscriptionInput, BillingRecordUncheckedCreateWithoutSubscriptionInput>
  }

  export type BillingRecordUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: BillingRecordWhereUniqueInput
    data: XOR<BillingRecordUpdateWithoutSubscriptionInput, BillingRecordUncheckedUpdateWithoutSubscriptionInput>
  }

  export type BillingRecordUpdateManyWithWhereWithoutSubscriptionInput = {
    where: BillingRecordScalarWhereInput
    data: XOR<BillingRecordUpdateManyMutationInput, BillingRecordUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type BillingRecordScalarWhereInput = {
    AND?: BillingRecordScalarWhereInput | BillingRecordScalarWhereInput[]
    OR?: BillingRecordScalarWhereInput[]
    NOT?: BillingRecordScalarWhereInput | BillingRecordScalarWhereInput[]
    id?: StringFilter<"BillingRecord"> | string
    subscriptionId?: StringFilter<"BillingRecord"> | string
    invoiceNumber?: StringFilter<"BillingRecord"> | string
    amount?: DecimalFilter<"BillingRecord"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"BillingRecord"> | string
    status?: StringFilter<"BillingRecord"> | string
    paymentMethod?: StringNullableFilter<"BillingRecord"> | string | null
    invoiceDate?: DateTimeFilter<"BillingRecord"> | Date | string
    dueDate?: DateTimeFilter<"BillingRecord"> | Date | string
    paidAt?: DateTimeNullableFilter<"BillingRecord"> | Date | string | null
    stripeInvoiceId?: StringNullableFilter<"BillingRecord"> | string | null
    ewayTransactionId?: StringNullableFilter<"BillingRecord"> | string | null
    invoiceUrl?: StringNullableFilter<"BillingRecord"> | string | null
    failureReason?: StringNullableFilter<"BillingRecord"> | string | null
    usageDetails?: JsonNullableFilter<"BillingRecord">
    createdAt?: DateTimeFilter<"BillingRecord"> | Date | string
  }

  export type UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: UsageRecordWhereUniqueInput
    update: XOR<UsageRecordUpdateWithoutSubscriptionInput, UsageRecordUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput>
  }

  export type UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: UsageRecordWhereUniqueInput
    data: XOR<UsageRecordUpdateWithoutSubscriptionInput, UsageRecordUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UsageRecordUpdateManyWithWhereWithoutSubscriptionInput = {
    where: UsageRecordScalarWhereInput
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UsageRecordScalarWhereInput = {
    AND?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
    OR?: UsageRecordScalarWhereInput[]
    NOT?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
    id?: StringFilter<"UsageRecord"> | string
    subscriptionId?: StringFilter<"UsageRecord"> | string
    recordType?: StringFilter<"UsageRecord"> | string
    quantity?: DecimalFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalNullableFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFilter<"UsageRecord"> | Date | string
    periodEnd?: DateTimeFilter<"UsageRecord"> | Date | string
    metadata?: JsonNullableFilter<"UsageRecord">
    createdAt?: DateTimeFilter<"UsageRecord"> | Date | string
  }

  export type WorkspaceSubscriptionCreateWithoutBillingRecordsInput = {
    id?: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionUncheckedCreateWithoutBillingRecordsInput = {
    id?: string
    workspaceId: string
    planId: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionCreateOrConnectWithoutBillingRecordsInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    create: XOR<WorkspaceSubscriptionCreateWithoutBillingRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutBillingRecordsInput>
  }

  export type WorkspaceSubscriptionUpsertWithoutBillingRecordsInput = {
    update: XOR<WorkspaceSubscriptionUpdateWithoutBillingRecordsInput, WorkspaceSubscriptionUncheckedUpdateWithoutBillingRecordsInput>
    create: XOR<WorkspaceSubscriptionCreateWithoutBillingRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutBillingRecordsInput>
    where?: WorkspaceSubscriptionWhereInput
  }

  export type WorkspaceSubscriptionUpdateToOneWithWhereWithoutBillingRecordsInput = {
    where?: WorkspaceSubscriptionWhereInput
    data: XOR<WorkspaceSubscriptionUpdateWithoutBillingRecordsInput, WorkspaceSubscriptionUncheckedUpdateWithoutBillingRecordsInput>
  }

  export type WorkspaceSubscriptionUpdateWithoutBillingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateWithoutBillingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionCreateWithoutUsageRecordsInput = {
    id?: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    billingRecords?: BillingRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionUncheckedCreateWithoutUsageRecordsInput = {
    id?: string
    workspaceId: string
    planId: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingRecords?: BillingRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionCreateOrConnectWithoutUsageRecordsInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    create: XOR<WorkspaceSubscriptionCreateWithoutUsageRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutUsageRecordsInput>
  }

  export type WorkspaceSubscriptionUpsertWithoutUsageRecordsInput = {
    update: XOR<WorkspaceSubscriptionUpdateWithoutUsageRecordsInput, WorkspaceSubscriptionUncheckedUpdateWithoutUsageRecordsInput>
    create: XOR<WorkspaceSubscriptionCreateWithoutUsageRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutUsageRecordsInput>
    where?: WorkspaceSubscriptionWhereInput
  }

  export type WorkspaceSubscriptionUpdateToOneWithWhereWithoutUsageRecordsInput = {
    where?: WorkspaceSubscriptionWhereInput
    data: XOR<WorkspaceSubscriptionUpdateWithoutUsageRecordsInput, WorkspaceSubscriptionUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type WorkspaceSubscriptionUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    billingRecords?: BillingRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingRecords?: BillingRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type UserCreateWithoutUsageCountersInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsageCountersInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsageCountersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsageCountersInput, UserUncheckedCreateWithoutUsageCountersInput>
  }

  export type UserUpsertWithoutUsageCountersInput = {
    update: XOR<UserUpdateWithoutUsageCountersInput, UserUncheckedUpdateWithoutUsageCountersInput>
    create: XOR<UserCreateWithoutUsageCountersInput, UserUncheckedCreateWithoutUsageCountersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsageCountersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsageCountersInput, UserUncheckedUpdateWithoutUsageCountersInput>
  }

  export type UserUpdateWithoutUsageCountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUsageCountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPlanRecommendationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlanRecommendationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlanRecommendationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlanRecommendationsInput, UserUncheckedCreateWithoutPlanRecommendationsInput>
  }

  export type SubscriptionPlanCreateWithoutCurrentPlanRecommendationsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutPlanInput
    planPricing?: PlanPricingCreateNestedManyWithoutPlanInput
    planFeatures?: PlanFeatureMatrixCreateNestedManyWithoutPlanInput
    recommendedPlanRecommendations?: PlanRecommendationCreateNestedManyWithoutRecommendedPlanInput
    customPlans?: CustomPlanCreateNestedManyWithoutBasePlanInput
  }

  export type SubscriptionPlanUncheckedCreateWithoutCurrentPlanRecommendationsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutPlanInput
    planPricing?: PlanPricingUncheckedCreateNestedManyWithoutPlanInput
    planFeatures?: PlanFeatureMatrixUncheckedCreateNestedManyWithoutPlanInput
    recommendedPlanRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutRecommendedPlanInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutBasePlanInput
  }

  export type SubscriptionPlanCreateOrConnectWithoutCurrentPlanRecommendationsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutCurrentPlanRecommendationsInput, SubscriptionPlanUncheckedCreateWithoutCurrentPlanRecommendationsInput>
  }

  export type SubscriptionPlanCreateWithoutRecommendedPlanRecommendationsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutPlanInput
    planPricing?: PlanPricingCreateNestedManyWithoutPlanInput
    planFeatures?: PlanFeatureMatrixCreateNestedManyWithoutPlanInput
    currentPlanRecommendations?: PlanRecommendationCreateNestedManyWithoutCurrentPlanInput
    customPlans?: CustomPlanCreateNestedManyWithoutBasePlanInput
  }

  export type SubscriptionPlanUncheckedCreateWithoutRecommendedPlanRecommendationsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutPlanInput
    planPricing?: PlanPricingUncheckedCreateNestedManyWithoutPlanInput
    planFeatures?: PlanFeatureMatrixUncheckedCreateNestedManyWithoutPlanInput
    currentPlanRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutCurrentPlanInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutBasePlanInput
  }

  export type SubscriptionPlanCreateOrConnectWithoutRecommendedPlanRecommendationsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutRecommendedPlanRecommendationsInput, SubscriptionPlanUncheckedCreateWithoutRecommendedPlanRecommendationsInput>
  }

  export type UserUpsertWithoutPlanRecommendationsInput = {
    update: XOR<UserUpdateWithoutPlanRecommendationsInput, UserUncheckedUpdateWithoutPlanRecommendationsInput>
    create: XOR<UserCreateWithoutPlanRecommendationsInput, UserUncheckedCreateWithoutPlanRecommendationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlanRecommendationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlanRecommendationsInput, UserUncheckedUpdateWithoutPlanRecommendationsInput>
  }

  export type UserUpdateWithoutPlanRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlanRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionPlanUpsertWithoutCurrentPlanRecommendationsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutCurrentPlanRecommendationsInput, SubscriptionPlanUncheckedUpdateWithoutCurrentPlanRecommendationsInput>
    create: XOR<SubscriptionPlanCreateWithoutCurrentPlanRecommendationsInput, SubscriptionPlanUncheckedCreateWithoutCurrentPlanRecommendationsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutCurrentPlanRecommendationsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutCurrentPlanRecommendationsInput, SubscriptionPlanUncheckedUpdateWithoutCurrentPlanRecommendationsInput>
  }

  export type SubscriptionPlanUpdateWithoutCurrentPlanRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutPlanNestedInput
    planPricing?: PlanPricingUpdateManyWithoutPlanNestedInput
    planFeatures?: PlanFeatureMatrixUpdateManyWithoutPlanNestedInput
    recommendedPlanRecommendations?: PlanRecommendationUpdateManyWithoutRecommendedPlanNestedInput
    customPlans?: CustomPlanUpdateManyWithoutBasePlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateWithoutCurrentPlanRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    planPricing?: PlanPricingUncheckedUpdateManyWithoutPlanNestedInput
    planFeatures?: PlanFeatureMatrixUncheckedUpdateManyWithoutPlanNestedInput
    recommendedPlanRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutRecommendedPlanNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutBasePlanNestedInput
  }

  export type SubscriptionPlanUpsertWithoutRecommendedPlanRecommendationsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutRecommendedPlanRecommendationsInput, SubscriptionPlanUncheckedUpdateWithoutRecommendedPlanRecommendationsInput>
    create: XOR<SubscriptionPlanCreateWithoutRecommendedPlanRecommendationsInput, SubscriptionPlanUncheckedCreateWithoutRecommendedPlanRecommendationsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutRecommendedPlanRecommendationsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutRecommendedPlanRecommendationsInput, SubscriptionPlanUncheckedUpdateWithoutRecommendedPlanRecommendationsInput>
  }

  export type SubscriptionPlanUpdateWithoutRecommendedPlanRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutPlanNestedInput
    planPricing?: PlanPricingUpdateManyWithoutPlanNestedInput
    planFeatures?: PlanFeatureMatrixUpdateManyWithoutPlanNestedInput
    currentPlanRecommendations?: PlanRecommendationUpdateManyWithoutCurrentPlanNestedInput
    customPlans?: CustomPlanUpdateManyWithoutBasePlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateWithoutRecommendedPlanRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    planPricing?: PlanPricingUncheckedUpdateManyWithoutPlanNestedInput
    planFeatures?: PlanFeatureMatrixUncheckedUpdateManyWithoutPlanNestedInput
    currentPlanRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutCurrentPlanNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutBasePlanNestedInput
  }

  export type UserCreateWithoutCustomPlansInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomPlansInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomPlansInput, UserUncheckedCreateWithoutCustomPlansInput>
  }

  export type SubscriptionPlanCreateWithoutCustomPlansInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutPlanInput
    planPricing?: PlanPricingCreateNestedManyWithoutPlanInput
    planFeatures?: PlanFeatureMatrixCreateNestedManyWithoutPlanInput
    currentPlanRecommendations?: PlanRecommendationCreateNestedManyWithoutCurrentPlanInput
    recommendedPlanRecommendations?: PlanRecommendationCreateNestedManyWithoutRecommendedPlanInput
  }

  export type SubscriptionPlanUncheckedCreateWithoutCustomPlansInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutPlanInput
    planPricing?: PlanPricingUncheckedCreateNestedManyWithoutPlanInput
    planFeatures?: PlanFeatureMatrixUncheckedCreateNestedManyWithoutPlanInput
    currentPlanRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutCurrentPlanInput
    recommendedPlanRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutRecommendedPlanInput
  }

  export type SubscriptionPlanCreateOrConnectWithoutCustomPlansInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutCustomPlansInput, SubscriptionPlanUncheckedCreateWithoutCustomPlansInput>
  }

  export type UserUpsertWithoutCustomPlansInput = {
    update: XOR<UserUpdateWithoutCustomPlansInput, UserUncheckedUpdateWithoutCustomPlansInput>
    create: XOR<UserCreateWithoutCustomPlansInput, UserUncheckedCreateWithoutCustomPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomPlansInput, UserUncheckedUpdateWithoutCustomPlansInput>
  }

  export type UserUpdateWithoutCustomPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionPlanUpsertWithoutCustomPlansInput = {
    update: XOR<SubscriptionPlanUpdateWithoutCustomPlansInput, SubscriptionPlanUncheckedUpdateWithoutCustomPlansInput>
    create: XOR<SubscriptionPlanCreateWithoutCustomPlansInput, SubscriptionPlanUncheckedCreateWithoutCustomPlansInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutCustomPlansInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutCustomPlansInput, SubscriptionPlanUncheckedUpdateWithoutCustomPlansInput>
  }

  export type SubscriptionPlanUpdateWithoutCustomPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutPlanNestedInput
    planPricing?: PlanPricingUpdateManyWithoutPlanNestedInput
    planFeatures?: PlanFeatureMatrixUpdateManyWithoutPlanNestedInput
    currentPlanRecommendations?: PlanRecommendationUpdateManyWithoutCurrentPlanNestedInput
    recommendedPlanRecommendations?: PlanRecommendationUpdateManyWithoutRecommendedPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateWithoutCustomPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    planPricing?: PlanPricingUncheckedUpdateManyWithoutPlanNestedInput
    planFeatures?: PlanFeatureMatrixUncheckedUpdateManyWithoutPlanNestedInput
    currentPlanRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutCurrentPlanNestedInput
    recommendedPlanRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutRecommendedPlanNestedInput
  }

  export type PlanFeatureMatrixCreateWithoutFeatureFlagInput = {
    id?: string
    isEnabled?: boolean
    usageLimit?: number | null
    includedUsage?: number
    overageRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutPlanFeaturesInput
  }

  export type PlanFeatureMatrixUncheckedCreateWithoutFeatureFlagInput = {
    id?: string
    planId: string
    isEnabled?: boolean
    usageLimit?: number | null
    includedUsage?: number
    overageRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PlanFeatureMatrixCreateOrConnectWithoutFeatureFlagInput = {
    where: PlanFeatureMatrixWhereUniqueInput
    create: XOR<PlanFeatureMatrixCreateWithoutFeatureFlagInput, PlanFeatureMatrixUncheckedCreateWithoutFeatureFlagInput>
  }

  export type PlanFeatureMatrixCreateManyFeatureFlagInputEnvelope = {
    data: PlanFeatureMatrixCreateManyFeatureFlagInput | PlanFeatureMatrixCreateManyFeatureFlagInput[]
    skipDuplicates?: boolean
  }

  export type PlanFeatureMatrixUpsertWithWhereUniqueWithoutFeatureFlagInput = {
    where: PlanFeatureMatrixWhereUniqueInput
    update: XOR<PlanFeatureMatrixUpdateWithoutFeatureFlagInput, PlanFeatureMatrixUncheckedUpdateWithoutFeatureFlagInput>
    create: XOR<PlanFeatureMatrixCreateWithoutFeatureFlagInput, PlanFeatureMatrixUncheckedCreateWithoutFeatureFlagInput>
  }

  export type PlanFeatureMatrixUpdateWithWhereUniqueWithoutFeatureFlagInput = {
    where: PlanFeatureMatrixWhereUniqueInput
    data: XOR<PlanFeatureMatrixUpdateWithoutFeatureFlagInput, PlanFeatureMatrixUncheckedUpdateWithoutFeatureFlagInput>
  }

  export type PlanFeatureMatrixUpdateManyWithWhereWithoutFeatureFlagInput = {
    where: PlanFeatureMatrixScalarWhereInput
    data: XOR<PlanFeatureMatrixUpdateManyMutationInput, PlanFeatureMatrixUncheckedUpdateManyWithoutFeatureFlagInput>
  }

  export type SubscriptionPlanCreateWithoutPlanFeaturesInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutPlanInput
    planPricing?: PlanPricingCreateNestedManyWithoutPlanInput
    currentPlanRecommendations?: PlanRecommendationCreateNestedManyWithoutCurrentPlanInput
    recommendedPlanRecommendations?: PlanRecommendationCreateNestedManyWithoutRecommendedPlanInput
    customPlans?: CustomPlanCreateNestedManyWithoutBasePlanInput
  }

  export type SubscriptionPlanUncheckedCreateWithoutPlanFeaturesInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    planCode?: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingInterval?: string
    tier?: string
    sortOrder?: number
    maxApiCalls?: bigint | number
    maxTokens?: bigint | number
    maxStorageMb?: bigint | number
    maxProcessingMin?: bigint | number
    maxWorkspaces?: number
    maxUsers?: number
    maxFileSize?: bigint | number
    maxTranscriptionsMonthly?: bigint | number
    maxFilesDaily?: number
    maxFilesMonthly?: number
    maxConcurrentJobs?: number
    maxVoiceSynthesisMonthly?: bigint | number
    maxExportOperationsMonthly?: number
    maxAudioDurationMinutes?: number
    priorityLevel?: number
    planCategory?: string
    trialDays?: number
    isCustom?: boolean
    isEnterprise?: boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanCreaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanCreateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanCreateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanCreatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanCreateintegrationFeaturesInput | string[]
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutPlanInput
    planPricing?: PlanPricingUncheckedCreateNestedManyWithoutPlanInput
    currentPlanRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutCurrentPlanInput
    recommendedPlanRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutRecommendedPlanInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutBasePlanInput
  }

  export type SubscriptionPlanCreateOrConnectWithoutPlanFeaturesInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutPlanFeaturesInput, SubscriptionPlanUncheckedCreateWithoutPlanFeaturesInput>
  }

  export type FeatureFlagCreateWithoutPlanFeaturesInput = {
    id?: string
    featureName: string
    displayName: string
    description?: string | null
    category?: string | null
    featureType?: string | null
    minPlanLevel?: number
    requiredPlans?: FeatureFlagCreaterequiredPlansInput | string[]
    excludedPlans?: FeatureFlagCreateexcludedPlansInput | string[]
    isEnabled?: boolean
    isBeta?: boolean
    isDeprecated?: boolean
    usageCount?: bigint | number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagUncheckedCreateWithoutPlanFeaturesInput = {
    id?: string
    featureName: string
    displayName: string
    description?: string | null
    category?: string | null
    featureType?: string | null
    minPlanLevel?: number
    requiredPlans?: FeatureFlagCreaterequiredPlansInput | string[]
    excludedPlans?: FeatureFlagCreateexcludedPlansInput | string[]
    isEnabled?: boolean
    isBeta?: boolean
    isDeprecated?: boolean
    usageCount?: bigint | number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagCreateOrConnectWithoutPlanFeaturesInput = {
    where: FeatureFlagWhereUniqueInput
    create: XOR<FeatureFlagCreateWithoutPlanFeaturesInput, FeatureFlagUncheckedCreateWithoutPlanFeaturesInput>
  }

  export type SubscriptionPlanUpsertWithoutPlanFeaturesInput = {
    update: XOR<SubscriptionPlanUpdateWithoutPlanFeaturesInput, SubscriptionPlanUncheckedUpdateWithoutPlanFeaturesInput>
    create: XOR<SubscriptionPlanCreateWithoutPlanFeaturesInput, SubscriptionPlanUncheckedCreateWithoutPlanFeaturesInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutPlanFeaturesInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutPlanFeaturesInput, SubscriptionPlanUncheckedUpdateWithoutPlanFeaturesInput>
  }

  export type SubscriptionPlanUpdateWithoutPlanFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutPlanNestedInput
    planPricing?: PlanPricingUpdateManyWithoutPlanNestedInput
    currentPlanRecommendations?: PlanRecommendationUpdateManyWithoutCurrentPlanNestedInput
    recommendedPlanRecommendations?: PlanRecommendationUpdateManyWithoutRecommendedPlanNestedInput
    customPlans?: CustomPlanUpdateManyWithoutBasePlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateWithoutPlanFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planCode?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    sortOrder?: FloatFieldUpdateOperationsInput | number
    maxApiCalls?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    maxStorageMb?: BigIntFieldUpdateOperationsInput | bigint | number
    maxProcessingMin?: BigIntFieldUpdateOperationsInput | bigint | number
    maxWorkspaces?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    maxTranscriptionsMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxFilesDaily?: IntFieldUpdateOperationsInput | number
    maxFilesMonthly?: IntFieldUpdateOperationsInput | number
    maxConcurrentJobs?: IntFieldUpdateOperationsInput | number
    maxVoiceSynthesisMonthly?: BigIntFieldUpdateOperationsInput | bigint | number
    maxExportOperationsMonthly?: IntFieldUpdateOperationsInput | number
    maxAudioDurationMinutes?: IntFieldUpdateOperationsInput | number
    priorityLevel?: IntFieldUpdateOperationsInput | number
    planCategory?: StringFieldUpdateOperationsInput | string
    trialDays?: IntFieldUpdateOperationsInput | number
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    isEnterprise?: BoolFieldUpdateOperationsInput | boolean
    features?: JsonNullValueInput | InputJsonValue
    recommendedFor?: SubscriptionPlanUpdaterecommendedForInput | string[]
    allowedFileTypes?: SubscriptionPlanUpdateallowedFileTypesInput | string[]
    analysisFeatures?: SubscriptionPlanUpdateanalysisFeaturesInput | string[]
    collaborationFeatures?: SubscriptionPlanUpdatecollaborationFeaturesInput | string[]
    integrationFeatures?: SubscriptionPlanUpdateintegrationFeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    planPricing?: PlanPricingUncheckedUpdateManyWithoutPlanNestedInput
    currentPlanRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutCurrentPlanNestedInput
    recommendedPlanRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutRecommendedPlanNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutBasePlanNestedInput
  }

  export type FeatureFlagUpsertWithoutPlanFeaturesInput = {
    update: XOR<FeatureFlagUpdateWithoutPlanFeaturesInput, FeatureFlagUncheckedUpdateWithoutPlanFeaturesInput>
    create: XOR<FeatureFlagCreateWithoutPlanFeaturesInput, FeatureFlagUncheckedCreateWithoutPlanFeaturesInput>
    where?: FeatureFlagWhereInput
  }

  export type FeatureFlagUpdateToOneWithWhereWithoutPlanFeaturesInput = {
    where?: FeatureFlagWhereInput
    data: XOR<FeatureFlagUpdateWithoutPlanFeaturesInput, FeatureFlagUncheckedUpdateWithoutPlanFeaturesInput>
  }

  export type FeatureFlagUpdateWithoutPlanFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    minPlanLevel?: IntFieldUpdateOperationsInput | number
    requiredPlans?: FeatureFlagUpdaterequiredPlansInput | string[]
    excludedPlans?: FeatureFlagUpdateexcludedPlansInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isBeta?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: BigIntFieldUpdateOperationsInput | bigint | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagUncheckedUpdateWithoutPlanFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: NullableStringFieldUpdateOperationsInput | string | null
    minPlanLevel?: IntFieldUpdateOperationsInput | number
    requiredPlans?: FeatureFlagUpdaterequiredPlansInput | string[]
    excludedPlans?: FeatureFlagUpdateexcludedPlansInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isBeta?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: BigIntFieldUpdateOperationsInput | bigint | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutEwayCustomersInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEwayCustomersInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEwayCustomersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEwayCustomersInput, UserUncheckedCreateWithoutEwayCustomersInput>
  }

  export type EwayTransactionCreateWithoutEwayCustomerInput = {
    id?: string
    workspaceId?: string | null
    subscriptionId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    ewayTransactionId?: bigint | number | null
    ewayAccessCode?: string | null
    ewayAuthCode?: string | null
    responseCode?: string | null
    responseMessage?: string | null
    transactionStatus: string
    isRecurring?: boolean
    ewayInvoiceNumber?: string | null
    ewayInvoiceReference?: string | null
    fraudAction?: string | null
    verificationStatus?: string | null
    beagleScore?: number | null
    errorCode?: string | null
    errorMessage?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutEwayTransactionsInput
  }

  export type EwayTransactionUncheckedCreateWithoutEwayCustomerInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    subscriptionId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    ewayTransactionId?: bigint | number | null
    ewayAccessCode?: string | null
    ewayAuthCode?: string | null
    responseCode?: string | null
    responseMessage?: string | null
    transactionStatus: string
    isRecurring?: boolean
    ewayInvoiceNumber?: string | null
    ewayInvoiceReference?: string | null
    fraudAction?: string | null
    verificationStatus?: string | null
    beagleScore?: number | null
    errorCode?: string | null
    errorMessage?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayTransactionCreateOrConnectWithoutEwayCustomerInput = {
    where: EwayTransactionWhereUniqueInput
    create: XOR<EwayTransactionCreateWithoutEwayCustomerInput, EwayTransactionUncheckedCreateWithoutEwayCustomerInput>
  }

  export type EwayTransactionCreateManyEwayCustomerInputEnvelope = {
    data: EwayTransactionCreateManyEwayCustomerInput | EwayTransactionCreateManyEwayCustomerInput[]
    skipDuplicates?: boolean
  }

  export type EwayRecurringScheduleCreateWithoutEwayCustomerInput = {
    id?: string
    workspaceId?: string | null
    subscriptionId: string
    scheduleType: string
    billingAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    startDate: Date | string
    nextBillingDate: Date | string
    lastProcessedAt?: Date | string | null
    status?: string
    failedAttempts?: number
    lastTransactionId?: string | null
    cancelledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEwayRecurringSchedulesInput
  }

  export type EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    subscriptionId: string
    scheduleType: string
    billingAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    startDate: Date | string
    nextBillingDate: Date | string
    lastProcessedAt?: Date | string | null
    status?: string
    failedAttempts?: number
    lastTransactionId?: string | null
    cancelledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput = {
    where: EwayRecurringScheduleWhereUniqueInput
    create: XOR<EwayRecurringScheduleCreateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput>
  }

  export type EwayRecurringScheduleCreateManyEwayCustomerInputEnvelope = {
    data: EwayRecurringScheduleCreateManyEwayCustomerInput | EwayRecurringScheduleCreateManyEwayCustomerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEwayCustomersInput = {
    update: XOR<UserUpdateWithoutEwayCustomersInput, UserUncheckedUpdateWithoutEwayCustomersInput>
    create: XOR<UserCreateWithoutEwayCustomersInput, UserUncheckedCreateWithoutEwayCustomersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEwayCustomersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEwayCustomersInput, UserUncheckedUpdateWithoutEwayCustomersInput>
  }

  export type UserUpdateWithoutEwayCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEwayCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EwayTransactionUpsertWithWhereUniqueWithoutEwayCustomerInput = {
    where: EwayTransactionWhereUniqueInput
    update: XOR<EwayTransactionUpdateWithoutEwayCustomerInput, EwayTransactionUncheckedUpdateWithoutEwayCustomerInput>
    create: XOR<EwayTransactionCreateWithoutEwayCustomerInput, EwayTransactionUncheckedCreateWithoutEwayCustomerInput>
  }

  export type EwayTransactionUpdateWithWhereUniqueWithoutEwayCustomerInput = {
    where: EwayTransactionWhereUniqueInput
    data: XOR<EwayTransactionUpdateWithoutEwayCustomerInput, EwayTransactionUncheckedUpdateWithoutEwayCustomerInput>
  }

  export type EwayTransactionUpdateManyWithWhereWithoutEwayCustomerInput = {
    where: EwayTransactionScalarWhereInput
    data: XOR<EwayTransactionUpdateManyMutationInput, EwayTransactionUncheckedUpdateManyWithoutEwayCustomerInput>
  }

  export type EwayRecurringScheduleUpsertWithWhereUniqueWithoutEwayCustomerInput = {
    where: EwayRecurringScheduleWhereUniqueInput
    update: XOR<EwayRecurringScheduleUpdateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedUpdateWithoutEwayCustomerInput>
    create: XOR<EwayRecurringScheduleCreateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput>
  }

  export type EwayRecurringScheduleUpdateWithWhereUniqueWithoutEwayCustomerInput = {
    where: EwayRecurringScheduleWhereUniqueInput
    data: XOR<EwayRecurringScheduleUpdateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedUpdateWithoutEwayCustomerInput>
  }

  export type EwayRecurringScheduleUpdateManyWithWhereWithoutEwayCustomerInput = {
    where: EwayRecurringScheduleScalarWhereInput
    data: XOR<EwayRecurringScheduleUpdateManyMutationInput, EwayRecurringScheduleUncheckedUpdateManyWithoutEwayCustomerInput>
  }

  export type UserCreateWithoutEwayTransactionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEwayTransactionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEwayTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEwayTransactionsInput, UserUncheckedCreateWithoutEwayTransactionsInput>
  }

  export type EwayCustomerCreateWithoutTransactionsInput = {
    id?: string
    ewayCustomerToken: string
    firstName: string
    lastName: string
    email: string
    companyName?: string | null
    country?: string
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    cardLastFour?: string | null
    cardType?: string | null
    cardExpiryMonth?: number | null
    cardExpiryYear?: number | null
    ewayReference?: string | null
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEwayCustomersInput
    recurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    ewayCustomerToken: string
    firstName: string
    lastName: string
    email: string
    companyName?: string | null
    country?: string
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    cardLastFour?: string | null
    cardType?: string | null
    cardExpiryMonth?: number | null
    cardExpiryYear?: number | null
    ewayReference?: string | null
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerCreateOrConnectWithoutTransactionsInput = {
    where: EwayCustomerWhereUniqueInput
    create: XOR<EwayCustomerCreateWithoutTransactionsInput, EwayCustomerUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutEwayTransactionsInput = {
    update: XOR<UserUpdateWithoutEwayTransactionsInput, UserUncheckedUpdateWithoutEwayTransactionsInput>
    create: XOR<UserCreateWithoutEwayTransactionsInput, UserUncheckedCreateWithoutEwayTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEwayTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEwayTransactionsInput, UserUncheckedUpdateWithoutEwayTransactionsInput>
  }

  export type UserUpdateWithoutEwayTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEwayTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EwayCustomerUpsertWithoutTransactionsInput = {
    update: XOR<EwayCustomerUpdateWithoutTransactionsInput, EwayCustomerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<EwayCustomerCreateWithoutTransactionsInput, EwayCustomerUncheckedCreateWithoutTransactionsInput>
    where?: EwayCustomerWhereInput
  }

  export type EwayCustomerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: EwayCustomerWhereInput
    data: XOR<EwayCustomerUpdateWithoutTransactionsInput, EwayCustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type EwayCustomerUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ewayCustomerToken?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardLastFour?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    ewayReference?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEwayCustomersNestedInput
    recurringSchedules?: EwayRecurringScheduleUpdateManyWithoutEwayCustomerNestedInput
  }

  export type EwayCustomerUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ewayCustomerToken?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardLastFour?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    ewayReference?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutEwayCustomerNestedInput
  }

  export type UserCreateWithoutEwayRecurringSchedulesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEwayRecurringSchedulesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEwayRecurringSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEwayRecurringSchedulesInput, UserUncheckedCreateWithoutEwayRecurringSchedulesInput>
  }

  export type EwayCustomerCreateWithoutRecurringSchedulesInput = {
    id?: string
    ewayCustomerToken: string
    firstName: string
    lastName: string
    email: string
    companyName?: string | null
    country?: string
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    cardLastFour?: string | null
    cardType?: string | null
    cardExpiryMonth?: number | null
    cardExpiryYear?: number | null
    ewayReference?: string | null
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEwayCustomersInput
    transactions?: EwayTransactionCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerUncheckedCreateWithoutRecurringSchedulesInput = {
    id?: string
    userId: string
    ewayCustomerToken: string
    firstName: string
    lastName: string
    email: string
    companyName?: string | null
    country?: string
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    cardLastFour?: string | null
    cardType?: string | null
    cardExpiryMonth?: number | null
    cardExpiryYear?: number | null
    ewayReference?: string | null
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: EwayTransactionUncheckedCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerCreateOrConnectWithoutRecurringSchedulesInput = {
    where: EwayCustomerWhereUniqueInput
    create: XOR<EwayCustomerCreateWithoutRecurringSchedulesInput, EwayCustomerUncheckedCreateWithoutRecurringSchedulesInput>
  }

  export type UserUpsertWithoutEwayRecurringSchedulesInput = {
    update: XOR<UserUpdateWithoutEwayRecurringSchedulesInput, UserUncheckedUpdateWithoutEwayRecurringSchedulesInput>
    create: XOR<UserCreateWithoutEwayRecurringSchedulesInput, UserUncheckedCreateWithoutEwayRecurringSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEwayRecurringSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEwayRecurringSchedulesInput, UserUncheckedUpdateWithoutEwayRecurringSchedulesInput>
  }

  export type UserUpdateWithoutEwayRecurringSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEwayRecurringSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EwayCustomerUpsertWithoutRecurringSchedulesInput = {
    update: XOR<EwayCustomerUpdateWithoutRecurringSchedulesInput, EwayCustomerUncheckedUpdateWithoutRecurringSchedulesInput>
    create: XOR<EwayCustomerCreateWithoutRecurringSchedulesInput, EwayCustomerUncheckedCreateWithoutRecurringSchedulesInput>
    where?: EwayCustomerWhereInput
  }

  export type EwayCustomerUpdateToOneWithWhereWithoutRecurringSchedulesInput = {
    where?: EwayCustomerWhereInput
    data: XOR<EwayCustomerUpdateWithoutRecurringSchedulesInput, EwayCustomerUncheckedUpdateWithoutRecurringSchedulesInput>
  }

  export type EwayCustomerUpdateWithoutRecurringSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ewayCustomerToken?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardLastFour?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    ewayReference?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEwayCustomersNestedInput
    transactions?: EwayTransactionUpdateManyWithoutEwayCustomerNestedInput
  }

  export type EwayCustomerUncheckedUpdateWithoutRecurringSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ewayCustomerToken?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardLastFour?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    ewayReference?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: EwayTransactionUncheckedUpdateManyWithoutEwayCustomerNestedInput
  }

  export type UserCreateWithoutExportsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExportsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExportsInput, UserUncheckedCreateWithoutExportsInput>
  }

  export type UserUpsertWithoutExportsInput = {
    update: XOR<UserUpdateWithoutExportsInput, UserUncheckedUpdateWithoutExportsInput>
    create: XOR<UserCreateWithoutExportsInput, UserUncheckedCreateWithoutExportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExportsInput, UserUncheckedUpdateWithoutExportsInput>
  }

  export type UserUpdateWithoutExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type WorkspaceCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: WorkspaceSettingsUncheckedCreateNestedOneWithoutWorkspaceInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuota?: StorageQuotaUncheckedCreateNestedOneWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAuditLogsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAuditLogsInput, WorkspaceUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutAuditLogsInput = {
    update: XOR<WorkspaceUpdateWithoutAuditLogsInput, WorkspaceUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<WorkspaceCreateWithoutAuditLogsInput, WorkspaceUncheckedCreateWithoutAuditLogsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAuditLogsInput, WorkspaceUncheckedUpdateWithoutAuditLogsInput>
  }

  export type WorkspaceUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: WorkspaceSettingsUncheckedUpdateOneWithoutWorkspaceNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuota?: StorageQuotaUncheckedUpdateOneWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutTestimonialsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
  }

  export type UserUncheckedCreateWithoutTestimonialsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
  }

  export type UserCreateOrConnectWithoutTestimonialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestimonialsInput, UserUncheckedCreateWithoutTestimonialsInput>
  }

  export type UserUpsertWithoutTestimonialsInput = {
    update: XOR<UserUpdateWithoutTestimonialsInput, UserUncheckedUpdateWithoutTestimonialsInput>
    create: XOR<UserCreateWithoutTestimonialsInput, UserUncheckedCreateWithoutTestimonialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestimonialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestimonialsInput, UserUncheckedUpdateWithoutTestimonialsInput>
  }

  export type UserUpdateWithoutTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
  }

  export type RolePermissionCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutRoleInput = {
    id?: string
    assignedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutUserRolesInput
    assignedByUser?: UserCreateNestedOneWithoutAssignedRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
    assignedBy?: string | null
    assignedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    isSystemRole?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    isSystemRole?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRolesInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    resource: string
    action: string
    isSystemPermission?: boolean
    createdAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    resource: string
    action: string
    isSystemPermission?: boolean
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isSystemPermission?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isSystemPermission?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUserRolesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    isSystemRole?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    isSystemRole?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutAssignedRolesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    projects?: AudioProjectCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricCreateNestedManyWithoutUserInput
    exports?: ExportHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    quota?: UserQuotaCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedRolesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    isActive?: boolean
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    timezone?: string | null
    businessName?: string | null
    mobileNumber?: string | null
    country?: string | null
    currency?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    taxNumber?: string | null
    companySize?: string | null
    industry?: string | null
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    projects?: AudioProjectUncheckedCreateNestedManyWithoutUserInput
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    quota?: UserQuotaUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    processingTemplates?: ProcessingTemplateUncheckedCreateNestedManyWithoutUserInput
    customPlans?: CustomPlanUncheckedCreateNestedManyWithoutRequestedByUserInput
    planRecommendations?: PlanRecommendationUncheckedCreateNestedManyWithoutUserInput
    usageCounters?: UsageCounterUncheckedCreateNestedManyWithoutUserInput
    ewayCustomers?: EwayCustomerUncheckedCreateNestedManyWithoutUserInput
    ewayTransactions?: EwayTransactionUncheckedCreateNestedManyWithoutUserInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserUpsertWithoutAssignedRolesInput = {
    update: XOR<UserUpdateWithoutAssignedRolesInput, UserUncheckedUpdateWithoutAssignedRolesInput>
    create: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedRolesInput, UserUncheckedUpdateWithoutAssignedRolesInput>
  }

  export type UserUpdateWithoutAssignedRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    projects?: AudioProjectUncheckedUpdateManyWithoutUserNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    quota?: UserQuotaUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    processingTemplates?: ProcessingTemplateUncheckedUpdateManyWithoutUserNestedInput
    customPlans?: CustomPlanUncheckedUpdateManyWithoutRequestedByUserNestedInput
    planRecommendations?: PlanRecommendationUncheckedUpdateManyWithoutUserNestedInput
    usageCounters?: UsageCounterUncheckedUpdateManyWithoutUserNestedInput
    ewayCustomers?: EwayCustomerUncheckedUpdateManyWithoutUserNestedInput
    ewayTransactions?: EwayTransactionUncheckedUpdateManyWithoutUserNestedInput
    ewayRecurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUserCreateManyWorkspaceInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateManyWorkspaceInput = {
    id?: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    invitedById?: string | null
  }

  export type AudioHistoryCreateManyWorkspaceInput = {
    id?: string
    userId: string
    uploadId?: string | null
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioUploadCreateManyWorkspaceInput = {
    id?: string
    userId: string
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AudioProjectCreateManyWorkspaceInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    color?: string | null
    status?: string
    isPublic?: boolean
    tags?: AudioProjectCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageMetricCreateManyWorkspaceInput = {
    id?: string
    userId: string
    metricType: string
    provider?: string | null
    quantity: bigint | number
    cost: Decimal | DecimalJsLike | number | string
    currency?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
    recordedAt?: Date | string
  }

  export type WorkspaceSubscriptionCreateManyWorkspaceInput = {
    id?: string
    planId: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyWorkspaceInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: string
    category?: string | null
    createdAt?: Date | string
  }

  export type WorkspaceUserUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
  }

  export type WorkspaceUserUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AudioHistoryUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioHistoryNestedInput
    upload?: AudioUploadUpdateOneWithoutAudioHistoryNestedInput
    segments?: AudioSegmentUpdateManyWithoutHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    uploadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segments?: AudioSegmentUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    uploadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioUploadUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAudioUploadsNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUploadNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUpdateManyWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUploadNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUncheckedUpdateManyWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioProjectUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: AudioProjectUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type AudioProjectUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: AudioProjectUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioProjectUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: AudioProjectUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsageMetricsNestedInput
  }

  export type UsageMetricUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceSubscriptionUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    billingRecords?: BillingRecordUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingRecords?: BillingRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioHistoryCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    uploadId?: string | null
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    createdAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type WorkspaceUserCreateManyUserInput = {
    id?: string
    workspaceId: string
    role?: string
    joinedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: Date | string | null
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type AudioUploadCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    originalFilename: string
    fileSize: bigint | number
    fileType: string
    mimeType: string
    duration?: number | null
    sampleRate?: number | null
    channels?: number | null
    bitrate?: number | null
    storageProvider?: string
    storagePath: string
    storageUrl?: string | null
    cdnUrl?: string | null
    checksumMd5?: string | null
    checksumSha256?: string | null
    status?: string
    uploadedAt?: Date | string
    processingStartedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AudioProjectCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    name: string
    description?: string | null
    color?: string | null
    status?: string
    isPublic?: boolean
    tags?: AudioProjectCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessingJobCreateManyUserInput = {
    id?: string
    uploadId: string
    jobType: string
    priority?: number
    processingOptions: JsonNullValueInput | InputJsonValue
    status?: string
    progress?: number
    cpuTimeMs?: bigint | number | null
    memoryUsageMb?: number | null
    queuedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    maxRetries?: number
  }

  export type UsageMetricCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    metricType: string
    provider?: string | null
    quantity: bigint | number
    cost: Decimal | DecimalJsLike | number | string
    currency?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
    recordedAt?: Date | string
  }

  export type ExportHistoryCreateManyUserInput = {
    id?: string
    exportType: string
    dataType: string
    dateFrom?: Date | string | null
    dateTo?: Date | string | null
    workspaceIds?: ExportHistoryCreateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename: string
    fileSize: bigint | number
    storagePath?: string | null
    downloadUrl?: string | null
    expiresAt?: Date | string | null
    status?: string
    downloadCount?: number
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ApiKeyManagementCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    provider: string
    keyName: string
    encryptedKey: string
    keyHash: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    totalRequests?: bigint | number
    totalTokens?: bigint | number
    totalCost?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: string
    category?: string | null
    createdAt?: Date | string
  }

  export type SecurityEventCreateManyUserInput = {
    id?: string
    eventType: string
    severity?: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ProcessingTemplateCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    name: string
    description?: string | null
    summaryStyle?: string
    temperature?: number
    maxTokens?: number
    language?: string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomPlanCreateManyRequestedByUserInput = {
    id?: string
    workspaceId: string
    basePlanId?: string | null
    planName: string
    description?: string | null
    customMaxTranscriptionsMonthly?: bigint | number | null
    customMaxFilesDaily?: number | null
    customMaxFilesMonthly?: number | null
    customMaxConcurrentJobs?: number | null
    customMaxVoiceSynthesisMonthly?: bigint | number | null
    customMaxExportOperationsMonthly?: number | null
    customMaxAudioDurationMinutes?: number | null
    customPriorityLevel?: number | null
    customFeatures?: CustomPlanCreatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanCreateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanCreateadditionalFeaturesInput | string[]
    customPrice?: Decimal | DecimalJsLike | number | string | null
    pricingModel?: string
    billingInterval?: string
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenew?: boolean
    noticePeriodDays?: number
    approvedBy?: string | null
    approvalStatus?: string
    approvalNotes?: string | null
    isActive?: boolean
    activatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanRecommendationCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    currentPlanId: string
    recommendedPlanId: string
    recommendationReason: string
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: Decimal | DecimalJsLike | number | string | null
    roiMonths?: number | null
    triggeredBy?: string | null
    benefits?: PlanRecommendationCreatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationCreatelimitationsRemovedInput | string[]
    status?: string
    viewedAt?: Date | string | null
    dismissedAt?: Date | string | null
    acceptedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageCounterCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    periodType: string
    periodStart: Date | string
    periodEnd: Date | string
    transcriptionsUsed?: number
    filesUploaded?: number
    voiceSynthesisUsed?: number
    exportOperationsUsed?: number
    totalProcessingMinutes?: Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: Date | string
    autoReset?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayCustomerCreateManyUserInput = {
    id?: string
    ewayCustomerToken: string
    firstName: string
    lastName: string
    email: string
    companyName?: string | null
    country?: string
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    cardLastFour?: string | null
    cardType?: string | null
    cardExpiryMonth?: number | null
    cardExpiryYear?: number | null
    ewayReference?: string | null
    isActive?: boolean
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayTransactionCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    ewayCustomerId: string
    subscriptionId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    ewayTransactionId?: bigint | number | null
    ewayAccessCode?: string | null
    ewayAuthCode?: string | null
    responseCode?: string | null
    responseMessage?: string | null
    transactionStatus: string
    isRecurring?: boolean
    ewayInvoiceNumber?: string | null
    ewayInvoiceReference?: string | null
    fraudAction?: string | null
    verificationStatus?: string | null
    beagleScore?: number | null
    errorCode?: string | null
    errorMessage?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayRecurringScheduleCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    ewayCustomerId: string
    subscriptionId: string
    scheduleType: string
    billingAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    startDate: Date | string
    nextBillingDate: Date | string
    lastProcessedAt?: Date | string | null
    status?: string
    failedAttempts?: number
    lastTransactionId?: string | null
    cancelledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRoleCreateManyUserInput = {
    id?: string
    roleId: string
    assignedBy?: string | null
    assignedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type UserRoleCreateManyAssignedByUserInput = {
    id?: string
    userId: string
    roleId: string
    assignedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type TestimonialCreateManyUserInput = {
    id?: string
    customerName: string
    customerRole?: string | null
    companyName?: string | null
    avatarUrl?: string | null
    content: string
    rating?: number
    featuredOn?: string | null
    useCase?: string | null
    isVerified?: boolean
    verificationMethod?: string | null
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneWithoutAudioHistoryNestedInput
    upload?: AudioUploadUpdateOneWithoutAudioHistoryNestedInput
    segments?: AudioSegmentUpdateManyWithoutHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segments?: AudioSegmentUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutUsersNestedInput
  }

  export type WorkspaceUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioUploadUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneWithoutAudioUploadsNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUploadNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUpdateManyWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUploadNestedInput
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUncheckedUpdateManyWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    fileType?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleRate?: NullableIntFieldUpdateOperationsInput | number | null
    channels?: NullableIntFieldUpdateOperationsInput | number | null
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    checksumSha256?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioProjectUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: AudioProjectUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneWithoutProjectsNestedInput
  }

  export type AudioProjectUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: AudioProjectUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioProjectUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: AudioProjectUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessingJobUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    processingOptions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    cpuTimeMs?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    memoryUsageMb?: NullableIntFieldUpdateOperationsInput | number | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    upload?: AudioUploadUpdateOneRequiredWithoutProcessingJobsNestedInput
  }

  export type ProcessingJobUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    processingOptions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    cpuTimeMs?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    memoryUsageMb?: NullableIntFieldUpdateOperationsInput | number | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessingJobUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    processingOptions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    cpuTimeMs?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    memoryUsageMb?: NullableIntFieldUpdateOperationsInput | number | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
  }

  export type UsageMetricUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneWithoutUsageMetricsNestedInput
  }

  export type UsageMetricUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    metricType?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    metricType?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    dateFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaceIds?: ExportHistoryUpdateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExportHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    dateFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaceIds?: ExportHistoryUpdateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExportHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    dateFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaceIds?: ExportHistoryUpdateworkspaceIdsInput | string[]
    filters?: NullableJsonNullValueInput | InputJsonValue
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyManagementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRequests?: BigIntFieldUpdateOperationsInput | bigint | number
    totalTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyManagementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRequests?: BigIntFieldUpdateOperationsInput | bigint | number
    totalTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyManagementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRequests?: BigIntFieldUpdateOperationsInput | bigint | number
    totalTokens?: BigIntFieldUpdateOperationsInput | bigint | number
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProcessingTemplateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summaryStyle?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessingTemplateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summaryStyle?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessingTemplateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summaryStyle?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    configJson?: JsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPlanUpdateWithoutRequestedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customMaxTranscriptionsMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxFilesDaily?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxFilesMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxConcurrentJobs?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxVoiceSynthesisMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxExportOperationsMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxAudioDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customPriorityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    customFeatures?: CustomPlanUpdatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanUpdateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanUpdateadditionalFeaturesInput | string[]
    customPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    noticePeriodDays?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePlan?: SubscriptionPlanUpdateOneWithoutCustomPlansNestedInput
  }

  export type CustomPlanUncheckedUpdateWithoutRequestedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    basePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customMaxTranscriptionsMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxFilesDaily?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxFilesMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxConcurrentJobs?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxVoiceSynthesisMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxExportOperationsMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxAudioDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customPriorityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    customFeatures?: CustomPlanUpdatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanUpdateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanUpdateadditionalFeaturesInput | string[]
    customPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    noticePeriodDays?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPlanUncheckedUpdateManyWithoutRequestedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    basePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customMaxTranscriptionsMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxFilesDaily?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxFilesMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxConcurrentJobs?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxVoiceSynthesisMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxExportOperationsMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxAudioDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customPriorityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    customFeatures?: CustomPlanUpdatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanUpdateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanUpdateadditionalFeaturesInput | string[]
    customPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    noticePeriodDays?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanRecommendationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPlan?: SubscriptionPlanUpdateOneRequiredWithoutCurrentPlanRecommendationsNestedInput
    recommendedPlan?: SubscriptionPlanUpdateOneRequiredWithoutRecommendedPlanRecommendationsNestedInput
  }

  export type PlanRecommendationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPlanId?: StringFieldUpdateOperationsInput | string
    recommendedPlanId?: StringFieldUpdateOperationsInput | string
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanRecommendationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPlanId?: StringFieldUpdateOperationsInput | string
    recommendedPlanId?: StringFieldUpdateOperationsInput | string
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageCounterUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    periodType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptionsUsed?: IntFieldUpdateOperationsInput | number
    filesUploaded?: IntFieldUpdateOperationsInput | number
    voiceSynthesisUsed?: IntFieldUpdateOperationsInput | number
    exportOperationsUsed?: IntFieldUpdateOperationsInput | number
    totalProcessingMinutes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: IntFieldUpdateOperationsInput | number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoReset?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageCounterUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    periodType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptionsUsed?: IntFieldUpdateOperationsInput | number
    filesUploaded?: IntFieldUpdateOperationsInput | number
    voiceSynthesisUsed?: IntFieldUpdateOperationsInput | number
    exportOperationsUsed?: IntFieldUpdateOperationsInput | number
    totalProcessingMinutes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: IntFieldUpdateOperationsInput | number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoReset?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageCounterUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    periodType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptionsUsed?: IntFieldUpdateOperationsInput | number
    filesUploaded?: IntFieldUpdateOperationsInput | number
    voiceSynthesisUsed?: IntFieldUpdateOperationsInput | number
    exportOperationsUsed?: IntFieldUpdateOperationsInput | number
    totalProcessingMinutes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    concurrentJobsPeak?: IntFieldUpdateOperationsInput | number
    featureUsage?: JsonNullValueInput | InputJsonValue
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoReset?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayCustomerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ewayCustomerToken?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardLastFour?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    ewayReference?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: EwayTransactionUpdateManyWithoutEwayCustomerNestedInput
    recurringSchedules?: EwayRecurringScheduleUpdateManyWithoutEwayCustomerNestedInput
  }

  export type EwayCustomerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ewayCustomerToken?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardLastFour?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    ewayReference?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: EwayTransactionUncheckedUpdateManyWithoutEwayCustomerNestedInput
    recurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutEwayCustomerNestedInput
  }

  export type EwayCustomerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ewayCustomerToken?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardLastFour?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    ewayReference?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayTransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    ewayAuthCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionStatus?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    ewayInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ewayInvoiceReference?: NullableStringFieldUpdateOperationsInput | string | null
    fraudAction?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
    ewayCustomer?: EwayCustomerUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type EwayTransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayCustomerId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    ewayAuthCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionStatus?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    ewayInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ewayInvoiceReference?: NullableStringFieldUpdateOperationsInput | string | null
    fraudAction?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayCustomerId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    ewayAuthCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionStatus?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    ewayInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ewayInvoiceReference?: NullableStringFieldUpdateOperationsInput | string | null
    fraudAction?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayRecurringScheduleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    billingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lastTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayCustomer?: EwayCustomerUpdateOneRequiredWithoutRecurringSchedulesNestedInput
  }

  export type EwayRecurringScheduleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayCustomerId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    billingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lastTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayRecurringScheduleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayCustomerId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    billingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lastTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    assignedByUser?: UserUpdateOneWithoutAssignedRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleUpdateWithoutAssignedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutAssignedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleUncheckedUpdateManyWithoutAssignedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestimonialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    featuredOn?: NullableStringFieldUpdateOperationsInput | string | null
    useCase?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    featuredOn?: NullableStringFieldUpdateOperationsInput | string | null
    useCase?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    featuredOn?: NullableStringFieldUpdateOperationsInput | string | null
    useCase?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioHistoryCreateManyUploadInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    title?: string | null
    audioUrl?: string | null
    cdnUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    wordCount?: number | null
    speakerCount?: number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    apiProvider?: string | null
    modelVersion?: string | null
    transcriptionCost?: Decimal | DecimalJsLike | number | string | null
    summarizationCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessingJobCreateManyUploadInput = {
    id?: string
    userId: string
    jobType: string
    priority?: number
    processingOptions: JsonNullValueInput | InputJsonValue
    status?: string
    progress?: number
    cpuTimeMs?: bigint | number | null
    memoryUsageMb?: number | null
    queuedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    maxRetries?: number
  }

  export type AudioChunkCreateManyUploadInput = {
    id?: string
    chunkIndex: number
    startTime: number
    endTime: number
    fileSize: bigint | number
    storagePath: string
    checksumMd5?: string | null
    status?: string
    processedAt?: Date | string | null
  }

  export type AudioHistoryUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioHistoryNestedInput
    workspace?: WorkspaceUpdateOneWithoutAudioHistoryNestedInput
    segments?: AudioSegmentUpdateManyWithoutHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segments?: AudioSegmentUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateManyWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableFloatFieldUpdateOperationsInput | number | null
    apiProvider?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptionCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    summarizationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessingJobUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    processingOptions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    cpuTimeMs?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    memoryUsageMb?: NullableIntFieldUpdateOperationsInput | number | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutProcessingJobsNestedInput
  }

  export type ProcessingJobUncheckedUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    processingOptions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    cpuTimeMs?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    memoryUsageMb?: NullableIntFieldUpdateOperationsInput | number | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessingJobUncheckedUpdateManyWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    processingOptions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    cpuTimeMs?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    memoryUsageMb?: NullableIntFieldUpdateOperationsInput | number | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
  }

  export type AudioChunkUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioChunkUncheckedUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioChunkUncheckedUpdateManyWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksumMd5?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioSegmentCreateManyHistoryInput = {
    id?: string
    segmentIndex: number
    startTime: number
    endTime: number
    text: string
    confidence?: number | null
    language?: string | null
    speakerId?: string | null
    emotion?: string | null
    sentiment?: string | null
    tokens?: AudioSegmentCreatetokensInput | number[]
    logprobs?: AudioSegmentCreatelogprobsInput | number[]
    temperature?: number | null
    avgLogprob?: number | null
    compressionRatio?: number | null
    noSpeechProb?: number | null
  }

  export type AudioSegmentUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    tokens?: AudioSegmentUpdatetokensInput | number[]
    logprobs?: AudioSegmentUpdatelogprobsInput | number[]
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    avgLogprob?: NullableFloatFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    noSpeechProb?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AudioSegmentUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    tokens?: AudioSegmentUpdatetokensInput | number[]
    logprobs?: AudioSegmentUpdatelogprobsInput | number[]
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    avgLogprob?: NullableFloatFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    noSpeechProb?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AudioSegmentUncheckedUpdateManyWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIndex?: IntFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    speakerId?: NullableStringFieldUpdateOperationsInput | string | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    tokens?: AudioSegmentUpdatetokensInput | number[]
    logprobs?: AudioSegmentUpdatelogprobsInput | number[]
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    avgLogprob?: NullableFloatFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    noSpeechProb?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WorkspaceSubscriptionCreateManyPlanInput = {
    id?: string
    workspaceId: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    trialEnd?: Date | string | null
    paymentGateway?: string
    paymentMethodId?: string | null
    currency?: string
    amount: Decimal | DecimalJsLike | number | string
    ewayCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPricingCreateManyPlanInput = {
    id?: string
    currency: string
    price: Decimal | DecimalJsLike | number | string
    billingPeriod: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanFeatureMatrixCreateManyPlanInput = {
    id?: string
    featureFlagId: string
    isEnabled?: boolean
    usageLimit?: number | null
    includedUsage?: number
    overageRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PlanRecommendationCreateManyCurrentPlanInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    recommendedPlanId: string
    recommendationReason: string
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: Decimal | DecimalJsLike | number | string | null
    roiMonths?: number | null
    triggeredBy?: string | null
    benefits?: PlanRecommendationCreatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationCreatelimitationsRemovedInput | string[]
    status?: string
    viewedAt?: Date | string | null
    dismissedAt?: Date | string | null
    acceptedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanRecommendationCreateManyRecommendedPlanInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    currentPlanId: string
    recommendationReason: string
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: Decimal | DecimalJsLike | number | string | null
    roiMonths?: number | null
    triggeredBy?: string | null
    benefits?: PlanRecommendationCreatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationCreatelimitationsRemovedInput | string[]
    status?: string
    viewedAt?: Date | string | null
    dismissedAt?: Date | string | null
    acceptedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomPlanCreateManyBasePlanInput = {
    id?: string
    workspaceId: string
    planName: string
    description?: string | null
    customMaxTranscriptionsMonthly?: bigint | number | null
    customMaxFilesDaily?: number | null
    customMaxFilesMonthly?: number | null
    customMaxConcurrentJobs?: number | null
    customMaxVoiceSynthesisMonthly?: bigint | number | null
    customMaxExportOperationsMonthly?: number | null
    customMaxAudioDurationMinutes?: number | null
    customPriorityLevel?: number | null
    customFeatures?: CustomPlanCreatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanCreateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanCreateadditionalFeaturesInput | string[]
    customPrice?: Decimal | DecimalJsLike | number | string | null
    pricingModel?: string
    billingInterval?: string
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenew?: boolean
    noticePeriodDays?: number
    requestedBy?: string | null
    approvedBy?: string | null
    approvalStatus?: string
    approvalNotes?: string | null
    isActive?: boolean
    activatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceSubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionsNestedInput
    billingRecords?: BillingRecordUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingRecords?: BillingRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGateway?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ewayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPricingUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPricingUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPricingUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureMatrixUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    includedUsage?: IntFieldUpdateOperationsInput | number
    overageRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureFlag?: FeatureFlagUpdateOneRequiredWithoutPlanFeaturesNestedInput
  }

  export type PlanFeatureMatrixUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureFlagId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    includedUsage?: IntFieldUpdateOperationsInput | number
    overageRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureMatrixUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureFlagId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    includedUsage?: IntFieldUpdateOperationsInput | number
    overageRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanRecommendationUpdateWithoutCurrentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlanRecommendationsNestedInput
    recommendedPlan?: SubscriptionPlanUpdateOneRequiredWithoutRecommendedPlanRecommendationsNestedInput
  }

  export type PlanRecommendationUncheckedUpdateWithoutCurrentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedPlanId?: StringFieldUpdateOperationsInput | string
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanRecommendationUncheckedUpdateManyWithoutCurrentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedPlanId?: StringFieldUpdateOperationsInput | string
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanRecommendationUpdateWithoutRecommendedPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlanRecommendationsNestedInput
    currentPlan?: SubscriptionPlanUpdateOneRequiredWithoutCurrentPlanRecommendationsNestedInput
  }

  export type PlanRecommendationUncheckedUpdateWithoutRecommendedPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPlanId?: StringFieldUpdateOperationsInput | string
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanRecommendationUncheckedUpdateManyWithoutRecommendedPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPlanId?: StringFieldUpdateOperationsInput | string
    recommendationReason?: StringFieldUpdateOperationsInput | string
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usagePattern?: NullableJsonNullValueInput | InputJsonValue
    projectedSavings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: PlanRecommendationUpdatebenefitsInput | string[]
    limitationsRemoved?: PlanRecommendationUpdatelimitationsRemovedInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPlanUpdateWithoutBasePlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customMaxTranscriptionsMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxFilesDaily?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxFilesMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxConcurrentJobs?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxVoiceSynthesisMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxExportOperationsMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxAudioDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customPriorityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    customFeatures?: CustomPlanUpdatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanUpdateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanUpdateadditionalFeaturesInput | string[]
    customPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    noticePeriodDays?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedByUser?: UserUpdateOneWithoutCustomPlansNestedInput
  }

  export type CustomPlanUncheckedUpdateWithoutBasePlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customMaxTranscriptionsMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxFilesDaily?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxFilesMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxConcurrentJobs?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxVoiceSynthesisMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxExportOperationsMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxAudioDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customPriorityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    customFeatures?: CustomPlanUpdatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanUpdateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanUpdateadditionalFeaturesInput | string[]
    customPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    noticePeriodDays?: IntFieldUpdateOperationsInput | number
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPlanUncheckedUpdateManyWithoutBasePlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customMaxTranscriptionsMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxFilesDaily?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxFilesMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxConcurrentJobs?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxVoiceSynthesisMonthly?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customMaxExportOperationsMonthly?: NullableIntFieldUpdateOperationsInput | number | null
    customMaxAudioDurationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customPriorityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    customFeatures?: CustomPlanUpdatecustomFeaturesInput | string[]
    excludedFeatures?: CustomPlanUpdateexcludedFeaturesInput | string[]
    additionalFeatures?: CustomPlanUpdateadditionalFeaturesInput | string[]
    customPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    billingInterval?: StringFieldUpdateOperationsInput | string
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    noticePeriodDays?: IntFieldUpdateOperationsInput | number
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRecordCreateManySubscriptionInput = {
    id?: string
    invoiceNumber: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    paymentMethod?: string | null
    invoiceDate: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    stripeInvoiceId?: string | null
    ewayTransactionId?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageRecordCreateManySubscriptionInput = {
    id?: string
    recordType: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingRecordUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRecordUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRecordUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    ewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    usageDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureMatrixCreateManyFeatureFlagInput = {
    id?: string
    planId: string
    isEnabled?: boolean
    usageLimit?: number | null
    includedUsage?: number
    overageRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PlanFeatureMatrixUpdateWithoutFeatureFlagInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    includedUsage?: IntFieldUpdateOperationsInput | number
    overageRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutPlanFeaturesNestedInput
  }

  export type PlanFeatureMatrixUncheckedUpdateWithoutFeatureFlagInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    includedUsage?: IntFieldUpdateOperationsInput | number
    overageRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureMatrixUncheckedUpdateManyWithoutFeatureFlagInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    includedUsage?: IntFieldUpdateOperationsInput | number
    overageRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayTransactionCreateManyEwayCustomerInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    subscriptionId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    ewayTransactionId?: bigint | number | null
    ewayAccessCode?: string | null
    ewayAuthCode?: string | null
    responseCode?: string | null
    responseMessage?: string | null
    transactionStatus: string
    isRecurring?: boolean
    ewayInvoiceNumber?: string | null
    ewayInvoiceReference?: string | null
    fraudAction?: string | null
    verificationStatus?: string | null
    beagleScore?: number | null
    errorCode?: string | null
    errorMessage?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayRecurringScheduleCreateManyEwayCustomerInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    subscriptionId: string
    scheduleType: string
    billingAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    startDate: Date | string
    nextBillingDate: Date | string
    lastProcessedAt?: Date | string | null
    status?: string
    failedAttempts?: number
    lastTransactionId?: string | null
    cancelledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayTransactionUpdateWithoutEwayCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    ewayAuthCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionStatus?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    ewayInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ewayInvoiceReference?: NullableStringFieldUpdateOperationsInput | string | null
    fraudAction?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutEwayTransactionsNestedInput
  }

  export type EwayTransactionUncheckedUpdateWithoutEwayCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    ewayAuthCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionStatus?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    ewayInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ewayInvoiceReference?: NullableStringFieldUpdateOperationsInput | string | null
    fraudAction?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayTransactionUncheckedUpdateManyWithoutEwayCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    ewayTransactionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ewayAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    ewayAuthCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionStatus?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    ewayInvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ewayInvoiceReference?: NullableStringFieldUpdateOperationsInput | string | null
    fraudAction?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayRawResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EwayRecurringScheduleUpdateWithoutEwayCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    billingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lastTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEwayRecurringSchedulesNestedInput
  }

  export type EwayRecurringScheduleUncheckedUpdateWithoutEwayCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    billingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lastTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayRecurringScheduleUncheckedUpdateManyWithoutEwayCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    scheduleType?: StringFieldUpdateOperationsInput | string
    billingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lastTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type UserRoleCreateManyRoleInput = {
    id?: string
    userId: string
    assignedBy?: string | null
    assignedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    assignedByUser?: UserUpdateOneWithoutAssignedRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use WorkspaceCountOutputTypeDefaultArgs instead
     */
    export type WorkspaceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioUploadCountOutputTypeDefaultArgs instead
     */
    export type AudioUploadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioUploadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioHistoryCountOutputTypeDefaultArgs instead
     */
    export type AudioHistoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioHistoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlanCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceSubscriptionCountOutputTypeDefaultArgs instead
     */
    export type WorkspaceSubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeatureFlagCountOutputTypeDefaultArgs instead
     */
    export type FeatureFlagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeatureFlagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EwayCustomerCountOutputTypeDefaultArgs instead
     */
    export type EwayCustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EwayCustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceDefaultArgs instead
     */
    export type WorkspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceUserDefaultArgs instead
     */
    export type WorkspaceUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceInvitationDefaultArgs instead
     */
    export type WorkspaceInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceInvitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SecurityEventDefaultArgs instead
     */
    export type SecurityEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SecurityEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSettingsDefaultArgs instead
     */
    export type UserSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceSettingsDefaultArgs instead
     */
    export type WorkspaceSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessingTemplateDefaultArgs instead
     */
    export type ProcessingTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessingTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyManagementDefaultArgs instead
     */
    export type ApiKeyManagementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyManagementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioUploadDefaultArgs instead
     */
    export type AudioUploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioUploadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessingJobDefaultArgs instead
     */
    export type ProcessingJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessingJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioHistoryDefaultArgs instead
     */
    export type AudioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioSegmentDefaultArgs instead
     */
    export type AudioSegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioSegmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioChunkDefaultArgs instead
     */
    export type AudioChunkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioChunkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioProjectDefaultArgs instead
     */
    export type AudioProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsageMetricDefaultArgs instead
     */
    export type UsageMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsageMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserQuotaDefaultArgs instead
     */
    export type UserQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserQuotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageQuotaDefaultArgs instead
     */
    export type StorageQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageQuotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlanDefaultArgs instead
     */
    export type SubscriptionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanPricingDefaultArgs instead
     */
    export type PlanPricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanPricingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CurrencyDefaultArgs instead
     */
    export type CurrencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CurrencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceSubscriptionDefaultArgs instead
     */
    export type WorkspaceSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BillingRecordDefaultArgs instead
     */
    export type BillingRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillingRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsageRecordDefaultArgs instead
     */
    export type UsageRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsageRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsageCounterDefaultArgs instead
     */
    export type UsageCounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsageCounterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanRecommendationDefaultArgs instead
     */
    export type PlanRecommendationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanRecommendationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomPlanDefaultArgs instead
     */
    export type CustomPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeatureFlagDefaultArgs instead
     */
    export type FeatureFlagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeatureFlagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanFeatureMatrixDefaultArgs instead
     */
    export type PlanFeatureMatrixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanFeatureMatrixDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EwayCustomerDefaultArgs instead
     */
    export type EwayCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EwayCustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EwayTransactionDefaultArgs instead
     */
    export type EwayTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EwayTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EwayRecurringScheduleDefaultArgs instead
     */
    export type EwayRecurringScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EwayRecurringScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EwayWebhookEventDefaultArgs instead
     */
    export type EwayWebhookEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EwayWebhookEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExportHistoryDefaultArgs instead
     */
    export type ExportHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExportHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DataRetentionPolicyDefaultArgs instead
     */
    export type DataRetentionPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataRetentionPolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentMethodDefaultArgs instead
     */
    export type PaymentMethodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentMethodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestimonialDefaultArgs instead
     */
    export type TestimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestimonialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebsiteContentDefaultArgs instead
     */
    export type WebsiteContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebsiteContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionDefaultArgs instead
     */
    export type RolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}