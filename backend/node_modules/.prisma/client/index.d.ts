
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Workspace
 * 
 */
export type Workspace = $Result.DefaultSelection<Prisma.$WorkspacePayload>
/**
 * Model WorkspaceUser
 * 
 */
export type WorkspaceUser = $Result.DefaultSelection<Prisma.$WorkspaceUserPayload>
/**
 * Model WorkspaceInvitation
 * 
 */
export type WorkspaceInvitation = $Result.DefaultSelection<Prisma.$WorkspaceInvitationPayload>
/**
 * Model AudioUpload
 * 
 */
export type AudioUpload = $Result.DefaultSelection<Prisma.$AudioUploadPayload>
/**
 * Model ProcessingJob
 * 
 */
export type ProcessingJob = $Result.DefaultSelection<Prisma.$ProcessingJobPayload>
/**
 * Model AudioHistory
 * 
 */
export type AudioHistory = $Result.DefaultSelection<Prisma.$AudioHistoryPayload>
/**
 * Model AudioSegment
 * 
 */
export type AudioSegment = $Result.DefaultSelection<Prisma.$AudioSegmentPayload>
/**
 * Model AudioChunk
 * 
 */
export type AudioChunk = $Result.DefaultSelection<Prisma.$AudioChunkPayload>
/**
 * Model StorageProvider
 * 
 */
export type StorageProvider = $Result.DefaultSelection<Prisma.$StorageProviderPayload>
/**
 * Model FileStorage
 * 
 */
export type FileStorage = $Result.DefaultSelection<Prisma.$FileStoragePayload>
/**
 * Model SubscriptionPlan
 * 
 */
export type SubscriptionPlan = $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>
/**
 * Model WorkspaceSubscription
 * 
 */
export type WorkspaceSubscription = $Result.DefaultSelection<Prisma.$WorkspaceSubscriptionPayload>
/**
 * Model BillingRecord
 * 
 */
export type BillingRecord = $Result.DefaultSelection<Prisma.$BillingRecordPayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model ApiKeyManagement
 * 
 */
export type ApiKeyManagement = $Result.DefaultSelection<Prisma.$ApiKeyManagementPayload>
/**
 * Model ApiKeyUsageLog
 * 
 */
export type ApiKeyUsageLog = $Result.DefaultSelection<Prisma.$ApiKeyUsageLogPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model UsageMetric
 * 
 */
export type UsageMetric = $Result.DefaultSelection<Prisma.$UsageMetricPayload>
/**
 * Model UserQuota
 * 
 */
export type UserQuota = $Result.DefaultSelection<Prisma.$UserQuotaPayload>
/**
 * Model StorageQuota
 * 
 */
export type StorageQuota = $Result.DefaultSelection<Prisma.$StorageQuotaPayload>
/**
 * Model UsageRecord
 * 
 */
export type UsageRecord = $Result.DefaultSelection<Prisma.$UsageRecordPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model SecurityEvent
 * 
 */
export type SecurityEvent = $Result.DefaultSelection<Prisma.$SecurityEventPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model EmailLog
 * 
 */
export type EmailLog = $Result.DefaultSelection<Prisma.$EmailLogPayload>
/**
 * Model EmailPreference
 * 
 */
export type EmailPreference = $Result.DefaultSelection<Prisma.$EmailPreferencePayload>
/**
 * Model Integration
 * 
 */
export type Integration = $Result.DefaultSelection<Prisma.$IntegrationPayload>
/**
 * Model WorkspaceAutomation
 * 
 */
export type WorkspaceAutomation = $Result.DefaultSelection<Prisma.$WorkspaceAutomationPayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model CustomField
 * 
 */
export type CustomField = $Result.DefaultSelection<Prisma.$CustomFieldPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model AiAgent
 * 
 */
export type AiAgent = $Result.DefaultSelection<Prisma.$AiAgentPayload>
/**
 * Model AiConversation
 * 
 */
export type AiConversation = $Result.DefaultSelection<Prisma.$AiConversationPayload>
/**
 * Model AiMessage
 * 
 */
export type AiMessage = $Result.DefaultSelection<Prisma.$AiMessagePayload>
/**
 * Model AiTokenUsage
 * 
 */
export type AiTokenUsage = $Result.DefaultSelection<Prisma.$AiTokenUsagePayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model UsageTracking
 * 
 */
export type UsageTracking = $Result.DefaultSelection<Prisma.$UsageTrackingPayload>
/**
 * Model UsageReport
 * 
 */
export type UsageReport = $Result.DefaultSelection<Prisma.$UsageReportPayload>
/**
 * Model PaymentGatewayConfig
 * 
 */
export type PaymentGatewayConfig = $Result.DefaultSelection<Prisma.$PaymentGatewayConfigPayload>
/**
 * Model PlanPricing
 * 
 */
export type PlanPricing = $Result.DefaultSelection<Prisma.$PlanPricingPayload>
/**
 * Model EwayTransaction
 * 
 */
export type EwayTransaction = $Result.DefaultSelection<Prisma.$EwayTransactionPayload>
/**
 * Model EwayCustomer
 * 
 */
export type EwayCustomer = $Result.DefaultSelection<Prisma.$EwayCustomerPayload>
/**
 * Model EwayRecurringSchedule
 * 
 */
export type EwayRecurringSchedule = $Result.DefaultSelection<Prisma.$EwayRecurringSchedulePayload>
/**
 * Model EwayWebhookEvent
 * 
 */
export type EwayWebhookEvent = $Result.DefaultSelection<Prisma.$EwayWebhookEventPayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model HealthCheck
 * 
 */
export type HealthCheck = $Result.DefaultSelection<Prisma.$HealthCheckPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<ExtArgs>;

  /**
   * `prisma.workspaceUser`: Exposes CRUD operations for the **WorkspaceUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceUsers
    * const workspaceUsers = await prisma.workspaceUser.findMany()
    * ```
    */
  get workspaceUser(): Prisma.WorkspaceUserDelegate<ExtArgs>;

  /**
   * `prisma.workspaceInvitation`: Exposes CRUD operations for the **WorkspaceInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceInvitations
    * const workspaceInvitations = await prisma.workspaceInvitation.findMany()
    * ```
    */
  get workspaceInvitation(): Prisma.WorkspaceInvitationDelegate<ExtArgs>;

  /**
   * `prisma.audioUpload`: Exposes CRUD operations for the **AudioUpload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioUploads
    * const audioUploads = await prisma.audioUpload.findMany()
    * ```
    */
  get audioUpload(): Prisma.AudioUploadDelegate<ExtArgs>;

  /**
   * `prisma.processingJob`: Exposes CRUD operations for the **ProcessingJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessingJobs
    * const processingJobs = await prisma.processingJob.findMany()
    * ```
    */
  get processingJob(): Prisma.ProcessingJobDelegate<ExtArgs>;

  /**
   * `prisma.audioHistory`: Exposes CRUD operations for the **AudioHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioHistories
    * const audioHistories = await prisma.audioHistory.findMany()
    * ```
    */
  get audioHistory(): Prisma.AudioHistoryDelegate<ExtArgs>;

  /**
   * `prisma.audioSegment`: Exposes CRUD operations for the **AudioSegment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioSegments
    * const audioSegments = await prisma.audioSegment.findMany()
    * ```
    */
  get audioSegment(): Prisma.AudioSegmentDelegate<ExtArgs>;

  /**
   * `prisma.audioChunk`: Exposes CRUD operations for the **AudioChunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioChunks
    * const audioChunks = await prisma.audioChunk.findMany()
    * ```
    */
  get audioChunk(): Prisma.AudioChunkDelegate<ExtArgs>;

  /**
   * `prisma.storageProvider`: Exposes CRUD operations for the **StorageProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorageProviders
    * const storageProviders = await prisma.storageProvider.findMany()
    * ```
    */
  get storageProvider(): Prisma.StorageProviderDelegate<ExtArgs>;

  /**
   * `prisma.fileStorage`: Exposes CRUD operations for the **FileStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileStorages
    * const fileStorages = await prisma.fileStorage.findMany()
    * ```
    */
  get fileStorage(): Prisma.FileStorageDelegate<ExtArgs>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
    * ```
    */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<ExtArgs>;

  /**
   * `prisma.workspaceSubscription`: Exposes CRUD operations for the **WorkspaceSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceSubscriptions
    * const workspaceSubscriptions = await prisma.workspaceSubscription.findMany()
    * ```
    */
  get workspaceSubscription(): Prisma.WorkspaceSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.billingRecord`: Exposes CRUD operations for the **BillingRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingRecords
    * const billingRecords = await prisma.billingRecord.findMany()
    * ```
    */
  get billingRecord(): Prisma.BillingRecordDelegate<ExtArgs>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs>;

  /**
   * `prisma.apiKeyManagement`: Exposes CRUD operations for the **ApiKeyManagement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeyManagements
    * const apiKeyManagements = await prisma.apiKeyManagement.findMany()
    * ```
    */
  get apiKeyManagement(): Prisma.ApiKeyManagementDelegate<ExtArgs>;

  /**
   * `prisma.apiKeyUsageLog`: Exposes CRUD operations for the **ApiKeyUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeyUsageLogs
    * const apiKeyUsageLogs = await prisma.apiKeyUsageLog.findMany()
    * ```
    */
  get apiKeyUsageLog(): Prisma.ApiKeyUsageLogDelegate<ExtArgs>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs>;

  /**
   * `prisma.usageMetric`: Exposes CRUD operations for the **UsageMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageMetrics
    * const usageMetrics = await prisma.usageMetric.findMany()
    * ```
    */
  get usageMetric(): Prisma.UsageMetricDelegate<ExtArgs>;

  /**
   * `prisma.userQuota`: Exposes CRUD operations for the **UserQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserQuotas
    * const userQuotas = await prisma.userQuota.findMany()
    * ```
    */
  get userQuota(): Prisma.UserQuotaDelegate<ExtArgs>;

  /**
   * `prisma.storageQuota`: Exposes CRUD operations for the **StorageQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorageQuotas
    * const storageQuotas = await prisma.storageQuota.findMany()
    * ```
    */
  get storageQuota(): Prisma.StorageQuotaDelegate<ExtArgs>;

  /**
   * `prisma.usageRecord`: Exposes CRUD operations for the **UsageRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageRecords
    * const usageRecords = await prisma.usageRecord.findMany()
    * ```
    */
  get usageRecord(): Prisma.UsageRecordDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.securityEvent`: Exposes CRUD operations for the **SecurityEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityEvents
    * const securityEvents = await prisma.securityEvent.findMany()
    * ```
    */
  get securityEvent(): Prisma.SecurityEventDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs>;

  /**
   * `prisma.emailLog`: Exposes CRUD operations for the **EmailLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailLogs
    * const emailLogs = await prisma.emailLog.findMany()
    * ```
    */
  get emailLog(): Prisma.EmailLogDelegate<ExtArgs>;

  /**
   * `prisma.emailPreference`: Exposes CRUD operations for the **EmailPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailPreferences
    * const emailPreferences = await prisma.emailPreference.findMany()
    * ```
    */
  get emailPreference(): Prisma.EmailPreferenceDelegate<ExtArgs>;

  /**
   * `prisma.integration`: Exposes CRUD operations for the **Integration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integration.findMany()
    * ```
    */
  get integration(): Prisma.IntegrationDelegate<ExtArgs>;

  /**
   * `prisma.workspaceAutomation`: Exposes CRUD operations for the **WorkspaceAutomation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceAutomations
    * const workspaceAutomations = await prisma.workspaceAutomation.findMany()
    * ```
    */
  get workspaceAutomation(): Prisma.WorkspaceAutomationDelegate<ExtArgs>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs>;

  /**
   * `prisma.customField`: Exposes CRUD operations for the **CustomField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomFields
    * const customFields = await prisma.customField.findMany()
    * ```
    */
  get customField(): Prisma.CustomFieldDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.aiAgent`: Exposes CRUD operations for the **AiAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiAgents
    * const aiAgents = await prisma.aiAgent.findMany()
    * ```
    */
  get aiAgent(): Prisma.AiAgentDelegate<ExtArgs>;

  /**
   * `prisma.aiConversation`: Exposes CRUD operations for the **AiConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiConversations
    * const aiConversations = await prisma.aiConversation.findMany()
    * ```
    */
  get aiConversation(): Prisma.AiConversationDelegate<ExtArgs>;

  /**
   * `prisma.aiMessage`: Exposes CRUD operations for the **AiMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiMessages
    * const aiMessages = await prisma.aiMessage.findMany()
    * ```
    */
  get aiMessage(): Prisma.AiMessageDelegate<ExtArgs>;

  /**
   * `prisma.aiTokenUsage`: Exposes CRUD operations for the **AiTokenUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiTokenUsages
    * const aiTokenUsages = await prisma.aiTokenUsage.findMany()
    * ```
    */
  get aiTokenUsage(): Prisma.AiTokenUsageDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs>;

  /**
   * `prisma.usageTracking`: Exposes CRUD operations for the **UsageTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageTrackings
    * const usageTrackings = await prisma.usageTracking.findMany()
    * ```
    */
  get usageTracking(): Prisma.UsageTrackingDelegate<ExtArgs>;

  /**
   * `prisma.usageReport`: Exposes CRUD operations for the **UsageReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageReports
    * const usageReports = await prisma.usageReport.findMany()
    * ```
    */
  get usageReport(): Prisma.UsageReportDelegate<ExtArgs>;

  /**
   * `prisma.paymentGatewayConfig`: Exposes CRUD operations for the **PaymentGatewayConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentGatewayConfigs
    * const paymentGatewayConfigs = await prisma.paymentGatewayConfig.findMany()
    * ```
    */
  get paymentGatewayConfig(): Prisma.PaymentGatewayConfigDelegate<ExtArgs>;

  /**
   * `prisma.planPricing`: Exposes CRUD operations for the **PlanPricing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanPricings
    * const planPricings = await prisma.planPricing.findMany()
    * ```
    */
  get planPricing(): Prisma.PlanPricingDelegate<ExtArgs>;

  /**
   * `prisma.ewayTransaction`: Exposes CRUD operations for the **EwayTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EwayTransactions
    * const ewayTransactions = await prisma.ewayTransaction.findMany()
    * ```
    */
  get ewayTransaction(): Prisma.EwayTransactionDelegate<ExtArgs>;

  /**
   * `prisma.ewayCustomer`: Exposes CRUD operations for the **EwayCustomer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EwayCustomers
    * const ewayCustomers = await prisma.ewayCustomer.findMany()
    * ```
    */
  get ewayCustomer(): Prisma.EwayCustomerDelegate<ExtArgs>;

  /**
   * `prisma.ewayRecurringSchedule`: Exposes CRUD operations for the **EwayRecurringSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EwayRecurringSchedules
    * const ewayRecurringSchedules = await prisma.ewayRecurringSchedule.findMany()
    * ```
    */
  get ewayRecurringSchedule(): Prisma.EwayRecurringScheduleDelegate<ExtArgs>;

  /**
   * `prisma.ewayWebhookEvent`: Exposes CRUD operations for the **EwayWebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EwayWebhookEvents
    * const ewayWebhookEvents = await prisma.ewayWebhookEvent.findMany()
    * ```
    */
  get ewayWebhookEvent(): Prisma.EwayWebhookEventDelegate<ExtArgs>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs>;

  /**
   * `prisma.healthCheck`: Exposes CRUD operations for the **HealthCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthChecks
    * const healthChecks = await prisma.healthCheck.findMany()
    * ```
    */
  get healthCheck(): Prisma.HealthCheckDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    RefreshToken: 'RefreshToken',
    Workspace: 'Workspace',
    WorkspaceUser: 'WorkspaceUser',
    WorkspaceInvitation: 'WorkspaceInvitation',
    AudioUpload: 'AudioUpload',
    ProcessingJob: 'ProcessingJob',
    AudioHistory: 'AudioHistory',
    AudioSegment: 'AudioSegment',
    AudioChunk: 'AudioChunk',
    StorageProvider: 'StorageProvider',
    FileStorage: 'FileStorage',
    SubscriptionPlan: 'SubscriptionPlan',
    WorkspaceSubscription: 'WorkspaceSubscription',
    BillingRecord: 'BillingRecord',
    PaymentMethod: 'PaymentMethod',
    ApiKeyManagement: 'ApiKeyManagement',
    ApiKeyUsageLog: 'ApiKeyUsageLog',
    UserSettings: 'UserSettings',
    UsageMetric: 'UsageMetric',
    UserQuota: 'UserQuota',
    StorageQuota: 'StorageQuota',
    UsageRecord: 'UsageRecord',
    AuditLog: 'AuditLog',
    SecurityEvent: 'SecurityEvent',
    Notification: 'Notification',
    EmailTemplate: 'EmailTemplate',
    EmailLog: 'EmailLog',
    EmailPreference: 'EmailPreference',
    Integration: 'Integration',
    WorkspaceAutomation: 'WorkspaceAutomation',
    Webhook: 'Webhook',
    CustomField: 'CustomField',
    Tag: 'Tag',
    AiAgent: 'AiAgent',
    AiConversation: 'AiConversation',
    AiMessage: 'AiMessage',
    AiTokenUsage: 'AiTokenUsage',
    Role: 'Role',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    UsageTracking: 'UsageTracking',
    UsageReport: 'UsageReport',
    PaymentGatewayConfig: 'PaymentGatewayConfig',
    PlanPricing: 'PlanPricing',
    EwayTransaction: 'EwayTransaction',
    EwayCustomer: 'EwayCustomer',
    EwayRecurringSchedule: 'EwayRecurringSchedule',
    EwayWebhookEvent: 'EwayWebhookEvent',
    SystemConfig: 'SystemConfig',
    HealthCheck: 'HealthCheck'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "refreshToken" | "workspace" | "workspaceUser" | "workspaceInvitation" | "audioUpload" | "processingJob" | "audioHistory" | "audioSegment" | "audioChunk" | "storageProvider" | "fileStorage" | "subscriptionPlan" | "workspaceSubscription" | "billingRecord" | "paymentMethod" | "apiKeyManagement" | "apiKeyUsageLog" | "userSettings" | "usageMetric" | "userQuota" | "storageQuota" | "usageRecord" | "auditLog" | "securityEvent" | "notification" | "emailTemplate" | "emailLog" | "emailPreference" | "integration" | "workspaceAutomation" | "webhook" | "customField" | "tag" | "aiAgent" | "aiConversation" | "aiMessage" | "aiTokenUsage" | "role" | "permission" | "rolePermission" | "usageTracking" | "usageReport" | "paymentGatewayConfig" | "planPricing" | "ewayTransaction" | "ewayCustomer" | "ewayRecurringSchedule" | "ewayWebhookEvent" | "systemConfig" | "healthCheck"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Workspace: {
        payload: Prisma.$WorkspacePayload<ExtArgs>
        fields: Prisma.WorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          create: {
            args: Prisma.WorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          createMany: {
            args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          update: {
            args: Prisma.WorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspace>
          }
          groupBy: {
            args: Prisma.WorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceUser: {
        payload: Prisma.$WorkspaceUserPayload<ExtArgs>
        fields: Prisma.WorkspaceUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          findMany: {
            args: Prisma.WorkspaceUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          create: {
            args: Prisma.WorkspaceUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          createMany: {
            args: Prisma.WorkspaceUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          update: {
            args: Prisma.WorkspaceUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceUser>
          }
          groupBy: {
            args: Prisma.WorkspaceUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceUserCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceInvitation: {
        payload: Prisma.$WorkspaceInvitationPayload<ExtArgs>
        fields: Prisma.WorkspaceInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          findMany: {
            args: Prisma.WorkspaceInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          create: {
            args: Prisma.WorkspaceInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          createMany: {
            args: Prisma.WorkspaceInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          update: {
            args: Prisma.WorkspaceInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceInvitation>
          }
          groupBy: {
            args: Prisma.WorkspaceInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceInvitationCountAggregateOutputType> | number
          }
        }
      }
      AudioUpload: {
        payload: Prisma.$AudioUploadPayload<ExtArgs>
        fields: Prisma.AudioUploadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioUploadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioUploadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>
          }
          findFirst: {
            args: Prisma.AudioUploadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioUploadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>
          }
          findMany: {
            args: Prisma.AudioUploadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>[]
          }
          create: {
            args: Prisma.AudioUploadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>
          }
          createMany: {
            args: Prisma.AudioUploadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioUploadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>[]
          }
          delete: {
            args: Prisma.AudioUploadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>
          }
          update: {
            args: Prisma.AudioUploadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>
          }
          deleteMany: {
            args: Prisma.AudioUploadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioUploadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AudioUploadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioUploadPayload>
          }
          aggregate: {
            args: Prisma.AudioUploadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioUpload>
          }
          groupBy: {
            args: Prisma.AudioUploadGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioUploadGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioUploadCountArgs<ExtArgs>
            result: $Utils.Optional<AudioUploadCountAggregateOutputType> | number
          }
        }
      }
      ProcessingJob: {
        payload: Prisma.$ProcessingJobPayload<ExtArgs>
        fields: Prisma.ProcessingJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessingJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessingJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>
          }
          findFirst: {
            args: Prisma.ProcessingJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessingJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>
          }
          findMany: {
            args: Prisma.ProcessingJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>[]
          }
          create: {
            args: Prisma.ProcessingJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>
          }
          createMany: {
            args: Prisma.ProcessingJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessingJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>[]
          }
          delete: {
            args: Prisma.ProcessingJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>
          }
          update: {
            args: Prisma.ProcessingJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>
          }
          deleteMany: {
            args: Prisma.ProcessingJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessingJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessingJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingJobPayload>
          }
          aggregate: {
            args: Prisma.ProcessingJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessingJob>
          }
          groupBy: {
            args: Prisma.ProcessingJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessingJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessingJobCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessingJobCountAggregateOutputType> | number
          }
        }
      }
      AudioHistory: {
        payload: Prisma.$AudioHistoryPayload<ExtArgs>
        fields: Prisma.AudioHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>
          }
          findFirst: {
            args: Prisma.AudioHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>
          }
          findMany: {
            args: Prisma.AudioHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>[]
          }
          create: {
            args: Prisma.AudioHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>
          }
          createMany: {
            args: Prisma.AudioHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>[]
          }
          delete: {
            args: Prisma.AudioHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>
          }
          update: {
            args: Prisma.AudioHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AudioHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AudioHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioHistoryPayload>
          }
          aggregate: {
            args: Prisma.AudioHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioHistory>
          }
          groupBy: {
            args: Prisma.AudioHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AudioHistoryCountAggregateOutputType> | number
          }
        }
      }
      AudioSegment: {
        payload: Prisma.$AudioSegmentPayload<ExtArgs>
        fields: Prisma.AudioSegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioSegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioSegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>
          }
          findFirst: {
            args: Prisma.AudioSegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioSegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>
          }
          findMany: {
            args: Prisma.AudioSegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>[]
          }
          create: {
            args: Prisma.AudioSegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>
          }
          createMany: {
            args: Prisma.AudioSegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioSegmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>[]
          }
          delete: {
            args: Prisma.AudioSegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>
          }
          update: {
            args: Prisma.AudioSegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>
          }
          deleteMany: {
            args: Prisma.AudioSegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioSegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AudioSegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioSegmentPayload>
          }
          aggregate: {
            args: Prisma.AudioSegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioSegment>
          }
          groupBy: {
            args: Prisma.AudioSegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioSegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioSegmentCountArgs<ExtArgs>
            result: $Utils.Optional<AudioSegmentCountAggregateOutputType> | number
          }
        }
      }
      AudioChunk: {
        payload: Prisma.$AudioChunkPayload<ExtArgs>
        fields: Prisma.AudioChunkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioChunkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioChunkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>
          }
          findFirst: {
            args: Prisma.AudioChunkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioChunkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>
          }
          findMany: {
            args: Prisma.AudioChunkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>[]
          }
          create: {
            args: Prisma.AudioChunkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>
          }
          createMany: {
            args: Prisma.AudioChunkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioChunkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>[]
          }
          delete: {
            args: Prisma.AudioChunkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>
          }
          update: {
            args: Prisma.AudioChunkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>
          }
          deleteMany: {
            args: Prisma.AudioChunkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioChunkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AudioChunkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChunkPayload>
          }
          aggregate: {
            args: Prisma.AudioChunkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioChunk>
          }
          groupBy: {
            args: Prisma.AudioChunkGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioChunkGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioChunkCountArgs<ExtArgs>
            result: $Utils.Optional<AudioChunkCountAggregateOutputType> | number
          }
        }
      }
      StorageProvider: {
        payload: Prisma.$StorageProviderPayload<ExtArgs>
        fields: Prisma.StorageProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorageProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorageProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageProviderPayload>
          }
          findFirst: {
            args: Prisma.StorageProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorageProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageProviderPayload>
          }
          findMany: {
            args: Prisma.StorageProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageProviderPayload>[]
          }
          create: {
            args: Prisma.StorageProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageProviderPayload>
          }
          createMany: {
            args: Prisma.StorageProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StorageProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageProviderPayload>[]
          }
          delete: {
            args: Prisma.StorageProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageProviderPayload>
          }
          update: {
            args: Prisma.StorageProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageProviderPayload>
          }
          deleteMany: {
            args: Prisma.StorageProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorageProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StorageProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageProviderPayload>
          }
          aggregate: {
            args: Prisma.StorageProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorageProvider>
          }
          groupBy: {
            args: Prisma.StorageProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorageProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorageProviderCountArgs<ExtArgs>
            result: $Utils.Optional<StorageProviderCountAggregateOutputType> | number
          }
        }
      }
      FileStorage: {
        payload: Prisma.$FileStoragePayload<ExtArgs>
        fields: Prisma.FileStorageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileStorageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileStorageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>
          }
          findFirst: {
            args: Prisma.FileStorageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileStorageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>
          }
          findMany: {
            args: Prisma.FileStorageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>[]
          }
          create: {
            args: Prisma.FileStorageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>
          }
          createMany: {
            args: Prisma.FileStorageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileStorageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>[]
          }
          delete: {
            args: Prisma.FileStorageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>
          }
          update: {
            args: Prisma.FileStorageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>
          }
          deleteMany: {
            args: Prisma.FileStorageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileStorageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FileStorageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>
          }
          aggregate: {
            args: Prisma.FileStorageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileStorage>
          }
          groupBy: {
            args: Prisma.FileStorageGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileStorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileStorageCountArgs<ExtArgs>
            result: $Utils.Optional<FileStorageCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
        fields: Prisma.SubscriptionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPlan>
          }
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceSubscription: {
        payload: Prisma.$WorkspaceSubscriptionPayload<ExtArgs>
        fields: Prisma.WorkspaceSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>
          }
          findMany: {
            args: Prisma.WorkspaceSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>[]
          }
          create: {
            args: Prisma.WorkspaceSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>
          }
          createMany: {
            args: Prisma.WorkspaceSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>
          }
          update: {
            args: Prisma.WorkspaceSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceSubscription>
          }
          groupBy: {
            args: Prisma.WorkspaceSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      BillingRecord: {
        payload: Prisma.$BillingRecordPayload<ExtArgs>
        fields: Prisma.BillingRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>
          }
          findFirst: {
            args: Prisma.BillingRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>
          }
          findMany: {
            args: Prisma.BillingRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>[]
          }
          create: {
            args: Prisma.BillingRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>
          }
          createMany: {
            args: Prisma.BillingRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>[]
          }
          delete: {
            args: Prisma.BillingRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>
          }
          update: {
            args: Prisma.BillingRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>
          }
          deleteMany: {
            args: Prisma.BillingRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillingRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingRecordPayload>
          }
          aggregate: {
            args: Prisma.BillingRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingRecord>
          }
          groupBy: {
            args: Prisma.BillingRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingRecordCountArgs<ExtArgs>
            result: $Utils.Optional<BillingRecordCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      ApiKeyManagement: {
        payload: Prisma.$ApiKeyManagementPayload<ExtArgs>
        fields: Prisma.ApiKeyManagementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyManagementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyManagementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyManagementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyManagementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>
          }
          findMany: {
            args: Prisma.ApiKeyManagementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>[]
          }
          create: {
            args: Prisma.ApiKeyManagementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>
          }
          createMany: {
            args: Prisma.ApiKeyManagementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyManagementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyManagementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>
          }
          update: {
            args: Prisma.ApiKeyManagementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyManagementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyManagementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyManagementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyManagementPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyManagementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKeyManagement>
          }
          groupBy: {
            args: Prisma.ApiKeyManagementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyManagementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyManagementCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyManagementCountAggregateOutputType> | number
          }
        }
      }
      ApiKeyUsageLog: {
        payload: Prisma.$ApiKeyUsageLogPayload<ExtArgs>
        fields: Prisma.ApiKeyUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsageLogPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsageLogPayload>
          }
          findMany: {
            args: Prisma.ApiKeyUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsageLogPayload>[]
          }
          create: {
            args: Prisma.ApiKeyUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsageLogPayload>
          }
          createMany: {
            args: Prisma.ApiKeyUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsageLogPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsageLogPayload>
          }
          update: {
            args: Prisma.ApiKeyUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsageLogPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKeyUsageLog>
          }
          groupBy: {
            args: Prisma.ApiKeyUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyUsageLogCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      UsageMetric: {
        payload: Prisma.$UsageMetricPayload<ExtArgs>
        fields: Prisma.UsageMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>
          }
          findFirst: {
            args: Prisma.UsageMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>
          }
          findMany: {
            args: Prisma.UsageMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>[]
          }
          create: {
            args: Prisma.UsageMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>
          }
          createMany: {
            args: Prisma.UsageMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>[]
          }
          delete: {
            args: Prisma.UsageMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>
          }
          update: {
            args: Prisma.UsageMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>
          }
          deleteMany: {
            args: Prisma.UsageMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsageMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>
          }
          aggregate: {
            args: Prisma.UsageMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageMetric>
          }
          groupBy: {
            args: Prisma.UsageMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageMetricCountArgs<ExtArgs>
            result: $Utils.Optional<UsageMetricCountAggregateOutputType> | number
          }
        }
      }
      UserQuota: {
        payload: Prisma.$UserQuotaPayload<ExtArgs>
        fields: Prisma.UserQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          findFirst: {
            args: Prisma.UserQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          findMany: {
            args: Prisma.UserQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>[]
          }
          create: {
            args: Prisma.UserQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          createMany: {
            args: Prisma.UserQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>[]
          }
          delete: {
            args: Prisma.UserQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          update: {
            args: Prisma.UserQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          deleteMany: {
            args: Prisma.UserQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          aggregate: {
            args: Prisma.UserQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserQuota>
          }
          groupBy: {
            args: Prisma.UserQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<UserQuotaCountAggregateOutputType> | number
          }
        }
      }
      StorageQuota: {
        payload: Prisma.$StorageQuotaPayload<ExtArgs>
        fields: Prisma.StorageQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorageQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorageQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          findFirst: {
            args: Prisma.StorageQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorageQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          findMany: {
            args: Prisma.StorageQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>[]
          }
          create: {
            args: Prisma.StorageQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          createMany: {
            args: Prisma.StorageQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StorageQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>[]
          }
          delete: {
            args: Prisma.StorageQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          update: {
            args: Prisma.StorageQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          deleteMany: {
            args: Prisma.StorageQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorageQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StorageQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          aggregate: {
            args: Prisma.StorageQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorageQuota>
          }
          groupBy: {
            args: Prisma.StorageQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorageQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorageQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<StorageQuotaCountAggregateOutputType> | number
          }
        }
      }
      UsageRecord: {
        payload: Prisma.$UsageRecordPayload<ExtArgs>
        fields: Prisma.UsageRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          findFirst: {
            args: Prisma.UsageRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          findMany: {
            args: Prisma.UsageRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>[]
          }
          create: {
            args: Prisma.UsageRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          createMany: {
            args: Prisma.UsageRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>[]
          }
          delete: {
            args: Prisma.UsageRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          update: {
            args: Prisma.UsageRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          deleteMany: {
            args: Prisma.UsageRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsageRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          aggregate: {
            args: Prisma.UsageRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageRecord>
          }
          groupBy: {
            args: Prisma.UsageRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageRecordCountArgs<ExtArgs>
            result: $Utils.Optional<UsageRecordCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      SecurityEvent: {
        payload: Prisma.$SecurityEventPayload<ExtArgs>
        fields: Prisma.SecurityEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          findFirst: {
            args: Prisma.SecurityEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          findMany: {
            args: Prisma.SecurityEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          create: {
            args: Prisma.SecurityEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          createMany: {
            args: Prisma.SecurityEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          delete: {
            args: Prisma.SecurityEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          update: {
            args: Prisma.SecurityEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          deleteMany: {
            args: Prisma.SecurityEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SecurityEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          aggregate: {
            args: Prisma.SecurityEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityEvent>
          }
          groupBy: {
            args: Prisma.SecurityEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityEventCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityEventCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      EmailLog: {
        payload: Prisma.$EmailLogPayload<ExtArgs>
        fields: Prisma.EmailLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findFirst: {
            args: Prisma.EmailLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findMany: {
            args: Prisma.EmailLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          create: {
            args: Prisma.EmailLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          createMany: {
            args: Prisma.EmailLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          delete: {
            args: Prisma.EmailLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          update: {
            args: Prisma.EmailLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          deleteMany: {
            args: Prisma.EmailLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          aggregate: {
            args: Prisma.EmailLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailLog>
          }
          groupBy: {
            args: Prisma.EmailLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailLogCountArgs<ExtArgs>
            result: $Utils.Optional<EmailLogCountAggregateOutputType> | number
          }
        }
      }
      EmailPreference: {
        payload: Prisma.$EmailPreferencePayload<ExtArgs>
        fields: Prisma.EmailPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPreferencePayload>
          }
          findFirst: {
            args: Prisma.EmailPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPreferencePayload>
          }
          findMany: {
            args: Prisma.EmailPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPreferencePayload>[]
          }
          create: {
            args: Prisma.EmailPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPreferencePayload>
          }
          createMany: {
            args: Prisma.EmailPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPreferencePayload>[]
          }
          delete: {
            args: Prisma.EmailPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPreferencePayload>
          }
          update: {
            args: Prisma.EmailPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPreferencePayload>
          }
          deleteMany: {
            args: Prisma.EmailPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPreferencePayload>
          }
          aggregate: {
            args: Prisma.EmailPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailPreference>
          }
          groupBy: {
            args: Prisma.EmailPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<EmailPreferenceCountAggregateOutputType> | number
          }
        }
      }
      Integration: {
        payload: Prisma.$IntegrationPayload<ExtArgs>
        fields: Prisma.IntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findFirst: {
            args: Prisma.IntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findMany: {
            args: Prisma.IntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          create: {
            args: Prisma.IntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          createMany: {
            args: Prisma.IntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          delete: {
            args: Prisma.IntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          update: {
            args: Prisma.IntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          aggregate: {
            args: Prisma.IntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration>
          }
          groupBy: {
            args: Prisma.IntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceAutomation: {
        payload: Prisma.$WorkspaceAutomationPayload<ExtArgs>
        fields: Prisma.WorkspaceAutomationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceAutomationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceAutomationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceAutomationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceAutomationPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceAutomationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceAutomationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceAutomationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceAutomationPayload>
          }
          findMany: {
            args: Prisma.WorkspaceAutomationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceAutomationPayload>[]
          }
          create: {
            args: Prisma.WorkspaceAutomationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceAutomationPayload>
          }
          createMany: {
            args: Prisma.WorkspaceAutomationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceAutomationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceAutomationPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceAutomationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceAutomationPayload>
          }
          update: {
            args: Prisma.WorkspaceAutomationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceAutomationPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceAutomationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceAutomationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceAutomationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceAutomationPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAutomationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceAutomation>
          }
          groupBy: {
            args: Prisma.WorkspaceAutomationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceAutomationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceAutomationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceAutomationCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      CustomField: {
        payload: Prisma.$CustomFieldPayload<ExtArgs>
        fields: Prisma.CustomFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          findFirst: {
            args: Prisma.CustomFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          findMany: {
            args: Prisma.CustomFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
          }
          create: {
            args: Prisma.CustomFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          createMany: {
            args: Prisma.CustomFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
          }
          delete: {
            args: Prisma.CustomFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          update: {
            args: Prisma.CustomFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          deleteMany: {
            args: Prisma.CustomFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          aggregate: {
            args: Prisma.CustomFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomField>
          }
          groupBy: {
            args: Prisma.CustomFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomFieldCountArgs<ExtArgs>
            result: $Utils.Optional<CustomFieldCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      AiAgent: {
        payload: Prisma.$AiAgentPayload<ExtArgs>
        fields: Prisma.AiAgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiAgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiAgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          findFirst: {
            args: Prisma.AiAgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiAgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          findMany: {
            args: Prisma.AiAgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>[]
          }
          create: {
            args: Prisma.AiAgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          createMany: {
            args: Prisma.AiAgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiAgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>[]
          }
          delete: {
            args: Prisma.AiAgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          update: {
            args: Prisma.AiAgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          deleteMany: {
            args: Prisma.AiAgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiAgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiAgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          aggregate: {
            args: Prisma.AiAgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiAgent>
          }
          groupBy: {
            args: Prisma.AiAgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiAgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiAgentCountArgs<ExtArgs>
            result: $Utils.Optional<AiAgentCountAggregateOutputType> | number
          }
        }
      }
      AiConversation: {
        payload: Prisma.$AiConversationPayload<ExtArgs>
        fields: Prisma.AiConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          findFirst: {
            args: Prisma.AiConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          findMany: {
            args: Prisma.AiConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>[]
          }
          create: {
            args: Prisma.AiConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          createMany: {
            args: Prisma.AiConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>[]
          }
          delete: {
            args: Prisma.AiConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          update: {
            args: Prisma.AiConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          deleteMany: {
            args: Prisma.AiConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          aggregate: {
            args: Prisma.AiConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiConversation>
          }
          groupBy: {
            args: Prisma.AiConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiConversationCountArgs<ExtArgs>
            result: $Utils.Optional<AiConversationCountAggregateOutputType> | number
          }
        }
      }
      AiMessage: {
        payload: Prisma.$AiMessagePayload<ExtArgs>
        fields: Prisma.AiMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          findFirst: {
            args: Prisma.AiMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          findMany: {
            args: Prisma.AiMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>[]
          }
          create: {
            args: Prisma.AiMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          createMany: {
            args: Prisma.AiMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>[]
          }
          delete: {
            args: Prisma.AiMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          update: {
            args: Prisma.AiMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          deleteMany: {
            args: Prisma.AiMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          aggregate: {
            args: Prisma.AiMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiMessage>
          }
          groupBy: {
            args: Prisma.AiMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiMessageCountArgs<ExtArgs>
            result: $Utils.Optional<AiMessageCountAggregateOutputType> | number
          }
        }
      }
      AiTokenUsage: {
        payload: Prisma.$AiTokenUsagePayload<ExtArgs>
        fields: Prisma.AiTokenUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiTokenUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTokenUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiTokenUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTokenUsagePayload>
          }
          findFirst: {
            args: Prisma.AiTokenUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTokenUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiTokenUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTokenUsagePayload>
          }
          findMany: {
            args: Prisma.AiTokenUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTokenUsagePayload>[]
          }
          create: {
            args: Prisma.AiTokenUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTokenUsagePayload>
          }
          createMany: {
            args: Prisma.AiTokenUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiTokenUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTokenUsagePayload>[]
          }
          delete: {
            args: Prisma.AiTokenUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTokenUsagePayload>
          }
          update: {
            args: Prisma.AiTokenUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTokenUsagePayload>
          }
          deleteMany: {
            args: Prisma.AiTokenUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiTokenUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiTokenUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTokenUsagePayload>
          }
          aggregate: {
            args: Prisma.AiTokenUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiTokenUsage>
          }
          groupBy: {
            args: Prisma.AiTokenUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiTokenUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiTokenUsageCountArgs<ExtArgs>
            result: $Utils.Optional<AiTokenUsageCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      UsageTracking: {
        payload: Prisma.$UsageTrackingPayload<ExtArgs>
        fields: Prisma.UsageTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          findFirst: {
            args: Prisma.UsageTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          findMany: {
            args: Prisma.UsageTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>[]
          }
          create: {
            args: Prisma.UsageTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          createMany: {
            args: Prisma.UsageTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>[]
          }
          delete: {
            args: Prisma.UsageTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          update: {
            args: Prisma.UsageTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          deleteMany: {
            args: Prisma.UsageTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsageTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          aggregate: {
            args: Prisma.UsageTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageTracking>
          }
          groupBy: {
            args: Prisma.UsageTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<UsageTrackingCountAggregateOutputType> | number
          }
        }
      }
      UsageReport: {
        payload: Prisma.$UsageReportPayload<ExtArgs>
        fields: Prisma.UsageReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageReportPayload>
          }
          findFirst: {
            args: Prisma.UsageReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageReportPayload>
          }
          findMany: {
            args: Prisma.UsageReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageReportPayload>[]
          }
          create: {
            args: Prisma.UsageReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageReportPayload>
          }
          createMany: {
            args: Prisma.UsageReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageReportPayload>[]
          }
          delete: {
            args: Prisma.UsageReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageReportPayload>
          }
          update: {
            args: Prisma.UsageReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageReportPayload>
          }
          deleteMany: {
            args: Prisma.UsageReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsageReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageReportPayload>
          }
          aggregate: {
            args: Prisma.UsageReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageReport>
          }
          groupBy: {
            args: Prisma.UsageReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageReportCountArgs<ExtArgs>
            result: $Utils.Optional<UsageReportCountAggregateOutputType> | number
          }
        }
      }
      PaymentGatewayConfig: {
        payload: Prisma.$PaymentGatewayConfigPayload<ExtArgs>
        fields: Prisma.PaymentGatewayConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentGatewayConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentGatewayConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>
          }
          findFirst: {
            args: Prisma.PaymentGatewayConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentGatewayConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>
          }
          findMany: {
            args: Prisma.PaymentGatewayConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>[]
          }
          create: {
            args: Prisma.PaymentGatewayConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>
          }
          createMany: {
            args: Prisma.PaymentGatewayConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentGatewayConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>[]
          }
          delete: {
            args: Prisma.PaymentGatewayConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>
          }
          update: {
            args: Prisma.PaymentGatewayConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>
          }
          deleteMany: {
            args: Prisma.PaymentGatewayConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentGatewayConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentGatewayConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>
          }
          aggregate: {
            args: Prisma.PaymentGatewayConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentGatewayConfig>
          }
          groupBy: {
            args: Prisma.PaymentGatewayConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGatewayConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentGatewayConfigCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentGatewayConfigCountAggregateOutputType> | number
          }
        }
      }
      PlanPricing: {
        payload: Prisma.$PlanPricingPayload<ExtArgs>
        fields: Prisma.PlanPricingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanPricingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanPricingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>
          }
          findFirst: {
            args: Prisma.PlanPricingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanPricingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>
          }
          findMany: {
            args: Prisma.PlanPricingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>[]
          }
          create: {
            args: Prisma.PlanPricingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>
          }
          createMany: {
            args: Prisma.PlanPricingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanPricingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>[]
          }
          delete: {
            args: Prisma.PlanPricingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>
          }
          update: {
            args: Prisma.PlanPricingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>
          }
          deleteMany: {
            args: Prisma.PlanPricingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanPricingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanPricingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricingPayload>
          }
          aggregate: {
            args: Prisma.PlanPricingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanPricing>
          }
          groupBy: {
            args: Prisma.PlanPricingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanPricingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanPricingCountArgs<ExtArgs>
            result: $Utils.Optional<PlanPricingCountAggregateOutputType> | number
          }
        }
      }
      EwayTransaction: {
        payload: Prisma.$EwayTransactionPayload<ExtArgs>
        fields: Prisma.EwayTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EwayTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EwayTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>
          }
          findFirst: {
            args: Prisma.EwayTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EwayTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>
          }
          findMany: {
            args: Prisma.EwayTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>[]
          }
          create: {
            args: Prisma.EwayTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>
          }
          createMany: {
            args: Prisma.EwayTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EwayTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>[]
          }
          delete: {
            args: Prisma.EwayTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>
          }
          update: {
            args: Prisma.EwayTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>
          }
          deleteMany: {
            args: Prisma.EwayTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EwayTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EwayTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayTransactionPayload>
          }
          aggregate: {
            args: Prisma.EwayTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEwayTransaction>
          }
          groupBy: {
            args: Prisma.EwayTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EwayTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EwayTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<EwayTransactionCountAggregateOutputType> | number
          }
        }
      }
      EwayCustomer: {
        payload: Prisma.$EwayCustomerPayload<ExtArgs>
        fields: Prisma.EwayCustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EwayCustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EwayCustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>
          }
          findFirst: {
            args: Prisma.EwayCustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EwayCustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>
          }
          findMany: {
            args: Prisma.EwayCustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>[]
          }
          create: {
            args: Prisma.EwayCustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>
          }
          createMany: {
            args: Prisma.EwayCustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EwayCustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>[]
          }
          delete: {
            args: Prisma.EwayCustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>
          }
          update: {
            args: Prisma.EwayCustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>
          }
          deleteMany: {
            args: Prisma.EwayCustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EwayCustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EwayCustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayCustomerPayload>
          }
          aggregate: {
            args: Prisma.EwayCustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEwayCustomer>
          }
          groupBy: {
            args: Prisma.EwayCustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<EwayCustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.EwayCustomerCountArgs<ExtArgs>
            result: $Utils.Optional<EwayCustomerCountAggregateOutputType> | number
          }
        }
      }
      EwayRecurringSchedule: {
        payload: Prisma.$EwayRecurringSchedulePayload<ExtArgs>
        fields: Prisma.EwayRecurringScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EwayRecurringScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EwayRecurringScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>
          }
          findFirst: {
            args: Prisma.EwayRecurringScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EwayRecurringScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>
          }
          findMany: {
            args: Prisma.EwayRecurringScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>[]
          }
          create: {
            args: Prisma.EwayRecurringScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>
          }
          createMany: {
            args: Prisma.EwayRecurringScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EwayRecurringScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>[]
          }
          delete: {
            args: Prisma.EwayRecurringScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>
          }
          update: {
            args: Prisma.EwayRecurringScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>
          }
          deleteMany: {
            args: Prisma.EwayRecurringScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EwayRecurringScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EwayRecurringScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayRecurringSchedulePayload>
          }
          aggregate: {
            args: Prisma.EwayRecurringScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEwayRecurringSchedule>
          }
          groupBy: {
            args: Prisma.EwayRecurringScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<EwayRecurringScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.EwayRecurringScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<EwayRecurringScheduleCountAggregateOutputType> | number
          }
        }
      }
      EwayWebhookEvent: {
        payload: Prisma.$EwayWebhookEventPayload<ExtArgs>
        fields: Prisma.EwayWebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EwayWebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EwayWebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>
          }
          findFirst: {
            args: Prisma.EwayWebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EwayWebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>
          }
          findMany: {
            args: Prisma.EwayWebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>[]
          }
          create: {
            args: Prisma.EwayWebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>
          }
          createMany: {
            args: Prisma.EwayWebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EwayWebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>[]
          }
          delete: {
            args: Prisma.EwayWebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>
          }
          update: {
            args: Prisma.EwayWebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.EwayWebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EwayWebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EwayWebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwayWebhookEventPayload>
          }
          aggregate: {
            args: Prisma.EwayWebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEwayWebhookEvent>
          }
          groupBy: {
            args: Prisma.EwayWebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EwayWebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EwayWebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<EwayWebhookEventCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      HealthCheck: {
        payload: Prisma.$HealthCheckPayload<ExtArgs>
        fields: Prisma.HealthCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthCheckPayload>
          }
          findFirst: {
            args: Prisma.HealthCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthCheckPayload>
          }
          findMany: {
            args: Prisma.HealthCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthCheckPayload>[]
          }
          create: {
            args: Prisma.HealthCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthCheckPayload>
          }
          createMany: {
            args: Prisma.HealthCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthCheckPayload>[]
          }
          delete: {
            args: Prisma.HealthCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthCheckPayload>
          }
          update: {
            args: Prisma.HealthCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthCheckPayload>
          }
          deleteMany: {
            args: Prisma.HealthCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthCheckPayload>
          }
          aggregate: {
            args: Prisma.HealthCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthCheck>
          }
          groupBy: {
            args: Prisma.HealthCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthCheckCountArgs<ExtArgs>
            result: $Utils.Optional<HealthCheckCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    workspaces: number
    audioHistory: number
    audioUploads: number
    apiKeys: number
    sessions: number
    refreshTokens: number
    auditLogs: number
    securityEvents: number
    notifications: number
    audioSegments: number
    quotaUsage: number
    aiTokenUsage: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | UserCountOutputTypeCountWorkspacesArgs
    audioHistory?: boolean | UserCountOutputTypeCountAudioHistoryArgs
    audioUploads?: boolean | UserCountOutputTypeCountAudioUploadsArgs
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    securityEvents?: boolean | UserCountOutputTypeCountSecurityEventsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    audioSegments?: boolean | UserCountOutputTypeCountAudioSegmentsArgs
    quotaUsage?: boolean | UserCountOutputTypeCountQuotaUsageArgs
    aiTokenUsage?: boolean | UserCountOutputTypeCountAiTokenUsageArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAudioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAudioUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioUploadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyManagementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSecurityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAudioSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioSegmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuotaUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuotaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiTokenUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiTokenUsageWhereInput
  }


  /**
   * Count Type WorkspaceCountOutputType
   */

  export type WorkspaceCountOutputType = {
    users: number
    invitations: number
    audioHistory: number
    audioUploads: number
    subscriptions: number
    storageQuotas: number
    integrations: number
    automations: number
    webhooks: number
    customFields: number
    tags: number
    aiAgents: number
  }

  export type WorkspaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | WorkspaceCountOutputTypeCountUsersArgs
    invitations?: boolean | WorkspaceCountOutputTypeCountInvitationsArgs
    audioHistory?: boolean | WorkspaceCountOutputTypeCountAudioHistoryArgs
    audioUploads?: boolean | WorkspaceCountOutputTypeCountAudioUploadsArgs
    subscriptions?: boolean | WorkspaceCountOutputTypeCountSubscriptionsArgs
    storageQuotas?: boolean | WorkspaceCountOutputTypeCountStorageQuotasArgs
    integrations?: boolean | WorkspaceCountOutputTypeCountIntegrationsArgs
    automations?: boolean | WorkspaceCountOutputTypeCountAutomationsArgs
    webhooks?: boolean | WorkspaceCountOutputTypeCountWebhooksArgs
    customFields?: boolean | WorkspaceCountOutputTypeCountCustomFieldsArgs
    tags?: boolean | WorkspaceCountOutputTypeCountTagsArgs
    aiAgents?: boolean | WorkspaceCountOutputTypeCountAiAgentsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAudioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioHistoryWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAudioUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioUploadWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceSubscriptionWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountStorageQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageQuotaWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAutomationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceAutomationWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountWebhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountCustomFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAiAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiAgentWhereInput
  }


  /**
   * Count Type AudioUploadCountOutputType
   */

  export type AudioUploadCountOutputType = {
    processingJobs: number
    audioChunks: number
  }

  export type AudioUploadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processingJobs?: boolean | AudioUploadCountOutputTypeCountProcessingJobsArgs
    audioChunks?: boolean | AudioUploadCountOutputTypeCountAudioChunksArgs
  }

  // Custom InputTypes
  /**
   * AudioUploadCountOutputType without action
   */
  export type AudioUploadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUploadCountOutputType
     */
    select?: AudioUploadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AudioUploadCountOutputType without action
   */
  export type AudioUploadCountOutputTypeCountProcessingJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessingJobWhereInput
  }

  /**
   * AudioUploadCountOutputType without action
   */
  export type AudioUploadCountOutputTypeCountAudioChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioChunkWhereInput
  }


  /**
   * Count Type AudioHistoryCountOutputType
   */

  export type AudioHistoryCountOutputType = {
    segments: number
  }

  export type AudioHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segments?: boolean | AudioHistoryCountOutputTypeCountSegmentsArgs
  }

  // Custom InputTypes
  /**
   * AudioHistoryCountOutputType without action
   */
  export type AudioHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistoryCountOutputType
     */
    select?: AudioHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AudioHistoryCountOutputType without action
   */
  export type AudioHistoryCountOutputTypeCountSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioSegmentWhereInput
  }


  /**
   * Count Type StorageProviderCountOutputType
   */

  export type StorageProviderCountOutputType = {
    files: number
  }

  export type StorageProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | StorageProviderCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * StorageProviderCountOutputType without action
   */
  export type StorageProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageProviderCountOutputType
     */
    select?: StorageProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StorageProviderCountOutputType without action
   */
  export type StorageProviderCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileStorageWhereInput
  }


  /**
   * Count Type SubscriptionPlanCountOutputType
   */

  export type SubscriptionPlanCountOutputType = {
    subscriptions: number
    planPricing: number
  }

  export type SubscriptionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlanCountOutputTypeCountSubscriptionsArgs
    planPricing?: boolean | SubscriptionPlanCountOutputTypeCountPlanPricingArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlanCountOutputType
     */
    select?: SubscriptionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceSubscriptionWhereInput
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountPlanPricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanPricingWhereInput
  }


  /**
   * Count Type WorkspaceSubscriptionCountOutputType
   */

  export type WorkspaceSubscriptionCountOutputType = {
    billingRecords: number
    usageRecords: number
  }

  export type WorkspaceSubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingRecords?: boolean | WorkspaceSubscriptionCountOutputTypeCountBillingRecordsArgs
    usageRecords?: boolean | WorkspaceSubscriptionCountOutputTypeCountUsageRecordsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceSubscriptionCountOutputType without action
   */
  export type WorkspaceSubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscriptionCountOutputType
     */
    select?: WorkspaceSubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceSubscriptionCountOutputType without action
   */
  export type WorkspaceSubscriptionCountOutputTypeCountBillingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingRecordWhereInput
  }

  /**
   * WorkspaceSubscriptionCountOutputType without action
   */
  export type WorkspaceSubscriptionCountOutputTypeCountUsageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageRecordWhereInput
  }


  /**
   * Count Type ApiKeyManagementCountOutputType
   */

  export type ApiKeyManagementCountOutputType = {
    usageLogs: number
  }

  export type ApiKeyManagementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usageLogs?: boolean | ApiKeyManagementCountOutputTypeCountUsageLogsArgs
  }

  // Custom InputTypes
  /**
   * ApiKeyManagementCountOutputType without action
   */
  export type ApiKeyManagementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagementCountOutputType
     */
    select?: ApiKeyManagementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApiKeyManagementCountOutputType without action
   */
  export type ApiKeyManagementCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyUsageLogWhereInput
  }


  /**
   * Count Type EmailTemplateCountOutputType
   */

  export type EmailTemplateCountOutputType = {
    emailLogs: number
  }

  export type EmailTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailLogs?: boolean | EmailTemplateCountOutputTypeCountEmailLogsArgs
  }

  // Custom InputTypes
  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplateCountOutputType
     */
    select?: EmailTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountEmailLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
  }


  /**
   * Count Type AiAgentCountOutputType
   */

  export type AiAgentCountOutputType = {
    conversations: number
  }

  export type AiAgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | AiAgentCountOutputTypeCountConversationsArgs
  }

  // Custom InputTypes
  /**
   * AiAgentCountOutputType without action
   */
  export type AiAgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgentCountOutputType
     */
    select?: AiAgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiAgentCountOutputType without action
   */
  export type AiAgentCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiConversationWhereInput
  }


  /**
   * Count Type AiConversationCountOutputType
   */

  export type AiConversationCountOutputType = {
    messages: number
  }

  export type AiConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | AiConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * AiConversationCountOutputType without action
   */
  export type AiConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversationCountOutputType
     */
    select?: AiConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiConversationCountOutputType without action
   */
  export type AiConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiMessageWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type EwayCustomerCountOutputType
   */

  export type EwayCustomerCountOutputType = {
    transactions: number
    recurringSchedules: number
  }

  export type EwayCustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | EwayCustomerCountOutputTypeCountTransactionsArgs
    recurringSchedules?: boolean | EwayCustomerCountOutputTypeCountRecurringSchedulesArgs
  }

  // Custom InputTypes
  /**
   * EwayCustomerCountOutputType without action
   */
  export type EwayCustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomerCountOutputType
     */
    select?: EwayCustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EwayCustomerCountOutputType without action
   */
  export type EwayCustomerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayTransactionWhereInput
  }

  /**
   * EwayCustomerCountOutputType without action
   */
  export type EwayCustomerCountOutputTypeCountRecurringSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayRecurringScheduleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    role: string | null
    firstName: string | null
    lastName: string | null
    avatar: string | null
    phoneNumber: string | null
    timezone: string | null
    lastLoginAt: Date | null
    emailVerified: boolean | null
    emailVerifiedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    role: string | null
    firstName: string | null
    lastName: string | null
    avatar: string | null
    phoneNumber: string | null
    timezone: string | null
    lastLoginAt: Date | null
    emailVerified: boolean | null
    emailVerifiedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    role: number
    firstName: number
    lastName: number
    avatar: number
    phoneNumber: number
    timezone: number
    lastLoginAt: number
    emailVerified: number
    emailVerifiedAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    firstName?: true
    lastName?: true
    avatar?: true
    phoneNumber?: true
    timezone?: true
    lastLoginAt?: true
    emailVerified?: true
    emailVerifiedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    firstName?: true
    lastName?: true
    avatar?: true
    phoneNumber?: true
    timezone?: true
    lastLoginAt?: true
    emailVerified?: true
    emailVerifiedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    firstName?: true
    lastName?: true
    avatar?: true
    phoneNumber?: true
    timezone?: true
    lastLoginAt?: true
    emailVerified?: true
    emailVerifiedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    passwordHash: string
    role: string
    firstName: string | null
    lastName: string | null
    avatar: string | null
    phoneNumber: string | null
    timezone: string
    lastLoginAt: Date | null
    emailVerified: boolean
    emailVerifiedAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    phoneNumber?: boolean
    timezone?: boolean
    lastLoginAt?: boolean
    emailVerified?: boolean
    emailVerifiedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    audioHistory?: boolean | User$audioHistoryArgs<ExtArgs>
    audioUploads?: boolean | User$audioUploadsArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    securityEvents?: boolean | User$securityEventsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    audioSegments?: boolean | User$audioSegmentsArgs<ExtArgs>
    emailPreferences?: boolean | User$emailPreferencesArgs<ExtArgs>
    quotaUsage?: boolean | User$quotaUsageArgs<ExtArgs>
    aiTokenUsage?: boolean | User$aiTokenUsageArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    phoneNumber?: boolean
    timezone?: boolean
    lastLoginAt?: boolean
    emailVerified?: boolean
    emailVerifiedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    phoneNumber?: boolean
    timezone?: boolean
    lastLoginAt?: boolean
    emailVerified?: boolean
    emailVerifiedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    audioHistory?: boolean | User$audioHistoryArgs<ExtArgs>
    audioUploads?: boolean | User$audioUploadsArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    securityEvents?: boolean | User$securityEventsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    audioSegments?: boolean | User$audioSegmentsArgs<ExtArgs>
    emailPreferences?: boolean | User$emailPreferencesArgs<ExtArgs>
    quotaUsage?: boolean | User$quotaUsageArgs<ExtArgs>
    aiTokenUsage?: boolean | User$aiTokenUsageArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      workspaces: Prisma.$WorkspaceUserPayload<ExtArgs>[]
      audioHistory: Prisma.$AudioHistoryPayload<ExtArgs>[]
      audioUploads: Prisma.$AudioUploadPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyManagementPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      settings: Prisma.$UserSettingsPayload<ExtArgs> | null
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      securityEvents: Prisma.$SecurityEventPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      audioSegments: Prisma.$AudioSegmentPayload<ExtArgs>[]
      emailPreferences: Prisma.$EmailPreferencePayload<ExtArgs> | null
      quotaUsage: Prisma.$UserQuotaPayload<ExtArgs>[]
      aiTokenUsage: Prisma.$AiTokenUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      passwordHash: string
      role: string
      firstName: string | null
      lastName: string | null
      avatar: string | null
      phoneNumber: string | null
      timezone: string
      lastLoginAt: Date | null
      emailVerified: boolean
      emailVerifiedAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspaces<T extends User$workspacesArgs<ExtArgs> = {}>(args?: Subset<T, User$workspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany"> | Null>
    audioHistory<T extends User$audioHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$audioHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    audioUploads<T extends User$audioUploadsArgs<ExtArgs> = {}>(args?: Subset<T, User$audioUploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findMany"> | Null>
    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany"> | Null>
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    securityEvents<T extends User$securityEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$securityEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    audioSegments<T extends User$audioSegmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$audioSegmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findMany"> | Null>
    emailPreferences<T extends User$emailPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$emailPreferencesArgs<ExtArgs>>): Prisma__EmailPreferenceClient<$Result.GetResult<Prisma.$EmailPreferencePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    quotaUsage<T extends User$quotaUsageArgs<ExtArgs> = {}>(args?: Subset<T, User$quotaUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findMany"> | Null>
    aiTokenUsage<T extends User$aiTokenUsageArgs<ExtArgs> = {}>(args?: Subset<T, User$aiTokenUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiTokenUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.workspaces
   */
  export type User$workspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    cursor?: WorkspaceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * User.audioHistory
   */
  export type User$audioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    where?: AudioHistoryWhereInput
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    cursor?: AudioHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioHistoryScalarFieldEnum | AudioHistoryScalarFieldEnum[]
  }

  /**
   * User.audioUploads
   */
  export type User$audioUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    where?: AudioUploadWhereInput
    orderBy?: AudioUploadOrderByWithRelationInput | AudioUploadOrderByWithRelationInput[]
    cursor?: AudioUploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioUploadScalarFieldEnum | AudioUploadScalarFieldEnum[]
  }

  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    where?: ApiKeyManagementWhereInput
    orderBy?: ApiKeyManagementOrderByWithRelationInput | ApiKeyManagementOrderByWithRelationInput[]
    cursor?: ApiKeyManagementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyManagementScalarFieldEnum | ApiKeyManagementScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.securityEvents
   */
  export type User$securityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    where?: SecurityEventWhereInput
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    cursor?: SecurityEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.audioSegments
   */
  export type User$audioSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    where?: AudioSegmentWhereInput
    orderBy?: AudioSegmentOrderByWithRelationInput | AudioSegmentOrderByWithRelationInput[]
    cursor?: AudioSegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioSegmentScalarFieldEnum | AudioSegmentScalarFieldEnum[]
  }

  /**
   * User.emailPreferences
   */
  export type User$emailPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailPreference
     */
    select?: EmailPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailPreferenceInclude<ExtArgs> | null
    where?: EmailPreferenceWhereInput
  }

  /**
   * User.quotaUsage
   */
  export type User$quotaUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    where?: UserQuotaWhereInput
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    cursor?: UserQuotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserQuotaScalarFieldEnum | UserQuotaScalarFieldEnum[]
  }

  /**
   * User.aiTokenUsage
   */
  export type User$aiTokenUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTokenUsage
     */
    select?: AiTokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTokenUsageInclude<ExtArgs> | null
    where?: AiTokenUsageWhereInput
    orderBy?: AiTokenUsageOrderByWithRelationInput | AiTokenUsageOrderByWithRelationInput[]
    cursor?: AiTokenUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiTokenUsageScalarFieldEnum | AiTokenUsageScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    tokenHash: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    tokenHash: string
    expiresAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokenHash: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly tokenHash: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    revokedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date
    revokedAt: Date | null
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date
      revokedAt: Date | null
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Workspace
   */

  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    logo: string | null
    website: string | null
    industry: string | null
    size: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    logo: string | null
    website: string | null
    industry: string | null
    size: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    logo: number
    website: number
    industry: number
    size: number
    isActive: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    logo?: true
    website?: true
    industry?: true
    size?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    logo?: true
    website?: true
    industry?: true
    size?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    logo?: true
    website?: true
    industry?: true
    size?: true
    isActive?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithAggregationInput | WorkspaceOrderByWithAggregationInput[]
    by: WorkspaceScalarFieldEnum[] | WorkspaceScalarFieldEnum
    having?: WorkspaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceCountAggregateInputType | true
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }

  export type WorkspaceGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    logo: string | null
    website: string | null
    industry: string | null
    size: string | null
    isActive: boolean
    settings: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    logo?: boolean
    website?: boolean
    industry?: boolean
    size?: boolean
    isActive?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Workspace$usersArgs<ExtArgs>
    invitations?: boolean | Workspace$invitationsArgs<ExtArgs>
    audioHistory?: boolean | Workspace$audioHistoryArgs<ExtArgs>
    audioUploads?: boolean | Workspace$audioUploadsArgs<ExtArgs>
    subscriptions?: boolean | Workspace$subscriptionsArgs<ExtArgs>
    storageQuotas?: boolean | Workspace$storageQuotasArgs<ExtArgs>
    integrations?: boolean | Workspace$integrationsArgs<ExtArgs>
    automations?: boolean | Workspace$automationsArgs<ExtArgs>
    webhooks?: boolean | Workspace$webhooksArgs<ExtArgs>
    customFields?: boolean | Workspace$customFieldsArgs<ExtArgs>
    tags?: boolean | Workspace$tagsArgs<ExtArgs>
    aiAgents?: boolean | Workspace$aiAgentsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    logo?: boolean
    website?: boolean
    industry?: boolean
    size?: boolean
    isActive?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    logo?: boolean
    website?: boolean
    industry?: boolean
    size?: boolean
    isActive?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Workspace$usersArgs<ExtArgs>
    invitations?: boolean | Workspace$invitationsArgs<ExtArgs>
    audioHistory?: boolean | Workspace$audioHistoryArgs<ExtArgs>
    audioUploads?: boolean | Workspace$audioUploadsArgs<ExtArgs>
    subscriptions?: boolean | Workspace$subscriptionsArgs<ExtArgs>
    storageQuotas?: boolean | Workspace$storageQuotasArgs<ExtArgs>
    integrations?: boolean | Workspace$integrationsArgs<ExtArgs>
    automations?: boolean | Workspace$automationsArgs<ExtArgs>
    webhooks?: boolean | Workspace$webhooksArgs<ExtArgs>
    customFields?: boolean | Workspace$customFieldsArgs<ExtArgs>
    tags?: boolean | Workspace$tagsArgs<ExtArgs>
    aiAgents?: boolean | Workspace$aiAgentsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workspace"
    objects: {
      users: Prisma.$WorkspaceUserPayload<ExtArgs>[]
      invitations: Prisma.$WorkspaceInvitationPayload<ExtArgs>[]
      audioHistory: Prisma.$AudioHistoryPayload<ExtArgs>[]
      audioUploads: Prisma.$AudioUploadPayload<ExtArgs>[]
      subscriptions: Prisma.$WorkspaceSubscriptionPayload<ExtArgs>[]
      storageQuotas: Prisma.$StorageQuotaPayload<ExtArgs>[]
      integrations: Prisma.$IntegrationPayload<ExtArgs>[]
      automations: Prisma.$WorkspaceAutomationPayload<ExtArgs>[]
      webhooks: Prisma.$WebhookPayload<ExtArgs>[]
      customFields: Prisma.$CustomFieldPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      aiAgents: Prisma.$AiAgentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      logo: string | null
      website: string | null
      industry: string | null
      size: string | null
      isActive: boolean
      settings: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspace"]>
    composites: {}
  }

  type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceDefaultArgs> = $Result.GetResult<Prisma.$WorkspacePayload, S>

  type WorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workspace'], meta: { name: 'Workspace' } }
    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFindUniqueArgs>(args: SelectSubset<T, WorkspaceFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Workspace that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFindFirstArgs>(args?: SelectSubset<T, WorkspaceFindFirstArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Workspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceFindManyArgs>(args?: SelectSubset<T, WorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
     */
    create<T extends WorkspaceCreateArgs>(args: SelectSubset<T, WorkspaceCreateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workspaces.
     * @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceCreateManyArgs>(args?: SelectSubset<T, WorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workspaces and returns the data saved in the database.
     * @param {WorkspaceCreateManyAndReturnArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDeleteArgs>(args: SelectSubset<T, WorkspaceDeleteArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUpdateArgs>(args: SelectSubset<T, WorkspaceUpdateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUpdateManyArgs>(args: SelectSubset<T, WorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUpsertArgs>(args: SelectSubset<T, WorkspaceUpsertArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workspace model
   */
  readonly fields: WorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Workspace$usersArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany"> | Null>
    invitations<T extends Workspace$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    audioHistory<T extends Workspace$audioHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$audioHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    audioUploads<T extends Workspace$audioUploadsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$audioUploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findMany"> | Null>
    subscriptions<T extends Workspace$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    storageQuotas<T extends Workspace$storageQuotasArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$storageQuotasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findMany"> | Null>
    integrations<T extends Workspace$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    automations<T extends Workspace$automationsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$automationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceAutomationPayload<ExtArgs>, T, "findMany"> | Null>
    webhooks<T extends Workspace$webhooksArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$webhooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany"> | Null>
    customFields<T extends Workspace$customFieldsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$customFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends Workspace$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    aiAgents<T extends Workspace$aiAgentsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$aiAgentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workspace model
   */ 
  interface WorkspaceFieldRefs {
    readonly id: FieldRef<"Workspace", 'String'>
    readonly name: FieldRef<"Workspace", 'String'>
    readonly slug: FieldRef<"Workspace", 'String'>
    readonly description: FieldRef<"Workspace", 'String'>
    readonly logo: FieldRef<"Workspace", 'String'>
    readonly website: FieldRef<"Workspace", 'String'>
    readonly industry: FieldRef<"Workspace", 'String'>
    readonly size: FieldRef<"Workspace", 'String'>
    readonly isActive: FieldRef<"Workspace", 'Boolean'>
    readonly settings: FieldRef<"Workspace", 'Json'>
    readonly createdAt: FieldRef<"Workspace", 'DateTime'>
    readonly updatedAt: FieldRef<"Workspace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workspace findUnique
   */
  export type WorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findFirst
   */
  export type WorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
  }

  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace createManyAndReturn
   */
  export type WorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
  }

  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
  }

  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput
  }

  /**
   * Workspace.users
   */
  export type Workspace$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    cursor?: WorkspaceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * Workspace.invitations
   */
  export type Workspace$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    cursor?: WorkspaceInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * Workspace.audioHistory
   */
  export type Workspace$audioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    where?: AudioHistoryWhereInput
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    cursor?: AudioHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioHistoryScalarFieldEnum | AudioHistoryScalarFieldEnum[]
  }

  /**
   * Workspace.audioUploads
   */
  export type Workspace$audioUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    where?: AudioUploadWhereInput
    orderBy?: AudioUploadOrderByWithRelationInput | AudioUploadOrderByWithRelationInput[]
    cursor?: AudioUploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioUploadScalarFieldEnum | AudioUploadScalarFieldEnum[]
  }

  /**
   * Workspace.subscriptions
   */
  export type Workspace$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    where?: WorkspaceSubscriptionWhereInput
    orderBy?: WorkspaceSubscriptionOrderByWithRelationInput | WorkspaceSubscriptionOrderByWithRelationInput[]
    cursor?: WorkspaceSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceSubscriptionScalarFieldEnum | WorkspaceSubscriptionScalarFieldEnum[]
  }

  /**
   * Workspace.storageQuotas
   */
  export type Workspace$storageQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    where?: StorageQuotaWhereInput
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    cursor?: StorageQuotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorageQuotaScalarFieldEnum | StorageQuotaScalarFieldEnum[]
  }

  /**
   * Workspace.integrations
   */
  export type Workspace$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    cursor?: IntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Workspace.automations
   */
  export type Workspace$automationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceAutomation
     */
    select?: WorkspaceAutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceAutomationInclude<ExtArgs> | null
    where?: WorkspaceAutomationWhereInput
    orderBy?: WorkspaceAutomationOrderByWithRelationInput | WorkspaceAutomationOrderByWithRelationInput[]
    cursor?: WorkspaceAutomationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceAutomationScalarFieldEnum | WorkspaceAutomationScalarFieldEnum[]
  }

  /**
   * Workspace.webhooks
   */
  export type Workspace$webhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    cursor?: WebhookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Workspace.customFields
   */
  export type Workspace$customFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    where?: CustomFieldWhereInput
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    cursor?: CustomFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * Workspace.tags
   */
  export type Workspace$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Workspace.aiAgents
   */
  export type Workspace$aiAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    where?: AiAgentWhereInput
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    cursor?: AiAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiAgentScalarFieldEnum | AiAgentScalarFieldEnum[]
  }

  /**
   * Workspace without action
   */
  export type WorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceUser
   */

  export type AggregateWorkspaceUser = {
    _count: WorkspaceUserCountAggregateOutputType | null
    _min: WorkspaceUserMinAggregateOutputType | null
    _max: WorkspaceUserMaxAggregateOutputType | null
  }

  export type WorkspaceUserMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    lastActiveAt: Date | null
  }

  export type WorkspaceUserMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    lastActiveAt: Date | null
  }

  export type WorkspaceUserCountAggregateOutputType = {
    id: number
    workspaceId: number
    userId: number
    role: number
    permissions: number
    joinedAt: number
    lastActiveAt: number
    _all: number
  }


  export type WorkspaceUserMinAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    lastActiveAt?: true
  }

  export type WorkspaceUserMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    lastActiveAt?: true
  }

  export type WorkspaceUserCountAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    permissions?: true
    joinedAt?: true
    lastActiveAt?: true
    _all?: true
  }

  export type WorkspaceUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUser to aggregate.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceUsers
    **/
    _count?: true | WorkspaceUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceUserMaxAggregateInputType
  }

  export type GetWorkspaceUserAggregateType<T extends WorkspaceUserAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceUser[P]>
      : GetScalarType<T[P], AggregateWorkspaceUser[P]>
  }




  export type WorkspaceUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithAggregationInput | WorkspaceUserOrderByWithAggregationInput[]
    by: WorkspaceUserScalarFieldEnum[] | WorkspaceUserScalarFieldEnum
    having?: WorkspaceUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceUserCountAggregateInputType | true
    _min?: WorkspaceUserMinAggregateInputType
    _max?: WorkspaceUserMaxAggregateInputType
  }

  export type WorkspaceUserGroupByOutputType = {
    id: string
    workspaceId: string
    userId: string
    role: string
    permissions: JsonValue
    joinedAt: Date
    lastActiveAt: Date | null
    _count: WorkspaceUserCountAggregateOutputType | null
    _min: WorkspaceUserMinAggregateOutputType | null
    _max: WorkspaceUserMaxAggregateOutputType | null
  }

  type GetWorkspaceUserGroupByPayload<T extends WorkspaceUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceUserGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceUserGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    joinedAt?: boolean
    lastActiveAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    joinedAt?: boolean
    lastActiveAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    joinedAt?: boolean
    lastActiveAt?: boolean
  }

  export type WorkspaceUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkspaceUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkspaceUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceUser"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      userId: string
      role: string
      permissions: Prisma.JsonValue
      joinedAt: Date
      lastActiveAt: Date | null
    }, ExtArgs["result"]["workspaceUser"]>
    composites: {}
  }

  type WorkspaceUserGetPayload<S extends boolean | null | undefined | WorkspaceUserDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceUserPayload, S>

  type WorkspaceUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceUserCountAggregateInputType | true
    }

  export interface WorkspaceUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceUser'], meta: { name: 'WorkspaceUser' } }
    /**
     * Find zero or one WorkspaceUser that matches the filter.
     * @param {WorkspaceUserFindUniqueArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceUserFindUniqueArgs>(args: SelectSubset<T, WorkspaceUserFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkspaceUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceUserFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceUserFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkspaceUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindFirstArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceUserFindFirstArgs>(args?: SelectSubset<T, WorkspaceUserFindFirstArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkspaceUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindFirstOrThrowArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceUserFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkspaceUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceUsers
     * const workspaceUsers = await prisma.workspaceUser.findMany()
     * 
     * // Get first 10 WorkspaceUsers
     * const workspaceUsers = await prisma.workspaceUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceUserFindManyArgs>(args?: SelectSubset<T, WorkspaceUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkspaceUser.
     * @param {WorkspaceUserCreateArgs} args - Arguments to create a WorkspaceUser.
     * @example
     * // Create one WorkspaceUser
     * const WorkspaceUser = await prisma.workspaceUser.create({
     *   data: {
     *     // ... data to create a WorkspaceUser
     *   }
     * })
     * 
     */
    create<T extends WorkspaceUserCreateArgs>(args: SelectSubset<T, WorkspaceUserCreateArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkspaceUsers.
     * @param {WorkspaceUserCreateManyArgs} args - Arguments to create many WorkspaceUsers.
     * @example
     * // Create many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceUserCreateManyArgs>(args?: SelectSubset<T, WorkspaceUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceUsers and returns the data saved in the database.
     * @param {WorkspaceUserCreateManyAndReturnArgs} args - Arguments to create many WorkspaceUsers.
     * @example
     * // Create many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceUsers and only return the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceUserCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkspaceUser.
     * @param {WorkspaceUserDeleteArgs} args - Arguments to delete one WorkspaceUser.
     * @example
     * // Delete one WorkspaceUser
     * const WorkspaceUser = await prisma.workspaceUser.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceUser
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceUserDeleteArgs>(args: SelectSubset<T, WorkspaceUserDeleteArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkspaceUser.
     * @param {WorkspaceUserUpdateArgs} args - Arguments to update one WorkspaceUser.
     * @example
     * // Update one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUserUpdateArgs>(args: SelectSubset<T, WorkspaceUserUpdateArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkspaceUsers.
     * @param {WorkspaceUserDeleteManyArgs} args - Arguments to filter WorkspaceUsers to delete.
     * @example
     * // Delete a few WorkspaceUsers
     * const { count } = await prisma.workspaceUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceUserDeleteManyArgs>(args?: SelectSubset<T, WorkspaceUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUserUpdateManyArgs>(args: SelectSubset<T, WorkspaceUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkspaceUser.
     * @param {WorkspaceUserUpsertArgs} args - Arguments to update or create a WorkspaceUser.
     * @example
     * // Update or create a WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.upsert({
     *   create: {
     *     // ... data to create a WorkspaceUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceUser we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUserUpsertArgs>(args: SelectSubset<T, WorkspaceUserUpsertArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkspaceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserCountArgs} args - Arguments to filter WorkspaceUsers to count.
     * @example
     * // Count the number of WorkspaceUsers
     * const count = await prisma.workspaceUser.count({
     *   where: {
     *     // ... the filter for the WorkspaceUsers we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceUserCountArgs>(
      args?: Subset<T, WorkspaceUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceUserAggregateArgs>(args: Subset<T, WorkspaceUserAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceUserAggregateType<T>>

    /**
     * Group by WorkspaceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceUserGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceUser model
   */
  readonly fields: WorkspaceUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceUser model
   */ 
  interface WorkspaceUserFieldRefs {
    readonly id: FieldRef<"WorkspaceUser", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceUser", 'String'>
    readonly userId: FieldRef<"WorkspaceUser", 'String'>
    readonly role: FieldRef<"WorkspaceUser", 'String'>
    readonly permissions: FieldRef<"WorkspaceUser", 'Json'>
    readonly joinedAt: FieldRef<"WorkspaceUser", 'DateTime'>
    readonly lastActiveAt: FieldRef<"WorkspaceUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceUser findUnique
   */
  export type WorkspaceUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser findUniqueOrThrow
   */
  export type WorkspaceUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser findFirst
   */
  export type WorkspaceUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUsers.
     */
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser findFirstOrThrow
   */
  export type WorkspaceUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUsers.
     */
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser findMany
   */
  export type WorkspaceUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUsers to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser create
   */
  export type WorkspaceUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceUser.
     */
    data: XOR<WorkspaceUserCreateInput, WorkspaceUserUncheckedCreateInput>
  }

  /**
   * WorkspaceUser createMany
   */
  export type WorkspaceUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceUsers.
     */
    data: WorkspaceUserCreateManyInput | WorkspaceUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceUser createManyAndReturn
   */
  export type WorkspaceUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkspaceUsers.
     */
    data: WorkspaceUserCreateManyInput | WorkspaceUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceUser update
   */
  export type WorkspaceUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceUser.
     */
    data: XOR<WorkspaceUserUpdateInput, WorkspaceUserUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceUser to update.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser updateMany
   */
  export type WorkspaceUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceUsers.
     */
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceUsers to update
     */
    where?: WorkspaceUserWhereInput
  }

  /**
   * WorkspaceUser upsert
   */
  export type WorkspaceUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceUser to update in case it exists.
     */
    where: WorkspaceUserWhereUniqueInput
    /**
     * In case the WorkspaceUser found by the `where` argument doesn't exist, create a new WorkspaceUser with this data.
     */
    create: XOR<WorkspaceUserCreateInput, WorkspaceUserUncheckedCreateInput>
    /**
     * In case the WorkspaceUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUserUpdateInput, WorkspaceUserUncheckedUpdateInput>
  }

  /**
   * WorkspaceUser delete
   */
  export type WorkspaceUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceUser to delete.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser deleteMany
   */
  export type WorkspaceUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUsers to delete
     */
    where?: WorkspaceUserWhereInput
  }

  /**
   * WorkspaceUser without action
   */
  export type WorkspaceUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceInvitation
   */

  export type AggregateWorkspaceInvitation = {
    _count: WorkspaceInvitationCountAggregateOutputType | null
    _min: WorkspaceInvitationMinAggregateOutputType | null
    _max: WorkspaceInvitationMaxAggregateOutputType | null
  }

  export type WorkspaceInvitationMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    email: string | null
    role: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    acceptedAt: Date | null
  }

  export type WorkspaceInvitationMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    email: string | null
    role: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    acceptedAt: Date | null
  }

  export type WorkspaceInvitationCountAggregateOutputType = {
    id: number
    workspaceId: number
    email: number
    role: number
    token: number
    expiresAt: number
    createdAt: number
    acceptedAt: number
    _all: number
  }


  export type WorkspaceInvitationMinAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    acceptedAt?: true
  }

  export type WorkspaceInvitationMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    acceptedAt?: true
  }

  export type WorkspaceInvitationCountAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    acceptedAt?: true
    _all?: true
  }

  export type WorkspaceInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceInvitation to aggregate.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceInvitations
    **/
    _count?: true | WorkspaceInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceInvitationMaxAggregateInputType
  }

  export type GetWorkspaceInvitationAggregateType<T extends WorkspaceInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceInvitation[P]>
      : GetScalarType<T[P], AggregateWorkspaceInvitation[P]>
  }




  export type WorkspaceInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithAggregationInput | WorkspaceInvitationOrderByWithAggregationInput[]
    by: WorkspaceInvitationScalarFieldEnum[] | WorkspaceInvitationScalarFieldEnum
    having?: WorkspaceInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceInvitationCountAggregateInputType | true
    _min?: WorkspaceInvitationMinAggregateInputType
    _max?: WorkspaceInvitationMaxAggregateInputType
  }

  export type WorkspaceInvitationGroupByOutputType = {
    id: string
    workspaceId: string
    email: string
    role: string
    token: string
    expiresAt: Date
    createdAt: Date
    acceptedAt: Date | null
    _count: WorkspaceInvitationCountAggregateOutputType | null
    _min: WorkspaceInvitationMinAggregateOutputType | null
    _max: WorkspaceInvitationMaxAggregateOutputType | null
  }

  type GetWorkspaceInvitationGroupByPayload<T extends WorkspaceInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceInvitationGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    acceptedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    acceptedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    acceptedAt?: boolean
  }

  export type WorkspaceInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WorkspaceInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceInvitation"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      email: string
      role: string
      token: string
      expiresAt: Date
      createdAt: Date
      acceptedAt: Date | null
    }, ExtArgs["result"]["workspaceInvitation"]>
    composites: {}
  }

  type WorkspaceInvitationGetPayload<S extends boolean | null | undefined | WorkspaceInvitationDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceInvitationPayload, S>

  type WorkspaceInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceInvitationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceInvitationCountAggregateInputType | true
    }

  export interface WorkspaceInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceInvitation'], meta: { name: 'WorkspaceInvitation' } }
    /**
     * Find zero or one WorkspaceInvitation that matches the filter.
     * @param {WorkspaceInvitationFindUniqueArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceInvitationFindUniqueArgs>(args: SelectSubset<T, WorkspaceInvitationFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkspaceInvitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceInvitationFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkspaceInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindFirstArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceInvitationFindFirstArgs>(args?: SelectSubset<T, WorkspaceInvitationFindFirstArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkspaceInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindFirstOrThrowArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkspaceInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceInvitations
     * const workspaceInvitations = await prisma.workspaceInvitation.findMany()
     * 
     * // Get first 10 WorkspaceInvitations
     * const workspaceInvitations = await prisma.workspaceInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceInvitationFindManyArgs>(args?: SelectSubset<T, WorkspaceInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkspaceInvitation.
     * @param {WorkspaceInvitationCreateArgs} args - Arguments to create a WorkspaceInvitation.
     * @example
     * // Create one WorkspaceInvitation
     * const WorkspaceInvitation = await prisma.workspaceInvitation.create({
     *   data: {
     *     // ... data to create a WorkspaceInvitation
     *   }
     * })
     * 
     */
    create<T extends WorkspaceInvitationCreateArgs>(args: SelectSubset<T, WorkspaceInvitationCreateArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkspaceInvitations.
     * @param {WorkspaceInvitationCreateManyArgs} args - Arguments to create many WorkspaceInvitations.
     * @example
     * // Create many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceInvitationCreateManyArgs>(args?: SelectSubset<T, WorkspaceInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceInvitations and returns the data saved in the database.
     * @param {WorkspaceInvitationCreateManyAndReturnArgs} args - Arguments to create many WorkspaceInvitations.
     * @example
     * // Create many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceInvitations and only return the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkspaceInvitation.
     * @param {WorkspaceInvitationDeleteArgs} args - Arguments to delete one WorkspaceInvitation.
     * @example
     * // Delete one WorkspaceInvitation
     * const WorkspaceInvitation = await prisma.workspaceInvitation.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceInvitation
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceInvitationDeleteArgs>(args: SelectSubset<T, WorkspaceInvitationDeleteArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkspaceInvitation.
     * @param {WorkspaceInvitationUpdateArgs} args - Arguments to update one WorkspaceInvitation.
     * @example
     * // Update one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceInvitationUpdateArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkspaceInvitations.
     * @param {WorkspaceInvitationDeleteManyArgs} args - Arguments to filter WorkspaceInvitations to delete.
     * @example
     * // Delete a few WorkspaceInvitations
     * const { count } = await prisma.workspaceInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceInvitationDeleteManyArgs>(args?: SelectSubset<T, WorkspaceInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceInvitationUpdateManyArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkspaceInvitation.
     * @param {WorkspaceInvitationUpsertArgs} args - Arguments to update or create a WorkspaceInvitation.
     * @example
     * // Update or create a WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.upsert({
     *   create: {
     *     // ... data to create a WorkspaceInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceInvitation we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceInvitationUpsertArgs>(args: SelectSubset<T, WorkspaceInvitationUpsertArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkspaceInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationCountArgs} args - Arguments to filter WorkspaceInvitations to count.
     * @example
     * // Count the number of WorkspaceInvitations
     * const count = await prisma.workspaceInvitation.count({
     *   where: {
     *     // ... the filter for the WorkspaceInvitations we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceInvitationCountArgs>(
      args?: Subset<T, WorkspaceInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceInvitationAggregateArgs>(args: Subset<T, WorkspaceInvitationAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceInvitationAggregateType<T>>

    /**
     * Group by WorkspaceInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceInvitationGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceInvitation model
   */
  readonly fields: WorkspaceInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceInvitation model
   */ 
  interface WorkspaceInvitationFieldRefs {
    readonly id: FieldRef<"WorkspaceInvitation", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceInvitation", 'String'>
    readonly email: FieldRef<"WorkspaceInvitation", 'String'>
    readonly role: FieldRef<"WorkspaceInvitation", 'String'>
    readonly token: FieldRef<"WorkspaceInvitation", 'String'>
    readonly expiresAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
    readonly createdAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceInvitation findUnique
   */
  export type WorkspaceInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation findUniqueOrThrow
   */
  export type WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation findFirst
   */
  export type WorkspaceInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceInvitations.
     */
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation findFirstOrThrow
   */
  export type WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceInvitations.
     */
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation findMany
   */
  export type WorkspaceInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitations to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation create
   */
  export type WorkspaceInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceInvitation.
     */
    data: XOR<WorkspaceInvitationCreateInput, WorkspaceInvitationUncheckedCreateInput>
  }

  /**
   * WorkspaceInvitation createMany
   */
  export type WorkspaceInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceInvitations.
     */
    data: WorkspaceInvitationCreateManyInput | WorkspaceInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceInvitation createManyAndReturn
   */
  export type WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkspaceInvitations.
     */
    data: WorkspaceInvitationCreateManyInput | WorkspaceInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceInvitation update
   */
  export type WorkspaceInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceInvitation.
     */
    data: XOR<WorkspaceInvitationUpdateInput, WorkspaceInvitationUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceInvitation to update.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation updateMany
   */
  export type WorkspaceInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceInvitations.
     */
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceInvitations to update
     */
    where?: WorkspaceInvitationWhereInput
  }

  /**
   * WorkspaceInvitation upsert
   */
  export type WorkspaceInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceInvitation to update in case it exists.
     */
    where: WorkspaceInvitationWhereUniqueInput
    /**
     * In case the WorkspaceInvitation found by the `where` argument doesn't exist, create a new WorkspaceInvitation with this data.
     */
    create: XOR<WorkspaceInvitationCreateInput, WorkspaceInvitationUncheckedCreateInput>
    /**
     * In case the WorkspaceInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceInvitationUpdateInput, WorkspaceInvitationUncheckedUpdateInput>
  }

  /**
   * WorkspaceInvitation delete
   */
  export type WorkspaceInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceInvitation to delete.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation deleteMany
   */
  export type WorkspaceInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceInvitations to delete
     */
    where?: WorkspaceInvitationWhereInput
  }

  /**
   * WorkspaceInvitation without action
   */
  export type WorkspaceInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
  }


  /**
   * Model AudioUpload
   */

  export type AggregateAudioUpload = {
    _count: AudioUploadCountAggregateOutputType | null
    _avg: AudioUploadAvgAggregateOutputType | null
    _sum: AudioUploadSumAggregateOutputType | null
    _min: AudioUploadMinAggregateOutputType | null
    _max: AudioUploadMaxAggregateOutputType | null
  }

  export type AudioUploadAvgAggregateOutputType = {
    fileSize: number | null
    uploadProgress: number | null
  }

  export type AudioUploadSumAggregateOutputType = {
    fileSize: bigint | null
    uploadProgress: number | null
  }

  export type AudioUploadMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    originalFileName: string | null
    fileSize: bigint | null
    mimeType: string | null
    uploadStatus: string | null
    uploadProgress: number | null
    storageProvider: string | null
    storagePath: string | null
    storageUrl: string | null
    cdnUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AudioUploadMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    originalFileName: string | null
    fileSize: bigint | null
    mimeType: string | null
    uploadStatus: string | null
    uploadProgress: number | null
    storageProvider: string | null
    storagePath: string | null
    storageUrl: string | null
    cdnUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AudioUploadCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    originalFileName: number
    fileSize: number
    mimeType: number
    uploadStatus: number
    uploadProgress: number
    storageProvider: number
    storagePath: number
    storageUrl: number
    cdnUrl: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AudioUploadAvgAggregateInputType = {
    fileSize?: true
    uploadProgress?: true
  }

  export type AudioUploadSumAggregateInputType = {
    fileSize?: true
    uploadProgress?: true
  }

  export type AudioUploadMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    originalFileName?: true
    fileSize?: true
    mimeType?: true
    uploadStatus?: true
    uploadProgress?: true
    storageProvider?: true
    storagePath?: true
    storageUrl?: true
    cdnUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AudioUploadMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    originalFileName?: true
    fileSize?: true
    mimeType?: true
    uploadStatus?: true
    uploadProgress?: true
    storageProvider?: true
    storagePath?: true
    storageUrl?: true
    cdnUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AudioUploadCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    originalFileName?: true
    fileSize?: true
    mimeType?: true
    uploadStatus?: true
    uploadProgress?: true
    storageProvider?: true
    storagePath?: true
    storageUrl?: true
    cdnUrl?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AudioUploadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioUpload to aggregate.
     */
    where?: AudioUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioUploads to fetch.
     */
    orderBy?: AudioUploadOrderByWithRelationInput | AudioUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioUploads
    **/
    _count?: true | AudioUploadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioUploadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioUploadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioUploadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioUploadMaxAggregateInputType
  }

  export type GetAudioUploadAggregateType<T extends AudioUploadAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioUpload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioUpload[P]>
      : GetScalarType<T[P], AggregateAudioUpload[P]>
  }




  export type AudioUploadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioUploadWhereInput
    orderBy?: AudioUploadOrderByWithAggregationInput | AudioUploadOrderByWithAggregationInput[]
    by: AudioUploadScalarFieldEnum[] | AudioUploadScalarFieldEnum
    having?: AudioUploadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioUploadCountAggregateInputType | true
    _avg?: AudioUploadAvgAggregateInputType
    _sum?: AudioUploadSumAggregateInputType
    _min?: AudioUploadMinAggregateInputType
    _max?: AudioUploadMaxAggregateInputType
  }

  export type AudioUploadGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string
    originalFileName: string
    fileSize: bigint
    mimeType: string
    uploadStatus: string
    uploadProgress: number
    storageProvider: string
    storagePath: string | null
    storageUrl: string | null
    cdnUrl: string | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: AudioUploadCountAggregateOutputType | null
    _avg: AudioUploadAvgAggregateOutputType | null
    _sum: AudioUploadSumAggregateOutputType | null
    _min: AudioUploadMinAggregateOutputType | null
    _max: AudioUploadMaxAggregateOutputType | null
  }

  type GetAudioUploadGroupByPayload<T extends AudioUploadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioUploadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioUploadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioUploadGroupByOutputType[P]>
            : GetScalarType<T[P], AudioUploadGroupByOutputType[P]>
        }
      >
    >


  export type AudioUploadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    originalFileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadStatus?: boolean
    uploadProgress?: boolean
    storageProvider?: boolean
    storagePath?: boolean
    storageUrl?: boolean
    cdnUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    processingJobs?: boolean | AudioUpload$processingJobsArgs<ExtArgs>
    audioChunks?: boolean | AudioUpload$audioChunksArgs<ExtArgs>
    fileStorage?: boolean | AudioUpload$fileStorageArgs<ExtArgs>
    _count?: boolean | AudioUploadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioUpload"]>

  export type AudioUploadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    originalFileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadStatus?: boolean
    uploadProgress?: boolean
    storageProvider?: boolean
    storagePath?: boolean
    storageUrl?: boolean
    cdnUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioUpload"]>

  export type AudioUploadSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    originalFileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadStatus?: boolean
    uploadProgress?: boolean
    storageProvider?: boolean
    storagePath?: boolean
    storageUrl?: boolean
    cdnUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AudioUploadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    processingJobs?: boolean | AudioUpload$processingJobsArgs<ExtArgs>
    audioChunks?: boolean | AudioUpload$audioChunksArgs<ExtArgs>
    fileStorage?: boolean | AudioUpload$fileStorageArgs<ExtArgs>
    _count?: boolean | AudioUploadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AudioUploadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $AudioUploadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioUpload"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      processingJobs: Prisma.$ProcessingJobPayload<ExtArgs>[]
      audioChunks: Prisma.$AudioChunkPayload<ExtArgs>[]
      fileStorage: Prisma.$FileStoragePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string
      originalFileName: string
      fileSize: bigint
      mimeType: string
      uploadStatus: string
      uploadProgress: number
      storageProvider: string
      storagePath: string | null
      storageUrl: string | null
      cdnUrl: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["audioUpload"]>
    composites: {}
  }

  type AudioUploadGetPayload<S extends boolean | null | undefined | AudioUploadDefaultArgs> = $Result.GetResult<Prisma.$AudioUploadPayload, S>

  type AudioUploadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AudioUploadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AudioUploadCountAggregateInputType | true
    }

  export interface AudioUploadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioUpload'], meta: { name: 'AudioUpload' } }
    /**
     * Find zero or one AudioUpload that matches the filter.
     * @param {AudioUploadFindUniqueArgs} args - Arguments to find a AudioUpload
     * @example
     * // Get one AudioUpload
     * const audioUpload = await prisma.audioUpload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioUploadFindUniqueArgs>(args: SelectSubset<T, AudioUploadFindUniqueArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AudioUpload that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AudioUploadFindUniqueOrThrowArgs} args - Arguments to find a AudioUpload
     * @example
     * // Get one AudioUpload
     * const audioUpload = await prisma.audioUpload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioUploadFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioUploadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AudioUpload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadFindFirstArgs} args - Arguments to find a AudioUpload
     * @example
     * // Get one AudioUpload
     * const audioUpload = await prisma.audioUpload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioUploadFindFirstArgs>(args?: SelectSubset<T, AudioUploadFindFirstArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AudioUpload that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadFindFirstOrThrowArgs} args - Arguments to find a AudioUpload
     * @example
     * // Get one AudioUpload
     * const audioUpload = await prisma.audioUpload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioUploadFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioUploadFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AudioUploads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioUploads
     * const audioUploads = await prisma.audioUpload.findMany()
     * 
     * // Get first 10 AudioUploads
     * const audioUploads = await prisma.audioUpload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioUploadWithIdOnly = await prisma.audioUpload.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioUploadFindManyArgs>(args?: SelectSubset<T, AudioUploadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AudioUpload.
     * @param {AudioUploadCreateArgs} args - Arguments to create a AudioUpload.
     * @example
     * // Create one AudioUpload
     * const AudioUpload = await prisma.audioUpload.create({
     *   data: {
     *     // ... data to create a AudioUpload
     *   }
     * })
     * 
     */
    create<T extends AudioUploadCreateArgs>(args: SelectSubset<T, AudioUploadCreateArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AudioUploads.
     * @param {AudioUploadCreateManyArgs} args - Arguments to create many AudioUploads.
     * @example
     * // Create many AudioUploads
     * const audioUpload = await prisma.audioUpload.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioUploadCreateManyArgs>(args?: SelectSubset<T, AudioUploadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioUploads and returns the data saved in the database.
     * @param {AudioUploadCreateManyAndReturnArgs} args - Arguments to create many AudioUploads.
     * @example
     * // Create many AudioUploads
     * const audioUpload = await prisma.audioUpload.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioUploads and only return the `id`
     * const audioUploadWithIdOnly = await prisma.audioUpload.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioUploadCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioUploadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AudioUpload.
     * @param {AudioUploadDeleteArgs} args - Arguments to delete one AudioUpload.
     * @example
     * // Delete one AudioUpload
     * const AudioUpload = await prisma.audioUpload.delete({
     *   where: {
     *     // ... filter to delete one AudioUpload
     *   }
     * })
     * 
     */
    delete<T extends AudioUploadDeleteArgs>(args: SelectSubset<T, AudioUploadDeleteArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AudioUpload.
     * @param {AudioUploadUpdateArgs} args - Arguments to update one AudioUpload.
     * @example
     * // Update one AudioUpload
     * const audioUpload = await prisma.audioUpload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioUploadUpdateArgs>(args: SelectSubset<T, AudioUploadUpdateArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AudioUploads.
     * @param {AudioUploadDeleteManyArgs} args - Arguments to filter AudioUploads to delete.
     * @example
     * // Delete a few AudioUploads
     * const { count } = await prisma.audioUpload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioUploadDeleteManyArgs>(args?: SelectSubset<T, AudioUploadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioUploads
     * const audioUpload = await prisma.audioUpload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioUploadUpdateManyArgs>(args: SelectSubset<T, AudioUploadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AudioUpload.
     * @param {AudioUploadUpsertArgs} args - Arguments to update or create a AudioUpload.
     * @example
     * // Update or create a AudioUpload
     * const audioUpload = await prisma.audioUpload.upsert({
     *   create: {
     *     // ... data to create a AudioUpload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioUpload we want to update
     *   }
     * })
     */
    upsert<T extends AudioUploadUpsertArgs>(args: SelectSubset<T, AudioUploadUpsertArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AudioUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadCountArgs} args - Arguments to filter AudioUploads to count.
     * @example
     * // Count the number of AudioUploads
     * const count = await prisma.audioUpload.count({
     *   where: {
     *     // ... the filter for the AudioUploads we want to count
     *   }
     * })
    **/
    count<T extends AudioUploadCountArgs>(
      args?: Subset<T, AudioUploadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioUploadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioUploadAggregateArgs>(args: Subset<T, AudioUploadAggregateArgs>): Prisma.PrismaPromise<GetAudioUploadAggregateType<T>>

    /**
     * Group by AudioUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUploadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioUploadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioUploadGroupByArgs['orderBy'] }
        : { orderBy?: AudioUploadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioUploadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioUploadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioUpload model
   */
  readonly fields: AudioUploadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioUpload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioUploadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    processingJobs<T extends AudioUpload$processingJobsArgs<ExtArgs> = {}>(args?: Subset<T, AudioUpload$processingJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findMany"> | Null>
    audioChunks<T extends AudioUpload$audioChunksArgs<ExtArgs> = {}>(args?: Subset<T, AudioUpload$audioChunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "findMany"> | Null>
    fileStorage<T extends AudioUpload$fileStorageArgs<ExtArgs> = {}>(args?: Subset<T, AudioUpload$fileStorageArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioUpload model
   */ 
  interface AudioUploadFieldRefs {
    readonly id: FieldRef<"AudioUpload", 'String'>
    readonly userId: FieldRef<"AudioUpload", 'String'>
    readonly workspaceId: FieldRef<"AudioUpload", 'String'>
    readonly originalFileName: FieldRef<"AudioUpload", 'String'>
    readonly fileSize: FieldRef<"AudioUpload", 'BigInt'>
    readonly mimeType: FieldRef<"AudioUpload", 'String'>
    readonly uploadStatus: FieldRef<"AudioUpload", 'String'>
    readonly uploadProgress: FieldRef<"AudioUpload", 'Float'>
    readonly storageProvider: FieldRef<"AudioUpload", 'String'>
    readonly storagePath: FieldRef<"AudioUpload", 'String'>
    readonly storageUrl: FieldRef<"AudioUpload", 'String'>
    readonly cdnUrl: FieldRef<"AudioUpload", 'String'>
    readonly metadata: FieldRef<"AudioUpload", 'Json'>
    readonly createdAt: FieldRef<"AudioUpload", 'DateTime'>
    readonly updatedAt: FieldRef<"AudioUpload", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioUpload findUnique
   */
  export type AudioUploadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * Filter, which AudioUpload to fetch.
     */
    where: AudioUploadWhereUniqueInput
  }

  /**
   * AudioUpload findUniqueOrThrow
   */
  export type AudioUploadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * Filter, which AudioUpload to fetch.
     */
    where: AudioUploadWhereUniqueInput
  }

  /**
   * AudioUpload findFirst
   */
  export type AudioUploadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * Filter, which AudioUpload to fetch.
     */
    where?: AudioUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioUploads to fetch.
     */
    orderBy?: AudioUploadOrderByWithRelationInput | AudioUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioUploads.
     */
    cursor?: AudioUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioUploads.
     */
    distinct?: AudioUploadScalarFieldEnum | AudioUploadScalarFieldEnum[]
  }

  /**
   * AudioUpload findFirstOrThrow
   */
  export type AudioUploadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * Filter, which AudioUpload to fetch.
     */
    where?: AudioUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioUploads to fetch.
     */
    orderBy?: AudioUploadOrderByWithRelationInput | AudioUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioUploads.
     */
    cursor?: AudioUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioUploads.
     */
    distinct?: AudioUploadScalarFieldEnum | AudioUploadScalarFieldEnum[]
  }

  /**
   * AudioUpload findMany
   */
  export type AudioUploadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * Filter, which AudioUploads to fetch.
     */
    where?: AudioUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioUploads to fetch.
     */
    orderBy?: AudioUploadOrderByWithRelationInput | AudioUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioUploads.
     */
    cursor?: AudioUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioUploads.
     */
    skip?: number
    distinct?: AudioUploadScalarFieldEnum | AudioUploadScalarFieldEnum[]
  }

  /**
   * AudioUpload create
   */
  export type AudioUploadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioUpload.
     */
    data: XOR<AudioUploadCreateInput, AudioUploadUncheckedCreateInput>
  }

  /**
   * AudioUpload createMany
   */
  export type AudioUploadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioUploads.
     */
    data: AudioUploadCreateManyInput | AudioUploadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioUpload createManyAndReturn
   */
  export type AudioUploadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AudioUploads.
     */
    data: AudioUploadCreateManyInput | AudioUploadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioUpload update
   */
  export type AudioUploadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioUpload.
     */
    data: XOR<AudioUploadUpdateInput, AudioUploadUncheckedUpdateInput>
    /**
     * Choose, which AudioUpload to update.
     */
    where: AudioUploadWhereUniqueInput
  }

  /**
   * AudioUpload updateMany
   */
  export type AudioUploadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioUploads.
     */
    data: XOR<AudioUploadUpdateManyMutationInput, AudioUploadUncheckedUpdateManyInput>
    /**
     * Filter which AudioUploads to update
     */
    where?: AudioUploadWhereInput
  }

  /**
   * AudioUpload upsert
   */
  export type AudioUploadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioUpload to update in case it exists.
     */
    where: AudioUploadWhereUniqueInput
    /**
     * In case the AudioUpload found by the `where` argument doesn't exist, create a new AudioUpload with this data.
     */
    create: XOR<AudioUploadCreateInput, AudioUploadUncheckedCreateInput>
    /**
     * In case the AudioUpload was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioUploadUpdateInput, AudioUploadUncheckedUpdateInput>
  }

  /**
   * AudioUpload delete
   */
  export type AudioUploadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
    /**
     * Filter which AudioUpload to delete.
     */
    where: AudioUploadWhereUniqueInput
  }

  /**
   * AudioUpload deleteMany
   */
  export type AudioUploadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioUploads to delete
     */
    where?: AudioUploadWhereInput
  }

  /**
   * AudioUpload.processingJobs
   */
  export type AudioUpload$processingJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    where?: ProcessingJobWhereInput
    orderBy?: ProcessingJobOrderByWithRelationInput | ProcessingJobOrderByWithRelationInput[]
    cursor?: ProcessingJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessingJobScalarFieldEnum | ProcessingJobScalarFieldEnum[]
  }

  /**
   * AudioUpload.audioChunks
   */
  export type AudioUpload$audioChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    where?: AudioChunkWhereInput
    orderBy?: AudioChunkOrderByWithRelationInput | AudioChunkOrderByWithRelationInput[]
    cursor?: AudioChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioChunkScalarFieldEnum | AudioChunkScalarFieldEnum[]
  }

  /**
   * AudioUpload.fileStorage
   */
  export type AudioUpload$fileStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    where?: FileStorageWhereInput
  }

  /**
   * AudioUpload without action
   */
  export type AudioUploadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioUpload
     */
    select?: AudioUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioUploadInclude<ExtArgs> | null
  }


  /**
   * Model ProcessingJob
   */

  export type AggregateProcessingJob = {
    _count: ProcessingJobCountAggregateOutputType | null
    _avg: ProcessingJobAvgAggregateOutputType | null
    _sum: ProcessingJobSumAggregateOutputType | null
    _min: ProcessingJobMinAggregateOutputType | null
    _max: ProcessingJobMaxAggregateOutputType | null
  }

  export type ProcessingJobAvgAggregateOutputType = {
    priority: number | null
    progress: number | null
  }

  export type ProcessingJobSumAggregateOutputType = {
    priority: number | null
    progress: number | null
  }

  export type ProcessingJobMinAggregateOutputType = {
    id: string | null
    uploadId: string | null
    jobType: string | null
    status: string | null
    priority: number | null
    progress: number | null
    startedAt: Date | null
    completedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessingJobMaxAggregateOutputType = {
    id: string | null
    uploadId: string | null
    jobType: string | null
    status: string | null
    priority: number | null
    progress: number | null
    startedAt: Date | null
    completedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessingJobCountAggregateOutputType = {
    id: number
    uploadId: number
    jobType: number
    status: number
    priority: number
    progress: number
    startedAt: number
    completedAt: number
    error: number
    result: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProcessingJobAvgAggregateInputType = {
    priority?: true
    progress?: true
  }

  export type ProcessingJobSumAggregateInputType = {
    priority?: true
    progress?: true
  }

  export type ProcessingJobMinAggregateInputType = {
    id?: true
    uploadId?: true
    jobType?: true
    status?: true
    priority?: true
    progress?: true
    startedAt?: true
    completedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessingJobMaxAggregateInputType = {
    id?: true
    uploadId?: true
    jobType?: true
    status?: true
    priority?: true
    progress?: true
    startedAt?: true
    completedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessingJobCountAggregateInputType = {
    id?: true
    uploadId?: true
    jobType?: true
    status?: true
    priority?: true
    progress?: true
    startedAt?: true
    completedAt?: true
    error?: true
    result?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProcessingJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessingJob to aggregate.
     */
    where?: ProcessingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingJobs to fetch.
     */
    orderBy?: ProcessingJobOrderByWithRelationInput | ProcessingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessingJobs
    **/
    _count?: true | ProcessingJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessingJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessingJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessingJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessingJobMaxAggregateInputType
  }

  export type GetProcessingJobAggregateType<T extends ProcessingJobAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessingJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessingJob[P]>
      : GetScalarType<T[P], AggregateProcessingJob[P]>
  }




  export type ProcessingJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessingJobWhereInput
    orderBy?: ProcessingJobOrderByWithAggregationInput | ProcessingJobOrderByWithAggregationInput[]
    by: ProcessingJobScalarFieldEnum[] | ProcessingJobScalarFieldEnum
    having?: ProcessingJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessingJobCountAggregateInputType | true
    _avg?: ProcessingJobAvgAggregateInputType
    _sum?: ProcessingJobSumAggregateInputType
    _min?: ProcessingJobMinAggregateInputType
    _max?: ProcessingJobMaxAggregateInputType
  }

  export type ProcessingJobGroupByOutputType = {
    id: string
    uploadId: string
    jobType: string
    status: string
    priority: number
    progress: number
    startedAt: Date | null
    completedAt: Date | null
    error: string | null
    result: JsonValue | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ProcessingJobCountAggregateOutputType | null
    _avg: ProcessingJobAvgAggregateOutputType | null
    _sum: ProcessingJobSumAggregateOutputType | null
    _min: ProcessingJobMinAggregateOutputType | null
    _max: ProcessingJobMaxAggregateOutputType | null
  }

  type GetProcessingJobGroupByPayload<T extends ProcessingJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessingJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessingJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessingJobGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessingJobGroupByOutputType[P]>
        }
      >
    >


  export type ProcessingJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploadId?: boolean
    jobType?: boolean
    status?: boolean
    priority?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    error?: boolean
    result?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
    audioHistory?: boolean | ProcessingJob$audioHistoryArgs<ExtArgs>
  }, ExtArgs["result"]["processingJob"]>

  export type ProcessingJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploadId?: boolean
    jobType?: boolean
    status?: boolean
    priority?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    error?: boolean
    result?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processingJob"]>

  export type ProcessingJobSelectScalar = {
    id?: boolean
    uploadId?: boolean
    jobType?: boolean
    status?: boolean
    priority?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    error?: boolean
    result?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProcessingJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
    audioHistory?: boolean | ProcessingJob$audioHistoryArgs<ExtArgs>
  }
  export type ProcessingJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }

  export type $ProcessingJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessingJob"
    objects: {
      upload: Prisma.$AudioUploadPayload<ExtArgs>
      audioHistory: Prisma.$AudioHistoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uploadId: string
      jobType: string
      status: string
      priority: number
      progress: number
      startedAt: Date | null
      completedAt: Date | null
      error: string | null
      result: Prisma.JsonValue | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["processingJob"]>
    composites: {}
  }

  type ProcessingJobGetPayload<S extends boolean | null | undefined | ProcessingJobDefaultArgs> = $Result.GetResult<Prisma.$ProcessingJobPayload, S>

  type ProcessingJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessingJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessingJobCountAggregateInputType | true
    }

  export interface ProcessingJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessingJob'], meta: { name: 'ProcessingJob' } }
    /**
     * Find zero or one ProcessingJob that matches the filter.
     * @param {ProcessingJobFindUniqueArgs} args - Arguments to find a ProcessingJob
     * @example
     * // Get one ProcessingJob
     * const processingJob = await prisma.processingJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessingJobFindUniqueArgs>(args: SelectSubset<T, ProcessingJobFindUniqueArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProcessingJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessingJobFindUniqueOrThrowArgs} args - Arguments to find a ProcessingJob
     * @example
     * // Get one ProcessingJob
     * const processingJob = await prisma.processingJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessingJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessingJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProcessingJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobFindFirstArgs} args - Arguments to find a ProcessingJob
     * @example
     * // Get one ProcessingJob
     * const processingJob = await prisma.processingJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessingJobFindFirstArgs>(args?: SelectSubset<T, ProcessingJobFindFirstArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProcessingJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobFindFirstOrThrowArgs} args - Arguments to find a ProcessingJob
     * @example
     * // Get one ProcessingJob
     * const processingJob = await prisma.processingJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessingJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessingJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProcessingJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessingJobs
     * const processingJobs = await prisma.processingJob.findMany()
     * 
     * // Get first 10 ProcessingJobs
     * const processingJobs = await prisma.processingJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processingJobWithIdOnly = await prisma.processingJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessingJobFindManyArgs>(args?: SelectSubset<T, ProcessingJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProcessingJob.
     * @param {ProcessingJobCreateArgs} args - Arguments to create a ProcessingJob.
     * @example
     * // Create one ProcessingJob
     * const ProcessingJob = await prisma.processingJob.create({
     *   data: {
     *     // ... data to create a ProcessingJob
     *   }
     * })
     * 
     */
    create<T extends ProcessingJobCreateArgs>(args: SelectSubset<T, ProcessingJobCreateArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProcessingJobs.
     * @param {ProcessingJobCreateManyArgs} args - Arguments to create many ProcessingJobs.
     * @example
     * // Create many ProcessingJobs
     * const processingJob = await prisma.processingJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessingJobCreateManyArgs>(args?: SelectSubset<T, ProcessingJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessingJobs and returns the data saved in the database.
     * @param {ProcessingJobCreateManyAndReturnArgs} args - Arguments to create many ProcessingJobs.
     * @example
     * // Create many ProcessingJobs
     * const processingJob = await prisma.processingJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessingJobs and only return the `id`
     * const processingJobWithIdOnly = await prisma.processingJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessingJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessingJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProcessingJob.
     * @param {ProcessingJobDeleteArgs} args - Arguments to delete one ProcessingJob.
     * @example
     * // Delete one ProcessingJob
     * const ProcessingJob = await prisma.processingJob.delete({
     *   where: {
     *     // ... filter to delete one ProcessingJob
     *   }
     * })
     * 
     */
    delete<T extends ProcessingJobDeleteArgs>(args: SelectSubset<T, ProcessingJobDeleteArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProcessingJob.
     * @param {ProcessingJobUpdateArgs} args - Arguments to update one ProcessingJob.
     * @example
     * // Update one ProcessingJob
     * const processingJob = await prisma.processingJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessingJobUpdateArgs>(args: SelectSubset<T, ProcessingJobUpdateArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProcessingJobs.
     * @param {ProcessingJobDeleteManyArgs} args - Arguments to filter ProcessingJobs to delete.
     * @example
     * // Delete a few ProcessingJobs
     * const { count } = await prisma.processingJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessingJobDeleteManyArgs>(args?: SelectSubset<T, ProcessingJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessingJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessingJobs
     * const processingJob = await prisma.processingJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessingJobUpdateManyArgs>(args: SelectSubset<T, ProcessingJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessingJob.
     * @param {ProcessingJobUpsertArgs} args - Arguments to update or create a ProcessingJob.
     * @example
     * // Update or create a ProcessingJob
     * const processingJob = await prisma.processingJob.upsert({
     *   create: {
     *     // ... data to create a ProcessingJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessingJob we want to update
     *   }
     * })
     */
    upsert<T extends ProcessingJobUpsertArgs>(args: SelectSubset<T, ProcessingJobUpsertArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProcessingJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobCountArgs} args - Arguments to filter ProcessingJobs to count.
     * @example
     * // Count the number of ProcessingJobs
     * const count = await prisma.processingJob.count({
     *   where: {
     *     // ... the filter for the ProcessingJobs we want to count
     *   }
     * })
    **/
    count<T extends ProcessingJobCountArgs>(
      args?: Subset<T, ProcessingJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessingJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessingJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessingJobAggregateArgs>(args: Subset<T, ProcessingJobAggregateArgs>): Prisma.PrismaPromise<GetProcessingJobAggregateType<T>>

    /**
     * Group by ProcessingJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessingJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessingJobGroupByArgs['orderBy'] }
        : { orderBy?: ProcessingJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessingJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessingJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessingJob model
   */
  readonly fields: ProcessingJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessingJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessingJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    upload<T extends AudioUploadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AudioUploadDefaultArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    audioHistory<T extends ProcessingJob$audioHistoryArgs<ExtArgs> = {}>(args?: Subset<T, ProcessingJob$audioHistoryArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessingJob model
   */ 
  interface ProcessingJobFieldRefs {
    readonly id: FieldRef<"ProcessingJob", 'String'>
    readonly uploadId: FieldRef<"ProcessingJob", 'String'>
    readonly jobType: FieldRef<"ProcessingJob", 'String'>
    readonly status: FieldRef<"ProcessingJob", 'String'>
    readonly priority: FieldRef<"ProcessingJob", 'Int'>
    readonly progress: FieldRef<"ProcessingJob", 'Float'>
    readonly startedAt: FieldRef<"ProcessingJob", 'DateTime'>
    readonly completedAt: FieldRef<"ProcessingJob", 'DateTime'>
    readonly error: FieldRef<"ProcessingJob", 'String'>
    readonly result: FieldRef<"ProcessingJob", 'Json'>
    readonly metadata: FieldRef<"ProcessingJob", 'Json'>
    readonly createdAt: FieldRef<"ProcessingJob", 'DateTime'>
    readonly updatedAt: FieldRef<"ProcessingJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProcessingJob findUnique
   */
  export type ProcessingJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingJob to fetch.
     */
    where: ProcessingJobWhereUniqueInput
  }

  /**
   * ProcessingJob findUniqueOrThrow
   */
  export type ProcessingJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingJob to fetch.
     */
    where: ProcessingJobWhereUniqueInput
  }

  /**
   * ProcessingJob findFirst
   */
  export type ProcessingJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingJob to fetch.
     */
    where?: ProcessingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingJobs to fetch.
     */
    orderBy?: ProcessingJobOrderByWithRelationInput | ProcessingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessingJobs.
     */
    cursor?: ProcessingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessingJobs.
     */
    distinct?: ProcessingJobScalarFieldEnum | ProcessingJobScalarFieldEnum[]
  }

  /**
   * ProcessingJob findFirstOrThrow
   */
  export type ProcessingJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingJob to fetch.
     */
    where?: ProcessingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingJobs to fetch.
     */
    orderBy?: ProcessingJobOrderByWithRelationInput | ProcessingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessingJobs.
     */
    cursor?: ProcessingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessingJobs.
     */
    distinct?: ProcessingJobScalarFieldEnum | ProcessingJobScalarFieldEnum[]
  }

  /**
   * ProcessingJob findMany
   */
  export type ProcessingJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingJobs to fetch.
     */
    where?: ProcessingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingJobs to fetch.
     */
    orderBy?: ProcessingJobOrderByWithRelationInput | ProcessingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessingJobs.
     */
    cursor?: ProcessingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingJobs.
     */
    skip?: number
    distinct?: ProcessingJobScalarFieldEnum | ProcessingJobScalarFieldEnum[]
  }

  /**
   * ProcessingJob create
   */
  export type ProcessingJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessingJob.
     */
    data: XOR<ProcessingJobCreateInput, ProcessingJobUncheckedCreateInput>
  }

  /**
   * ProcessingJob createMany
   */
  export type ProcessingJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessingJobs.
     */
    data: ProcessingJobCreateManyInput | ProcessingJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessingJob createManyAndReturn
   */
  export type ProcessingJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProcessingJobs.
     */
    data: ProcessingJobCreateManyInput | ProcessingJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessingJob update
   */
  export type ProcessingJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessingJob.
     */
    data: XOR<ProcessingJobUpdateInput, ProcessingJobUncheckedUpdateInput>
    /**
     * Choose, which ProcessingJob to update.
     */
    where: ProcessingJobWhereUniqueInput
  }

  /**
   * ProcessingJob updateMany
   */
  export type ProcessingJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessingJobs.
     */
    data: XOR<ProcessingJobUpdateManyMutationInput, ProcessingJobUncheckedUpdateManyInput>
    /**
     * Filter which ProcessingJobs to update
     */
    where?: ProcessingJobWhereInput
  }

  /**
   * ProcessingJob upsert
   */
  export type ProcessingJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessingJob to update in case it exists.
     */
    where: ProcessingJobWhereUniqueInput
    /**
     * In case the ProcessingJob found by the `where` argument doesn't exist, create a new ProcessingJob with this data.
     */
    create: XOR<ProcessingJobCreateInput, ProcessingJobUncheckedCreateInput>
    /**
     * In case the ProcessingJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessingJobUpdateInput, ProcessingJobUncheckedUpdateInput>
  }

  /**
   * ProcessingJob delete
   */
  export type ProcessingJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    /**
     * Filter which ProcessingJob to delete.
     */
    where: ProcessingJobWhereUniqueInput
  }

  /**
   * ProcessingJob deleteMany
   */
  export type ProcessingJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessingJobs to delete
     */
    where?: ProcessingJobWhereInput
  }

  /**
   * ProcessingJob.audioHistory
   */
  export type ProcessingJob$audioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    where?: AudioHistoryWhereInput
  }

  /**
   * ProcessingJob without action
   */
  export type ProcessingJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
  }


  /**
   * Model AudioHistory
   */

  export type AggregateAudioHistory = {
    _count: AudioHistoryCountAggregateOutputType | null
    _avg: AudioHistoryAvgAggregateOutputType | null
    _sum: AudioHistorySumAggregateOutputType | null
    _min: AudioHistoryMinAggregateOutputType | null
    _max: AudioHistoryMaxAggregateOutputType | null
  }

  export type AudioHistoryAvgAggregateOutputType = {
    fileSizeBytes: number | null
    durationSeconds: number | null
    confidence: number | null
    speakers: number | null
  }

  export type AudioHistorySumAggregateOutputType = {
    fileSizeBytes: bigint | null
    durationSeconds: number | null
    confidence: number | null
    speakers: number | null
  }

  export type AudioHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    processingJobId: string | null
    title: string | null
    audioUrl: string | null
    fileSizeBytes: bigint | null
    durationSeconds: number | null
    transcript: string | null
    summary: string | null
    language: string | null
    confidence: number | null
    speakers: number | null
    createdAt: Date | null
  }

  export type AudioHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    processingJobId: string | null
    title: string | null
    audioUrl: string | null
    fileSizeBytes: bigint | null
    durationSeconds: number | null
    transcript: string | null
    summary: string | null
    language: string | null
    confidence: number | null
    speakers: number | null
    createdAt: Date | null
  }

  export type AudioHistoryCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    processingJobId: number
    title: number
    audioUrl: number
    fileSizeBytes: number
    durationSeconds: number
    transcript: number
    summary: number
    keyMoments: number
    processingOptions: number
    language: number
    confidence: number
    speakers: number
    tags: number
    createdAt: number
    _all: number
  }


  export type AudioHistoryAvgAggregateInputType = {
    fileSizeBytes?: true
    durationSeconds?: true
    confidence?: true
    speakers?: true
  }

  export type AudioHistorySumAggregateInputType = {
    fileSizeBytes?: true
    durationSeconds?: true
    confidence?: true
    speakers?: true
  }

  export type AudioHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    processingJobId?: true
    title?: true
    audioUrl?: true
    fileSizeBytes?: true
    durationSeconds?: true
    transcript?: true
    summary?: true
    language?: true
    confidence?: true
    speakers?: true
    createdAt?: true
  }

  export type AudioHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    processingJobId?: true
    title?: true
    audioUrl?: true
    fileSizeBytes?: true
    durationSeconds?: true
    transcript?: true
    summary?: true
    language?: true
    confidence?: true
    speakers?: true
    createdAt?: true
  }

  export type AudioHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    processingJobId?: true
    title?: true
    audioUrl?: true
    fileSizeBytes?: true
    durationSeconds?: true
    transcript?: true
    summary?: true
    keyMoments?: true
    processingOptions?: true
    language?: true
    confidence?: true
    speakers?: true
    tags?: true
    createdAt?: true
    _all?: true
  }

  export type AudioHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioHistory to aggregate.
     */
    where?: AudioHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioHistories to fetch.
     */
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioHistories
    **/
    _count?: true | AudioHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioHistoryMaxAggregateInputType
  }

  export type GetAudioHistoryAggregateType<T extends AudioHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioHistory[P]>
      : GetScalarType<T[P], AggregateAudioHistory[P]>
  }




  export type AudioHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioHistoryWhereInput
    orderBy?: AudioHistoryOrderByWithAggregationInput | AudioHistoryOrderByWithAggregationInput[]
    by: AudioHistoryScalarFieldEnum[] | AudioHistoryScalarFieldEnum
    having?: AudioHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioHistoryCountAggregateInputType | true
    _avg?: AudioHistoryAvgAggregateInputType
    _sum?: AudioHistorySumAggregateInputType
    _min?: AudioHistoryMinAggregateInputType
    _max?: AudioHistoryMaxAggregateInputType
  }

  export type AudioHistoryGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    processingJobId: string | null
    title: string | null
    audioUrl: string | null
    fileSizeBytes: bigint | null
    durationSeconds: number | null
    transcript: string | null
    summary: string | null
    keyMoments: JsonValue | null
    processingOptions: JsonValue | null
    language: string | null
    confidence: number | null
    speakers: number | null
    tags: string[]
    createdAt: Date
    _count: AudioHistoryCountAggregateOutputType | null
    _avg: AudioHistoryAvgAggregateOutputType | null
    _sum: AudioHistorySumAggregateOutputType | null
    _min: AudioHistoryMinAggregateOutputType | null
    _max: AudioHistoryMaxAggregateOutputType | null
  }

  type GetAudioHistoryGroupByPayload<T extends AudioHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AudioHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AudioHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    processingJobId?: boolean
    title?: boolean
    audioUrl?: boolean
    fileSizeBytes?: boolean
    durationSeconds?: boolean
    transcript?: boolean
    summary?: boolean
    keyMoments?: boolean
    processingOptions?: boolean
    language?: boolean
    confidence?: boolean
    speakers?: boolean
    tags?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioHistory$workspaceArgs<ExtArgs>
    processingJob?: boolean | AudioHistory$processingJobArgs<ExtArgs>
    segments?: boolean | AudioHistory$segmentsArgs<ExtArgs>
    _count?: boolean | AudioHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioHistory"]>

  export type AudioHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    processingJobId?: boolean
    title?: boolean
    audioUrl?: boolean
    fileSizeBytes?: boolean
    durationSeconds?: boolean
    transcript?: boolean
    summary?: boolean
    keyMoments?: boolean
    processingOptions?: boolean
    language?: boolean
    confidence?: boolean
    speakers?: boolean
    tags?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioHistory$workspaceArgs<ExtArgs>
    processingJob?: boolean | AudioHistory$processingJobArgs<ExtArgs>
  }, ExtArgs["result"]["audioHistory"]>

  export type AudioHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    processingJobId?: boolean
    title?: boolean
    audioUrl?: boolean
    fileSizeBytes?: boolean
    durationSeconds?: boolean
    transcript?: boolean
    summary?: boolean
    keyMoments?: boolean
    processingOptions?: boolean
    language?: boolean
    confidence?: boolean
    speakers?: boolean
    tags?: boolean
    createdAt?: boolean
  }

  export type AudioHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioHistory$workspaceArgs<ExtArgs>
    processingJob?: boolean | AudioHistory$processingJobArgs<ExtArgs>
    segments?: boolean | AudioHistory$segmentsArgs<ExtArgs>
    _count?: boolean | AudioHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AudioHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | AudioHistory$workspaceArgs<ExtArgs>
    processingJob?: boolean | AudioHistory$processingJobArgs<ExtArgs>
  }

  export type $AudioHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs> | null
      processingJob: Prisma.$ProcessingJobPayload<ExtArgs> | null
      segments: Prisma.$AudioSegmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      processingJobId: string | null
      title: string | null
      audioUrl: string | null
      fileSizeBytes: bigint | null
      durationSeconds: number | null
      transcript: string | null
      summary: string | null
      keyMoments: Prisma.JsonValue | null
      processingOptions: Prisma.JsonValue | null
      language: string | null
      confidence: number | null
      speakers: number | null
      tags: string[]
      createdAt: Date
    }, ExtArgs["result"]["audioHistory"]>
    composites: {}
  }

  type AudioHistoryGetPayload<S extends boolean | null | undefined | AudioHistoryDefaultArgs> = $Result.GetResult<Prisma.$AudioHistoryPayload, S>

  type AudioHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AudioHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AudioHistoryCountAggregateInputType | true
    }

  export interface AudioHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioHistory'], meta: { name: 'AudioHistory' } }
    /**
     * Find zero or one AudioHistory that matches the filter.
     * @param {AudioHistoryFindUniqueArgs} args - Arguments to find a AudioHistory
     * @example
     * // Get one AudioHistory
     * const audioHistory = await prisma.audioHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioHistoryFindUniqueArgs>(args: SelectSubset<T, AudioHistoryFindUniqueArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AudioHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AudioHistoryFindUniqueOrThrowArgs} args - Arguments to find a AudioHistory
     * @example
     * // Get one AudioHistory
     * const audioHistory = await prisma.audioHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AudioHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryFindFirstArgs} args - Arguments to find a AudioHistory
     * @example
     * // Get one AudioHistory
     * const audioHistory = await prisma.audioHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioHistoryFindFirstArgs>(args?: SelectSubset<T, AudioHistoryFindFirstArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AudioHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryFindFirstOrThrowArgs} args - Arguments to find a AudioHistory
     * @example
     * // Get one AudioHistory
     * const audioHistory = await prisma.audioHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AudioHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioHistories
     * const audioHistories = await prisma.audioHistory.findMany()
     * 
     * // Get first 10 AudioHistories
     * const audioHistories = await prisma.audioHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioHistoryWithIdOnly = await prisma.audioHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioHistoryFindManyArgs>(args?: SelectSubset<T, AudioHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AudioHistory.
     * @param {AudioHistoryCreateArgs} args - Arguments to create a AudioHistory.
     * @example
     * // Create one AudioHistory
     * const AudioHistory = await prisma.audioHistory.create({
     *   data: {
     *     // ... data to create a AudioHistory
     *   }
     * })
     * 
     */
    create<T extends AudioHistoryCreateArgs>(args: SelectSubset<T, AudioHistoryCreateArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AudioHistories.
     * @param {AudioHistoryCreateManyArgs} args - Arguments to create many AudioHistories.
     * @example
     * // Create many AudioHistories
     * const audioHistory = await prisma.audioHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioHistoryCreateManyArgs>(args?: SelectSubset<T, AudioHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioHistories and returns the data saved in the database.
     * @param {AudioHistoryCreateManyAndReturnArgs} args - Arguments to create many AudioHistories.
     * @example
     * // Create many AudioHistories
     * const audioHistory = await prisma.audioHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioHistories and only return the `id`
     * const audioHistoryWithIdOnly = await prisma.audioHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AudioHistory.
     * @param {AudioHistoryDeleteArgs} args - Arguments to delete one AudioHistory.
     * @example
     * // Delete one AudioHistory
     * const AudioHistory = await prisma.audioHistory.delete({
     *   where: {
     *     // ... filter to delete one AudioHistory
     *   }
     * })
     * 
     */
    delete<T extends AudioHistoryDeleteArgs>(args: SelectSubset<T, AudioHistoryDeleteArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AudioHistory.
     * @param {AudioHistoryUpdateArgs} args - Arguments to update one AudioHistory.
     * @example
     * // Update one AudioHistory
     * const audioHistory = await prisma.audioHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioHistoryUpdateArgs>(args: SelectSubset<T, AudioHistoryUpdateArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AudioHistories.
     * @param {AudioHistoryDeleteManyArgs} args - Arguments to filter AudioHistories to delete.
     * @example
     * // Delete a few AudioHistories
     * const { count } = await prisma.audioHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioHistoryDeleteManyArgs>(args?: SelectSubset<T, AudioHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioHistories
     * const audioHistory = await prisma.audioHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioHistoryUpdateManyArgs>(args: SelectSubset<T, AudioHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AudioHistory.
     * @param {AudioHistoryUpsertArgs} args - Arguments to update or create a AudioHistory.
     * @example
     * // Update or create a AudioHistory
     * const audioHistory = await prisma.audioHistory.upsert({
     *   create: {
     *     // ... data to create a AudioHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioHistory we want to update
     *   }
     * })
     */
    upsert<T extends AudioHistoryUpsertArgs>(args: SelectSubset<T, AudioHistoryUpsertArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AudioHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryCountArgs} args - Arguments to filter AudioHistories to count.
     * @example
     * // Count the number of AudioHistories
     * const count = await prisma.audioHistory.count({
     *   where: {
     *     // ... the filter for the AudioHistories we want to count
     *   }
     * })
    **/
    count<T extends AudioHistoryCountArgs>(
      args?: Subset<T, AudioHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioHistoryAggregateArgs>(args: Subset<T, AudioHistoryAggregateArgs>): Prisma.PrismaPromise<GetAudioHistoryAggregateType<T>>

    /**
     * Group by AudioHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AudioHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioHistory model
   */
  readonly fields: AudioHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workspace<T extends AudioHistory$workspaceArgs<ExtArgs> = {}>(args?: Subset<T, AudioHistory$workspaceArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    processingJob<T extends AudioHistory$processingJobArgs<ExtArgs> = {}>(args?: Subset<T, AudioHistory$processingJobArgs<ExtArgs>>): Prisma__ProcessingJobClient<$Result.GetResult<Prisma.$ProcessingJobPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    segments<T extends AudioHistory$segmentsArgs<ExtArgs> = {}>(args?: Subset<T, AudioHistory$segmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioHistory model
   */ 
  interface AudioHistoryFieldRefs {
    readonly id: FieldRef<"AudioHistory", 'String'>
    readonly userId: FieldRef<"AudioHistory", 'String'>
    readonly workspaceId: FieldRef<"AudioHistory", 'String'>
    readonly processingJobId: FieldRef<"AudioHistory", 'String'>
    readonly title: FieldRef<"AudioHistory", 'String'>
    readonly audioUrl: FieldRef<"AudioHistory", 'String'>
    readonly fileSizeBytes: FieldRef<"AudioHistory", 'BigInt'>
    readonly durationSeconds: FieldRef<"AudioHistory", 'Int'>
    readonly transcript: FieldRef<"AudioHistory", 'String'>
    readonly summary: FieldRef<"AudioHistory", 'String'>
    readonly keyMoments: FieldRef<"AudioHistory", 'Json'>
    readonly processingOptions: FieldRef<"AudioHistory", 'Json'>
    readonly language: FieldRef<"AudioHistory", 'String'>
    readonly confidence: FieldRef<"AudioHistory", 'Float'>
    readonly speakers: FieldRef<"AudioHistory", 'Int'>
    readonly tags: FieldRef<"AudioHistory", 'String[]'>
    readonly createdAt: FieldRef<"AudioHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioHistory findUnique
   */
  export type AudioHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AudioHistory to fetch.
     */
    where: AudioHistoryWhereUniqueInput
  }

  /**
   * AudioHistory findUniqueOrThrow
   */
  export type AudioHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AudioHistory to fetch.
     */
    where: AudioHistoryWhereUniqueInput
  }

  /**
   * AudioHistory findFirst
   */
  export type AudioHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AudioHistory to fetch.
     */
    where?: AudioHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioHistories to fetch.
     */
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioHistories.
     */
    cursor?: AudioHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioHistories.
     */
    distinct?: AudioHistoryScalarFieldEnum | AudioHistoryScalarFieldEnum[]
  }

  /**
   * AudioHistory findFirstOrThrow
   */
  export type AudioHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AudioHistory to fetch.
     */
    where?: AudioHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioHistories to fetch.
     */
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioHistories.
     */
    cursor?: AudioHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioHistories.
     */
    distinct?: AudioHistoryScalarFieldEnum | AudioHistoryScalarFieldEnum[]
  }

  /**
   * AudioHistory findMany
   */
  export type AudioHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AudioHistories to fetch.
     */
    where?: AudioHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioHistories to fetch.
     */
    orderBy?: AudioHistoryOrderByWithRelationInput | AudioHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioHistories.
     */
    cursor?: AudioHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioHistories.
     */
    skip?: number
    distinct?: AudioHistoryScalarFieldEnum | AudioHistoryScalarFieldEnum[]
  }

  /**
   * AudioHistory create
   */
  export type AudioHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioHistory.
     */
    data: XOR<AudioHistoryCreateInput, AudioHistoryUncheckedCreateInput>
  }

  /**
   * AudioHistory createMany
   */
  export type AudioHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioHistories.
     */
    data: AudioHistoryCreateManyInput | AudioHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioHistory createManyAndReturn
   */
  export type AudioHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AudioHistories.
     */
    data: AudioHistoryCreateManyInput | AudioHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioHistory update
   */
  export type AudioHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioHistory.
     */
    data: XOR<AudioHistoryUpdateInput, AudioHistoryUncheckedUpdateInput>
    /**
     * Choose, which AudioHistory to update.
     */
    where: AudioHistoryWhereUniqueInput
  }

  /**
   * AudioHistory updateMany
   */
  export type AudioHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioHistories.
     */
    data: XOR<AudioHistoryUpdateManyMutationInput, AudioHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AudioHistories to update
     */
    where?: AudioHistoryWhereInput
  }

  /**
   * AudioHistory upsert
   */
  export type AudioHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioHistory to update in case it exists.
     */
    where: AudioHistoryWhereUniqueInput
    /**
     * In case the AudioHistory found by the `where` argument doesn't exist, create a new AudioHistory with this data.
     */
    create: XOR<AudioHistoryCreateInput, AudioHistoryUncheckedCreateInput>
    /**
     * In case the AudioHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioHistoryUpdateInput, AudioHistoryUncheckedUpdateInput>
  }

  /**
   * AudioHistory delete
   */
  export type AudioHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
    /**
     * Filter which AudioHistory to delete.
     */
    where: AudioHistoryWhereUniqueInput
  }

  /**
   * AudioHistory deleteMany
   */
  export type AudioHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioHistories to delete
     */
    where?: AudioHistoryWhereInput
  }

  /**
   * AudioHistory.workspace
   */
  export type AudioHistory$workspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
  }

  /**
   * AudioHistory.processingJob
   */
  export type AudioHistory$processingJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingJob
     */
    select?: ProcessingJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingJobInclude<ExtArgs> | null
    where?: ProcessingJobWhereInput
  }

  /**
   * AudioHistory.segments
   */
  export type AudioHistory$segmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    where?: AudioSegmentWhereInput
    orderBy?: AudioSegmentOrderByWithRelationInput | AudioSegmentOrderByWithRelationInput[]
    cursor?: AudioSegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioSegmentScalarFieldEnum | AudioSegmentScalarFieldEnum[]
  }

  /**
   * AudioHistory without action
   */
  export type AudioHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioHistory
     */
    select?: AudioHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AudioSegment
   */

  export type AggregateAudioSegment = {
    _count: AudioSegmentCountAggregateOutputType | null
    _avg: AudioSegmentAvgAggregateOutputType | null
    _sum: AudioSegmentSumAggregateOutputType | null
    _min: AudioSegmentMinAggregateOutputType | null
    _max: AudioSegmentMaxAggregateOutputType | null
  }

  export type AudioSegmentAvgAggregateOutputType = {
    startTime: number | null
    endTime: number | null
    confidence: number | null
  }

  export type AudioSegmentSumAggregateOutputType = {
    startTime: number | null
    endTime: number | null
    confidence: number | null
  }

  export type AudioSegmentMinAggregateOutputType = {
    id: string | null
    audioHistoryId: string | null
    userId: string | null
    startTime: number | null
    endTime: number | null
    text: string | null
    speaker: string | null
    confidence: number | null
    sentiment: string | null
    createdAt: Date | null
  }

  export type AudioSegmentMaxAggregateOutputType = {
    id: string | null
    audioHistoryId: string | null
    userId: string | null
    startTime: number | null
    endTime: number | null
    text: string | null
    speaker: string | null
    confidence: number | null
    sentiment: string | null
    createdAt: Date | null
  }

  export type AudioSegmentCountAggregateOutputType = {
    id: number
    audioHistoryId: number
    userId: number
    startTime: number
    endTime: number
    text: number
    speaker: number
    confidence: number
    keywords: number
    sentiment: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AudioSegmentAvgAggregateInputType = {
    startTime?: true
    endTime?: true
    confidence?: true
  }

  export type AudioSegmentSumAggregateInputType = {
    startTime?: true
    endTime?: true
    confidence?: true
  }

  export type AudioSegmentMinAggregateInputType = {
    id?: true
    audioHistoryId?: true
    userId?: true
    startTime?: true
    endTime?: true
    text?: true
    speaker?: true
    confidence?: true
    sentiment?: true
    createdAt?: true
  }

  export type AudioSegmentMaxAggregateInputType = {
    id?: true
    audioHistoryId?: true
    userId?: true
    startTime?: true
    endTime?: true
    text?: true
    speaker?: true
    confidence?: true
    sentiment?: true
    createdAt?: true
  }

  export type AudioSegmentCountAggregateInputType = {
    id?: true
    audioHistoryId?: true
    userId?: true
    startTime?: true
    endTime?: true
    text?: true
    speaker?: true
    confidence?: true
    keywords?: true
    sentiment?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AudioSegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioSegment to aggregate.
     */
    where?: AudioSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioSegments to fetch.
     */
    orderBy?: AudioSegmentOrderByWithRelationInput | AudioSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioSegments
    **/
    _count?: true | AudioSegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioSegmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioSegmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioSegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioSegmentMaxAggregateInputType
  }

  export type GetAudioSegmentAggregateType<T extends AudioSegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioSegment[P]>
      : GetScalarType<T[P], AggregateAudioSegment[P]>
  }




  export type AudioSegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioSegmentWhereInput
    orderBy?: AudioSegmentOrderByWithAggregationInput | AudioSegmentOrderByWithAggregationInput[]
    by: AudioSegmentScalarFieldEnum[] | AudioSegmentScalarFieldEnum
    having?: AudioSegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioSegmentCountAggregateInputType | true
    _avg?: AudioSegmentAvgAggregateInputType
    _sum?: AudioSegmentSumAggregateInputType
    _min?: AudioSegmentMinAggregateInputType
    _max?: AudioSegmentMaxAggregateInputType
  }

  export type AudioSegmentGroupByOutputType = {
    id: string
    audioHistoryId: string
    userId: string
    startTime: number
    endTime: number
    text: string
    speaker: string | null
    confidence: number | null
    keywords: string[]
    sentiment: string | null
    metadata: JsonValue
    createdAt: Date
    _count: AudioSegmentCountAggregateOutputType | null
    _avg: AudioSegmentAvgAggregateOutputType | null
    _sum: AudioSegmentSumAggregateOutputType | null
    _min: AudioSegmentMinAggregateOutputType | null
    _max: AudioSegmentMaxAggregateOutputType | null
  }

  type GetAudioSegmentGroupByPayload<T extends AudioSegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioSegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioSegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioSegmentGroupByOutputType[P]>
            : GetScalarType<T[P], AudioSegmentGroupByOutputType[P]>
        }
      >
    >


  export type AudioSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    audioHistoryId?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    text?: boolean
    speaker?: boolean
    confidence?: boolean
    keywords?: boolean
    sentiment?: boolean
    metadata?: boolean
    createdAt?: boolean
    audioHistory?: boolean | AudioHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioSegment"]>

  export type AudioSegmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    audioHistoryId?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    text?: boolean
    speaker?: boolean
    confidence?: boolean
    keywords?: boolean
    sentiment?: boolean
    metadata?: boolean
    createdAt?: boolean
    audioHistory?: boolean | AudioHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioSegment"]>

  export type AudioSegmentSelectScalar = {
    id?: boolean
    audioHistoryId?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    text?: boolean
    speaker?: boolean
    confidence?: boolean
    keywords?: boolean
    sentiment?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AudioSegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audioHistory?: boolean | AudioHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AudioSegmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audioHistory?: boolean | AudioHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AudioSegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioSegment"
    objects: {
      audioHistory: Prisma.$AudioHistoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      audioHistoryId: string
      userId: string
      startTime: number
      endTime: number
      text: string
      speaker: string | null
      confidence: number | null
      keywords: string[]
      sentiment: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["audioSegment"]>
    composites: {}
  }

  type AudioSegmentGetPayload<S extends boolean | null | undefined | AudioSegmentDefaultArgs> = $Result.GetResult<Prisma.$AudioSegmentPayload, S>

  type AudioSegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AudioSegmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AudioSegmentCountAggregateInputType | true
    }

  export interface AudioSegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioSegment'], meta: { name: 'AudioSegment' } }
    /**
     * Find zero or one AudioSegment that matches the filter.
     * @param {AudioSegmentFindUniqueArgs} args - Arguments to find a AudioSegment
     * @example
     * // Get one AudioSegment
     * const audioSegment = await prisma.audioSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioSegmentFindUniqueArgs>(args: SelectSubset<T, AudioSegmentFindUniqueArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AudioSegment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AudioSegmentFindUniqueOrThrowArgs} args - Arguments to find a AudioSegment
     * @example
     * // Get one AudioSegment
     * const audioSegment = await prisma.audioSegment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioSegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioSegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AudioSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentFindFirstArgs} args - Arguments to find a AudioSegment
     * @example
     * // Get one AudioSegment
     * const audioSegment = await prisma.audioSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioSegmentFindFirstArgs>(args?: SelectSubset<T, AudioSegmentFindFirstArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AudioSegment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentFindFirstOrThrowArgs} args - Arguments to find a AudioSegment
     * @example
     * // Get one AudioSegment
     * const audioSegment = await prisma.audioSegment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioSegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioSegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AudioSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioSegments
     * const audioSegments = await prisma.audioSegment.findMany()
     * 
     * // Get first 10 AudioSegments
     * const audioSegments = await prisma.audioSegment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioSegmentWithIdOnly = await prisma.audioSegment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioSegmentFindManyArgs>(args?: SelectSubset<T, AudioSegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AudioSegment.
     * @param {AudioSegmentCreateArgs} args - Arguments to create a AudioSegment.
     * @example
     * // Create one AudioSegment
     * const AudioSegment = await prisma.audioSegment.create({
     *   data: {
     *     // ... data to create a AudioSegment
     *   }
     * })
     * 
     */
    create<T extends AudioSegmentCreateArgs>(args: SelectSubset<T, AudioSegmentCreateArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AudioSegments.
     * @param {AudioSegmentCreateManyArgs} args - Arguments to create many AudioSegments.
     * @example
     * // Create many AudioSegments
     * const audioSegment = await prisma.audioSegment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioSegmentCreateManyArgs>(args?: SelectSubset<T, AudioSegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioSegments and returns the data saved in the database.
     * @param {AudioSegmentCreateManyAndReturnArgs} args - Arguments to create many AudioSegments.
     * @example
     * // Create many AudioSegments
     * const audioSegment = await prisma.audioSegment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioSegments and only return the `id`
     * const audioSegmentWithIdOnly = await prisma.audioSegment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioSegmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioSegmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AudioSegment.
     * @param {AudioSegmentDeleteArgs} args - Arguments to delete one AudioSegment.
     * @example
     * // Delete one AudioSegment
     * const AudioSegment = await prisma.audioSegment.delete({
     *   where: {
     *     // ... filter to delete one AudioSegment
     *   }
     * })
     * 
     */
    delete<T extends AudioSegmentDeleteArgs>(args: SelectSubset<T, AudioSegmentDeleteArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AudioSegment.
     * @param {AudioSegmentUpdateArgs} args - Arguments to update one AudioSegment.
     * @example
     * // Update one AudioSegment
     * const audioSegment = await prisma.audioSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioSegmentUpdateArgs>(args: SelectSubset<T, AudioSegmentUpdateArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AudioSegments.
     * @param {AudioSegmentDeleteManyArgs} args - Arguments to filter AudioSegments to delete.
     * @example
     * // Delete a few AudioSegments
     * const { count } = await prisma.audioSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioSegmentDeleteManyArgs>(args?: SelectSubset<T, AudioSegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioSegments
     * const audioSegment = await prisma.audioSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioSegmentUpdateManyArgs>(args: SelectSubset<T, AudioSegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AudioSegment.
     * @param {AudioSegmentUpsertArgs} args - Arguments to update or create a AudioSegment.
     * @example
     * // Update or create a AudioSegment
     * const audioSegment = await prisma.audioSegment.upsert({
     *   create: {
     *     // ... data to create a AudioSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioSegment we want to update
     *   }
     * })
     */
    upsert<T extends AudioSegmentUpsertArgs>(args: SelectSubset<T, AudioSegmentUpsertArgs<ExtArgs>>): Prisma__AudioSegmentClient<$Result.GetResult<Prisma.$AudioSegmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AudioSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentCountArgs} args - Arguments to filter AudioSegments to count.
     * @example
     * // Count the number of AudioSegments
     * const count = await prisma.audioSegment.count({
     *   where: {
     *     // ... the filter for the AudioSegments we want to count
     *   }
     * })
    **/
    count<T extends AudioSegmentCountArgs>(
      args?: Subset<T, AudioSegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioSegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioSegmentAggregateArgs>(args: Subset<T, AudioSegmentAggregateArgs>): Prisma.PrismaPromise<GetAudioSegmentAggregateType<T>>

    /**
     * Group by AudioSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioSegmentGroupByArgs['orderBy'] }
        : { orderBy?: AudioSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioSegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioSegment model
   */
  readonly fields: AudioSegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioSegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audioHistory<T extends AudioHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AudioHistoryDefaultArgs<ExtArgs>>): Prisma__AudioHistoryClient<$Result.GetResult<Prisma.$AudioHistoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioSegment model
   */ 
  interface AudioSegmentFieldRefs {
    readonly id: FieldRef<"AudioSegment", 'String'>
    readonly audioHistoryId: FieldRef<"AudioSegment", 'String'>
    readonly userId: FieldRef<"AudioSegment", 'String'>
    readonly startTime: FieldRef<"AudioSegment", 'Float'>
    readonly endTime: FieldRef<"AudioSegment", 'Float'>
    readonly text: FieldRef<"AudioSegment", 'String'>
    readonly speaker: FieldRef<"AudioSegment", 'String'>
    readonly confidence: FieldRef<"AudioSegment", 'Float'>
    readonly keywords: FieldRef<"AudioSegment", 'String[]'>
    readonly sentiment: FieldRef<"AudioSegment", 'String'>
    readonly metadata: FieldRef<"AudioSegment", 'Json'>
    readonly createdAt: FieldRef<"AudioSegment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioSegment findUnique
   */
  export type AudioSegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudioSegment to fetch.
     */
    where: AudioSegmentWhereUniqueInput
  }

  /**
   * AudioSegment findUniqueOrThrow
   */
  export type AudioSegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudioSegment to fetch.
     */
    where: AudioSegmentWhereUniqueInput
  }

  /**
   * AudioSegment findFirst
   */
  export type AudioSegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudioSegment to fetch.
     */
    where?: AudioSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioSegments to fetch.
     */
    orderBy?: AudioSegmentOrderByWithRelationInput | AudioSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioSegments.
     */
    cursor?: AudioSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioSegments.
     */
    distinct?: AudioSegmentScalarFieldEnum | AudioSegmentScalarFieldEnum[]
  }

  /**
   * AudioSegment findFirstOrThrow
   */
  export type AudioSegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudioSegment to fetch.
     */
    where?: AudioSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioSegments to fetch.
     */
    orderBy?: AudioSegmentOrderByWithRelationInput | AudioSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioSegments.
     */
    cursor?: AudioSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioSegments.
     */
    distinct?: AudioSegmentScalarFieldEnum | AudioSegmentScalarFieldEnum[]
  }

  /**
   * AudioSegment findMany
   */
  export type AudioSegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudioSegments to fetch.
     */
    where?: AudioSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioSegments to fetch.
     */
    orderBy?: AudioSegmentOrderByWithRelationInput | AudioSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioSegments.
     */
    cursor?: AudioSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioSegments.
     */
    skip?: number
    distinct?: AudioSegmentScalarFieldEnum | AudioSegmentScalarFieldEnum[]
  }

  /**
   * AudioSegment create
   */
  export type AudioSegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioSegment.
     */
    data: XOR<AudioSegmentCreateInput, AudioSegmentUncheckedCreateInput>
  }

  /**
   * AudioSegment createMany
   */
  export type AudioSegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioSegments.
     */
    data: AudioSegmentCreateManyInput | AudioSegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioSegment createManyAndReturn
   */
  export type AudioSegmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AudioSegments.
     */
    data: AudioSegmentCreateManyInput | AudioSegmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioSegment update
   */
  export type AudioSegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioSegment.
     */
    data: XOR<AudioSegmentUpdateInput, AudioSegmentUncheckedUpdateInput>
    /**
     * Choose, which AudioSegment to update.
     */
    where: AudioSegmentWhereUniqueInput
  }

  /**
   * AudioSegment updateMany
   */
  export type AudioSegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioSegments.
     */
    data: XOR<AudioSegmentUpdateManyMutationInput, AudioSegmentUncheckedUpdateManyInput>
    /**
     * Filter which AudioSegments to update
     */
    where?: AudioSegmentWhereInput
  }

  /**
   * AudioSegment upsert
   */
  export type AudioSegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioSegment to update in case it exists.
     */
    where: AudioSegmentWhereUniqueInput
    /**
     * In case the AudioSegment found by the `where` argument doesn't exist, create a new AudioSegment with this data.
     */
    create: XOR<AudioSegmentCreateInput, AudioSegmentUncheckedCreateInput>
    /**
     * In case the AudioSegment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioSegmentUpdateInput, AudioSegmentUncheckedUpdateInput>
  }

  /**
   * AudioSegment delete
   */
  export type AudioSegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
    /**
     * Filter which AudioSegment to delete.
     */
    where: AudioSegmentWhereUniqueInput
  }

  /**
   * AudioSegment deleteMany
   */
  export type AudioSegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioSegments to delete
     */
    where?: AudioSegmentWhereInput
  }

  /**
   * AudioSegment without action
   */
  export type AudioSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioSegment
     */
    select?: AudioSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioSegmentInclude<ExtArgs> | null
  }


  /**
   * Model AudioChunk
   */

  export type AggregateAudioChunk = {
    _count: AudioChunkCountAggregateOutputType | null
    _avg: AudioChunkAvgAggregateOutputType | null
    _sum: AudioChunkSumAggregateOutputType | null
    _min: AudioChunkMinAggregateOutputType | null
    _max: AudioChunkMaxAggregateOutputType | null
  }

  export type AudioChunkAvgAggregateOutputType = {
    chunkIndex: number | null
    startByte: number | null
    endByte: number | null
    size: number | null
  }

  export type AudioChunkSumAggregateOutputType = {
    chunkIndex: number | null
    startByte: bigint | null
    endByte: bigint | null
    size: bigint | null
  }

  export type AudioChunkMinAggregateOutputType = {
    id: string | null
    uploadId: string | null
    chunkIndex: number | null
    startByte: bigint | null
    endByte: bigint | null
    size: bigint | null
    storageKey: string | null
    checksum: string | null
    uploadedAt: Date | null
    createdAt: Date | null
  }

  export type AudioChunkMaxAggregateOutputType = {
    id: string | null
    uploadId: string | null
    chunkIndex: number | null
    startByte: bigint | null
    endByte: bigint | null
    size: bigint | null
    storageKey: string | null
    checksum: string | null
    uploadedAt: Date | null
    createdAt: Date | null
  }

  export type AudioChunkCountAggregateOutputType = {
    id: number
    uploadId: number
    chunkIndex: number
    startByte: number
    endByte: number
    size: number
    storageKey: number
    checksum: number
    uploadedAt: number
    createdAt: number
    _all: number
  }


  export type AudioChunkAvgAggregateInputType = {
    chunkIndex?: true
    startByte?: true
    endByte?: true
    size?: true
  }

  export type AudioChunkSumAggregateInputType = {
    chunkIndex?: true
    startByte?: true
    endByte?: true
    size?: true
  }

  export type AudioChunkMinAggregateInputType = {
    id?: true
    uploadId?: true
    chunkIndex?: true
    startByte?: true
    endByte?: true
    size?: true
    storageKey?: true
    checksum?: true
    uploadedAt?: true
    createdAt?: true
  }

  export type AudioChunkMaxAggregateInputType = {
    id?: true
    uploadId?: true
    chunkIndex?: true
    startByte?: true
    endByte?: true
    size?: true
    storageKey?: true
    checksum?: true
    uploadedAt?: true
    createdAt?: true
  }

  export type AudioChunkCountAggregateInputType = {
    id?: true
    uploadId?: true
    chunkIndex?: true
    startByte?: true
    endByte?: true
    size?: true
    storageKey?: true
    checksum?: true
    uploadedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AudioChunkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioChunk to aggregate.
     */
    where?: AudioChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioChunks to fetch.
     */
    orderBy?: AudioChunkOrderByWithRelationInput | AudioChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioChunks
    **/
    _count?: true | AudioChunkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioChunkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioChunkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioChunkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioChunkMaxAggregateInputType
  }

  export type GetAudioChunkAggregateType<T extends AudioChunkAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioChunk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioChunk[P]>
      : GetScalarType<T[P], AggregateAudioChunk[P]>
  }




  export type AudioChunkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioChunkWhereInput
    orderBy?: AudioChunkOrderByWithAggregationInput | AudioChunkOrderByWithAggregationInput[]
    by: AudioChunkScalarFieldEnum[] | AudioChunkScalarFieldEnum
    having?: AudioChunkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioChunkCountAggregateInputType | true
    _avg?: AudioChunkAvgAggregateInputType
    _sum?: AudioChunkSumAggregateInputType
    _min?: AudioChunkMinAggregateInputType
    _max?: AudioChunkMaxAggregateInputType
  }

  export type AudioChunkGroupByOutputType = {
    id: string
    uploadId: string
    chunkIndex: number
    startByte: bigint
    endByte: bigint
    size: bigint
    storageKey: string
    checksum: string
    uploadedAt: Date | null
    createdAt: Date
    _count: AudioChunkCountAggregateOutputType | null
    _avg: AudioChunkAvgAggregateOutputType | null
    _sum: AudioChunkSumAggregateOutputType | null
    _min: AudioChunkMinAggregateOutputType | null
    _max: AudioChunkMaxAggregateOutputType | null
  }

  type GetAudioChunkGroupByPayload<T extends AudioChunkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioChunkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioChunkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioChunkGroupByOutputType[P]>
            : GetScalarType<T[P], AudioChunkGroupByOutputType[P]>
        }
      >
    >


  export type AudioChunkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploadId?: boolean
    chunkIndex?: boolean
    startByte?: boolean
    endByte?: boolean
    size?: boolean
    storageKey?: boolean
    checksum?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioChunk"]>

  export type AudioChunkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploadId?: boolean
    chunkIndex?: boolean
    startByte?: boolean
    endByte?: boolean
    size?: boolean
    storageKey?: boolean
    checksum?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioChunk"]>

  export type AudioChunkSelectScalar = {
    id?: boolean
    uploadId?: boolean
    chunkIndex?: boolean
    startByte?: boolean
    endByte?: boolean
    size?: boolean
    storageKey?: boolean
    checksum?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
  }

  export type AudioChunkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }
  export type AudioChunkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }

  export type $AudioChunkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioChunk"
    objects: {
      upload: Prisma.$AudioUploadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uploadId: string
      chunkIndex: number
      startByte: bigint
      endByte: bigint
      size: bigint
      storageKey: string
      checksum: string
      uploadedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["audioChunk"]>
    composites: {}
  }

  type AudioChunkGetPayload<S extends boolean | null | undefined | AudioChunkDefaultArgs> = $Result.GetResult<Prisma.$AudioChunkPayload, S>

  type AudioChunkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AudioChunkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AudioChunkCountAggregateInputType | true
    }

  export interface AudioChunkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioChunk'], meta: { name: 'AudioChunk' } }
    /**
     * Find zero or one AudioChunk that matches the filter.
     * @param {AudioChunkFindUniqueArgs} args - Arguments to find a AudioChunk
     * @example
     * // Get one AudioChunk
     * const audioChunk = await prisma.audioChunk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioChunkFindUniqueArgs>(args: SelectSubset<T, AudioChunkFindUniqueArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AudioChunk that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AudioChunkFindUniqueOrThrowArgs} args - Arguments to find a AudioChunk
     * @example
     * // Get one AudioChunk
     * const audioChunk = await prisma.audioChunk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioChunkFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioChunkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AudioChunk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkFindFirstArgs} args - Arguments to find a AudioChunk
     * @example
     * // Get one AudioChunk
     * const audioChunk = await prisma.audioChunk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioChunkFindFirstArgs>(args?: SelectSubset<T, AudioChunkFindFirstArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AudioChunk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkFindFirstOrThrowArgs} args - Arguments to find a AudioChunk
     * @example
     * // Get one AudioChunk
     * const audioChunk = await prisma.audioChunk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioChunkFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioChunkFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AudioChunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioChunks
     * const audioChunks = await prisma.audioChunk.findMany()
     * 
     * // Get first 10 AudioChunks
     * const audioChunks = await prisma.audioChunk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioChunkWithIdOnly = await prisma.audioChunk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioChunkFindManyArgs>(args?: SelectSubset<T, AudioChunkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AudioChunk.
     * @param {AudioChunkCreateArgs} args - Arguments to create a AudioChunk.
     * @example
     * // Create one AudioChunk
     * const AudioChunk = await prisma.audioChunk.create({
     *   data: {
     *     // ... data to create a AudioChunk
     *   }
     * })
     * 
     */
    create<T extends AudioChunkCreateArgs>(args: SelectSubset<T, AudioChunkCreateArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AudioChunks.
     * @param {AudioChunkCreateManyArgs} args - Arguments to create many AudioChunks.
     * @example
     * // Create many AudioChunks
     * const audioChunk = await prisma.audioChunk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioChunkCreateManyArgs>(args?: SelectSubset<T, AudioChunkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioChunks and returns the data saved in the database.
     * @param {AudioChunkCreateManyAndReturnArgs} args - Arguments to create many AudioChunks.
     * @example
     * // Create many AudioChunks
     * const audioChunk = await prisma.audioChunk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioChunks and only return the `id`
     * const audioChunkWithIdOnly = await prisma.audioChunk.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioChunkCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioChunkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AudioChunk.
     * @param {AudioChunkDeleteArgs} args - Arguments to delete one AudioChunk.
     * @example
     * // Delete one AudioChunk
     * const AudioChunk = await prisma.audioChunk.delete({
     *   where: {
     *     // ... filter to delete one AudioChunk
     *   }
     * })
     * 
     */
    delete<T extends AudioChunkDeleteArgs>(args: SelectSubset<T, AudioChunkDeleteArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AudioChunk.
     * @param {AudioChunkUpdateArgs} args - Arguments to update one AudioChunk.
     * @example
     * // Update one AudioChunk
     * const audioChunk = await prisma.audioChunk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioChunkUpdateArgs>(args: SelectSubset<T, AudioChunkUpdateArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AudioChunks.
     * @param {AudioChunkDeleteManyArgs} args - Arguments to filter AudioChunks to delete.
     * @example
     * // Delete a few AudioChunks
     * const { count } = await prisma.audioChunk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioChunkDeleteManyArgs>(args?: SelectSubset<T, AudioChunkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioChunks
     * const audioChunk = await prisma.audioChunk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioChunkUpdateManyArgs>(args: SelectSubset<T, AudioChunkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AudioChunk.
     * @param {AudioChunkUpsertArgs} args - Arguments to update or create a AudioChunk.
     * @example
     * // Update or create a AudioChunk
     * const audioChunk = await prisma.audioChunk.upsert({
     *   create: {
     *     // ... data to create a AudioChunk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioChunk we want to update
     *   }
     * })
     */
    upsert<T extends AudioChunkUpsertArgs>(args: SelectSubset<T, AudioChunkUpsertArgs<ExtArgs>>): Prisma__AudioChunkClient<$Result.GetResult<Prisma.$AudioChunkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AudioChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkCountArgs} args - Arguments to filter AudioChunks to count.
     * @example
     * // Count the number of AudioChunks
     * const count = await prisma.audioChunk.count({
     *   where: {
     *     // ... the filter for the AudioChunks we want to count
     *   }
     * })
    **/
    count<T extends AudioChunkCountArgs>(
      args?: Subset<T, AudioChunkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioChunkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioChunkAggregateArgs>(args: Subset<T, AudioChunkAggregateArgs>): Prisma.PrismaPromise<GetAudioChunkAggregateType<T>>

    /**
     * Group by AudioChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChunkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioChunkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioChunkGroupByArgs['orderBy'] }
        : { orderBy?: AudioChunkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioChunkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioChunkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioChunk model
   */
  readonly fields: AudioChunkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioChunk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioChunkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    upload<T extends AudioUploadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AudioUploadDefaultArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioChunk model
   */ 
  interface AudioChunkFieldRefs {
    readonly id: FieldRef<"AudioChunk", 'String'>
    readonly uploadId: FieldRef<"AudioChunk", 'String'>
    readonly chunkIndex: FieldRef<"AudioChunk", 'Int'>
    readonly startByte: FieldRef<"AudioChunk", 'BigInt'>
    readonly endByte: FieldRef<"AudioChunk", 'BigInt'>
    readonly size: FieldRef<"AudioChunk", 'BigInt'>
    readonly storageKey: FieldRef<"AudioChunk", 'String'>
    readonly checksum: FieldRef<"AudioChunk", 'String'>
    readonly uploadedAt: FieldRef<"AudioChunk", 'DateTime'>
    readonly createdAt: FieldRef<"AudioChunk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioChunk findUnique
   */
  export type AudioChunkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * Filter, which AudioChunk to fetch.
     */
    where: AudioChunkWhereUniqueInput
  }

  /**
   * AudioChunk findUniqueOrThrow
   */
  export type AudioChunkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * Filter, which AudioChunk to fetch.
     */
    where: AudioChunkWhereUniqueInput
  }

  /**
   * AudioChunk findFirst
   */
  export type AudioChunkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * Filter, which AudioChunk to fetch.
     */
    where?: AudioChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioChunks to fetch.
     */
    orderBy?: AudioChunkOrderByWithRelationInput | AudioChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioChunks.
     */
    cursor?: AudioChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioChunks.
     */
    distinct?: AudioChunkScalarFieldEnum | AudioChunkScalarFieldEnum[]
  }

  /**
   * AudioChunk findFirstOrThrow
   */
  export type AudioChunkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * Filter, which AudioChunk to fetch.
     */
    where?: AudioChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioChunks to fetch.
     */
    orderBy?: AudioChunkOrderByWithRelationInput | AudioChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioChunks.
     */
    cursor?: AudioChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioChunks.
     */
    distinct?: AudioChunkScalarFieldEnum | AudioChunkScalarFieldEnum[]
  }

  /**
   * AudioChunk findMany
   */
  export type AudioChunkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * Filter, which AudioChunks to fetch.
     */
    where?: AudioChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioChunks to fetch.
     */
    orderBy?: AudioChunkOrderByWithRelationInput | AudioChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioChunks.
     */
    cursor?: AudioChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioChunks.
     */
    skip?: number
    distinct?: AudioChunkScalarFieldEnum | AudioChunkScalarFieldEnum[]
  }

  /**
   * AudioChunk create
   */
  export type AudioChunkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioChunk.
     */
    data: XOR<AudioChunkCreateInput, AudioChunkUncheckedCreateInput>
  }

  /**
   * AudioChunk createMany
   */
  export type AudioChunkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioChunks.
     */
    data: AudioChunkCreateManyInput | AudioChunkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioChunk createManyAndReturn
   */
  export type AudioChunkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AudioChunks.
     */
    data: AudioChunkCreateManyInput | AudioChunkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioChunk update
   */
  export type AudioChunkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioChunk.
     */
    data: XOR<AudioChunkUpdateInput, AudioChunkUncheckedUpdateInput>
    /**
     * Choose, which AudioChunk to update.
     */
    where: AudioChunkWhereUniqueInput
  }

  /**
   * AudioChunk updateMany
   */
  export type AudioChunkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioChunks.
     */
    data: XOR<AudioChunkUpdateManyMutationInput, AudioChunkUncheckedUpdateManyInput>
    /**
     * Filter which AudioChunks to update
     */
    where?: AudioChunkWhereInput
  }

  /**
   * AudioChunk upsert
   */
  export type AudioChunkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioChunk to update in case it exists.
     */
    where: AudioChunkWhereUniqueInput
    /**
     * In case the AudioChunk found by the `where` argument doesn't exist, create a new AudioChunk with this data.
     */
    create: XOR<AudioChunkCreateInput, AudioChunkUncheckedCreateInput>
    /**
     * In case the AudioChunk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioChunkUpdateInput, AudioChunkUncheckedUpdateInput>
  }

  /**
   * AudioChunk delete
   */
  export type AudioChunkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
    /**
     * Filter which AudioChunk to delete.
     */
    where: AudioChunkWhereUniqueInput
  }

  /**
   * AudioChunk deleteMany
   */
  export type AudioChunkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioChunks to delete
     */
    where?: AudioChunkWhereInput
  }

  /**
   * AudioChunk without action
   */
  export type AudioChunkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChunk
     */
    select?: AudioChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChunkInclude<ExtArgs> | null
  }


  /**
   * Model StorageProvider
   */

  export type AggregateStorageProvider = {
    _count: StorageProviderCountAggregateOutputType | null
    _min: StorageProviderMinAggregateOutputType | null
    _max: StorageProviderMaxAggregateOutputType | null
  }

  export type StorageProviderMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    endpoint: string | null
    region: string | null
    bucket: string | null
    cdnEndpoint: string | null
    isActive: boolean | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorageProviderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    endpoint: string | null
    region: string | null
    bucket: string | null
    cdnEndpoint: string | null
    isActive: boolean | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorageProviderCountAggregateOutputType = {
    id: number
    name: number
    type: number
    endpoint: number
    region: number
    bucket: number
    cdnEndpoint: number
    isActive: number
    isDefault: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StorageProviderMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    endpoint?: true
    region?: true
    bucket?: true
    cdnEndpoint?: true
    isActive?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorageProviderMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    endpoint?: true
    region?: true
    bucket?: true
    cdnEndpoint?: true
    isActive?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorageProviderCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    endpoint?: true
    region?: true
    bucket?: true
    cdnEndpoint?: true
    isActive?: true
    isDefault?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StorageProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageProvider to aggregate.
     */
    where?: StorageProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageProviders to fetch.
     */
    orderBy?: StorageProviderOrderByWithRelationInput | StorageProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorageProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorageProviders
    **/
    _count?: true | StorageProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageProviderMaxAggregateInputType
  }

  export type GetStorageProviderAggregateType<T extends StorageProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateStorageProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorageProvider[P]>
      : GetScalarType<T[P], AggregateStorageProvider[P]>
  }




  export type StorageProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageProviderWhereInput
    orderBy?: StorageProviderOrderByWithAggregationInput | StorageProviderOrderByWithAggregationInput[]
    by: StorageProviderScalarFieldEnum[] | StorageProviderScalarFieldEnum
    having?: StorageProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageProviderCountAggregateInputType | true
    _min?: StorageProviderMinAggregateInputType
    _max?: StorageProviderMaxAggregateInputType
  }

  export type StorageProviderGroupByOutputType = {
    id: string
    name: string
    type: string
    endpoint: string | null
    region: string | null
    bucket: string | null
    cdnEndpoint: string | null
    isActive: boolean
    isDefault: boolean
    config: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: StorageProviderCountAggregateOutputType | null
    _min: StorageProviderMinAggregateOutputType | null
    _max: StorageProviderMaxAggregateOutputType | null
  }

  type GetStorageProviderGroupByPayload<T extends StorageProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorageProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageProviderGroupByOutputType[P]>
            : GetScalarType<T[P], StorageProviderGroupByOutputType[P]>
        }
      >
    >


  export type StorageProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    endpoint?: boolean
    region?: boolean
    bucket?: boolean
    cdnEndpoint?: boolean
    isActive?: boolean
    isDefault?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    files?: boolean | StorageProvider$filesArgs<ExtArgs>
    _count?: boolean | StorageProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storageProvider"]>

  export type StorageProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    endpoint?: boolean
    region?: boolean
    bucket?: boolean
    cdnEndpoint?: boolean
    isActive?: boolean
    isDefault?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["storageProvider"]>

  export type StorageProviderSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    endpoint?: boolean
    region?: boolean
    bucket?: boolean
    cdnEndpoint?: boolean
    isActive?: boolean
    isDefault?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StorageProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | StorageProvider$filesArgs<ExtArgs>
    _count?: boolean | StorageProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StorageProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StorageProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorageProvider"
    objects: {
      files: Prisma.$FileStoragePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      endpoint: string | null
      region: string | null
      bucket: string | null
      cdnEndpoint: string | null
      isActive: boolean
      isDefault: boolean
      config: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storageProvider"]>
    composites: {}
  }

  type StorageProviderGetPayload<S extends boolean | null | undefined | StorageProviderDefaultArgs> = $Result.GetResult<Prisma.$StorageProviderPayload, S>

  type StorageProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorageProviderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StorageProviderCountAggregateInputType | true
    }

  export interface StorageProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorageProvider'], meta: { name: 'StorageProvider' } }
    /**
     * Find zero or one StorageProvider that matches the filter.
     * @param {StorageProviderFindUniqueArgs} args - Arguments to find a StorageProvider
     * @example
     * // Get one StorageProvider
     * const storageProvider = await prisma.storageProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorageProviderFindUniqueArgs>(args: SelectSubset<T, StorageProviderFindUniqueArgs<ExtArgs>>): Prisma__StorageProviderClient<$Result.GetResult<Prisma.$StorageProviderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StorageProvider that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StorageProviderFindUniqueOrThrowArgs} args - Arguments to find a StorageProvider
     * @example
     * // Get one StorageProvider
     * const storageProvider = await prisma.storageProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorageProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, StorageProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorageProviderClient<$Result.GetResult<Prisma.$StorageProviderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StorageProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageProviderFindFirstArgs} args - Arguments to find a StorageProvider
     * @example
     * // Get one StorageProvider
     * const storageProvider = await prisma.storageProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorageProviderFindFirstArgs>(args?: SelectSubset<T, StorageProviderFindFirstArgs<ExtArgs>>): Prisma__StorageProviderClient<$Result.GetResult<Prisma.$StorageProviderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StorageProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageProviderFindFirstOrThrowArgs} args - Arguments to find a StorageProvider
     * @example
     * // Get one StorageProvider
     * const storageProvider = await prisma.storageProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorageProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, StorageProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorageProviderClient<$Result.GetResult<Prisma.$StorageProviderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StorageProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorageProviders
     * const storageProviders = await prisma.storageProvider.findMany()
     * 
     * // Get first 10 StorageProviders
     * const storageProviders = await prisma.storageProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storageProviderWithIdOnly = await prisma.storageProvider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorageProviderFindManyArgs>(args?: SelectSubset<T, StorageProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageProviderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StorageProvider.
     * @param {StorageProviderCreateArgs} args - Arguments to create a StorageProvider.
     * @example
     * // Create one StorageProvider
     * const StorageProvider = await prisma.storageProvider.create({
     *   data: {
     *     // ... data to create a StorageProvider
     *   }
     * })
     * 
     */
    create<T extends StorageProviderCreateArgs>(args: SelectSubset<T, StorageProviderCreateArgs<ExtArgs>>): Prisma__StorageProviderClient<$Result.GetResult<Prisma.$StorageProviderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StorageProviders.
     * @param {StorageProviderCreateManyArgs} args - Arguments to create many StorageProviders.
     * @example
     * // Create many StorageProviders
     * const storageProvider = await prisma.storageProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorageProviderCreateManyArgs>(args?: SelectSubset<T, StorageProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StorageProviders and returns the data saved in the database.
     * @param {StorageProviderCreateManyAndReturnArgs} args - Arguments to create many StorageProviders.
     * @example
     * // Create many StorageProviders
     * const storageProvider = await prisma.storageProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StorageProviders and only return the `id`
     * const storageProviderWithIdOnly = await prisma.storageProvider.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StorageProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, StorageProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageProviderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StorageProvider.
     * @param {StorageProviderDeleteArgs} args - Arguments to delete one StorageProvider.
     * @example
     * // Delete one StorageProvider
     * const StorageProvider = await prisma.storageProvider.delete({
     *   where: {
     *     // ... filter to delete one StorageProvider
     *   }
     * })
     * 
     */
    delete<T extends StorageProviderDeleteArgs>(args: SelectSubset<T, StorageProviderDeleteArgs<ExtArgs>>): Prisma__StorageProviderClient<$Result.GetResult<Prisma.$StorageProviderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StorageProvider.
     * @param {StorageProviderUpdateArgs} args - Arguments to update one StorageProvider.
     * @example
     * // Update one StorageProvider
     * const storageProvider = await prisma.storageProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorageProviderUpdateArgs>(args: SelectSubset<T, StorageProviderUpdateArgs<ExtArgs>>): Prisma__StorageProviderClient<$Result.GetResult<Prisma.$StorageProviderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StorageProviders.
     * @param {StorageProviderDeleteManyArgs} args - Arguments to filter StorageProviders to delete.
     * @example
     * // Delete a few StorageProviders
     * const { count } = await prisma.storageProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorageProviderDeleteManyArgs>(args?: SelectSubset<T, StorageProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorageProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorageProviders
     * const storageProvider = await prisma.storageProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorageProviderUpdateManyArgs>(args: SelectSubset<T, StorageProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StorageProvider.
     * @param {StorageProviderUpsertArgs} args - Arguments to update or create a StorageProvider.
     * @example
     * // Update or create a StorageProvider
     * const storageProvider = await prisma.storageProvider.upsert({
     *   create: {
     *     // ... data to create a StorageProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorageProvider we want to update
     *   }
     * })
     */
    upsert<T extends StorageProviderUpsertArgs>(args: SelectSubset<T, StorageProviderUpsertArgs<ExtArgs>>): Prisma__StorageProviderClient<$Result.GetResult<Prisma.$StorageProviderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StorageProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageProviderCountArgs} args - Arguments to filter StorageProviders to count.
     * @example
     * // Count the number of StorageProviders
     * const count = await prisma.storageProvider.count({
     *   where: {
     *     // ... the filter for the StorageProviders we want to count
     *   }
     * })
    **/
    count<T extends StorageProviderCountArgs>(
      args?: Subset<T, StorageProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorageProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageProviderAggregateArgs>(args: Subset<T, StorageProviderAggregateArgs>): Prisma.PrismaPromise<GetStorageProviderAggregateType<T>>

    /**
     * Group by StorageProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageProviderGroupByArgs['orderBy'] }
        : { orderBy?: StorageProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorageProvider model
   */
  readonly fields: StorageProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorageProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorageProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    files<T extends StorageProvider$filesArgs<ExtArgs> = {}>(args?: Subset<T, StorageProvider$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorageProvider model
   */ 
  interface StorageProviderFieldRefs {
    readonly id: FieldRef<"StorageProvider", 'String'>
    readonly name: FieldRef<"StorageProvider", 'String'>
    readonly type: FieldRef<"StorageProvider", 'String'>
    readonly endpoint: FieldRef<"StorageProvider", 'String'>
    readonly region: FieldRef<"StorageProvider", 'String'>
    readonly bucket: FieldRef<"StorageProvider", 'String'>
    readonly cdnEndpoint: FieldRef<"StorageProvider", 'String'>
    readonly isActive: FieldRef<"StorageProvider", 'Boolean'>
    readonly isDefault: FieldRef<"StorageProvider", 'Boolean'>
    readonly config: FieldRef<"StorageProvider", 'Json'>
    readonly createdAt: FieldRef<"StorageProvider", 'DateTime'>
    readonly updatedAt: FieldRef<"StorageProvider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StorageProvider findUnique
   */
  export type StorageProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageProvider
     */
    select?: StorageProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageProviderInclude<ExtArgs> | null
    /**
     * Filter, which StorageProvider to fetch.
     */
    where: StorageProviderWhereUniqueInput
  }

  /**
   * StorageProvider findUniqueOrThrow
   */
  export type StorageProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageProvider
     */
    select?: StorageProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageProviderInclude<ExtArgs> | null
    /**
     * Filter, which StorageProvider to fetch.
     */
    where: StorageProviderWhereUniqueInput
  }

  /**
   * StorageProvider findFirst
   */
  export type StorageProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageProvider
     */
    select?: StorageProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageProviderInclude<ExtArgs> | null
    /**
     * Filter, which StorageProvider to fetch.
     */
    where?: StorageProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageProviders to fetch.
     */
    orderBy?: StorageProviderOrderByWithRelationInput | StorageProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageProviders.
     */
    cursor?: StorageProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageProviders.
     */
    distinct?: StorageProviderScalarFieldEnum | StorageProviderScalarFieldEnum[]
  }

  /**
   * StorageProvider findFirstOrThrow
   */
  export type StorageProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageProvider
     */
    select?: StorageProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageProviderInclude<ExtArgs> | null
    /**
     * Filter, which StorageProvider to fetch.
     */
    where?: StorageProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageProviders to fetch.
     */
    orderBy?: StorageProviderOrderByWithRelationInput | StorageProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageProviders.
     */
    cursor?: StorageProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageProviders.
     */
    distinct?: StorageProviderScalarFieldEnum | StorageProviderScalarFieldEnum[]
  }

  /**
   * StorageProvider findMany
   */
  export type StorageProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageProvider
     */
    select?: StorageProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageProviderInclude<ExtArgs> | null
    /**
     * Filter, which StorageProviders to fetch.
     */
    where?: StorageProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageProviders to fetch.
     */
    orderBy?: StorageProviderOrderByWithRelationInput | StorageProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorageProviders.
     */
    cursor?: StorageProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageProviders.
     */
    skip?: number
    distinct?: StorageProviderScalarFieldEnum | StorageProviderScalarFieldEnum[]
  }

  /**
   * StorageProvider create
   */
  export type StorageProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageProvider
     */
    select?: StorageProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a StorageProvider.
     */
    data: XOR<StorageProviderCreateInput, StorageProviderUncheckedCreateInput>
  }

  /**
   * StorageProvider createMany
   */
  export type StorageProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorageProviders.
     */
    data: StorageProviderCreateManyInput | StorageProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorageProvider createManyAndReturn
   */
  export type StorageProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageProvider
     */
    select?: StorageProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StorageProviders.
     */
    data: StorageProviderCreateManyInput | StorageProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorageProvider update
   */
  export type StorageProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageProvider
     */
    select?: StorageProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a StorageProvider.
     */
    data: XOR<StorageProviderUpdateInput, StorageProviderUncheckedUpdateInput>
    /**
     * Choose, which StorageProvider to update.
     */
    where: StorageProviderWhereUniqueInput
  }

  /**
   * StorageProvider updateMany
   */
  export type StorageProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorageProviders.
     */
    data: XOR<StorageProviderUpdateManyMutationInput, StorageProviderUncheckedUpdateManyInput>
    /**
     * Filter which StorageProviders to update
     */
    where?: StorageProviderWhereInput
  }

  /**
   * StorageProvider upsert
   */
  export type StorageProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageProvider
     */
    select?: StorageProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the StorageProvider to update in case it exists.
     */
    where: StorageProviderWhereUniqueInput
    /**
     * In case the StorageProvider found by the `where` argument doesn't exist, create a new StorageProvider with this data.
     */
    create: XOR<StorageProviderCreateInput, StorageProviderUncheckedCreateInput>
    /**
     * In case the StorageProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorageProviderUpdateInput, StorageProviderUncheckedUpdateInput>
  }

  /**
   * StorageProvider delete
   */
  export type StorageProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageProvider
     */
    select?: StorageProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageProviderInclude<ExtArgs> | null
    /**
     * Filter which StorageProvider to delete.
     */
    where: StorageProviderWhereUniqueInput
  }

  /**
   * StorageProvider deleteMany
   */
  export type StorageProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageProviders to delete
     */
    where?: StorageProviderWhereInput
  }

  /**
   * StorageProvider.files
   */
  export type StorageProvider$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    where?: FileStorageWhereInput
    orderBy?: FileStorageOrderByWithRelationInput | FileStorageOrderByWithRelationInput[]
    cursor?: FileStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileStorageScalarFieldEnum | FileStorageScalarFieldEnum[]
  }

  /**
   * StorageProvider without action
   */
  export type StorageProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageProvider
     */
    select?: StorageProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageProviderInclude<ExtArgs> | null
  }


  /**
   * Model FileStorage
   */

  export type AggregateFileStorage = {
    _count: FileStorageCountAggregateOutputType | null
    _avg: FileStorageAvgAggregateOutputType | null
    _sum: FileStorageSumAggregateOutputType | null
    _min: FileStorageMinAggregateOutputType | null
    _max: FileStorageMaxAggregateOutputType | null
  }

  export type FileStorageAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type FileStorageSumAggregateOutputType = {
    fileSize: bigint | null
  }

  export type FileStorageMinAggregateOutputType = {
    id: string | null
    uploadId: string | null
    providerId: string | null
    storageKey: string | null
    fileName: string | null
    fileSize: bigint | null
    mimeType: string | null
    checksum: string | null
    publicUrl: string | null
    cdnUrl: string | null
    expiresAt: Date | null
    createdAt: Date | null
    lastAccessedAt: Date | null
  }

  export type FileStorageMaxAggregateOutputType = {
    id: string | null
    uploadId: string | null
    providerId: string | null
    storageKey: string | null
    fileName: string | null
    fileSize: bigint | null
    mimeType: string | null
    checksum: string | null
    publicUrl: string | null
    cdnUrl: string | null
    expiresAt: Date | null
    createdAt: Date | null
    lastAccessedAt: Date | null
  }

  export type FileStorageCountAggregateOutputType = {
    id: number
    uploadId: number
    providerId: number
    storageKey: number
    fileName: number
    fileSize: number
    mimeType: number
    checksum: number
    publicUrl: number
    cdnUrl: number
    expiresAt: number
    metadata: number
    createdAt: number
    lastAccessedAt: number
    _all: number
  }


  export type FileStorageAvgAggregateInputType = {
    fileSize?: true
  }

  export type FileStorageSumAggregateInputType = {
    fileSize?: true
  }

  export type FileStorageMinAggregateInputType = {
    id?: true
    uploadId?: true
    providerId?: true
    storageKey?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    checksum?: true
    publicUrl?: true
    cdnUrl?: true
    expiresAt?: true
    createdAt?: true
    lastAccessedAt?: true
  }

  export type FileStorageMaxAggregateInputType = {
    id?: true
    uploadId?: true
    providerId?: true
    storageKey?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    checksum?: true
    publicUrl?: true
    cdnUrl?: true
    expiresAt?: true
    createdAt?: true
    lastAccessedAt?: true
  }

  export type FileStorageCountAggregateInputType = {
    id?: true
    uploadId?: true
    providerId?: true
    storageKey?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    checksum?: true
    publicUrl?: true
    cdnUrl?: true
    expiresAt?: true
    metadata?: true
    createdAt?: true
    lastAccessedAt?: true
    _all?: true
  }

  export type FileStorageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileStorage to aggregate.
     */
    where?: FileStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileStorages to fetch.
     */
    orderBy?: FileStorageOrderByWithRelationInput | FileStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileStorages
    **/
    _count?: true | FileStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileStorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileStorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileStorageMaxAggregateInputType
  }

  export type GetFileStorageAggregateType<T extends FileStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateFileStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileStorage[P]>
      : GetScalarType<T[P], AggregateFileStorage[P]>
  }




  export type FileStorageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileStorageWhereInput
    orderBy?: FileStorageOrderByWithAggregationInput | FileStorageOrderByWithAggregationInput[]
    by: FileStorageScalarFieldEnum[] | FileStorageScalarFieldEnum
    having?: FileStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileStorageCountAggregateInputType | true
    _avg?: FileStorageAvgAggregateInputType
    _sum?: FileStorageSumAggregateInputType
    _min?: FileStorageMinAggregateInputType
    _max?: FileStorageMaxAggregateInputType
  }

  export type FileStorageGroupByOutputType = {
    id: string
    uploadId: string
    providerId: string
    storageKey: string
    fileName: string
    fileSize: bigint
    mimeType: string
    checksum: string
    publicUrl: string | null
    cdnUrl: string | null
    expiresAt: Date | null
    metadata: JsonValue
    createdAt: Date
    lastAccessedAt: Date | null
    _count: FileStorageCountAggregateOutputType | null
    _avg: FileStorageAvgAggregateOutputType | null
    _sum: FileStorageSumAggregateOutputType | null
    _min: FileStorageMinAggregateOutputType | null
    _max: FileStorageMaxAggregateOutputType | null
  }

  type GetFileStorageGroupByPayload<T extends FileStorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileStorageGroupByOutputType[P]>
            : GetScalarType<T[P], FileStorageGroupByOutputType[P]>
        }
      >
    >


  export type FileStorageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploadId?: boolean
    providerId?: boolean
    storageKey?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    checksum?: boolean
    publicUrl?: boolean
    cdnUrl?: boolean
    expiresAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    lastAccessedAt?: boolean
    provider?: boolean | StorageProviderDefaultArgs<ExtArgs>
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileStorage"]>

  export type FileStorageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploadId?: boolean
    providerId?: boolean
    storageKey?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    checksum?: boolean
    publicUrl?: boolean
    cdnUrl?: boolean
    expiresAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    lastAccessedAt?: boolean
    provider?: boolean | StorageProviderDefaultArgs<ExtArgs>
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileStorage"]>

  export type FileStorageSelectScalar = {
    id?: boolean
    uploadId?: boolean
    providerId?: boolean
    storageKey?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    checksum?: boolean
    publicUrl?: boolean
    cdnUrl?: boolean
    expiresAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    lastAccessedAt?: boolean
  }

  export type FileStorageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | StorageProviderDefaultArgs<ExtArgs>
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }
  export type FileStorageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | StorageProviderDefaultArgs<ExtArgs>
    upload?: boolean | AudioUploadDefaultArgs<ExtArgs>
  }

  export type $FileStoragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileStorage"
    objects: {
      provider: Prisma.$StorageProviderPayload<ExtArgs>
      upload: Prisma.$AudioUploadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uploadId: string
      providerId: string
      storageKey: string
      fileName: string
      fileSize: bigint
      mimeType: string
      checksum: string
      publicUrl: string | null
      cdnUrl: string | null
      expiresAt: Date | null
      metadata: Prisma.JsonValue
      createdAt: Date
      lastAccessedAt: Date | null
    }, ExtArgs["result"]["fileStorage"]>
    composites: {}
  }

  type FileStorageGetPayload<S extends boolean | null | undefined | FileStorageDefaultArgs> = $Result.GetResult<Prisma.$FileStoragePayload, S>

  type FileStorageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FileStorageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FileStorageCountAggregateInputType | true
    }

  export interface FileStorageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileStorage'], meta: { name: 'FileStorage' } }
    /**
     * Find zero or one FileStorage that matches the filter.
     * @param {FileStorageFindUniqueArgs} args - Arguments to find a FileStorage
     * @example
     * // Get one FileStorage
     * const fileStorage = await prisma.fileStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileStorageFindUniqueArgs>(args: SelectSubset<T, FileStorageFindUniqueArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FileStorage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FileStorageFindUniqueOrThrowArgs} args - Arguments to find a FileStorage
     * @example
     * // Get one FileStorage
     * const fileStorage = await prisma.fileStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileStorageFindUniqueOrThrowArgs>(args: SelectSubset<T, FileStorageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FileStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageFindFirstArgs} args - Arguments to find a FileStorage
     * @example
     * // Get one FileStorage
     * const fileStorage = await prisma.fileStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileStorageFindFirstArgs>(args?: SelectSubset<T, FileStorageFindFirstArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FileStorage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageFindFirstOrThrowArgs} args - Arguments to find a FileStorage
     * @example
     * // Get one FileStorage
     * const fileStorage = await prisma.fileStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileStorageFindFirstOrThrowArgs>(args?: SelectSubset<T, FileStorageFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FileStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileStorages
     * const fileStorages = await prisma.fileStorage.findMany()
     * 
     * // Get first 10 FileStorages
     * const fileStorages = await prisma.fileStorage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileStorageWithIdOnly = await prisma.fileStorage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileStorageFindManyArgs>(args?: SelectSubset<T, FileStorageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FileStorage.
     * @param {FileStorageCreateArgs} args - Arguments to create a FileStorage.
     * @example
     * // Create one FileStorage
     * const FileStorage = await prisma.fileStorage.create({
     *   data: {
     *     // ... data to create a FileStorage
     *   }
     * })
     * 
     */
    create<T extends FileStorageCreateArgs>(args: SelectSubset<T, FileStorageCreateArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FileStorages.
     * @param {FileStorageCreateManyArgs} args - Arguments to create many FileStorages.
     * @example
     * // Create many FileStorages
     * const fileStorage = await prisma.fileStorage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileStorageCreateManyArgs>(args?: SelectSubset<T, FileStorageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileStorages and returns the data saved in the database.
     * @param {FileStorageCreateManyAndReturnArgs} args - Arguments to create many FileStorages.
     * @example
     * // Create many FileStorages
     * const fileStorage = await prisma.fileStorage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileStorages and only return the `id`
     * const fileStorageWithIdOnly = await prisma.fileStorage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileStorageCreateManyAndReturnArgs>(args?: SelectSubset<T, FileStorageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FileStorage.
     * @param {FileStorageDeleteArgs} args - Arguments to delete one FileStorage.
     * @example
     * // Delete one FileStorage
     * const FileStorage = await prisma.fileStorage.delete({
     *   where: {
     *     // ... filter to delete one FileStorage
     *   }
     * })
     * 
     */
    delete<T extends FileStorageDeleteArgs>(args: SelectSubset<T, FileStorageDeleteArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FileStorage.
     * @param {FileStorageUpdateArgs} args - Arguments to update one FileStorage.
     * @example
     * // Update one FileStorage
     * const fileStorage = await prisma.fileStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileStorageUpdateArgs>(args: SelectSubset<T, FileStorageUpdateArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FileStorages.
     * @param {FileStorageDeleteManyArgs} args - Arguments to filter FileStorages to delete.
     * @example
     * // Delete a few FileStorages
     * const { count } = await prisma.fileStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileStorageDeleteManyArgs>(args?: SelectSubset<T, FileStorageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileStorages
     * const fileStorage = await prisma.fileStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileStorageUpdateManyArgs>(args: SelectSubset<T, FileStorageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FileStorage.
     * @param {FileStorageUpsertArgs} args - Arguments to update or create a FileStorage.
     * @example
     * // Update or create a FileStorage
     * const fileStorage = await prisma.fileStorage.upsert({
     *   create: {
     *     // ... data to create a FileStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileStorage we want to update
     *   }
     * })
     */
    upsert<T extends FileStorageUpsertArgs>(args: SelectSubset<T, FileStorageUpsertArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FileStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageCountArgs} args - Arguments to filter FileStorages to count.
     * @example
     * // Count the number of FileStorages
     * const count = await prisma.fileStorage.count({
     *   where: {
     *     // ... the filter for the FileStorages we want to count
     *   }
     * })
    **/
    count<T extends FileStorageCountArgs>(
      args?: Subset<T, FileStorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileStorageAggregateArgs>(args: Subset<T, FileStorageAggregateArgs>): Prisma.PrismaPromise<GetFileStorageAggregateType<T>>

    /**
     * Group by FileStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileStorageGroupByArgs['orderBy'] }
        : { orderBy?: FileStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileStorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileStorage model
   */
  readonly fields: FileStorageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileStorageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends StorageProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StorageProviderDefaultArgs<ExtArgs>>): Prisma__StorageProviderClient<$Result.GetResult<Prisma.$StorageProviderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    upload<T extends AudioUploadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AudioUploadDefaultArgs<ExtArgs>>): Prisma__AudioUploadClient<$Result.GetResult<Prisma.$AudioUploadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileStorage model
   */ 
  interface FileStorageFieldRefs {
    readonly id: FieldRef<"FileStorage", 'String'>
    readonly uploadId: FieldRef<"FileStorage", 'String'>
    readonly providerId: FieldRef<"FileStorage", 'String'>
    readonly storageKey: FieldRef<"FileStorage", 'String'>
    readonly fileName: FieldRef<"FileStorage", 'String'>
    readonly fileSize: FieldRef<"FileStorage", 'BigInt'>
    readonly mimeType: FieldRef<"FileStorage", 'String'>
    readonly checksum: FieldRef<"FileStorage", 'String'>
    readonly publicUrl: FieldRef<"FileStorage", 'String'>
    readonly cdnUrl: FieldRef<"FileStorage", 'String'>
    readonly expiresAt: FieldRef<"FileStorage", 'DateTime'>
    readonly metadata: FieldRef<"FileStorage", 'Json'>
    readonly createdAt: FieldRef<"FileStorage", 'DateTime'>
    readonly lastAccessedAt: FieldRef<"FileStorage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileStorage findUnique
   */
  export type FileStorageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * Filter, which FileStorage to fetch.
     */
    where: FileStorageWhereUniqueInput
  }

  /**
   * FileStorage findUniqueOrThrow
   */
  export type FileStorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * Filter, which FileStorage to fetch.
     */
    where: FileStorageWhereUniqueInput
  }

  /**
   * FileStorage findFirst
   */
  export type FileStorageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * Filter, which FileStorage to fetch.
     */
    where?: FileStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileStorages to fetch.
     */
    orderBy?: FileStorageOrderByWithRelationInput | FileStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileStorages.
     */
    cursor?: FileStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileStorages.
     */
    distinct?: FileStorageScalarFieldEnum | FileStorageScalarFieldEnum[]
  }

  /**
   * FileStorage findFirstOrThrow
   */
  export type FileStorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * Filter, which FileStorage to fetch.
     */
    where?: FileStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileStorages to fetch.
     */
    orderBy?: FileStorageOrderByWithRelationInput | FileStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileStorages.
     */
    cursor?: FileStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileStorages.
     */
    distinct?: FileStorageScalarFieldEnum | FileStorageScalarFieldEnum[]
  }

  /**
   * FileStorage findMany
   */
  export type FileStorageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * Filter, which FileStorages to fetch.
     */
    where?: FileStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileStorages to fetch.
     */
    orderBy?: FileStorageOrderByWithRelationInput | FileStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileStorages.
     */
    cursor?: FileStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileStorages.
     */
    skip?: number
    distinct?: FileStorageScalarFieldEnum | FileStorageScalarFieldEnum[]
  }

  /**
   * FileStorage create
   */
  export type FileStorageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * The data needed to create a FileStorage.
     */
    data: XOR<FileStorageCreateInput, FileStorageUncheckedCreateInput>
  }

  /**
   * FileStorage createMany
   */
  export type FileStorageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileStorages.
     */
    data: FileStorageCreateManyInput | FileStorageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileStorage createManyAndReturn
   */
  export type FileStorageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FileStorages.
     */
    data: FileStorageCreateManyInput | FileStorageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileStorage update
   */
  export type FileStorageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * The data needed to update a FileStorage.
     */
    data: XOR<FileStorageUpdateInput, FileStorageUncheckedUpdateInput>
    /**
     * Choose, which FileStorage to update.
     */
    where: FileStorageWhereUniqueInput
  }

  /**
   * FileStorage updateMany
   */
  export type FileStorageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileStorages.
     */
    data: XOR<FileStorageUpdateManyMutationInput, FileStorageUncheckedUpdateManyInput>
    /**
     * Filter which FileStorages to update
     */
    where?: FileStorageWhereInput
  }

  /**
   * FileStorage upsert
   */
  export type FileStorageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * The filter to search for the FileStorage to update in case it exists.
     */
    where: FileStorageWhereUniqueInput
    /**
     * In case the FileStorage found by the `where` argument doesn't exist, create a new FileStorage with this data.
     */
    create: XOR<FileStorageCreateInput, FileStorageUncheckedCreateInput>
    /**
     * In case the FileStorage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileStorageUpdateInput, FileStorageUncheckedUpdateInput>
  }

  /**
   * FileStorage delete
   */
  export type FileStorageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * Filter which FileStorage to delete.
     */
    where: FileStorageWhereUniqueInput
  }

  /**
   * FileStorage deleteMany
   */
  export type FileStorageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileStorages to delete
     */
    where?: FileStorageWhereInput
  }

  /**
   * FileStorage without action
   */
  export type FileStorageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  export type SubscriptionPlanAvgAggregateOutputType = {
    price: Decimal | null
    trialDays: number | null
    sortOrder: number | null
  }

  export type SubscriptionPlanSumAggregateOutputType = {
    price: Decimal | null
    trialDays: number | null
    sortOrder: number | null
  }

  export type SubscriptionPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    tier: string | null
    price: Decimal | null
    currency: string | null
    billingPeriod: string | null
    isActive: boolean | null
    isPublic: boolean | null
    trialDays: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    tier: string | null
    price: Decimal | null
    currency: string | null
    billingPeriod: string | null
    isActive: boolean | null
    isPublic: boolean | null
    trialDays: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    tier: number
    price: number
    currency: number
    billingPeriod: number
    features: number
    quotas: number
    isActive: number
    isPublic: number
    trialDays: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionPlanAvgAggregateInputType = {
    price?: true
    trialDays?: true
    sortOrder?: true
  }

  export type SubscriptionPlanSumAggregateInputType = {
    price?: true
    trialDays?: true
    sortOrder?: true
  }

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    tier?: true
    price?: true
    currency?: true
    billingPeriod?: true
    isActive?: true
    isPublic?: true
    trialDays?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    tier?: true
    price?: true
    currency?: true
    billingPeriod?: true
    isActive?: true
    isPublic?: true
    trialDays?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    tier?: true
    price?: true
    currency?: true
    billingPeriod?: true
    features?: true
    quotas?: true
    isActive?: true
    isPublic?: true
    trialDays?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type GetSubscriptionPlanAggregateType<T extends SubscriptionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
  }




  export type SubscriptionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithAggregationInput | SubscriptionPlanOrderByWithAggregationInput[]
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum
    having?: SubscriptionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlanCountAggregateInputType | true
    _avg?: SubscriptionPlanAvgAggregateInputType
    _sum?: SubscriptionPlanSumAggregateInputType
    _min?: SubscriptionPlanMinAggregateInputType
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type SubscriptionPlanGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    tier: string
    price: Decimal
    currency: string
    billingPeriod: string
    features: JsonValue
    quotas: JsonValue
    isActive: boolean
    isPublic: boolean
    trialDays: number
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  type GetSubscriptionPlanGroupByPayload<T extends SubscriptionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    tier?: boolean
    price?: boolean
    currency?: boolean
    billingPeriod?: boolean
    features?: boolean
    quotas?: boolean
    isActive?: boolean
    isPublic?: boolean
    trialDays?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    planPricing?: boolean | SubscriptionPlan$planPricingArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    tier?: boolean
    price?: boolean
    currency?: boolean
    billingPeriod?: boolean
    features?: boolean
    quotas?: boolean
    isActive?: boolean
    isPublic?: boolean
    trialDays?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    tier?: boolean
    price?: boolean
    currency?: boolean
    billingPeriod?: boolean
    features?: boolean
    quotas?: boolean
    isActive?: boolean
    isPublic?: boolean
    trialDays?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    planPricing?: boolean | SubscriptionPlan$planPricingArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubscriptionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlan"
    objects: {
      subscriptions: Prisma.$WorkspaceSubscriptionPayload<ExtArgs>[]
      planPricing: Prisma.$PlanPricingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      tier: string
      price: Prisma.Decimal
      currency: string
      billingPeriod: string
      features: Prisma.JsonValue
      quotas: Prisma.JsonValue
      isActive: boolean
      isPublic: boolean
      trialDays: number
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionPlan"]>
    composites: {}
  }

  type SubscriptionPlanGetPayload<S extends boolean | null | undefined | SubscriptionPlanDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>

  type SubscriptionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionPlanCountAggregateInputType | true
    }

  export interface SubscriptionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'], meta: { name: 'SubscriptionPlan' } }
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPlanCreateArgs>(args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPlanDeleteArgs>(args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPlanUpdateArgs>(args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(args: Subset<T, SubscriptionPlanAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlan model
   */
  readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends SubscriptionPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    planPricing<T extends SubscriptionPlan$planPricingArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$planPricingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPlan model
   */ 
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<"SubscriptionPlan", 'String'>
    readonly name: FieldRef<"SubscriptionPlan", 'String'>
    readonly displayName: FieldRef<"SubscriptionPlan", 'String'>
    readonly description: FieldRef<"SubscriptionPlan", 'String'>
    readonly tier: FieldRef<"SubscriptionPlan", 'String'>
    readonly price: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly currency: FieldRef<"SubscriptionPlan", 'String'>
    readonly billingPeriod: FieldRef<"SubscriptionPlan", 'String'>
    readonly features: FieldRef<"SubscriptionPlan", 'Json'>
    readonly quotas: FieldRef<"SubscriptionPlan", 'Json'>
    readonly isActive: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly isPublic: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly trialDays: FieldRef<"SubscriptionPlan", 'Int'>
    readonly sortOrder: FieldRef<"SubscriptionPlan", 'Int'>
    readonly createdAt: FieldRef<"SubscriptionPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
  }

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
  }

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput
  }

  /**
   * SubscriptionPlan.subscriptions
   */
  export type SubscriptionPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    where?: WorkspaceSubscriptionWhereInput
    orderBy?: WorkspaceSubscriptionOrderByWithRelationInput | WorkspaceSubscriptionOrderByWithRelationInput[]
    cursor?: WorkspaceSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceSubscriptionScalarFieldEnum | WorkspaceSubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan.planPricing
   */
  export type SubscriptionPlan$planPricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    where?: PlanPricingWhereInput
    orderBy?: PlanPricingOrderByWithRelationInput | PlanPricingOrderByWithRelationInput[]
    cursor?: PlanPricingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanPricingScalarFieldEnum | PlanPricingScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceSubscription
   */

  export type AggregateWorkspaceSubscription = {
    _count: WorkspaceSubscriptionCountAggregateOutputType | null
    _min: WorkspaceSubscriptionMinAggregateOutputType | null
    _max: WorkspaceSubscriptionMaxAggregateOutputType | null
  }

  export type WorkspaceSubscriptionMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    planId: string | null
    status: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelledAt: Date | null
    cancelReason: string | null
    trialEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceSubscriptionMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    planId: string | null
    status: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelledAt: Date | null
    cancelReason: string | null
    trialEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceSubscriptionCountAggregateOutputType = {
    id: number
    workspaceId: number
    planId: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelledAt: number
    cancelReason: number
    trialEnd: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceSubscriptionMinAggregateInputType = {
    id?: true
    workspaceId?: true
    planId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelledAt?: true
    cancelReason?: true
    trialEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceSubscriptionMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    planId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelledAt?: true
    cancelReason?: true
    trialEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceSubscriptionCountAggregateInputType = {
    id?: true
    workspaceId?: true
    planId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelledAt?: true
    cancelReason?: true
    trialEnd?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceSubscription to aggregate.
     */
    where?: WorkspaceSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceSubscriptions to fetch.
     */
    orderBy?: WorkspaceSubscriptionOrderByWithRelationInput | WorkspaceSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceSubscriptions
    **/
    _count?: true | WorkspaceSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceSubscriptionMaxAggregateInputType
  }

  export type GetWorkspaceSubscriptionAggregateType<T extends WorkspaceSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceSubscription[P]>
      : GetScalarType<T[P], AggregateWorkspaceSubscription[P]>
  }




  export type WorkspaceSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceSubscriptionWhereInput
    orderBy?: WorkspaceSubscriptionOrderByWithAggregationInput | WorkspaceSubscriptionOrderByWithAggregationInput[]
    by: WorkspaceSubscriptionScalarFieldEnum[] | WorkspaceSubscriptionScalarFieldEnum
    having?: WorkspaceSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceSubscriptionCountAggregateInputType | true
    _min?: WorkspaceSubscriptionMinAggregateInputType
    _max?: WorkspaceSubscriptionMaxAggregateInputType
  }

  export type WorkspaceSubscriptionGroupByOutputType = {
    id: string
    workspaceId: string
    planId: string
    status: string
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelledAt: Date | null
    cancelReason: string | null
    trialEnd: Date | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceSubscriptionCountAggregateOutputType | null
    _min: WorkspaceSubscriptionMinAggregateOutputType | null
    _max: WorkspaceSubscriptionMaxAggregateOutputType | null
  }

  type GetWorkspaceSubscriptionGroupByPayload<T extends WorkspaceSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    trialEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    billingRecords?: boolean | WorkspaceSubscription$billingRecordsArgs<ExtArgs>
    usageRecords?: boolean | WorkspaceSubscription$usageRecordsArgs<ExtArgs>
    _count?: boolean | WorkspaceSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceSubscription"]>

  export type WorkspaceSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    trialEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceSubscription"]>

  export type WorkspaceSubscriptionSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    trialEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    billingRecords?: boolean | WorkspaceSubscription$billingRecordsArgs<ExtArgs>
    usageRecords?: boolean | WorkspaceSubscription$usageRecordsArgs<ExtArgs>
    _count?: boolean | WorkspaceSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $WorkspaceSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceSubscription"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
      billingRecords: Prisma.$BillingRecordPayload<ExtArgs>[]
      usageRecords: Prisma.$UsageRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      planId: string
      status: string
      currentPeriodStart: Date
      currentPeriodEnd: Date
      cancelledAt: Date | null
      cancelReason: string | null
      trialEnd: Date | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspaceSubscription"]>
    composites: {}
  }

  type WorkspaceSubscriptionGetPayload<S extends boolean | null | undefined | WorkspaceSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceSubscriptionPayload, S>

  type WorkspaceSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceSubscriptionCountAggregateInputType | true
    }

  export interface WorkspaceSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceSubscription'], meta: { name: 'WorkspaceSubscription' } }
    /**
     * Find zero or one WorkspaceSubscription that matches the filter.
     * @param {WorkspaceSubscriptionFindUniqueArgs} args - Arguments to find a WorkspaceSubscription
     * @example
     * // Get one WorkspaceSubscription
     * const workspaceSubscription = await prisma.workspaceSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceSubscriptionFindUniqueArgs>(args: SelectSubset<T, WorkspaceSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkspaceSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceSubscription
     * @example
     * // Get one WorkspaceSubscription
     * const workspaceSubscription = await prisma.workspaceSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkspaceSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionFindFirstArgs} args - Arguments to find a WorkspaceSubscription
     * @example
     * // Get one WorkspaceSubscription
     * const workspaceSubscription = await prisma.workspaceSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceSubscriptionFindFirstArgs>(args?: SelectSubset<T, WorkspaceSubscriptionFindFirstArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkspaceSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionFindFirstOrThrowArgs} args - Arguments to find a WorkspaceSubscription
     * @example
     * // Get one WorkspaceSubscription
     * const workspaceSubscription = await prisma.workspaceSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkspaceSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceSubscriptions
     * const workspaceSubscriptions = await prisma.workspaceSubscription.findMany()
     * 
     * // Get first 10 WorkspaceSubscriptions
     * const workspaceSubscriptions = await prisma.workspaceSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceSubscriptionWithIdOnly = await prisma.workspaceSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceSubscriptionFindManyArgs>(args?: SelectSubset<T, WorkspaceSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkspaceSubscription.
     * @param {WorkspaceSubscriptionCreateArgs} args - Arguments to create a WorkspaceSubscription.
     * @example
     * // Create one WorkspaceSubscription
     * const WorkspaceSubscription = await prisma.workspaceSubscription.create({
     *   data: {
     *     // ... data to create a WorkspaceSubscription
     *   }
     * })
     * 
     */
    create<T extends WorkspaceSubscriptionCreateArgs>(args: SelectSubset<T, WorkspaceSubscriptionCreateArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkspaceSubscriptions.
     * @param {WorkspaceSubscriptionCreateManyArgs} args - Arguments to create many WorkspaceSubscriptions.
     * @example
     * // Create many WorkspaceSubscriptions
     * const workspaceSubscription = await prisma.workspaceSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceSubscriptionCreateManyArgs>(args?: SelectSubset<T, WorkspaceSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceSubscriptions and returns the data saved in the database.
     * @param {WorkspaceSubscriptionCreateManyAndReturnArgs} args - Arguments to create many WorkspaceSubscriptions.
     * @example
     * // Create many WorkspaceSubscriptions
     * const workspaceSubscription = await prisma.workspaceSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceSubscriptions and only return the `id`
     * const workspaceSubscriptionWithIdOnly = await prisma.workspaceSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkspaceSubscription.
     * @param {WorkspaceSubscriptionDeleteArgs} args - Arguments to delete one WorkspaceSubscription.
     * @example
     * // Delete one WorkspaceSubscription
     * const WorkspaceSubscription = await prisma.workspaceSubscription.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceSubscription
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceSubscriptionDeleteArgs>(args: SelectSubset<T, WorkspaceSubscriptionDeleteArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkspaceSubscription.
     * @param {WorkspaceSubscriptionUpdateArgs} args - Arguments to update one WorkspaceSubscription.
     * @example
     * // Update one WorkspaceSubscription
     * const workspaceSubscription = await prisma.workspaceSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceSubscriptionUpdateArgs>(args: SelectSubset<T, WorkspaceSubscriptionUpdateArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkspaceSubscriptions.
     * @param {WorkspaceSubscriptionDeleteManyArgs} args - Arguments to filter WorkspaceSubscriptions to delete.
     * @example
     * // Delete a few WorkspaceSubscriptions
     * const { count } = await prisma.workspaceSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceSubscriptionDeleteManyArgs>(args?: SelectSubset<T, WorkspaceSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceSubscriptions
     * const workspaceSubscription = await prisma.workspaceSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceSubscriptionUpdateManyArgs>(args: SelectSubset<T, WorkspaceSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkspaceSubscription.
     * @param {WorkspaceSubscriptionUpsertArgs} args - Arguments to update or create a WorkspaceSubscription.
     * @example
     * // Update or create a WorkspaceSubscription
     * const workspaceSubscription = await prisma.workspaceSubscription.upsert({
     *   create: {
     *     // ... data to create a WorkspaceSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceSubscription we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceSubscriptionUpsertArgs>(args: SelectSubset<T, WorkspaceSubscriptionUpsertArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkspaceSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionCountArgs} args - Arguments to filter WorkspaceSubscriptions to count.
     * @example
     * // Count the number of WorkspaceSubscriptions
     * const count = await prisma.workspaceSubscription.count({
     *   where: {
     *     // ... the filter for the WorkspaceSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceSubscriptionCountArgs>(
      args?: Subset<T, WorkspaceSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceSubscriptionAggregateArgs>(args: Subset<T, WorkspaceSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceSubscriptionAggregateType<T>>

    /**
     * Group by WorkspaceSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceSubscription model
   */
  readonly fields: WorkspaceSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    billingRecords<T extends WorkspaceSubscription$billingRecordsArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceSubscription$billingRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "findMany"> | Null>
    usageRecords<T extends WorkspaceSubscription$usageRecordsArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceSubscription$usageRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceSubscription model
   */ 
  interface WorkspaceSubscriptionFieldRefs {
    readonly id: FieldRef<"WorkspaceSubscription", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceSubscription", 'String'>
    readonly planId: FieldRef<"WorkspaceSubscription", 'String'>
    readonly status: FieldRef<"WorkspaceSubscription", 'String'>
    readonly currentPeriodStart: FieldRef<"WorkspaceSubscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"WorkspaceSubscription", 'DateTime'>
    readonly cancelledAt: FieldRef<"WorkspaceSubscription", 'DateTime'>
    readonly cancelReason: FieldRef<"WorkspaceSubscription", 'String'>
    readonly trialEnd: FieldRef<"WorkspaceSubscription", 'DateTime'>
    readonly metadata: FieldRef<"WorkspaceSubscription", 'Json'>
    readonly createdAt: FieldRef<"WorkspaceSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkspaceSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceSubscription findUnique
   */
  export type WorkspaceSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSubscription to fetch.
     */
    where: WorkspaceSubscriptionWhereUniqueInput
  }

  /**
   * WorkspaceSubscription findUniqueOrThrow
   */
  export type WorkspaceSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSubscription to fetch.
     */
    where: WorkspaceSubscriptionWhereUniqueInput
  }

  /**
   * WorkspaceSubscription findFirst
   */
  export type WorkspaceSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSubscription to fetch.
     */
    where?: WorkspaceSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceSubscriptions to fetch.
     */
    orderBy?: WorkspaceSubscriptionOrderByWithRelationInput | WorkspaceSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceSubscriptions.
     */
    cursor?: WorkspaceSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceSubscriptions.
     */
    distinct?: WorkspaceSubscriptionScalarFieldEnum | WorkspaceSubscriptionScalarFieldEnum[]
  }

  /**
   * WorkspaceSubscription findFirstOrThrow
   */
  export type WorkspaceSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSubscription to fetch.
     */
    where?: WorkspaceSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceSubscriptions to fetch.
     */
    orderBy?: WorkspaceSubscriptionOrderByWithRelationInput | WorkspaceSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceSubscriptions.
     */
    cursor?: WorkspaceSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceSubscriptions.
     */
    distinct?: WorkspaceSubscriptionScalarFieldEnum | WorkspaceSubscriptionScalarFieldEnum[]
  }

  /**
   * WorkspaceSubscription findMany
   */
  export type WorkspaceSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceSubscriptions to fetch.
     */
    where?: WorkspaceSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceSubscriptions to fetch.
     */
    orderBy?: WorkspaceSubscriptionOrderByWithRelationInput | WorkspaceSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceSubscriptions.
     */
    cursor?: WorkspaceSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceSubscriptions.
     */
    skip?: number
    distinct?: WorkspaceSubscriptionScalarFieldEnum | WorkspaceSubscriptionScalarFieldEnum[]
  }

  /**
   * WorkspaceSubscription create
   */
  export type WorkspaceSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceSubscription.
     */
    data: XOR<WorkspaceSubscriptionCreateInput, WorkspaceSubscriptionUncheckedCreateInput>
  }

  /**
   * WorkspaceSubscription createMany
   */
  export type WorkspaceSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceSubscriptions.
     */
    data: WorkspaceSubscriptionCreateManyInput | WorkspaceSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceSubscription createManyAndReturn
   */
  export type WorkspaceSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkspaceSubscriptions.
     */
    data: WorkspaceSubscriptionCreateManyInput | WorkspaceSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceSubscription update
   */
  export type WorkspaceSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceSubscription.
     */
    data: XOR<WorkspaceSubscriptionUpdateInput, WorkspaceSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceSubscription to update.
     */
    where: WorkspaceSubscriptionWhereUniqueInput
  }

  /**
   * WorkspaceSubscription updateMany
   */
  export type WorkspaceSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceSubscriptions.
     */
    data: XOR<WorkspaceSubscriptionUpdateManyMutationInput, WorkspaceSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceSubscriptions to update
     */
    where?: WorkspaceSubscriptionWhereInput
  }

  /**
   * WorkspaceSubscription upsert
   */
  export type WorkspaceSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceSubscription to update in case it exists.
     */
    where: WorkspaceSubscriptionWhereUniqueInput
    /**
     * In case the WorkspaceSubscription found by the `where` argument doesn't exist, create a new WorkspaceSubscription with this data.
     */
    create: XOR<WorkspaceSubscriptionCreateInput, WorkspaceSubscriptionUncheckedCreateInput>
    /**
     * In case the WorkspaceSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceSubscriptionUpdateInput, WorkspaceSubscriptionUncheckedUpdateInput>
  }

  /**
   * WorkspaceSubscription delete
   */
  export type WorkspaceSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceSubscription to delete.
     */
    where: WorkspaceSubscriptionWhereUniqueInput
  }

  /**
   * WorkspaceSubscription deleteMany
   */
  export type WorkspaceSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceSubscriptions to delete
     */
    where?: WorkspaceSubscriptionWhereInput
  }

  /**
   * WorkspaceSubscription.billingRecords
   */
  export type WorkspaceSubscription$billingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    where?: BillingRecordWhereInput
    orderBy?: BillingRecordOrderByWithRelationInput | BillingRecordOrderByWithRelationInput[]
    cursor?: BillingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingRecordScalarFieldEnum | BillingRecordScalarFieldEnum[]
  }

  /**
   * WorkspaceSubscription.usageRecords
   */
  export type WorkspaceSubscription$usageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    where?: UsageRecordWhereInput
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    cursor?: UsageRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * WorkspaceSubscription without action
   */
  export type WorkspaceSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceSubscription
     */
    select?: WorkspaceSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model BillingRecord
   */

  export type AggregateBillingRecord = {
    _count: BillingRecordCountAggregateOutputType | null
    _avg: BillingRecordAvgAggregateOutputType | null
    _sum: BillingRecordSumAggregateOutputType | null
    _min: BillingRecordMinAggregateOutputType | null
    _max: BillingRecordMaxAggregateOutputType | null
  }

  export type BillingRecordAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type BillingRecordSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type BillingRecordMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    amount: Decimal | null
    currency: string | null
    status: string | null
    invoiceNumber: string | null
    invoiceUrl: string | null
    paymentMethod: string | null
    paymentIntentId: string | null
    failureReason: string | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type BillingRecordMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    amount: Decimal | null
    currency: string | null
    status: string | null
    invoiceNumber: string | null
    invoiceUrl: string | null
    paymentMethod: string | null
    paymentIntentId: string | null
    failureReason: string | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type BillingRecordCountAggregateOutputType = {
    id: number
    subscriptionId: number
    amount: number
    currency: number
    status: number
    invoiceNumber: number
    invoiceUrl: number
    paymentMethod: number
    paymentIntentId: number
    failureReason: number
    paidAt: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type BillingRecordAvgAggregateInputType = {
    amount?: true
  }

  export type BillingRecordSumAggregateInputType = {
    amount?: true
  }

  export type BillingRecordMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    status?: true
    invoiceNumber?: true
    invoiceUrl?: true
    paymentMethod?: true
    paymentIntentId?: true
    failureReason?: true
    paidAt?: true
    createdAt?: true
  }

  export type BillingRecordMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    status?: true
    invoiceNumber?: true
    invoiceUrl?: true
    paymentMethod?: true
    paymentIntentId?: true
    failureReason?: true
    paidAt?: true
    createdAt?: true
  }

  export type BillingRecordCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    status?: true
    invoiceNumber?: true
    invoiceUrl?: true
    paymentMethod?: true
    paymentIntentId?: true
    failureReason?: true
    paidAt?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type BillingRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingRecord to aggregate.
     */
    where?: BillingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRecords to fetch.
     */
    orderBy?: BillingRecordOrderByWithRelationInput | BillingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingRecords
    **/
    _count?: true | BillingRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingRecordMaxAggregateInputType
  }

  export type GetBillingRecordAggregateType<T extends BillingRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingRecord[P]>
      : GetScalarType<T[P], AggregateBillingRecord[P]>
  }




  export type BillingRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingRecordWhereInput
    orderBy?: BillingRecordOrderByWithAggregationInput | BillingRecordOrderByWithAggregationInput[]
    by: BillingRecordScalarFieldEnum[] | BillingRecordScalarFieldEnum
    having?: BillingRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingRecordCountAggregateInputType | true
    _avg?: BillingRecordAvgAggregateInputType
    _sum?: BillingRecordSumAggregateInputType
    _min?: BillingRecordMinAggregateInputType
    _max?: BillingRecordMaxAggregateInputType
  }

  export type BillingRecordGroupByOutputType = {
    id: string
    subscriptionId: string
    amount: Decimal
    currency: string
    status: string
    invoiceNumber: string | null
    invoiceUrl: string | null
    paymentMethod: string | null
    paymentIntentId: string | null
    failureReason: string | null
    paidAt: Date | null
    metadata: JsonValue
    createdAt: Date
    _count: BillingRecordCountAggregateOutputType | null
    _avg: BillingRecordAvgAggregateOutputType | null
    _sum: BillingRecordSumAggregateOutputType | null
    _min: BillingRecordMinAggregateOutputType | null
    _max: BillingRecordMaxAggregateOutputType | null
  }

  type GetBillingRecordGroupByPayload<T extends BillingRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingRecordGroupByOutputType[P]>
            : GetScalarType<T[P], BillingRecordGroupByOutputType[P]>
        }
      >
    >


  export type BillingRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    invoiceNumber?: boolean
    invoiceUrl?: boolean
    paymentMethod?: boolean
    paymentIntentId?: boolean
    failureReason?: boolean
    paidAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingRecord"]>

  export type BillingRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    invoiceNumber?: boolean
    invoiceUrl?: boolean
    paymentMethod?: boolean
    paymentIntentId?: boolean
    failureReason?: boolean
    paidAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingRecord"]>

  export type BillingRecordSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    invoiceNumber?: boolean
    invoiceUrl?: boolean
    paymentMethod?: boolean
    paymentIntentId?: boolean
    failureReason?: boolean
    paidAt?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type BillingRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }
  export type BillingRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }

  export type $BillingRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingRecord"
    objects: {
      subscription: Prisma.$WorkspaceSubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      amount: Prisma.Decimal
      currency: string
      status: string
      invoiceNumber: string | null
      invoiceUrl: string | null
      paymentMethod: string | null
      paymentIntentId: string | null
      failureReason: string | null
      paidAt: Date | null
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["billingRecord"]>
    composites: {}
  }

  type BillingRecordGetPayload<S extends boolean | null | undefined | BillingRecordDefaultArgs> = $Result.GetResult<Prisma.$BillingRecordPayload, S>

  type BillingRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BillingRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillingRecordCountAggregateInputType | true
    }

  export interface BillingRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingRecord'], meta: { name: 'BillingRecord' } }
    /**
     * Find zero or one BillingRecord that matches the filter.
     * @param {BillingRecordFindUniqueArgs} args - Arguments to find a BillingRecord
     * @example
     * // Get one BillingRecord
     * const billingRecord = await prisma.billingRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingRecordFindUniqueArgs>(args: SelectSubset<T, BillingRecordFindUniqueArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BillingRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BillingRecordFindUniqueOrThrowArgs} args - Arguments to find a BillingRecord
     * @example
     * // Get one BillingRecord
     * const billingRecord = await prisma.billingRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BillingRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordFindFirstArgs} args - Arguments to find a BillingRecord
     * @example
     * // Get one BillingRecord
     * const billingRecord = await prisma.billingRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingRecordFindFirstArgs>(args?: SelectSubset<T, BillingRecordFindFirstArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BillingRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordFindFirstOrThrowArgs} args - Arguments to find a BillingRecord
     * @example
     * // Get one BillingRecord
     * const billingRecord = await prisma.billingRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BillingRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingRecords
     * const billingRecords = await prisma.billingRecord.findMany()
     * 
     * // Get first 10 BillingRecords
     * const billingRecords = await prisma.billingRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingRecordWithIdOnly = await prisma.billingRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingRecordFindManyArgs>(args?: SelectSubset<T, BillingRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BillingRecord.
     * @param {BillingRecordCreateArgs} args - Arguments to create a BillingRecord.
     * @example
     * // Create one BillingRecord
     * const BillingRecord = await prisma.billingRecord.create({
     *   data: {
     *     // ... data to create a BillingRecord
     *   }
     * })
     * 
     */
    create<T extends BillingRecordCreateArgs>(args: SelectSubset<T, BillingRecordCreateArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BillingRecords.
     * @param {BillingRecordCreateManyArgs} args - Arguments to create many BillingRecords.
     * @example
     * // Create many BillingRecords
     * const billingRecord = await prisma.billingRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingRecordCreateManyArgs>(args?: SelectSubset<T, BillingRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingRecords and returns the data saved in the database.
     * @param {BillingRecordCreateManyAndReturnArgs} args - Arguments to create many BillingRecords.
     * @example
     * // Create many BillingRecords
     * const billingRecord = await prisma.billingRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingRecords and only return the `id`
     * const billingRecordWithIdOnly = await prisma.billingRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BillingRecord.
     * @param {BillingRecordDeleteArgs} args - Arguments to delete one BillingRecord.
     * @example
     * // Delete one BillingRecord
     * const BillingRecord = await prisma.billingRecord.delete({
     *   where: {
     *     // ... filter to delete one BillingRecord
     *   }
     * })
     * 
     */
    delete<T extends BillingRecordDeleteArgs>(args: SelectSubset<T, BillingRecordDeleteArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BillingRecord.
     * @param {BillingRecordUpdateArgs} args - Arguments to update one BillingRecord.
     * @example
     * // Update one BillingRecord
     * const billingRecord = await prisma.billingRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingRecordUpdateArgs>(args: SelectSubset<T, BillingRecordUpdateArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BillingRecords.
     * @param {BillingRecordDeleteManyArgs} args - Arguments to filter BillingRecords to delete.
     * @example
     * // Delete a few BillingRecords
     * const { count } = await prisma.billingRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingRecordDeleteManyArgs>(args?: SelectSubset<T, BillingRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingRecords
     * const billingRecord = await prisma.billingRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingRecordUpdateManyArgs>(args: SelectSubset<T, BillingRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BillingRecord.
     * @param {BillingRecordUpsertArgs} args - Arguments to update or create a BillingRecord.
     * @example
     * // Update or create a BillingRecord
     * const billingRecord = await prisma.billingRecord.upsert({
     *   create: {
     *     // ... data to create a BillingRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingRecord we want to update
     *   }
     * })
     */
    upsert<T extends BillingRecordUpsertArgs>(args: SelectSubset<T, BillingRecordUpsertArgs<ExtArgs>>): Prisma__BillingRecordClient<$Result.GetResult<Prisma.$BillingRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BillingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordCountArgs} args - Arguments to filter BillingRecords to count.
     * @example
     * // Count the number of BillingRecords
     * const count = await prisma.billingRecord.count({
     *   where: {
     *     // ... the filter for the BillingRecords we want to count
     *   }
     * })
    **/
    count<T extends BillingRecordCountArgs>(
      args?: Subset<T, BillingRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingRecordAggregateArgs>(args: Subset<T, BillingRecordAggregateArgs>): Prisma.PrismaPromise<GetBillingRecordAggregateType<T>>

    /**
     * Group by BillingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingRecordGroupByArgs['orderBy'] }
        : { orderBy?: BillingRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingRecord model
   */
  readonly fields: BillingRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends WorkspaceSubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceSubscriptionDefaultArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingRecord model
   */ 
  interface BillingRecordFieldRefs {
    readonly id: FieldRef<"BillingRecord", 'String'>
    readonly subscriptionId: FieldRef<"BillingRecord", 'String'>
    readonly amount: FieldRef<"BillingRecord", 'Decimal'>
    readonly currency: FieldRef<"BillingRecord", 'String'>
    readonly status: FieldRef<"BillingRecord", 'String'>
    readonly invoiceNumber: FieldRef<"BillingRecord", 'String'>
    readonly invoiceUrl: FieldRef<"BillingRecord", 'String'>
    readonly paymentMethod: FieldRef<"BillingRecord", 'String'>
    readonly paymentIntentId: FieldRef<"BillingRecord", 'String'>
    readonly failureReason: FieldRef<"BillingRecord", 'String'>
    readonly paidAt: FieldRef<"BillingRecord", 'DateTime'>
    readonly metadata: FieldRef<"BillingRecord", 'Json'>
    readonly createdAt: FieldRef<"BillingRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingRecord findUnique
   */
  export type BillingRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * Filter, which BillingRecord to fetch.
     */
    where: BillingRecordWhereUniqueInput
  }

  /**
   * BillingRecord findUniqueOrThrow
   */
  export type BillingRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * Filter, which BillingRecord to fetch.
     */
    where: BillingRecordWhereUniqueInput
  }

  /**
   * BillingRecord findFirst
   */
  export type BillingRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * Filter, which BillingRecord to fetch.
     */
    where?: BillingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRecords to fetch.
     */
    orderBy?: BillingRecordOrderByWithRelationInput | BillingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingRecords.
     */
    cursor?: BillingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingRecords.
     */
    distinct?: BillingRecordScalarFieldEnum | BillingRecordScalarFieldEnum[]
  }

  /**
   * BillingRecord findFirstOrThrow
   */
  export type BillingRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * Filter, which BillingRecord to fetch.
     */
    where?: BillingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRecords to fetch.
     */
    orderBy?: BillingRecordOrderByWithRelationInput | BillingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingRecords.
     */
    cursor?: BillingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingRecords.
     */
    distinct?: BillingRecordScalarFieldEnum | BillingRecordScalarFieldEnum[]
  }

  /**
   * BillingRecord findMany
   */
  export type BillingRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * Filter, which BillingRecords to fetch.
     */
    where?: BillingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingRecords to fetch.
     */
    orderBy?: BillingRecordOrderByWithRelationInput | BillingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingRecords.
     */
    cursor?: BillingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingRecords.
     */
    skip?: number
    distinct?: BillingRecordScalarFieldEnum | BillingRecordScalarFieldEnum[]
  }

  /**
   * BillingRecord create
   */
  export type BillingRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingRecord.
     */
    data: XOR<BillingRecordCreateInput, BillingRecordUncheckedCreateInput>
  }

  /**
   * BillingRecord createMany
   */
  export type BillingRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingRecords.
     */
    data: BillingRecordCreateManyInput | BillingRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingRecord createManyAndReturn
   */
  export type BillingRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BillingRecords.
     */
    data: BillingRecordCreateManyInput | BillingRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingRecord update
   */
  export type BillingRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingRecord.
     */
    data: XOR<BillingRecordUpdateInput, BillingRecordUncheckedUpdateInput>
    /**
     * Choose, which BillingRecord to update.
     */
    where: BillingRecordWhereUniqueInput
  }

  /**
   * BillingRecord updateMany
   */
  export type BillingRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingRecords.
     */
    data: XOR<BillingRecordUpdateManyMutationInput, BillingRecordUncheckedUpdateManyInput>
    /**
     * Filter which BillingRecords to update
     */
    where?: BillingRecordWhereInput
  }

  /**
   * BillingRecord upsert
   */
  export type BillingRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingRecord to update in case it exists.
     */
    where: BillingRecordWhereUniqueInput
    /**
     * In case the BillingRecord found by the `where` argument doesn't exist, create a new BillingRecord with this data.
     */
    create: XOR<BillingRecordCreateInput, BillingRecordUncheckedCreateInput>
    /**
     * In case the BillingRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingRecordUpdateInput, BillingRecordUncheckedUpdateInput>
  }

  /**
   * BillingRecord delete
   */
  export type BillingRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
    /**
     * Filter which BillingRecord to delete.
     */
    where: BillingRecordWhereUniqueInput
  }

  /**
   * BillingRecord deleteMany
   */
  export type BillingRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingRecords to delete
     */
    where?: BillingRecordWhereInput
  }

  /**
   * BillingRecord without action
   */
  export type BillingRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingRecord
     */
    select?: BillingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingRecordInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    expiryMonth: number | null
    expiryYear: number | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    expiryMonth: number | null
    expiryYear: number | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    type: string | null
    provider: string | null
    isDefault: boolean | null
    lastFour: string | null
    expiryMonth: number | null
    expiryYear: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    type: string | null
    provider: string | null
    isDefault: boolean | null
    lastFour: string | null
    expiryMonth: number | null
    expiryYear: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    workspaceId: number
    type: number
    provider: number
    isDefault: number
    lastFour: number
    expiryMonth: number
    expiryYear: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    expiryMonth?: true
    expiryYear?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    expiryMonth?: true
    expiryYear?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    workspaceId?: true
    type?: true
    provider?: true
    isDefault?: true
    lastFour?: true
    expiryMonth?: true
    expiryYear?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    type?: true
    provider?: true
    isDefault?: true
    lastFour?: true
    expiryMonth?: true
    expiryYear?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    workspaceId?: true
    type?: true
    provider?: true
    isDefault?: true
    lastFour?: true
    expiryMonth?: true
    expiryYear?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    workspaceId: string
    type: string
    provider: string
    isDefault: boolean
    lastFour: string | null
    expiryMonth: number | null
    expiryYear: number | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    type?: boolean
    provider?: boolean
    isDefault?: boolean
    lastFour?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    type?: boolean
    provider?: boolean
    isDefault?: boolean
    lastFour?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    type?: boolean
    provider?: boolean
    isDefault?: boolean
    lastFour?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      type: string
      provider: string
      isDefault: boolean
      lastFour: string | null
      expiryMonth: number | null
      expiryYear: number | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */ 
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly workspaceId: FieldRef<"PaymentMethod", 'String'>
    readonly type: FieldRef<"PaymentMethod", 'String'>
    readonly provider: FieldRef<"PaymentMethod", 'String'>
    readonly isDefault: FieldRef<"PaymentMethod", 'Boolean'>
    readonly lastFour: FieldRef<"PaymentMethod", 'String'>
    readonly expiryMonth: FieldRef<"PaymentMethod", 'Int'>
    readonly expiryYear: FieldRef<"PaymentMethod", 'Int'>
    readonly metadata: FieldRef<"PaymentMethod", 'Json'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
  }


  /**
   * Model ApiKeyManagement
   */

  export type AggregateApiKeyManagement = {
    _count: ApiKeyManagementCountAggregateOutputType | null
    _avg: ApiKeyManagementAvgAggregateOutputType | null
    _sum: ApiKeyManagementSumAggregateOutputType | null
    _min: ApiKeyManagementMinAggregateOutputType | null
    _max: ApiKeyManagementMaxAggregateOutputType | null
  }

  export type ApiKeyManagementAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type ApiKeyManagementSumAggregateOutputType = {
    usageCount: number | null
  }

  export type ApiKeyManagementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    keyHash: string | null
    keyPrefix: string | null
    encryptedKey: string | null
    isActive: boolean | null
    lastUsedAt: Date | null
    usageCount: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyManagementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    keyHash: string | null
    keyPrefix: string | null
    encryptedKey: string | null
    isActive: boolean | null
    lastUsedAt: Date | null
    usageCount: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyManagementCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    keyHash: number
    keyPrefix: number
    encryptedKey: number
    isActive: number
    lastUsedAt: number
    usageCount: number
    expiresAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiKeyManagementAvgAggregateInputType = {
    usageCount?: true
  }

  export type ApiKeyManagementSumAggregateInputType = {
    usageCount?: true
  }

  export type ApiKeyManagementMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    keyHash?: true
    keyPrefix?: true
    encryptedKey?: true
    isActive?: true
    lastUsedAt?: true
    usageCount?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyManagementMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    keyHash?: true
    keyPrefix?: true
    encryptedKey?: true
    isActive?: true
    lastUsedAt?: true
    usageCount?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyManagementCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    keyHash?: true
    keyPrefix?: true
    encryptedKey?: true
    isActive?: true
    lastUsedAt?: true
    usageCount?: true
    expiresAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiKeyManagementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeyManagement to aggregate.
     */
    where?: ApiKeyManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyManagements to fetch.
     */
    orderBy?: ApiKeyManagementOrderByWithRelationInput | ApiKeyManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeyManagements
    **/
    _count?: true | ApiKeyManagementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyManagementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeyManagementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyManagementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyManagementMaxAggregateInputType
  }

  export type GetApiKeyManagementAggregateType<T extends ApiKeyManagementAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKeyManagement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKeyManagement[P]>
      : GetScalarType<T[P], AggregateApiKeyManagement[P]>
  }




  export type ApiKeyManagementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyManagementWhereInput
    orderBy?: ApiKeyManagementOrderByWithAggregationInput | ApiKeyManagementOrderByWithAggregationInput[]
    by: ApiKeyManagementScalarFieldEnum[] | ApiKeyManagementScalarFieldEnum
    having?: ApiKeyManagementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyManagementCountAggregateInputType | true
    _avg?: ApiKeyManagementAvgAggregateInputType
    _sum?: ApiKeyManagementSumAggregateInputType
    _min?: ApiKeyManagementMinAggregateInputType
    _max?: ApiKeyManagementMaxAggregateInputType
  }

  export type ApiKeyManagementGroupByOutputType = {
    id: string
    userId: string
    provider: string
    keyHash: string
    keyPrefix: string
    encryptedKey: string
    isActive: boolean
    lastUsedAt: Date | null
    usageCount: number
    expiresAt: Date | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ApiKeyManagementCountAggregateOutputType | null
    _avg: ApiKeyManagementAvgAggregateOutputType | null
    _sum: ApiKeyManagementSumAggregateOutputType | null
    _min: ApiKeyManagementMinAggregateOutputType | null
    _max: ApiKeyManagementMaxAggregateOutputType | null
  }

  type GetApiKeyManagementGroupByPayload<T extends ApiKeyManagementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyManagementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyManagementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyManagementGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyManagementGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeyManagementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    encryptedKey?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    usageCount?: boolean
    expiresAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    usageLogs?: boolean | ApiKeyManagement$usageLogsArgs<ExtArgs>
    _count?: boolean | ApiKeyManagementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyManagement"]>

  export type ApiKeyManagementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    encryptedKey?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    usageCount?: boolean
    expiresAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyManagement"]>

  export type ApiKeyManagementSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    encryptedKey?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    usageCount?: boolean
    expiresAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApiKeyManagementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    usageLogs?: boolean | ApiKeyManagement$usageLogsArgs<ExtArgs>
    _count?: boolean | ApiKeyManagementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApiKeyManagementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApiKeyManagementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKeyManagement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      usageLogs: Prisma.$ApiKeyUsageLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: string
      keyHash: string
      keyPrefix: string
      encryptedKey: string
      isActive: boolean
      lastUsedAt: Date | null
      usageCount: number
      expiresAt: Date | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiKeyManagement"]>
    composites: {}
  }

  type ApiKeyManagementGetPayload<S extends boolean | null | undefined | ApiKeyManagementDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyManagementPayload, S>

  type ApiKeyManagementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyManagementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyManagementCountAggregateInputType | true
    }

  export interface ApiKeyManagementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKeyManagement'], meta: { name: 'ApiKeyManagement' } }
    /**
     * Find zero or one ApiKeyManagement that matches the filter.
     * @param {ApiKeyManagementFindUniqueArgs} args - Arguments to find a ApiKeyManagement
     * @example
     * // Get one ApiKeyManagement
     * const apiKeyManagement = await prisma.apiKeyManagement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyManagementFindUniqueArgs>(args: SelectSubset<T, ApiKeyManagementFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKeyManagement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyManagementFindUniqueOrThrowArgs} args - Arguments to find a ApiKeyManagement
     * @example
     * // Get one ApiKeyManagement
     * const apiKeyManagement = await prisma.apiKeyManagement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyManagementFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyManagementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKeyManagement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementFindFirstArgs} args - Arguments to find a ApiKeyManagement
     * @example
     * // Get one ApiKeyManagement
     * const apiKeyManagement = await prisma.apiKeyManagement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyManagementFindFirstArgs>(args?: SelectSubset<T, ApiKeyManagementFindFirstArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKeyManagement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementFindFirstOrThrowArgs} args - Arguments to find a ApiKeyManagement
     * @example
     * // Get one ApiKeyManagement
     * const apiKeyManagement = await prisma.apiKeyManagement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyManagementFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyManagementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeyManagements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeyManagements
     * const apiKeyManagements = await prisma.apiKeyManagement.findMany()
     * 
     * // Get first 10 ApiKeyManagements
     * const apiKeyManagements = await prisma.apiKeyManagement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyManagementWithIdOnly = await prisma.apiKeyManagement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyManagementFindManyArgs>(args?: SelectSubset<T, ApiKeyManagementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKeyManagement.
     * @param {ApiKeyManagementCreateArgs} args - Arguments to create a ApiKeyManagement.
     * @example
     * // Create one ApiKeyManagement
     * const ApiKeyManagement = await prisma.apiKeyManagement.create({
     *   data: {
     *     // ... data to create a ApiKeyManagement
     *   }
     * })
     * 
     */
    create<T extends ApiKeyManagementCreateArgs>(args: SelectSubset<T, ApiKeyManagementCreateArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeyManagements.
     * @param {ApiKeyManagementCreateManyArgs} args - Arguments to create many ApiKeyManagements.
     * @example
     * // Create many ApiKeyManagements
     * const apiKeyManagement = await prisma.apiKeyManagement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyManagementCreateManyArgs>(args?: SelectSubset<T, ApiKeyManagementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeyManagements and returns the data saved in the database.
     * @param {ApiKeyManagementCreateManyAndReturnArgs} args - Arguments to create many ApiKeyManagements.
     * @example
     * // Create many ApiKeyManagements
     * const apiKeyManagement = await prisma.apiKeyManagement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeyManagements and only return the `id`
     * const apiKeyManagementWithIdOnly = await prisma.apiKeyManagement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyManagementCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyManagementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKeyManagement.
     * @param {ApiKeyManagementDeleteArgs} args - Arguments to delete one ApiKeyManagement.
     * @example
     * // Delete one ApiKeyManagement
     * const ApiKeyManagement = await prisma.apiKeyManagement.delete({
     *   where: {
     *     // ... filter to delete one ApiKeyManagement
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyManagementDeleteArgs>(args: SelectSubset<T, ApiKeyManagementDeleteArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKeyManagement.
     * @param {ApiKeyManagementUpdateArgs} args - Arguments to update one ApiKeyManagement.
     * @example
     * // Update one ApiKeyManagement
     * const apiKeyManagement = await prisma.apiKeyManagement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyManagementUpdateArgs>(args: SelectSubset<T, ApiKeyManagementUpdateArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeyManagements.
     * @param {ApiKeyManagementDeleteManyArgs} args - Arguments to filter ApiKeyManagements to delete.
     * @example
     * // Delete a few ApiKeyManagements
     * const { count } = await prisma.apiKeyManagement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyManagementDeleteManyArgs>(args?: SelectSubset<T, ApiKeyManagementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeyManagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeyManagements
     * const apiKeyManagement = await prisma.apiKeyManagement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyManagementUpdateManyArgs>(args: SelectSubset<T, ApiKeyManagementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKeyManagement.
     * @param {ApiKeyManagementUpsertArgs} args - Arguments to update or create a ApiKeyManagement.
     * @example
     * // Update or create a ApiKeyManagement
     * const apiKeyManagement = await prisma.apiKeyManagement.upsert({
     *   create: {
     *     // ... data to create a ApiKeyManagement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKeyManagement we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyManagementUpsertArgs>(args: SelectSubset<T, ApiKeyManagementUpsertArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeyManagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementCountArgs} args - Arguments to filter ApiKeyManagements to count.
     * @example
     * // Count the number of ApiKeyManagements
     * const count = await prisma.apiKeyManagement.count({
     *   where: {
     *     // ... the filter for the ApiKeyManagements we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyManagementCountArgs>(
      args?: Subset<T, ApiKeyManagementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyManagementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKeyManagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyManagementAggregateArgs>(args: Subset<T, ApiKeyManagementAggregateArgs>): Prisma.PrismaPromise<GetApiKeyManagementAggregateType<T>>

    /**
     * Group by ApiKeyManagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyManagementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyManagementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyManagementGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyManagementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyManagementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyManagementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKeyManagement model
   */
  readonly fields: ApiKeyManagementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKeyManagement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyManagementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usageLogs<T extends ApiKeyManagement$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, ApiKeyManagement$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyUsageLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKeyManagement model
   */ 
  interface ApiKeyManagementFieldRefs {
    readonly id: FieldRef<"ApiKeyManagement", 'String'>
    readonly userId: FieldRef<"ApiKeyManagement", 'String'>
    readonly provider: FieldRef<"ApiKeyManagement", 'String'>
    readonly keyHash: FieldRef<"ApiKeyManagement", 'String'>
    readonly keyPrefix: FieldRef<"ApiKeyManagement", 'String'>
    readonly encryptedKey: FieldRef<"ApiKeyManagement", 'String'>
    readonly isActive: FieldRef<"ApiKeyManagement", 'Boolean'>
    readonly lastUsedAt: FieldRef<"ApiKeyManagement", 'DateTime'>
    readonly usageCount: FieldRef<"ApiKeyManagement", 'Int'>
    readonly expiresAt: FieldRef<"ApiKeyManagement", 'DateTime'>
    readonly metadata: FieldRef<"ApiKeyManagement", 'Json'>
    readonly createdAt: FieldRef<"ApiKeyManagement", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKeyManagement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKeyManagement findUnique
   */
  export type ApiKeyManagementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyManagement to fetch.
     */
    where: ApiKeyManagementWhereUniqueInput
  }

  /**
   * ApiKeyManagement findUniqueOrThrow
   */
  export type ApiKeyManagementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyManagement to fetch.
     */
    where: ApiKeyManagementWhereUniqueInput
  }

  /**
   * ApiKeyManagement findFirst
   */
  export type ApiKeyManagementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyManagement to fetch.
     */
    where?: ApiKeyManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyManagements to fetch.
     */
    orderBy?: ApiKeyManagementOrderByWithRelationInput | ApiKeyManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeyManagements.
     */
    cursor?: ApiKeyManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeyManagements.
     */
    distinct?: ApiKeyManagementScalarFieldEnum | ApiKeyManagementScalarFieldEnum[]
  }

  /**
   * ApiKeyManagement findFirstOrThrow
   */
  export type ApiKeyManagementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyManagement to fetch.
     */
    where?: ApiKeyManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyManagements to fetch.
     */
    orderBy?: ApiKeyManagementOrderByWithRelationInput | ApiKeyManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeyManagements.
     */
    cursor?: ApiKeyManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeyManagements.
     */
    distinct?: ApiKeyManagementScalarFieldEnum | ApiKeyManagementScalarFieldEnum[]
  }

  /**
   * ApiKeyManagement findMany
   */
  export type ApiKeyManagementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyManagements to fetch.
     */
    where?: ApiKeyManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyManagements to fetch.
     */
    orderBy?: ApiKeyManagementOrderByWithRelationInput | ApiKeyManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeyManagements.
     */
    cursor?: ApiKeyManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyManagements.
     */
    skip?: number
    distinct?: ApiKeyManagementScalarFieldEnum | ApiKeyManagementScalarFieldEnum[]
  }

  /**
   * ApiKeyManagement create
   */
  export type ApiKeyManagementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKeyManagement.
     */
    data: XOR<ApiKeyManagementCreateInput, ApiKeyManagementUncheckedCreateInput>
  }

  /**
   * ApiKeyManagement createMany
   */
  export type ApiKeyManagementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeyManagements.
     */
    data: ApiKeyManagementCreateManyInput | ApiKeyManagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKeyManagement createManyAndReturn
   */
  export type ApiKeyManagementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeyManagements.
     */
    data: ApiKeyManagementCreateManyInput | ApiKeyManagementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKeyManagement update
   */
  export type ApiKeyManagementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKeyManagement.
     */
    data: XOR<ApiKeyManagementUpdateInput, ApiKeyManagementUncheckedUpdateInput>
    /**
     * Choose, which ApiKeyManagement to update.
     */
    where: ApiKeyManagementWhereUniqueInput
  }

  /**
   * ApiKeyManagement updateMany
   */
  export type ApiKeyManagementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeyManagements.
     */
    data: XOR<ApiKeyManagementUpdateManyMutationInput, ApiKeyManagementUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeyManagements to update
     */
    where?: ApiKeyManagementWhereInput
  }

  /**
   * ApiKeyManagement upsert
   */
  export type ApiKeyManagementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKeyManagement to update in case it exists.
     */
    where: ApiKeyManagementWhereUniqueInput
    /**
     * In case the ApiKeyManagement found by the `where` argument doesn't exist, create a new ApiKeyManagement with this data.
     */
    create: XOR<ApiKeyManagementCreateInput, ApiKeyManagementUncheckedCreateInput>
    /**
     * In case the ApiKeyManagement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyManagementUpdateInput, ApiKeyManagementUncheckedUpdateInput>
  }

  /**
   * ApiKeyManagement delete
   */
  export type ApiKeyManagementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
    /**
     * Filter which ApiKeyManagement to delete.
     */
    where: ApiKeyManagementWhereUniqueInput
  }

  /**
   * ApiKeyManagement deleteMany
   */
  export type ApiKeyManagementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeyManagements to delete
     */
    where?: ApiKeyManagementWhereInput
  }

  /**
   * ApiKeyManagement.usageLogs
   */
  export type ApiKeyManagement$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsageLog
     */
    select?: ApiKeyUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageLogInclude<ExtArgs> | null
    where?: ApiKeyUsageLogWhereInput
    orderBy?: ApiKeyUsageLogOrderByWithRelationInput | ApiKeyUsageLogOrderByWithRelationInput[]
    cursor?: ApiKeyUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyUsageLogScalarFieldEnum | ApiKeyUsageLogScalarFieldEnum[]
  }

  /**
   * ApiKeyManagement without action
   */
  export type ApiKeyManagementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyManagement
     */
    select?: ApiKeyManagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyManagementInclude<ExtArgs> | null
  }


  /**
   * Model ApiKeyUsageLog
   */

  export type AggregateApiKeyUsageLog = {
    _count: ApiKeyUsageLogCountAggregateOutputType | null
    _avg: ApiKeyUsageLogAvgAggregateOutputType | null
    _sum: ApiKeyUsageLogSumAggregateOutputType | null
    _min: ApiKeyUsageLogMinAggregateOutputType | null
    _max: ApiKeyUsageLogMaxAggregateOutputType | null
  }

  export type ApiKeyUsageLogAvgAggregateOutputType = {
    statusCode: number | null
    responseTime: number | null
    tokensUsed: number | null
    cost: Decimal | null
  }

  export type ApiKeyUsageLogSumAggregateOutputType = {
    statusCode: number | null
    responseTime: number | null
    tokensUsed: number | null
    cost: Decimal | null
  }

  export type ApiKeyUsageLogMinAggregateOutputType = {
    id: string | null
    apiKeyId: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    tokensUsed: number | null
    cost: Decimal | null
    error: string | null
    createdAt: Date | null
  }

  export type ApiKeyUsageLogMaxAggregateOutputType = {
    id: string | null
    apiKeyId: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    tokensUsed: number | null
    cost: Decimal | null
    error: string | null
    createdAt: Date | null
  }

  export type ApiKeyUsageLogCountAggregateOutputType = {
    id: number
    apiKeyId: number
    endpoint: number
    method: number
    statusCode: number
    responseTime: number
    tokensUsed: number
    cost: number
    error: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ApiKeyUsageLogAvgAggregateInputType = {
    statusCode?: true
    responseTime?: true
    tokensUsed?: true
    cost?: true
  }

  export type ApiKeyUsageLogSumAggregateInputType = {
    statusCode?: true
    responseTime?: true
    tokensUsed?: true
    cost?: true
  }

  export type ApiKeyUsageLogMinAggregateInputType = {
    id?: true
    apiKeyId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    tokensUsed?: true
    cost?: true
    error?: true
    createdAt?: true
  }

  export type ApiKeyUsageLogMaxAggregateInputType = {
    id?: true
    apiKeyId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    tokensUsed?: true
    cost?: true
    error?: true
    createdAt?: true
  }

  export type ApiKeyUsageLogCountAggregateInputType = {
    id?: true
    apiKeyId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    tokensUsed?: true
    cost?: true
    error?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ApiKeyUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeyUsageLog to aggregate.
     */
    where?: ApiKeyUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyUsageLogs to fetch.
     */
    orderBy?: ApiKeyUsageLogOrderByWithRelationInput | ApiKeyUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeyUsageLogs
    **/
    _count?: true | ApiKeyUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeyUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyUsageLogMaxAggregateInputType
  }

  export type GetApiKeyUsageLogAggregateType<T extends ApiKeyUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKeyUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKeyUsageLog[P]>
      : GetScalarType<T[P], AggregateApiKeyUsageLog[P]>
  }




  export type ApiKeyUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyUsageLogWhereInput
    orderBy?: ApiKeyUsageLogOrderByWithAggregationInput | ApiKeyUsageLogOrderByWithAggregationInput[]
    by: ApiKeyUsageLogScalarFieldEnum[] | ApiKeyUsageLogScalarFieldEnum
    having?: ApiKeyUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyUsageLogCountAggregateInputType | true
    _avg?: ApiKeyUsageLogAvgAggregateInputType
    _sum?: ApiKeyUsageLogSumAggregateInputType
    _min?: ApiKeyUsageLogMinAggregateInputType
    _max?: ApiKeyUsageLogMaxAggregateInputType
  }

  export type ApiKeyUsageLogGroupByOutputType = {
    id: string
    apiKeyId: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    tokensUsed: number | null
    cost: Decimal | null
    error: string | null
    metadata: JsonValue
    createdAt: Date
    _count: ApiKeyUsageLogCountAggregateOutputType | null
    _avg: ApiKeyUsageLogAvgAggregateOutputType | null
    _sum: ApiKeyUsageLogSumAggregateOutputType | null
    _min: ApiKeyUsageLogMinAggregateOutputType | null
    _max: ApiKeyUsageLogMaxAggregateOutputType | null
  }

  type GetApiKeyUsageLogGroupByPayload<T extends ApiKeyUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeyUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiKeyId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    tokensUsed?: boolean
    cost?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    apiKey?: boolean | ApiKeyManagementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyUsageLog"]>

  export type ApiKeyUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiKeyId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    tokensUsed?: boolean
    cost?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    apiKey?: boolean | ApiKeyManagementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyUsageLog"]>

  export type ApiKeyUsageLogSelectScalar = {
    id?: boolean
    apiKeyId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    tokensUsed?: boolean
    cost?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ApiKeyUsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKey?: boolean | ApiKeyManagementDefaultArgs<ExtArgs>
  }
  export type ApiKeyUsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKey?: boolean | ApiKeyManagementDefaultArgs<ExtArgs>
  }

  export type $ApiKeyUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKeyUsageLog"
    objects: {
      apiKey: Prisma.$ApiKeyManagementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      apiKeyId: string
      endpoint: string
      method: string
      statusCode: number
      responseTime: number
      tokensUsed: number | null
      cost: Prisma.Decimal | null
      error: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["apiKeyUsageLog"]>
    composites: {}
  }

  type ApiKeyUsageLogGetPayload<S extends boolean | null | undefined | ApiKeyUsageLogDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyUsageLogPayload, S>

  type ApiKeyUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyUsageLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyUsageLogCountAggregateInputType | true
    }

  export interface ApiKeyUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKeyUsageLog'], meta: { name: 'ApiKeyUsageLog' } }
    /**
     * Find zero or one ApiKeyUsageLog that matches the filter.
     * @param {ApiKeyUsageLogFindUniqueArgs} args - Arguments to find a ApiKeyUsageLog
     * @example
     * // Get one ApiKeyUsageLog
     * const apiKeyUsageLog = await prisma.apiKeyUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyUsageLogFindUniqueArgs>(args: SelectSubset<T, ApiKeyUsageLogFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyUsageLogClient<$Result.GetResult<Prisma.$ApiKeyUsageLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKeyUsageLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyUsageLogFindUniqueOrThrowArgs} args - Arguments to find a ApiKeyUsageLog
     * @example
     * // Get one ApiKeyUsageLog
     * const apiKeyUsageLog = await prisma.apiKeyUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyUsageLogClient<$Result.GetResult<Prisma.$ApiKeyUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKeyUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageLogFindFirstArgs} args - Arguments to find a ApiKeyUsageLog
     * @example
     * // Get one ApiKeyUsageLog
     * const apiKeyUsageLog = await prisma.apiKeyUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyUsageLogFindFirstArgs>(args?: SelectSubset<T, ApiKeyUsageLogFindFirstArgs<ExtArgs>>): Prisma__ApiKeyUsageLogClient<$Result.GetResult<Prisma.$ApiKeyUsageLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKeyUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageLogFindFirstOrThrowArgs} args - Arguments to find a ApiKeyUsageLog
     * @example
     * // Get one ApiKeyUsageLog
     * const apiKeyUsageLog = await prisma.apiKeyUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyUsageLogClient<$Result.GetResult<Prisma.$ApiKeyUsageLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeyUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeyUsageLogs
     * const apiKeyUsageLogs = await prisma.apiKeyUsageLog.findMany()
     * 
     * // Get first 10 ApiKeyUsageLogs
     * const apiKeyUsageLogs = await prisma.apiKeyUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyUsageLogWithIdOnly = await prisma.apiKeyUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyUsageLogFindManyArgs>(args?: SelectSubset<T, ApiKeyUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyUsageLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKeyUsageLog.
     * @param {ApiKeyUsageLogCreateArgs} args - Arguments to create a ApiKeyUsageLog.
     * @example
     * // Create one ApiKeyUsageLog
     * const ApiKeyUsageLog = await prisma.apiKeyUsageLog.create({
     *   data: {
     *     // ... data to create a ApiKeyUsageLog
     *   }
     * })
     * 
     */
    create<T extends ApiKeyUsageLogCreateArgs>(args: SelectSubset<T, ApiKeyUsageLogCreateArgs<ExtArgs>>): Prisma__ApiKeyUsageLogClient<$Result.GetResult<Prisma.$ApiKeyUsageLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeyUsageLogs.
     * @param {ApiKeyUsageLogCreateManyArgs} args - Arguments to create many ApiKeyUsageLogs.
     * @example
     * // Create many ApiKeyUsageLogs
     * const apiKeyUsageLog = await prisma.apiKeyUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyUsageLogCreateManyArgs>(args?: SelectSubset<T, ApiKeyUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeyUsageLogs and returns the data saved in the database.
     * @param {ApiKeyUsageLogCreateManyAndReturnArgs} args - Arguments to create many ApiKeyUsageLogs.
     * @example
     * // Create many ApiKeyUsageLogs
     * const apiKeyUsageLog = await prisma.apiKeyUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeyUsageLogs and only return the `id`
     * const apiKeyUsageLogWithIdOnly = await prisma.apiKeyUsageLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyUsageLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKeyUsageLog.
     * @param {ApiKeyUsageLogDeleteArgs} args - Arguments to delete one ApiKeyUsageLog.
     * @example
     * // Delete one ApiKeyUsageLog
     * const ApiKeyUsageLog = await prisma.apiKeyUsageLog.delete({
     *   where: {
     *     // ... filter to delete one ApiKeyUsageLog
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyUsageLogDeleteArgs>(args: SelectSubset<T, ApiKeyUsageLogDeleteArgs<ExtArgs>>): Prisma__ApiKeyUsageLogClient<$Result.GetResult<Prisma.$ApiKeyUsageLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKeyUsageLog.
     * @param {ApiKeyUsageLogUpdateArgs} args - Arguments to update one ApiKeyUsageLog.
     * @example
     * // Update one ApiKeyUsageLog
     * const apiKeyUsageLog = await prisma.apiKeyUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUsageLogUpdateArgs>(args: SelectSubset<T, ApiKeyUsageLogUpdateArgs<ExtArgs>>): Prisma__ApiKeyUsageLogClient<$Result.GetResult<Prisma.$ApiKeyUsageLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeyUsageLogs.
     * @param {ApiKeyUsageLogDeleteManyArgs} args - Arguments to filter ApiKeyUsageLogs to delete.
     * @example
     * // Delete a few ApiKeyUsageLogs
     * const { count } = await prisma.apiKeyUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyUsageLogDeleteManyArgs>(args?: SelectSubset<T, ApiKeyUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeyUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeyUsageLogs
     * const apiKeyUsageLog = await prisma.apiKeyUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUsageLogUpdateManyArgs>(args: SelectSubset<T, ApiKeyUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKeyUsageLog.
     * @param {ApiKeyUsageLogUpsertArgs} args - Arguments to update or create a ApiKeyUsageLog.
     * @example
     * // Update or create a ApiKeyUsageLog
     * const apiKeyUsageLog = await prisma.apiKeyUsageLog.upsert({
     *   create: {
     *     // ... data to create a ApiKeyUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKeyUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUsageLogUpsertArgs>(args: SelectSubset<T, ApiKeyUsageLogUpsertArgs<ExtArgs>>): Prisma__ApiKeyUsageLogClient<$Result.GetResult<Prisma.$ApiKeyUsageLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeyUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageLogCountArgs} args - Arguments to filter ApiKeyUsageLogs to count.
     * @example
     * // Count the number of ApiKeyUsageLogs
     * const count = await prisma.apiKeyUsageLog.count({
     *   where: {
     *     // ... the filter for the ApiKeyUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyUsageLogCountArgs>(
      args?: Subset<T, ApiKeyUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKeyUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyUsageLogAggregateArgs>(args: Subset<T, ApiKeyUsageLogAggregateArgs>): Prisma.PrismaPromise<GetApiKeyUsageLogAggregateType<T>>

    /**
     * Group by ApiKeyUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKeyUsageLog model
   */
  readonly fields: ApiKeyUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKeyUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apiKey<T extends ApiKeyManagementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApiKeyManagementDefaultArgs<ExtArgs>>): Prisma__ApiKeyManagementClient<$Result.GetResult<Prisma.$ApiKeyManagementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKeyUsageLog model
   */ 
  interface ApiKeyUsageLogFieldRefs {
    readonly id: FieldRef<"ApiKeyUsageLog", 'String'>
    readonly apiKeyId: FieldRef<"ApiKeyUsageLog", 'String'>
    readonly endpoint: FieldRef<"ApiKeyUsageLog", 'String'>
    readonly method: FieldRef<"ApiKeyUsageLog", 'String'>
    readonly statusCode: FieldRef<"ApiKeyUsageLog", 'Int'>
    readonly responseTime: FieldRef<"ApiKeyUsageLog", 'Int'>
    readonly tokensUsed: FieldRef<"ApiKeyUsageLog", 'Int'>
    readonly cost: FieldRef<"ApiKeyUsageLog", 'Decimal'>
    readonly error: FieldRef<"ApiKeyUsageLog", 'String'>
    readonly metadata: FieldRef<"ApiKeyUsageLog", 'Json'>
    readonly createdAt: FieldRef<"ApiKeyUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKeyUsageLog findUnique
   */
  export type ApiKeyUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsageLog
     */
    select?: ApiKeyUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsageLog to fetch.
     */
    where: ApiKeyUsageLogWhereUniqueInput
  }

  /**
   * ApiKeyUsageLog findUniqueOrThrow
   */
  export type ApiKeyUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsageLog
     */
    select?: ApiKeyUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsageLog to fetch.
     */
    where: ApiKeyUsageLogWhereUniqueInput
  }

  /**
   * ApiKeyUsageLog findFirst
   */
  export type ApiKeyUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsageLog
     */
    select?: ApiKeyUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsageLog to fetch.
     */
    where?: ApiKeyUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyUsageLogs to fetch.
     */
    orderBy?: ApiKeyUsageLogOrderByWithRelationInput | ApiKeyUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeyUsageLogs.
     */
    cursor?: ApiKeyUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeyUsageLogs.
     */
    distinct?: ApiKeyUsageLogScalarFieldEnum | ApiKeyUsageLogScalarFieldEnum[]
  }

  /**
   * ApiKeyUsageLog findFirstOrThrow
   */
  export type ApiKeyUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsageLog
     */
    select?: ApiKeyUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsageLog to fetch.
     */
    where?: ApiKeyUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyUsageLogs to fetch.
     */
    orderBy?: ApiKeyUsageLogOrderByWithRelationInput | ApiKeyUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeyUsageLogs.
     */
    cursor?: ApiKeyUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeyUsageLogs.
     */
    distinct?: ApiKeyUsageLogScalarFieldEnum | ApiKeyUsageLogScalarFieldEnum[]
  }

  /**
   * ApiKeyUsageLog findMany
   */
  export type ApiKeyUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsageLog
     */
    select?: ApiKeyUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsageLogs to fetch.
     */
    where?: ApiKeyUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyUsageLogs to fetch.
     */
    orderBy?: ApiKeyUsageLogOrderByWithRelationInput | ApiKeyUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeyUsageLogs.
     */
    cursor?: ApiKeyUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyUsageLogs.
     */
    skip?: number
    distinct?: ApiKeyUsageLogScalarFieldEnum | ApiKeyUsageLogScalarFieldEnum[]
  }

  /**
   * ApiKeyUsageLog create
   */
  export type ApiKeyUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsageLog
     */
    select?: ApiKeyUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKeyUsageLog.
     */
    data: XOR<ApiKeyUsageLogCreateInput, ApiKeyUsageLogUncheckedCreateInput>
  }

  /**
   * ApiKeyUsageLog createMany
   */
  export type ApiKeyUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeyUsageLogs.
     */
    data: ApiKeyUsageLogCreateManyInput | ApiKeyUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKeyUsageLog createManyAndReturn
   */
  export type ApiKeyUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsageLog
     */
    select?: ApiKeyUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeyUsageLogs.
     */
    data: ApiKeyUsageLogCreateManyInput | ApiKeyUsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKeyUsageLog update
   */
  export type ApiKeyUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsageLog
     */
    select?: ApiKeyUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKeyUsageLog.
     */
    data: XOR<ApiKeyUsageLogUpdateInput, ApiKeyUsageLogUncheckedUpdateInput>
    /**
     * Choose, which ApiKeyUsageLog to update.
     */
    where: ApiKeyUsageLogWhereUniqueInput
  }

  /**
   * ApiKeyUsageLog updateMany
   */
  export type ApiKeyUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeyUsageLogs.
     */
    data: XOR<ApiKeyUsageLogUpdateManyMutationInput, ApiKeyUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeyUsageLogs to update
     */
    where?: ApiKeyUsageLogWhereInput
  }

  /**
   * ApiKeyUsageLog upsert
   */
  export type ApiKeyUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsageLog
     */
    select?: ApiKeyUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKeyUsageLog to update in case it exists.
     */
    where: ApiKeyUsageLogWhereUniqueInput
    /**
     * In case the ApiKeyUsageLog found by the `where` argument doesn't exist, create a new ApiKeyUsageLog with this data.
     */
    create: XOR<ApiKeyUsageLogCreateInput, ApiKeyUsageLogUncheckedCreateInput>
    /**
     * In case the ApiKeyUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUsageLogUpdateInput, ApiKeyUsageLogUncheckedUpdateInput>
  }

  /**
   * ApiKeyUsageLog delete
   */
  export type ApiKeyUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsageLog
     */
    select?: ApiKeyUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageLogInclude<ExtArgs> | null
    /**
     * Filter which ApiKeyUsageLog to delete.
     */
    where: ApiKeyUsageLogWhereUniqueInput
  }

  /**
   * ApiKeyUsageLog deleteMany
   */
  export type ApiKeyUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeyUsageLogs to delete
     */
    where?: ApiKeyUsageLogWhereInput
  }

  /**
   * ApiKeyUsageLog without action
   */
  export type ApiKeyUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsageLog
     */
    select?: ApiKeyUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageLogInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsMinAggregateOutputType = {
    userId: string | null
    openaiApiKeyEncrypted: string | null
    elevenlabsApiKeyEncrypted: string | null
    preferredLanguage: string | null
    summaryQuality: string | null
    theme: string | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    userId: string | null
    openaiApiKeyEncrypted: string | null
    elevenlabsApiKeyEncrypted: string | null
    preferredLanguage: string | null
    summaryQuality: string | null
    theme: string | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    userId: number
    openaiApiKeyEncrypted: number
    elevenlabsApiKeyEncrypted: number
    preferredLanguage: number
    summaryQuality: number
    theme: number
    notifications: number
    privacy: number
    settingsJson: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsMinAggregateInputType = {
    userId?: true
    openaiApiKeyEncrypted?: true
    elevenlabsApiKeyEncrypted?: true
    preferredLanguage?: true
    summaryQuality?: true
    theme?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    userId?: true
    openaiApiKeyEncrypted?: true
    elevenlabsApiKeyEncrypted?: true
    preferredLanguage?: true
    summaryQuality?: true
    theme?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    userId?: true
    openaiApiKeyEncrypted?: true
    elevenlabsApiKeyEncrypted?: true
    preferredLanguage?: true
    summaryQuality?: true
    theme?: true
    notifications?: true
    privacy?: true
    settingsJson?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    userId: string
    openaiApiKeyEncrypted: string | null
    elevenlabsApiKeyEncrypted: string | null
    preferredLanguage: string
    summaryQuality: string
    theme: string
    notifications: JsonValue
    privacy: JsonValue
    settingsJson: JsonValue
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    openaiApiKeyEncrypted?: boolean
    elevenlabsApiKeyEncrypted?: boolean
    preferredLanguage?: boolean
    summaryQuality?: boolean
    theme?: boolean
    notifications?: boolean
    privacy?: boolean
    settingsJson?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    openaiApiKeyEncrypted?: boolean
    elevenlabsApiKeyEncrypted?: boolean
    preferredLanguage?: boolean
    summaryQuality?: boolean
    theme?: boolean
    notifications?: boolean
    privacy?: boolean
    settingsJson?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    userId?: boolean
    openaiApiKeyEncrypted?: boolean
    elevenlabsApiKeyEncrypted?: boolean
    preferredLanguage?: boolean
    summaryQuality?: boolean
    theme?: boolean
    notifications?: boolean
    privacy?: boolean
    settingsJson?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      openaiApiKeyEncrypted: string | null
      elevenlabsApiKeyEncrypted: string | null
      preferredLanguage: string
      summaryQuality: string
      theme: string
      notifications: Prisma.JsonValue
      privacy: Prisma.JsonValue
      settingsJson: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSettingsWithUserIdOnly = await prisma.userSettings.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `userId`
     * const userSettingsWithUserIdOnly = await prisma.userSettings.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */ 
  interface UserSettingsFieldRefs {
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly openaiApiKeyEncrypted: FieldRef<"UserSettings", 'String'>
    readonly elevenlabsApiKeyEncrypted: FieldRef<"UserSettings", 'String'>
    readonly preferredLanguage: FieldRef<"UserSettings", 'String'>
    readonly summaryQuality: FieldRef<"UserSettings", 'String'>
    readonly theme: FieldRef<"UserSettings", 'String'>
    readonly notifications: FieldRef<"UserSettings", 'Json'>
    readonly privacy: FieldRef<"UserSettings", 'Json'>
    readonly settingsJson: FieldRef<"UserSettings", 'Json'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model UsageMetric
   */

  export type AggregateUsageMetric = {
    _count: UsageMetricCountAggregateOutputType | null
    _avg: UsageMetricAvgAggregateOutputType | null
    _sum: UsageMetricSumAggregateOutputType | null
    _min: UsageMetricMinAggregateOutputType | null
    _max: UsageMetricMaxAggregateOutputType | null
  }

  export type UsageMetricAvgAggregateOutputType = {
    value: number | null
  }

  export type UsageMetricSumAggregateOutputType = {
    value: bigint | null
  }

  export type UsageMetricMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    metricType: string | null
    value: bigint | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
  }

  export type UsageMetricMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    metricType: string | null
    value: bigint | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
  }

  export type UsageMetricCountAggregateOutputType = {
    id: number
    workspaceId: number
    metricType: number
    value: number
    period: number
    periodStart: number
    periodEnd: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type UsageMetricAvgAggregateInputType = {
    value?: true
  }

  export type UsageMetricSumAggregateInputType = {
    value?: true
  }

  export type UsageMetricMinAggregateInputType = {
    id?: true
    workspaceId?: true
    metricType?: true
    value?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
  }

  export type UsageMetricMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    metricType?: true
    value?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
  }

  export type UsageMetricCountAggregateInputType = {
    id?: true
    workspaceId?: true
    metricType?: true
    value?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type UsageMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageMetric to aggregate.
     */
    where?: UsageMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageMetrics
    **/
    _count?: true | UsageMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageMetricMaxAggregateInputType
  }

  export type GetUsageMetricAggregateType<T extends UsageMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageMetric[P]>
      : GetScalarType<T[P], AggregateUsageMetric[P]>
  }




  export type UsageMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageMetricWhereInput
    orderBy?: UsageMetricOrderByWithAggregationInput | UsageMetricOrderByWithAggregationInput[]
    by: UsageMetricScalarFieldEnum[] | UsageMetricScalarFieldEnum
    having?: UsageMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageMetricCountAggregateInputType | true
    _avg?: UsageMetricAvgAggregateInputType
    _sum?: UsageMetricSumAggregateInputType
    _min?: UsageMetricMinAggregateInputType
    _max?: UsageMetricMaxAggregateInputType
  }

  export type UsageMetricGroupByOutputType = {
    id: string
    workspaceId: string
    metricType: string
    value: bigint
    period: string
    periodStart: Date
    periodEnd: Date
    metadata: JsonValue
    createdAt: Date
    _count: UsageMetricCountAggregateOutputType | null
    _avg: UsageMetricAvgAggregateOutputType | null
    _sum: UsageMetricSumAggregateOutputType | null
    _min: UsageMetricMinAggregateOutputType | null
    _max: UsageMetricMaxAggregateOutputType | null
  }

  type GetUsageMetricGroupByPayload<T extends UsageMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageMetricGroupByOutputType[P]>
            : GetScalarType<T[P], UsageMetricGroupByOutputType[P]>
        }
      >
    >


  export type UsageMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    metricType?: boolean
    value?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["usageMetric"]>

  export type UsageMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    metricType?: boolean
    value?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["usageMetric"]>

  export type UsageMetricSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    metricType?: boolean
    value?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
  }


  export type $UsageMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      metricType: string
      value: bigint
      period: string
      periodStart: Date
      periodEnd: Date
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["usageMetric"]>
    composites: {}
  }

  type UsageMetricGetPayload<S extends boolean | null | undefined | UsageMetricDefaultArgs> = $Result.GetResult<Prisma.$UsageMetricPayload, S>

  type UsageMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsageMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsageMetricCountAggregateInputType | true
    }

  export interface UsageMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageMetric'], meta: { name: 'UsageMetric' } }
    /**
     * Find zero or one UsageMetric that matches the filter.
     * @param {UsageMetricFindUniqueArgs} args - Arguments to find a UsageMetric
     * @example
     * // Get one UsageMetric
     * const usageMetric = await prisma.usageMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageMetricFindUniqueArgs>(args: SelectSubset<T, UsageMetricFindUniqueArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsageMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsageMetricFindUniqueOrThrowArgs} args - Arguments to find a UsageMetric
     * @example
     * // Get one UsageMetric
     * const usageMetric = await prisma.usageMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsageMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricFindFirstArgs} args - Arguments to find a UsageMetric
     * @example
     * // Get one UsageMetric
     * const usageMetric = await prisma.usageMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageMetricFindFirstArgs>(args?: SelectSubset<T, UsageMetricFindFirstArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsageMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricFindFirstOrThrowArgs} args - Arguments to find a UsageMetric
     * @example
     * // Get one UsageMetric
     * const usageMetric = await prisma.usageMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsageMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageMetrics
     * const usageMetrics = await prisma.usageMetric.findMany()
     * 
     * // Get first 10 UsageMetrics
     * const usageMetrics = await prisma.usageMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageMetricWithIdOnly = await prisma.usageMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageMetricFindManyArgs>(args?: SelectSubset<T, UsageMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsageMetric.
     * @param {UsageMetricCreateArgs} args - Arguments to create a UsageMetric.
     * @example
     * // Create one UsageMetric
     * const UsageMetric = await prisma.usageMetric.create({
     *   data: {
     *     // ... data to create a UsageMetric
     *   }
     * })
     * 
     */
    create<T extends UsageMetricCreateArgs>(args: SelectSubset<T, UsageMetricCreateArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsageMetrics.
     * @param {UsageMetricCreateManyArgs} args - Arguments to create many UsageMetrics.
     * @example
     * // Create many UsageMetrics
     * const usageMetric = await prisma.usageMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageMetricCreateManyArgs>(args?: SelectSubset<T, UsageMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageMetrics and returns the data saved in the database.
     * @param {UsageMetricCreateManyAndReturnArgs} args - Arguments to create many UsageMetrics.
     * @example
     * // Create many UsageMetrics
     * const usageMetric = await prisma.usageMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageMetrics and only return the `id`
     * const usageMetricWithIdOnly = await prisma.usageMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsageMetric.
     * @param {UsageMetricDeleteArgs} args - Arguments to delete one UsageMetric.
     * @example
     * // Delete one UsageMetric
     * const UsageMetric = await prisma.usageMetric.delete({
     *   where: {
     *     // ... filter to delete one UsageMetric
     *   }
     * })
     * 
     */
    delete<T extends UsageMetricDeleteArgs>(args: SelectSubset<T, UsageMetricDeleteArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsageMetric.
     * @param {UsageMetricUpdateArgs} args - Arguments to update one UsageMetric.
     * @example
     * // Update one UsageMetric
     * const usageMetric = await prisma.usageMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageMetricUpdateArgs>(args: SelectSubset<T, UsageMetricUpdateArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsageMetrics.
     * @param {UsageMetricDeleteManyArgs} args - Arguments to filter UsageMetrics to delete.
     * @example
     * // Delete a few UsageMetrics
     * const { count } = await prisma.usageMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageMetricDeleteManyArgs>(args?: SelectSubset<T, UsageMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageMetrics
     * const usageMetric = await prisma.usageMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageMetricUpdateManyArgs>(args: SelectSubset<T, UsageMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageMetric.
     * @param {UsageMetricUpsertArgs} args - Arguments to update or create a UsageMetric.
     * @example
     * // Update or create a UsageMetric
     * const usageMetric = await prisma.usageMetric.upsert({
     *   create: {
     *     // ... data to create a UsageMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageMetric we want to update
     *   }
     * })
     */
    upsert<T extends UsageMetricUpsertArgs>(args: SelectSubset<T, UsageMetricUpsertArgs<ExtArgs>>): Prisma__UsageMetricClient<$Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricCountArgs} args - Arguments to filter UsageMetrics to count.
     * @example
     * // Count the number of UsageMetrics
     * const count = await prisma.usageMetric.count({
     *   where: {
     *     // ... the filter for the UsageMetrics we want to count
     *   }
     * })
    **/
    count<T extends UsageMetricCountArgs>(
      args?: Subset<T, UsageMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageMetricAggregateArgs>(args: Subset<T, UsageMetricAggregateArgs>): Prisma.PrismaPromise<GetUsageMetricAggregateType<T>>

    /**
     * Group by UsageMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageMetricGroupByArgs['orderBy'] }
        : { orderBy?: UsageMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageMetric model
   */
  readonly fields: UsageMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageMetric model
   */ 
  interface UsageMetricFieldRefs {
    readonly id: FieldRef<"UsageMetric", 'String'>
    readonly workspaceId: FieldRef<"UsageMetric", 'String'>
    readonly metricType: FieldRef<"UsageMetric", 'String'>
    readonly value: FieldRef<"UsageMetric", 'BigInt'>
    readonly period: FieldRef<"UsageMetric", 'String'>
    readonly periodStart: FieldRef<"UsageMetric", 'DateTime'>
    readonly periodEnd: FieldRef<"UsageMetric", 'DateTime'>
    readonly metadata: FieldRef<"UsageMetric", 'Json'>
    readonly createdAt: FieldRef<"UsageMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageMetric findUnique
   */
  export type UsageMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Filter, which UsageMetric to fetch.
     */
    where: UsageMetricWhereUniqueInput
  }

  /**
   * UsageMetric findUniqueOrThrow
   */
  export type UsageMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Filter, which UsageMetric to fetch.
     */
    where: UsageMetricWhereUniqueInput
  }

  /**
   * UsageMetric findFirst
   */
  export type UsageMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Filter, which UsageMetric to fetch.
     */
    where?: UsageMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageMetrics.
     */
    cursor?: UsageMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageMetrics.
     */
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[]
  }

  /**
   * UsageMetric findFirstOrThrow
   */
  export type UsageMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Filter, which UsageMetric to fetch.
     */
    where?: UsageMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageMetrics.
     */
    cursor?: UsageMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageMetrics.
     */
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[]
  }

  /**
   * UsageMetric findMany
   */
  export type UsageMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Filter, which UsageMetrics to fetch.
     */
    where?: UsageMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageMetrics.
     */
    cursor?: UsageMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMetrics.
     */
    skip?: number
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[]
  }

  /**
   * UsageMetric create
   */
  export type UsageMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * The data needed to create a UsageMetric.
     */
    data: XOR<UsageMetricCreateInput, UsageMetricUncheckedCreateInput>
  }

  /**
   * UsageMetric createMany
   */
  export type UsageMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageMetrics.
     */
    data: UsageMetricCreateManyInput | UsageMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageMetric createManyAndReturn
   */
  export type UsageMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsageMetrics.
     */
    data: UsageMetricCreateManyInput | UsageMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageMetric update
   */
  export type UsageMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * The data needed to update a UsageMetric.
     */
    data: XOR<UsageMetricUpdateInput, UsageMetricUncheckedUpdateInput>
    /**
     * Choose, which UsageMetric to update.
     */
    where: UsageMetricWhereUniqueInput
  }

  /**
   * UsageMetric updateMany
   */
  export type UsageMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageMetrics.
     */
    data: XOR<UsageMetricUpdateManyMutationInput, UsageMetricUncheckedUpdateManyInput>
    /**
     * Filter which UsageMetrics to update
     */
    where?: UsageMetricWhereInput
  }

  /**
   * UsageMetric upsert
   */
  export type UsageMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * The filter to search for the UsageMetric to update in case it exists.
     */
    where: UsageMetricWhereUniqueInput
    /**
     * In case the UsageMetric found by the `where` argument doesn't exist, create a new UsageMetric with this data.
     */
    create: XOR<UsageMetricCreateInput, UsageMetricUncheckedCreateInput>
    /**
     * In case the UsageMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageMetricUpdateInput, UsageMetricUncheckedUpdateInput>
  }

  /**
   * UsageMetric delete
   */
  export type UsageMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
    /**
     * Filter which UsageMetric to delete.
     */
    where: UsageMetricWhereUniqueInput
  }

  /**
   * UsageMetric deleteMany
   */
  export type UsageMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageMetrics to delete
     */
    where?: UsageMetricWhereInput
  }

  /**
   * UsageMetric without action
   */
  export type UsageMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null
  }


  /**
   * Model UserQuota
   */

  export type AggregateUserQuota = {
    _count: UserQuotaCountAggregateOutputType | null
    _avg: UserQuotaAvgAggregateOutputType | null
    _sum: UserQuotaSumAggregateOutputType | null
    _min: UserQuotaMinAggregateOutputType | null
    _max: UserQuotaMaxAggregateOutputType | null
  }

  export type UserQuotaAvgAggregateOutputType = {
    used: number | null
    limit: number | null
  }

  export type UserQuotaSumAggregateOutputType = {
    used: bigint | null
    limit: bigint | null
  }

  export type UserQuotaMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    quotaType: string | null
    used: bigint | null
    limit: bigint | null
    resetPeriod: string | null
    nextResetAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserQuotaMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    quotaType: string | null
    used: bigint | null
    limit: bigint | null
    resetPeriod: string | null
    nextResetAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserQuotaCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    quotaType: number
    used: number
    limit: number
    resetPeriod: number
    nextResetAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserQuotaAvgAggregateInputType = {
    used?: true
    limit?: true
  }

  export type UserQuotaSumAggregateInputType = {
    used?: true
    limit?: true
  }

  export type UserQuotaMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    quotaType?: true
    used?: true
    limit?: true
    resetPeriod?: true
    nextResetAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserQuotaMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    quotaType?: true
    used?: true
    limit?: true
    resetPeriod?: true
    nextResetAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserQuotaCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    quotaType?: true
    used?: true
    limit?: true
    resetPeriod?: true
    nextResetAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuota to aggregate.
     */
    where?: UserQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuotas to fetch.
     */
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserQuotas
    **/
    _count?: true | UserQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserQuotaMaxAggregateInputType
  }

  export type GetUserQuotaAggregateType<T extends UserQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateUserQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserQuota[P]>
      : GetScalarType<T[P], AggregateUserQuota[P]>
  }




  export type UserQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuotaWhereInput
    orderBy?: UserQuotaOrderByWithAggregationInput | UserQuotaOrderByWithAggregationInput[]
    by: UserQuotaScalarFieldEnum[] | UserQuotaScalarFieldEnum
    having?: UserQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserQuotaCountAggregateInputType | true
    _avg?: UserQuotaAvgAggregateInputType
    _sum?: UserQuotaSumAggregateInputType
    _min?: UserQuotaMinAggregateInputType
    _max?: UserQuotaMaxAggregateInputType
  }

  export type UserQuotaGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string
    quotaType: string
    used: bigint
    limit: bigint
    resetPeriod: string
    nextResetAt: Date
    createdAt: Date
    updatedAt: Date
    _count: UserQuotaCountAggregateOutputType | null
    _avg: UserQuotaAvgAggregateOutputType | null
    _sum: UserQuotaSumAggregateOutputType | null
    _min: UserQuotaMinAggregateOutputType | null
    _max: UserQuotaMaxAggregateOutputType | null
  }

  type GetUserQuotaGroupByPayload<T extends UserQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], UserQuotaGroupByOutputType[P]>
        }
      >
    >


  export type UserQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    quotaType?: boolean
    used?: boolean
    limit?: boolean
    resetPeriod?: boolean
    nextResetAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuota"]>

  export type UserQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    quotaType?: boolean
    used?: boolean
    limit?: boolean
    resetPeriod?: boolean
    nextResetAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuota"]>

  export type UserQuotaSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    quotaType?: boolean
    used?: boolean
    limit?: boolean
    resetPeriod?: boolean
    nextResetAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserQuotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserQuotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserQuota"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string
      quotaType: string
      used: bigint
      limit: bigint
      resetPeriod: string
      nextResetAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userQuota"]>
    composites: {}
  }

  type UserQuotaGetPayload<S extends boolean | null | undefined | UserQuotaDefaultArgs> = $Result.GetResult<Prisma.$UserQuotaPayload, S>

  type UserQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserQuotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserQuotaCountAggregateInputType | true
    }

  export interface UserQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserQuota'], meta: { name: 'UserQuota' } }
    /**
     * Find zero or one UserQuota that matches the filter.
     * @param {UserQuotaFindUniqueArgs} args - Arguments to find a UserQuota
     * @example
     * // Get one UserQuota
     * const userQuota = await prisma.userQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserQuotaFindUniqueArgs>(args: SelectSubset<T, UserQuotaFindUniqueArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserQuota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserQuotaFindUniqueOrThrowArgs} args - Arguments to find a UserQuota
     * @example
     * // Get one UserQuota
     * const userQuota = await prisma.userQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, UserQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaFindFirstArgs} args - Arguments to find a UserQuota
     * @example
     * // Get one UserQuota
     * const userQuota = await prisma.userQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserQuotaFindFirstArgs>(args?: SelectSubset<T, UserQuotaFindFirstArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaFindFirstOrThrowArgs} args - Arguments to find a UserQuota
     * @example
     * // Get one UserQuota
     * const userQuota = await prisma.userQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, UserQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserQuotas
     * const userQuotas = await prisma.userQuota.findMany()
     * 
     * // Get first 10 UserQuotas
     * const userQuotas = await prisma.userQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userQuotaWithIdOnly = await prisma.userQuota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserQuotaFindManyArgs>(args?: SelectSubset<T, UserQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserQuota.
     * @param {UserQuotaCreateArgs} args - Arguments to create a UserQuota.
     * @example
     * // Create one UserQuota
     * const UserQuota = await prisma.userQuota.create({
     *   data: {
     *     // ... data to create a UserQuota
     *   }
     * })
     * 
     */
    create<T extends UserQuotaCreateArgs>(args: SelectSubset<T, UserQuotaCreateArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserQuotas.
     * @param {UserQuotaCreateManyArgs} args - Arguments to create many UserQuotas.
     * @example
     * // Create many UserQuotas
     * const userQuota = await prisma.userQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserQuotaCreateManyArgs>(args?: SelectSubset<T, UserQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserQuotas and returns the data saved in the database.
     * @param {UserQuotaCreateManyAndReturnArgs} args - Arguments to create many UserQuotas.
     * @example
     * // Create many UserQuotas
     * const userQuota = await prisma.userQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserQuotas and only return the `id`
     * const userQuotaWithIdOnly = await prisma.userQuota.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, UserQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserQuota.
     * @param {UserQuotaDeleteArgs} args - Arguments to delete one UserQuota.
     * @example
     * // Delete one UserQuota
     * const UserQuota = await prisma.userQuota.delete({
     *   where: {
     *     // ... filter to delete one UserQuota
     *   }
     * })
     * 
     */
    delete<T extends UserQuotaDeleteArgs>(args: SelectSubset<T, UserQuotaDeleteArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserQuota.
     * @param {UserQuotaUpdateArgs} args - Arguments to update one UserQuota.
     * @example
     * // Update one UserQuota
     * const userQuota = await prisma.userQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserQuotaUpdateArgs>(args: SelectSubset<T, UserQuotaUpdateArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserQuotas.
     * @param {UserQuotaDeleteManyArgs} args - Arguments to filter UserQuotas to delete.
     * @example
     * // Delete a few UserQuotas
     * const { count } = await prisma.userQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserQuotaDeleteManyArgs>(args?: SelectSubset<T, UserQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserQuotas
     * const userQuota = await prisma.userQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserQuotaUpdateManyArgs>(args: SelectSubset<T, UserQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserQuota.
     * @param {UserQuotaUpsertArgs} args - Arguments to update or create a UserQuota.
     * @example
     * // Update or create a UserQuota
     * const userQuota = await prisma.userQuota.upsert({
     *   create: {
     *     // ... data to create a UserQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserQuota we want to update
     *   }
     * })
     */
    upsert<T extends UserQuotaUpsertArgs>(args: SelectSubset<T, UserQuotaUpsertArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaCountArgs} args - Arguments to filter UserQuotas to count.
     * @example
     * // Count the number of UserQuotas
     * const count = await prisma.userQuota.count({
     *   where: {
     *     // ... the filter for the UserQuotas we want to count
     *   }
     * })
    **/
    count<T extends UserQuotaCountArgs>(
      args?: Subset<T, UserQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserQuotaAggregateArgs>(args: Subset<T, UserQuotaAggregateArgs>): Prisma.PrismaPromise<GetUserQuotaAggregateType<T>>

    /**
     * Group by UserQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserQuotaGroupByArgs['orderBy'] }
        : { orderBy?: UserQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserQuota model
   */
  readonly fields: UserQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserQuota model
   */ 
  interface UserQuotaFieldRefs {
    readonly id: FieldRef<"UserQuota", 'String'>
    readonly userId: FieldRef<"UserQuota", 'String'>
    readonly workspaceId: FieldRef<"UserQuota", 'String'>
    readonly quotaType: FieldRef<"UserQuota", 'String'>
    readonly used: FieldRef<"UserQuota", 'BigInt'>
    readonly limit: FieldRef<"UserQuota", 'BigInt'>
    readonly resetPeriod: FieldRef<"UserQuota", 'String'>
    readonly nextResetAt: FieldRef<"UserQuota", 'DateTime'>
    readonly createdAt: FieldRef<"UserQuota", 'DateTime'>
    readonly updatedAt: FieldRef<"UserQuota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserQuota findUnique
   */
  export type UserQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UserQuota to fetch.
     */
    where: UserQuotaWhereUniqueInput
  }

  /**
   * UserQuota findUniqueOrThrow
   */
  export type UserQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UserQuota to fetch.
     */
    where: UserQuotaWhereUniqueInput
  }

  /**
   * UserQuota findFirst
   */
  export type UserQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UserQuota to fetch.
     */
    where?: UserQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuotas to fetch.
     */
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuotas.
     */
    cursor?: UserQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuotas.
     */
    distinct?: UserQuotaScalarFieldEnum | UserQuotaScalarFieldEnum[]
  }

  /**
   * UserQuota findFirstOrThrow
   */
  export type UserQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UserQuota to fetch.
     */
    where?: UserQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuotas to fetch.
     */
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuotas.
     */
    cursor?: UserQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuotas.
     */
    distinct?: UserQuotaScalarFieldEnum | UserQuotaScalarFieldEnum[]
  }

  /**
   * UserQuota findMany
   */
  export type UserQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UserQuotas to fetch.
     */
    where?: UserQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuotas to fetch.
     */
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserQuotas.
     */
    cursor?: UserQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuotas.
     */
    skip?: number
    distinct?: UserQuotaScalarFieldEnum | UserQuotaScalarFieldEnum[]
  }

  /**
   * UserQuota create
   */
  export type UserQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a UserQuota.
     */
    data: XOR<UserQuotaCreateInput, UserQuotaUncheckedCreateInput>
  }

  /**
   * UserQuota createMany
   */
  export type UserQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserQuotas.
     */
    data: UserQuotaCreateManyInput | UserQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserQuota createManyAndReturn
   */
  export type UserQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserQuotas.
     */
    data: UserQuotaCreateManyInput | UserQuotaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserQuota update
   */
  export type UserQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a UserQuota.
     */
    data: XOR<UserQuotaUpdateInput, UserQuotaUncheckedUpdateInput>
    /**
     * Choose, which UserQuota to update.
     */
    where: UserQuotaWhereUniqueInput
  }

  /**
   * UserQuota updateMany
   */
  export type UserQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserQuotas.
     */
    data: XOR<UserQuotaUpdateManyMutationInput, UserQuotaUncheckedUpdateManyInput>
    /**
     * Filter which UserQuotas to update
     */
    where?: UserQuotaWhereInput
  }

  /**
   * UserQuota upsert
   */
  export type UserQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the UserQuota to update in case it exists.
     */
    where: UserQuotaWhereUniqueInput
    /**
     * In case the UserQuota found by the `where` argument doesn't exist, create a new UserQuota with this data.
     */
    create: XOR<UserQuotaCreateInput, UserQuotaUncheckedCreateInput>
    /**
     * In case the UserQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserQuotaUpdateInput, UserQuotaUncheckedUpdateInput>
  }

  /**
   * UserQuota delete
   */
  export type UserQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
    /**
     * Filter which UserQuota to delete.
     */
    where: UserQuotaWhereUniqueInput
  }

  /**
   * UserQuota deleteMany
   */
  export type UserQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuotas to delete
     */
    where?: UserQuotaWhereInput
  }

  /**
   * UserQuota without action
   */
  export type UserQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuotaInclude<ExtArgs> | null
  }


  /**
   * Model StorageQuota
   */

  export type AggregateStorageQuota = {
    _count: StorageQuotaCountAggregateOutputType | null
    _avg: StorageQuotaAvgAggregateOutputType | null
    _sum: StorageQuotaSumAggregateOutputType | null
    _min: StorageQuotaMinAggregateOutputType | null
    _max: StorageQuotaMaxAggregateOutputType | null
  }

  export type StorageQuotaAvgAggregateOutputType = {
    totalBytes: number | null
    usedBytes: number | null
    fileCount: number | null
  }

  export type StorageQuotaSumAggregateOutputType = {
    totalBytes: bigint | null
    usedBytes: bigint | null
    fileCount: number | null
  }

  export type StorageQuotaMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    totalBytes: bigint | null
    usedBytes: bigint | null
    fileCount: number | null
    lastCalculated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorageQuotaMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    totalBytes: bigint | null
    usedBytes: bigint | null
    fileCount: number | null
    lastCalculated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorageQuotaCountAggregateOutputType = {
    id: number
    workspaceId: number
    totalBytes: number
    usedBytes: number
    fileCount: number
    lastCalculated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StorageQuotaAvgAggregateInputType = {
    totalBytes?: true
    usedBytes?: true
    fileCount?: true
  }

  export type StorageQuotaSumAggregateInputType = {
    totalBytes?: true
    usedBytes?: true
    fileCount?: true
  }

  export type StorageQuotaMinAggregateInputType = {
    id?: true
    workspaceId?: true
    totalBytes?: true
    usedBytes?: true
    fileCount?: true
    lastCalculated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorageQuotaMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    totalBytes?: true
    usedBytes?: true
    fileCount?: true
    lastCalculated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorageQuotaCountAggregateInputType = {
    id?: true
    workspaceId?: true
    totalBytes?: true
    usedBytes?: true
    fileCount?: true
    lastCalculated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StorageQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageQuota to aggregate.
     */
    where?: StorageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageQuotas to fetch.
     */
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorageQuotas
    **/
    _count?: true | StorageQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorageQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorageQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageQuotaMaxAggregateInputType
  }

  export type GetStorageQuotaAggregateType<T extends StorageQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateStorageQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorageQuota[P]>
      : GetScalarType<T[P], AggregateStorageQuota[P]>
  }




  export type StorageQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageQuotaWhereInput
    orderBy?: StorageQuotaOrderByWithAggregationInput | StorageQuotaOrderByWithAggregationInput[]
    by: StorageQuotaScalarFieldEnum[] | StorageQuotaScalarFieldEnum
    having?: StorageQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageQuotaCountAggregateInputType | true
    _avg?: StorageQuotaAvgAggregateInputType
    _sum?: StorageQuotaSumAggregateInputType
    _min?: StorageQuotaMinAggregateInputType
    _max?: StorageQuotaMaxAggregateInputType
  }

  export type StorageQuotaGroupByOutputType = {
    id: string
    workspaceId: string
    totalBytes: bigint
    usedBytes: bigint
    fileCount: number
    lastCalculated: Date
    createdAt: Date
    updatedAt: Date
    _count: StorageQuotaCountAggregateOutputType | null
    _avg: StorageQuotaAvgAggregateOutputType | null
    _sum: StorageQuotaSumAggregateOutputType | null
    _min: StorageQuotaMinAggregateOutputType | null
    _max: StorageQuotaMaxAggregateOutputType | null
  }

  type GetStorageQuotaGroupByPayload<T extends StorageQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorageQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], StorageQuotaGroupByOutputType[P]>
        }
      >
    >


  export type StorageQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    totalBytes?: boolean
    usedBytes?: boolean
    fileCount?: boolean
    lastCalculated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storageQuota"]>

  export type StorageQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    totalBytes?: boolean
    usedBytes?: boolean
    fileCount?: boolean
    lastCalculated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storageQuota"]>

  export type StorageQuotaSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    totalBytes?: boolean
    usedBytes?: boolean
    fileCount?: boolean
    lastCalculated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StorageQuotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type StorageQuotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $StorageQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorageQuota"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      totalBytes: bigint
      usedBytes: bigint
      fileCount: number
      lastCalculated: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storageQuota"]>
    composites: {}
  }

  type StorageQuotaGetPayload<S extends boolean | null | undefined | StorageQuotaDefaultArgs> = $Result.GetResult<Prisma.$StorageQuotaPayload, S>

  type StorageQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorageQuotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StorageQuotaCountAggregateInputType | true
    }

  export interface StorageQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorageQuota'], meta: { name: 'StorageQuota' } }
    /**
     * Find zero or one StorageQuota that matches the filter.
     * @param {StorageQuotaFindUniqueArgs} args - Arguments to find a StorageQuota
     * @example
     * // Get one StorageQuota
     * const storageQuota = await prisma.storageQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorageQuotaFindUniqueArgs>(args: SelectSubset<T, StorageQuotaFindUniqueArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StorageQuota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StorageQuotaFindUniqueOrThrowArgs} args - Arguments to find a StorageQuota
     * @example
     * // Get one StorageQuota
     * const storageQuota = await prisma.storageQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorageQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, StorageQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StorageQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaFindFirstArgs} args - Arguments to find a StorageQuota
     * @example
     * // Get one StorageQuota
     * const storageQuota = await prisma.storageQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorageQuotaFindFirstArgs>(args?: SelectSubset<T, StorageQuotaFindFirstArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StorageQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaFindFirstOrThrowArgs} args - Arguments to find a StorageQuota
     * @example
     * // Get one StorageQuota
     * const storageQuota = await prisma.storageQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorageQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, StorageQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StorageQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorageQuotas
     * const storageQuotas = await prisma.storageQuota.findMany()
     * 
     * // Get first 10 StorageQuotas
     * const storageQuotas = await prisma.storageQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storageQuotaWithIdOnly = await prisma.storageQuota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorageQuotaFindManyArgs>(args?: SelectSubset<T, StorageQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StorageQuota.
     * @param {StorageQuotaCreateArgs} args - Arguments to create a StorageQuota.
     * @example
     * // Create one StorageQuota
     * const StorageQuota = await prisma.storageQuota.create({
     *   data: {
     *     // ... data to create a StorageQuota
     *   }
     * })
     * 
     */
    create<T extends StorageQuotaCreateArgs>(args: SelectSubset<T, StorageQuotaCreateArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StorageQuotas.
     * @param {StorageQuotaCreateManyArgs} args - Arguments to create many StorageQuotas.
     * @example
     * // Create many StorageQuotas
     * const storageQuota = await prisma.storageQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorageQuotaCreateManyArgs>(args?: SelectSubset<T, StorageQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StorageQuotas and returns the data saved in the database.
     * @param {StorageQuotaCreateManyAndReturnArgs} args - Arguments to create many StorageQuotas.
     * @example
     * // Create many StorageQuotas
     * const storageQuota = await prisma.storageQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StorageQuotas and only return the `id`
     * const storageQuotaWithIdOnly = await prisma.storageQuota.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StorageQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, StorageQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StorageQuota.
     * @param {StorageQuotaDeleteArgs} args - Arguments to delete one StorageQuota.
     * @example
     * // Delete one StorageQuota
     * const StorageQuota = await prisma.storageQuota.delete({
     *   where: {
     *     // ... filter to delete one StorageQuota
     *   }
     * })
     * 
     */
    delete<T extends StorageQuotaDeleteArgs>(args: SelectSubset<T, StorageQuotaDeleteArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StorageQuota.
     * @param {StorageQuotaUpdateArgs} args - Arguments to update one StorageQuota.
     * @example
     * // Update one StorageQuota
     * const storageQuota = await prisma.storageQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorageQuotaUpdateArgs>(args: SelectSubset<T, StorageQuotaUpdateArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StorageQuotas.
     * @param {StorageQuotaDeleteManyArgs} args - Arguments to filter StorageQuotas to delete.
     * @example
     * // Delete a few StorageQuotas
     * const { count } = await prisma.storageQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorageQuotaDeleteManyArgs>(args?: SelectSubset<T, StorageQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorageQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorageQuotas
     * const storageQuota = await prisma.storageQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorageQuotaUpdateManyArgs>(args: SelectSubset<T, StorageQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StorageQuota.
     * @param {StorageQuotaUpsertArgs} args - Arguments to update or create a StorageQuota.
     * @example
     * // Update or create a StorageQuota
     * const storageQuota = await prisma.storageQuota.upsert({
     *   create: {
     *     // ... data to create a StorageQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorageQuota we want to update
     *   }
     * })
     */
    upsert<T extends StorageQuotaUpsertArgs>(args: SelectSubset<T, StorageQuotaUpsertArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StorageQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaCountArgs} args - Arguments to filter StorageQuotas to count.
     * @example
     * // Count the number of StorageQuotas
     * const count = await prisma.storageQuota.count({
     *   where: {
     *     // ... the filter for the StorageQuotas we want to count
     *   }
     * })
    **/
    count<T extends StorageQuotaCountArgs>(
      args?: Subset<T, StorageQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorageQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageQuotaAggregateArgs>(args: Subset<T, StorageQuotaAggregateArgs>): Prisma.PrismaPromise<GetStorageQuotaAggregateType<T>>

    /**
     * Group by StorageQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageQuotaGroupByArgs['orderBy'] }
        : { orderBy?: StorageQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorageQuota model
   */
  readonly fields: StorageQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorageQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorageQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorageQuota model
   */ 
  interface StorageQuotaFieldRefs {
    readonly id: FieldRef<"StorageQuota", 'String'>
    readonly workspaceId: FieldRef<"StorageQuota", 'String'>
    readonly totalBytes: FieldRef<"StorageQuota", 'BigInt'>
    readonly usedBytes: FieldRef<"StorageQuota", 'BigInt'>
    readonly fileCount: FieldRef<"StorageQuota", 'Int'>
    readonly lastCalculated: FieldRef<"StorageQuota", 'DateTime'>
    readonly createdAt: FieldRef<"StorageQuota", 'DateTime'>
    readonly updatedAt: FieldRef<"StorageQuota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StorageQuota findUnique
   */
  export type StorageQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuota to fetch.
     */
    where: StorageQuotaWhereUniqueInput
  }

  /**
   * StorageQuota findUniqueOrThrow
   */
  export type StorageQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuota to fetch.
     */
    where: StorageQuotaWhereUniqueInput
  }

  /**
   * StorageQuota findFirst
   */
  export type StorageQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuota to fetch.
     */
    where?: StorageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageQuotas to fetch.
     */
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageQuotas.
     */
    cursor?: StorageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageQuotas.
     */
    distinct?: StorageQuotaScalarFieldEnum | StorageQuotaScalarFieldEnum[]
  }

  /**
   * StorageQuota findFirstOrThrow
   */
  export type StorageQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuota to fetch.
     */
    where?: StorageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageQuotas to fetch.
     */
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageQuotas.
     */
    cursor?: StorageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageQuotas.
     */
    distinct?: StorageQuotaScalarFieldEnum | StorageQuotaScalarFieldEnum[]
  }

  /**
   * StorageQuota findMany
   */
  export type StorageQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuotas to fetch.
     */
    where?: StorageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageQuotas to fetch.
     */
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorageQuotas.
     */
    cursor?: StorageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageQuotas.
     */
    skip?: number
    distinct?: StorageQuotaScalarFieldEnum | StorageQuotaScalarFieldEnum[]
  }

  /**
   * StorageQuota create
   */
  export type StorageQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a StorageQuota.
     */
    data: XOR<StorageQuotaCreateInput, StorageQuotaUncheckedCreateInput>
  }

  /**
   * StorageQuota createMany
   */
  export type StorageQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorageQuotas.
     */
    data: StorageQuotaCreateManyInput | StorageQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorageQuota createManyAndReturn
   */
  export type StorageQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StorageQuotas.
     */
    data: StorageQuotaCreateManyInput | StorageQuotaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StorageQuota update
   */
  export type StorageQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a StorageQuota.
     */
    data: XOR<StorageQuotaUpdateInput, StorageQuotaUncheckedUpdateInput>
    /**
     * Choose, which StorageQuota to update.
     */
    where: StorageQuotaWhereUniqueInput
  }

  /**
   * StorageQuota updateMany
   */
  export type StorageQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorageQuotas.
     */
    data: XOR<StorageQuotaUpdateManyMutationInput, StorageQuotaUncheckedUpdateManyInput>
    /**
     * Filter which StorageQuotas to update
     */
    where?: StorageQuotaWhereInput
  }

  /**
   * StorageQuota upsert
   */
  export type StorageQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the StorageQuota to update in case it exists.
     */
    where: StorageQuotaWhereUniqueInput
    /**
     * In case the StorageQuota found by the `where` argument doesn't exist, create a new StorageQuota with this data.
     */
    create: XOR<StorageQuotaCreateInput, StorageQuotaUncheckedCreateInput>
    /**
     * In case the StorageQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorageQuotaUpdateInput, StorageQuotaUncheckedUpdateInput>
  }

  /**
   * StorageQuota delete
   */
  export type StorageQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter which StorageQuota to delete.
     */
    where: StorageQuotaWhereUniqueInput
  }

  /**
   * StorageQuota deleteMany
   */
  export type StorageQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageQuotas to delete
     */
    where?: StorageQuotaWhereInput
  }

  /**
   * StorageQuota without action
   */
  export type StorageQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
  }


  /**
   * Model UsageRecord
   */

  export type AggregateUsageRecord = {
    _count: UsageRecordCountAggregateOutputType | null
    _avg: UsageRecordAvgAggregateOutputType | null
    _sum: UsageRecordSumAggregateOutputType | null
    _min: UsageRecordMinAggregateOutputType | null
    _max: UsageRecordMaxAggregateOutputType | null
  }

  export type UsageRecordAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalCost: Decimal | null
  }

  export type UsageRecordSumAggregateOutputType = {
    quantity: bigint | null
    unitPrice: Decimal | null
    totalCost: Decimal | null
  }

  export type UsageRecordMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    recordType: string | null
    quantity: bigint | null
    unitPrice: Decimal | null
    totalCost: Decimal | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
  }

  export type UsageRecordMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    recordType: string | null
    quantity: bigint | null
    unitPrice: Decimal | null
    totalCost: Decimal | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
  }

  export type UsageRecordCountAggregateOutputType = {
    id: number
    subscriptionId: number
    recordType: number
    quantity: number
    unitPrice: number
    totalCost: number
    periodStart: number
    periodEnd: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type UsageRecordAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalCost?: true
  }

  export type UsageRecordSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalCost?: true
  }

  export type UsageRecordMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    recordType?: true
    quantity?: true
    unitPrice?: true
    totalCost?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
  }

  export type UsageRecordMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    recordType?: true
    quantity?: true
    unitPrice?: true
    totalCost?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
  }

  export type UsageRecordCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    recordType?: true
    quantity?: true
    unitPrice?: true
    totalCost?: true
    periodStart?: true
    periodEnd?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type UsageRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageRecord to aggregate.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageRecords
    **/
    _count?: true | UsageRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageRecordMaxAggregateInputType
  }

  export type GetUsageRecordAggregateType<T extends UsageRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageRecord[P]>
      : GetScalarType<T[P], AggregateUsageRecord[P]>
  }




  export type UsageRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageRecordWhereInput
    orderBy?: UsageRecordOrderByWithAggregationInput | UsageRecordOrderByWithAggregationInput[]
    by: UsageRecordScalarFieldEnum[] | UsageRecordScalarFieldEnum
    having?: UsageRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageRecordCountAggregateInputType | true
    _avg?: UsageRecordAvgAggregateInputType
    _sum?: UsageRecordSumAggregateInputType
    _min?: UsageRecordMinAggregateInputType
    _max?: UsageRecordMaxAggregateInputType
  }

  export type UsageRecordGroupByOutputType = {
    id: string
    subscriptionId: string
    recordType: string
    quantity: bigint
    unitPrice: Decimal | null
    totalCost: Decimal | null
    periodStart: Date
    periodEnd: Date
    metadata: JsonValue
    createdAt: Date
    _count: UsageRecordCountAggregateOutputType | null
    _avg: UsageRecordAvgAggregateOutputType | null
    _sum: UsageRecordSumAggregateOutputType | null
    _min: UsageRecordMinAggregateOutputType | null
    _max: UsageRecordMaxAggregateOutputType | null
  }

  type GetUsageRecordGroupByPayload<T extends UsageRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageRecordGroupByOutputType[P]>
            : GetScalarType<T[P], UsageRecordGroupByOutputType[P]>
        }
      >
    >


  export type UsageRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    recordType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalCost?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageRecord"]>

  export type UsageRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    recordType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalCost?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageRecord"]>

  export type UsageRecordSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    recordType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalCost?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type UsageRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }
  export type UsageRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | WorkspaceSubscriptionDefaultArgs<ExtArgs>
  }

  export type $UsageRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageRecord"
    objects: {
      subscription: Prisma.$WorkspaceSubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      recordType: string
      quantity: bigint
      unitPrice: Prisma.Decimal | null
      totalCost: Prisma.Decimal | null
      periodStart: Date
      periodEnd: Date
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["usageRecord"]>
    composites: {}
  }

  type UsageRecordGetPayload<S extends boolean | null | undefined | UsageRecordDefaultArgs> = $Result.GetResult<Prisma.$UsageRecordPayload, S>

  type UsageRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsageRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsageRecordCountAggregateInputType | true
    }

  export interface UsageRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageRecord'], meta: { name: 'UsageRecord' } }
    /**
     * Find zero or one UsageRecord that matches the filter.
     * @param {UsageRecordFindUniqueArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageRecordFindUniqueArgs>(args: SelectSubset<T, UsageRecordFindUniqueArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsageRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsageRecordFindUniqueOrThrowArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsageRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindFirstArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageRecordFindFirstArgs>(args?: SelectSubset<T, UsageRecordFindFirstArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsageRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindFirstOrThrowArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsageRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageRecords
     * const usageRecords = await prisma.usageRecord.findMany()
     * 
     * // Get first 10 UsageRecords
     * const usageRecords = await prisma.usageRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageRecordWithIdOnly = await prisma.usageRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageRecordFindManyArgs>(args?: SelectSubset<T, UsageRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsageRecord.
     * @param {UsageRecordCreateArgs} args - Arguments to create a UsageRecord.
     * @example
     * // Create one UsageRecord
     * const UsageRecord = await prisma.usageRecord.create({
     *   data: {
     *     // ... data to create a UsageRecord
     *   }
     * })
     * 
     */
    create<T extends UsageRecordCreateArgs>(args: SelectSubset<T, UsageRecordCreateArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsageRecords.
     * @param {UsageRecordCreateManyArgs} args - Arguments to create many UsageRecords.
     * @example
     * // Create many UsageRecords
     * const usageRecord = await prisma.usageRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageRecordCreateManyArgs>(args?: SelectSubset<T, UsageRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageRecords and returns the data saved in the database.
     * @param {UsageRecordCreateManyAndReturnArgs} args - Arguments to create many UsageRecords.
     * @example
     * // Create many UsageRecords
     * const usageRecord = await prisma.usageRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageRecords and only return the `id`
     * const usageRecordWithIdOnly = await prisma.usageRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsageRecord.
     * @param {UsageRecordDeleteArgs} args - Arguments to delete one UsageRecord.
     * @example
     * // Delete one UsageRecord
     * const UsageRecord = await prisma.usageRecord.delete({
     *   where: {
     *     // ... filter to delete one UsageRecord
     *   }
     * })
     * 
     */
    delete<T extends UsageRecordDeleteArgs>(args: SelectSubset<T, UsageRecordDeleteArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsageRecord.
     * @param {UsageRecordUpdateArgs} args - Arguments to update one UsageRecord.
     * @example
     * // Update one UsageRecord
     * const usageRecord = await prisma.usageRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageRecordUpdateArgs>(args: SelectSubset<T, UsageRecordUpdateArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsageRecords.
     * @param {UsageRecordDeleteManyArgs} args - Arguments to filter UsageRecords to delete.
     * @example
     * // Delete a few UsageRecords
     * const { count } = await prisma.usageRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageRecordDeleteManyArgs>(args?: SelectSubset<T, UsageRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageRecords
     * const usageRecord = await prisma.usageRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageRecordUpdateManyArgs>(args: SelectSubset<T, UsageRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageRecord.
     * @param {UsageRecordUpsertArgs} args - Arguments to update or create a UsageRecord.
     * @example
     * // Update or create a UsageRecord
     * const usageRecord = await prisma.usageRecord.upsert({
     *   create: {
     *     // ... data to create a UsageRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageRecord we want to update
     *   }
     * })
     */
    upsert<T extends UsageRecordUpsertArgs>(args: SelectSubset<T, UsageRecordUpsertArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsageRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordCountArgs} args - Arguments to filter UsageRecords to count.
     * @example
     * // Count the number of UsageRecords
     * const count = await prisma.usageRecord.count({
     *   where: {
     *     // ... the filter for the UsageRecords we want to count
     *   }
     * })
    **/
    count<T extends UsageRecordCountArgs>(
      args?: Subset<T, UsageRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageRecordAggregateArgs>(args: Subset<T, UsageRecordAggregateArgs>): Prisma.PrismaPromise<GetUsageRecordAggregateType<T>>

    /**
     * Group by UsageRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageRecordGroupByArgs['orderBy'] }
        : { orderBy?: UsageRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageRecord model
   */
  readonly fields: UsageRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends WorkspaceSubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceSubscriptionDefaultArgs<ExtArgs>>): Prisma__WorkspaceSubscriptionClient<$Result.GetResult<Prisma.$WorkspaceSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageRecord model
   */ 
  interface UsageRecordFieldRefs {
    readonly id: FieldRef<"UsageRecord", 'String'>
    readonly subscriptionId: FieldRef<"UsageRecord", 'String'>
    readonly recordType: FieldRef<"UsageRecord", 'String'>
    readonly quantity: FieldRef<"UsageRecord", 'BigInt'>
    readonly unitPrice: FieldRef<"UsageRecord", 'Decimal'>
    readonly totalCost: FieldRef<"UsageRecord", 'Decimal'>
    readonly periodStart: FieldRef<"UsageRecord", 'DateTime'>
    readonly periodEnd: FieldRef<"UsageRecord", 'DateTime'>
    readonly metadata: FieldRef<"UsageRecord", 'Json'>
    readonly createdAt: FieldRef<"UsageRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageRecord findUnique
   */
  export type UsageRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord findUniqueOrThrow
   */
  export type UsageRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord findFirst
   */
  export type UsageRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageRecords.
     */
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * UsageRecord findFirstOrThrow
   */
  export type UsageRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageRecords.
     */
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * UsageRecord findMany
   */
  export type UsageRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecords to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * UsageRecord create
   */
  export type UsageRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageRecord.
     */
    data: XOR<UsageRecordCreateInput, UsageRecordUncheckedCreateInput>
  }

  /**
   * UsageRecord createMany
   */
  export type UsageRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageRecords.
     */
    data: UsageRecordCreateManyInput | UsageRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageRecord createManyAndReturn
   */
  export type UsageRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsageRecords.
     */
    data: UsageRecordCreateManyInput | UsageRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageRecord update
   */
  export type UsageRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageRecord.
     */
    data: XOR<UsageRecordUpdateInput, UsageRecordUncheckedUpdateInput>
    /**
     * Choose, which UsageRecord to update.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord updateMany
   */
  export type UsageRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageRecords.
     */
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyInput>
    /**
     * Filter which UsageRecords to update
     */
    where?: UsageRecordWhereInput
  }

  /**
   * UsageRecord upsert
   */
  export type UsageRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageRecord to update in case it exists.
     */
    where: UsageRecordWhereUniqueInput
    /**
     * In case the UsageRecord found by the `where` argument doesn't exist, create a new UsageRecord with this data.
     */
    create: XOR<UsageRecordCreateInput, UsageRecordUncheckedCreateInput>
    /**
     * In case the UsageRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageRecordUpdateInput, UsageRecordUncheckedUpdateInput>
  }

  /**
   * UsageRecord delete
   */
  export type UsageRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter which UsageRecord to delete.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord deleteMany
   */
  export type UsageRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageRecords to delete
     */
    where?: UsageRecordWhereInput
  }

  /**
   * UsageRecord without action
   */
  export type UsageRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    action: number
    resource: number
    resourceId: number
    changes: number
    ipAddress: number
    userAgent: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    action?: true
    resource?: true
    resourceId?: true
    changes?: true
    ipAddress?: true
    userAgent?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    workspaceId: string | null
    action: string
    resource: string
    resourceId: string | null
    changes: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    metadata: JsonValue
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      workspaceId: string | null
      action: string
      resource: string
      resourceId: string | null
      changes: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly workspaceId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model SecurityEvent
   */

  export type AggregateSecurityEvent = {
    _count: SecurityEventCountAggregateOutputType | null
    _min: SecurityEventMinAggregateOutputType | null
    _max: SecurityEventMaxAggregateOutputType | null
  }

  export type SecurityEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    severity: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
  }

  export type SecurityEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    severity: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
  }

  export type SecurityEventCountAggregateOutputType = {
    id: number
    userId: number
    eventType: number
    severity: number
    description: number
    ipAddress: number
    userAgent: number
    metadata: number
    resolved: number
    resolvedAt: number
    resolvedBy: number
    createdAt: number
    _all: number
  }


  export type SecurityEventMinAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    severity?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
  }

  export type SecurityEventMaxAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    severity?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
  }

  export type SecurityEventCountAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    severity?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    metadata?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    _all?: true
  }

  export type SecurityEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityEvent to aggregate.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityEvents
    **/
    _count?: true | SecurityEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityEventMaxAggregateInputType
  }

  export type GetSecurityEventAggregateType<T extends SecurityEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityEvent[P]>
      : GetScalarType<T[P], AggregateSecurityEvent[P]>
  }




  export type SecurityEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityEventWhereInput
    orderBy?: SecurityEventOrderByWithAggregationInput | SecurityEventOrderByWithAggregationInput[]
    by: SecurityEventScalarFieldEnum[] | SecurityEventScalarFieldEnum
    having?: SecurityEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityEventCountAggregateInputType | true
    _min?: SecurityEventMinAggregateInputType
    _max?: SecurityEventMaxAggregateInputType
  }

  export type SecurityEventGroupByOutputType = {
    id: string
    userId: string | null
    eventType: string
    severity: string
    description: string
    ipAddress: string | null
    userAgent: string | null
    metadata: JsonValue
    resolved: boolean
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date
    _count: SecurityEventCountAggregateOutputType | null
    _min: SecurityEventMinAggregateOutputType | null
    _max: SecurityEventMaxAggregateOutputType | null
  }

  type GetSecurityEventGroupByPayload<T extends SecurityEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityEventGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityEventGroupByOutputType[P]>
        }
      >
    >


  export type SecurityEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    description?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    user?: boolean | SecurityEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["securityEvent"]>

  export type SecurityEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    description?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    user?: boolean | SecurityEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["securityEvent"]>

  export type SecurityEventSelectScalar = {
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    description?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
  }

  export type SecurityEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SecurityEvent$userArgs<ExtArgs>
  }
  export type SecurityEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SecurityEvent$userArgs<ExtArgs>
  }

  export type $SecurityEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      eventType: string
      severity: string
      description: string
      ipAddress: string | null
      userAgent: string | null
      metadata: Prisma.JsonValue
      resolved: boolean
      resolvedAt: Date | null
      resolvedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["securityEvent"]>
    composites: {}
  }

  type SecurityEventGetPayload<S extends boolean | null | undefined | SecurityEventDefaultArgs> = $Result.GetResult<Prisma.$SecurityEventPayload, S>

  type SecurityEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SecurityEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SecurityEventCountAggregateInputType | true
    }

  export interface SecurityEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityEvent'], meta: { name: 'SecurityEvent' } }
    /**
     * Find zero or one SecurityEvent that matches the filter.
     * @param {SecurityEventFindUniqueArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityEventFindUniqueArgs>(args: SelectSubset<T, SecurityEventFindUniqueArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SecurityEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SecurityEventFindUniqueOrThrowArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SecurityEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindFirstArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityEventFindFirstArgs>(args?: SelectSubset<T, SecurityEventFindFirstArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SecurityEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindFirstOrThrowArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SecurityEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityEvents
     * const securityEvents = await prisma.securityEvent.findMany()
     * 
     * // Get first 10 SecurityEvents
     * const securityEvents = await prisma.securityEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityEventFindManyArgs>(args?: SelectSubset<T, SecurityEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SecurityEvent.
     * @param {SecurityEventCreateArgs} args - Arguments to create a SecurityEvent.
     * @example
     * // Create one SecurityEvent
     * const SecurityEvent = await prisma.securityEvent.create({
     *   data: {
     *     // ... data to create a SecurityEvent
     *   }
     * })
     * 
     */
    create<T extends SecurityEventCreateArgs>(args: SelectSubset<T, SecurityEventCreateArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SecurityEvents.
     * @param {SecurityEventCreateManyArgs} args - Arguments to create many SecurityEvents.
     * @example
     * // Create many SecurityEvents
     * const securityEvent = await prisma.securityEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityEventCreateManyArgs>(args?: SelectSubset<T, SecurityEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityEvents and returns the data saved in the database.
     * @param {SecurityEventCreateManyAndReturnArgs} args - Arguments to create many SecurityEvents.
     * @example
     * // Create many SecurityEvents
     * const securityEvent = await prisma.securityEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityEvents and only return the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityEventCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SecurityEvent.
     * @param {SecurityEventDeleteArgs} args - Arguments to delete one SecurityEvent.
     * @example
     * // Delete one SecurityEvent
     * const SecurityEvent = await prisma.securityEvent.delete({
     *   where: {
     *     // ... filter to delete one SecurityEvent
     *   }
     * })
     * 
     */
    delete<T extends SecurityEventDeleteArgs>(args: SelectSubset<T, SecurityEventDeleteArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SecurityEvent.
     * @param {SecurityEventUpdateArgs} args - Arguments to update one SecurityEvent.
     * @example
     * // Update one SecurityEvent
     * const securityEvent = await prisma.securityEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityEventUpdateArgs>(args: SelectSubset<T, SecurityEventUpdateArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SecurityEvents.
     * @param {SecurityEventDeleteManyArgs} args - Arguments to filter SecurityEvents to delete.
     * @example
     * // Delete a few SecurityEvents
     * const { count } = await prisma.securityEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityEventDeleteManyArgs>(args?: SelectSubset<T, SecurityEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityEvents
     * const securityEvent = await prisma.securityEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityEventUpdateManyArgs>(args: SelectSubset<T, SecurityEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SecurityEvent.
     * @param {SecurityEventUpsertArgs} args - Arguments to update or create a SecurityEvent.
     * @example
     * // Update or create a SecurityEvent
     * const securityEvent = await prisma.securityEvent.upsert({
     *   create: {
     *     // ... data to create a SecurityEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityEvent we want to update
     *   }
     * })
     */
    upsert<T extends SecurityEventUpsertArgs>(args: SelectSubset<T, SecurityEventUpsertArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventCountArgs} args - Arguments to filter SecurityEvents to count.
     * @example
     * // Count the number of SecurityEvents
     * const count = await prisma.securityEvent.count({
     *   where: {
     *     // ... the filter for the SecurityEvents we want to count
     *   }
     * })
    **/
    count<T extends SecurityEventCountArgs>(
      args?: Subset<T, SecurityEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityEventAggregateArgs>(args: Subset<T, SecurityEventAggregateArgs>): Prisma.PrismaPromise<GetSecurityEventAggregateType<T>>

    /**
     * Group by SecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityEventGroupByArgs['orderBy'] }
        : { orderBy?: SecurityEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityEvent model
   */
  readonly fields: SecurityEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SecurityEvent$userArgs<ExtArgs> = {}>(args?: Subset<T, SecurityEvent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityEvent model
   */ 
  interface SecurityEventFieldRefs {
    readonly id: FieldRef<"SecurityEvent", 'String'>
    readonly userId: FieldRef<"SecurityEvent", 'String'>
    readonly eventType: FieldRef<"SecurityEvent", 'String'>
    readonly severity: FieldRef<"SecurityEvent", 'String'>
    readonly description: FieldRef<"SecurityEvent", 'String'>
    readonly ipAddress: FieldRef<"SecurityEvent", 'String'>
    readonly userAgent: FieldRef<"SecurityEvent", 'String'>
    readonly metadata: FieldRef<"SecurityEvent", 'Json'>
    readonly resolved: FieldRef<"SecurityEvent", 'Boolean'>
    readonly resolvedAt: FieldRef<"SecurityEvent", 'DateTime'>
    readonly resolvedBy: FieldRef<"SecurityEvent", 'String'>
    readonly createdAt: FieldRef<"SecurityEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityEvent findUnique
   */
  export type SecurityEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent findUniqueOrThrow
   */
  export type SecurityEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent findFirst
   */
  export type SecurityEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityEvents.
     */
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent findFirstOrThrow
   */
  export type SecurityEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityEvents.
     */
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent findMany
   */
  export type SecurityEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvents to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent create
   */
  export type SecurityEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * The data needed to create a SecurityEvent.
     */
    data: XOR<SecurityEventCreateInput, SecurityEventUncheckedCreateInput>
  }

  /**
   * SecurityEvent createMany
   */
  export type SecurityEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityEvents.
     */
    data: SecurityEventCreateManyInput | SecurityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityEvent createManyAndReturn
   */
  export type SecurityEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SecurityEvents.
     */
    data: SecurityEventCreateManyInput | SecurityEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityEvent update
   */
  export type SecurityEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * The data needed to update a SecurityEvent.
     */
    data: XOR<SecurityEventUpdateInput, SecurityEventUncheckedUpdateInput>
    /**
     * Choose, which SecurityEvent to update.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent updateMany
   */
  export type SecurityEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityEvents.
     */
    data: XOR<SecurityEventUpdateManyMutationInput, SecurityEventUncheckedUpdateManyInput>
    /**
     * Filter which SecurityEvents to update
     */
    where?: SecurityEventWhereInput
  }

  /**
   * SecurityEvent upsert
   */
  export type SecurityEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * The filter to search for the SecurityEvent to update in case it exists.
     */
    where: SecurityEventWhereUniqueInput
    /**
     * In case the SecurityEvent found by the `where` argument doesn't exist, create a new SecurityEvent with this data.
     */
    create: XOR<SecurityEventCreateInput, SecurityEventUncheckedCreateInput>
    /**
     * In case the SecurityEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityEventUpdateInput, SecurityEventUncheckedUpdateInput>
  }

  /**
   * SecurityEvent delete
   */
  export type SecurityEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter which SecurityEvent to delete.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent deleteMany
   */
  export type SecurityEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityEvents to delete
     */
    where?: SecurityEventWhereInput
  }

  /**
   * SecurityEvent.user
   */
  export type SecurityEvent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SecurityEvent without action
   */
  export type SecurityEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    actionUrl: string | null
    read: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    actionUrl: string | null
    read: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    actionUrl: number
    read: number
    readAt: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    read?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    read?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    read?: true
    readAt?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    actionUrl: string | null
    read: boolean
    readAt: Date | null
    metadata: JsonValue
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    read?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    read?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    read?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      actionUrl: string | null
      read: boolean
      readAt: Date | null
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    htmlContent: string | null
    textContent: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    htmlContent: string | null
    textContent: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    htmlContent: number
    textContent: number
    variables: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTemplateMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    htmlContent?: true
    textContent?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    htmlContent?: true
    textContent?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    htmlContent?: true
    textContent?: true
    variables?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    name: string
    subject: string
    htmlContent: string
    textContent: string
    variables: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    htmlContent?: boolean
    textContent?: boolean
    variables?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailLogs?: boolean | EmailTemplate$emailLogsArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    htmlContent?: boolean
    textContent?: boolean
    variables?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    htmlContent?: boolean
    textContent?: boolean
    variables?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailLogs?: boolean | EmailTemplate$emailLogsArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {
      emailLogs: Prisma.$EmailLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      htmlContent: string
      textContent: string
      variables: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }

  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTemplateFindUniqueArgs>(args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTemplateFindFirstArgs>(args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTemplateFindManyArgs>(args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
     */
    create<T extends EmailTemplateCreateArgs>(args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTemplateCreateManyArgs>(args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends EmailTemplateDeleteArgs>(args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTemplateUpdateArgs>(args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTemplateDeleteManyArgs>(args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTemplateUpdateManyArgs>(args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EmailTemplateUpsertArgs>(args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailLogs<T extends EmailTemplate$emailLogsArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$emailLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTemplate model
   */ 
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly htmlContent: FieldRef<"EmailTemplate", 'String'>
    readonly textContent: FieldRef<"EmailTemplate", 'String'>
    readonly variables: FieldRef<"EmailTemplate", 'Json'>
    readonly isActive: FieldRef<"EmailTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailTemplate.emailLogs
   */
  export type EmailTemplate$emailLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    cursor?: EmailLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
  }


  /**
   * Model EmailLog
   */

  export type AggregateEmailLog = {
    _count: EmailLogCountAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  export type EmailLogMinAggregateOutputType = {
    id: string | null
    templateId: string | null
    recipientEmail: string | null
    subject: string | null
    status: string | null
    provider: string | null
    providerMessageId: string | null
    openedAt: Date | null
    clickedAt: Date | null
    error: string | null
    createdAt: Date | null
  }

  export type EmailLogMaxAggregateOutputType = {
    id: string | null
    templateId: string | null
    recipientEmail: string | null
    subject: string | null
    status: string | null
    provider: string | null
    providerMessageId: string | null
    openedAt: Date | null
    clickedAt: Date | null
    error: string | null
    createdAt: Date | null
  }

  export type EmailLogCountAggregateOutputType = {
    id: number
    templateId: number
    recipientEmail: number
    subject: number
    status: number
    provider: number
    providerMessageId: number
    openedAt: number
    clickedAt: number
    error: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type EmailLogMinAggregateInputType = {
    id?: true
    templateId?: true
    recipientEmail?: true
    subject?: true
    status?: true
    provider?: true
    providerMessageId?: true
    openedAt?: true
    clickedAt?: true
    error?: true
    createdAt?: true
  }

  export type EmailLogMaxAggregateInputType = {
    id?: true
    templateId?: true
    recipientEmail?: true
    subject?: true
    status?: true
    provider?: true
    providerMessageId?: true
    openedAt?: true
    clickedAt?: true
    error?: true
    createdAt?: true
  }

  export type EmailLogCountAggregateInputType = {
    id?: true
    templateId?: true
    recipientEmail?: true
    subject?: true
    status?: true
    provider?: true
    providerMessageId?: true
    openedAt?: true
    clickedAt?: true
    error?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type EmailLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLog to aggregate.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailLogs
    **/
    _count?: true | EmailLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailLogMaxAggregateInputType
  }

  export type GetEmailLogAggregateType<T extends EmailLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailLog[P]>
      : GetScalarType<T[P], AggregateEmailLog[P]>
  }




  export type EmailLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithAggregationInput | EmailLogOrderByWithAggregationInput[]
    by: EmailLogScalarFieldEnum[] | EmailLogScalarFieldEnum
    having?: EmailLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailLogCountAggregateInputType | true
    _min?: EmailLogMinAggregateInputType
    _max?: EmailLogMaxAggregateInputType
  }

  export type EmailLogGroupByOutputType = {
    id: string
    templateId: string | null
    recipientEmail: string
    subject: string
    status: string
    provider: string
    providerMessageId: string | null
    openedAt: Date | null
    clickedAt: Date | null
    error: string | null
    metadata: JsonValue
    createdAt: Date
    _count: EmailLogCountAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  type GetEmailLogGroupByPayload<T extends EmailLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
        }
      >
    >


  export type EmailLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    recipientEmail?: boolean
    subject?: boolean
    status?: boolean
    provider?: boolean
    providerMessageId?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    template?: boolean | EmailLog$templateArgs<ExtArgs>
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    recipientEmail?: boolean
    subject?: boolean
    status?: boolean
    provider?: boolean
    providerMessageId?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    template?: boolean | EmailLog$templateArgs<ExtArgs>
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectScalar = {
    id?: boolean
    templateId?: boolean
    recipientEmail?: boolean
    subject?: boolean
    status?: boolean
    provider?: boolean
    providerMessageId?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type EmailLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | EmailLog$templateArgs<ExtArgs>
  }
  export type EmailLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | EmailLog$templateArgs<ExtArgs>
  }

  export type $EmailLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailLog"
    objects: {
      template: Prisma.$EmailTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      templateId: string | null
      recipientEmail: string
      subject: string
      status: string
      provider: string
      providerMessageId: string | null
      openedAt: Date | null
      clickedAt: Date | null
      error: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["emailLog"]>
    composites: {}
  }

  type EmailLogGetPayload<S extends boolean | null | undefined | EmailLogDefaultArgs> = $Result.GetResult<Prisma.$EmailLogPayload, S>

  type EmailLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailLogCountAggregateInputType | true
    }

  export interface EmailLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailLog'], meta: { name: 'EmailLog' } }
    /**
     * Find zero or one EmailLog that matches the filter.
     * @param {EmailLogFindUniqueArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailLogFindUniqueArgs>(args: SelectSubset<T, EmailLogFindUniqueArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailLogFindUniqueOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailLogFindFirstArgs>(args?: SelectSubset<T, EmailLogFindFirstArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailLogs
     * const emailLogs = await prisma.emailLog.findMany()
     * 
     * // Get first 10 EmailLogs
     * const emailLogs = await prisma.emailLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailLogFindManyArgs>(args?: SelectSubset<T, EmailLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailLog.
     * @param {EmailLogCreateArgs} args - Arguments to create a EmailLog.
     * @example
     * // Create one EmailLog
     * const EmailLog = await prisma.emailLog.create({
     *   data: {
     *     // ... data to create a EmailLog
     *   }
     * })
     * 
     */
    create<T extends EmailLogCreateArgs>(args: SelectSubset<T, EmailLogCreateArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailLogs.
     * @param {EmailLogCreateManyArgs} args - Arguments to create many EmailLogs.
     * @example
     * // Create many EmailLogs
     * const emailLog = await prisma.emailLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailLogCreateManyArgs>(args?: SelectSubset<T, EmailLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailLogs and returns the data saved in the database.
     * @param {EmailLogCreateManyAndReturnArgs} args - Arguments to create many EmailLogs.
     * @example
     * // Create many EmailLogs
     * const emailLog = await prisma.emailLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailLogs and only return the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailLog.
     * @param {EmailLogDeleteArgs} args - Arguments to delete one EmailLog.
     * @example
     * // Delete one EmailLog
     * const EmailLog = await prisma.emailLog.delete({
     *   where: {
     *     // ... filter to delete one EmailLog
     *   }
     * })
     * 
     */
    delete<T extends EmailLogDeleteArgs>(args: SelectSubset<T, EmailLogDeleteArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailLog.
     * @param {EmailLogUpdateArgs} args - Arguments to update one EmailLog.
     * @example
     * // Update one EmailLog
     * const emailLog = await prisma.emailLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailLogUpdateArgs>(args: SelectSubset<T, EmailLogUpdateArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailLogs.
     * @param {EmailLogDeleteManyArgs} args - Arguments to filter EmailLogs to delete.
     * @example
     * // Delete a few EmailLogs
     * const { count } = await prisma.emailLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailLogDeleteManyArgs>(args?: SelectSubset<T, EmailLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailLogs
     * const emailLog = await prisma.emailLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailLogUpdateManyArgs>(args: SelectSubset<T, EmailLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailLog.
     * @param {EmailLogUpsertArgs} args - Arguments to update or create a EmailLog.
     * @example
     * // Update or create a EmailLog
     * const emailLog = await prisma.emailLog.upsert({
     *   create: {
     *     // ... data to create a EmailLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailLog we want to update
     *   }
     * })
     */
    upsert<T extends EmailLogUpsertArgs>(args: SelectSubset<T, EmailLogUpsertArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogCountArgs} args - Arguments to filter EmailLogs to count.
     * @example
     * // Count the number of EmailLogs
     * const count = await prisma.emailLog.count({
     *   where: {
     *     // ... the filter for the EmailLogs we want to count
     *   }
     * })
    **/
    count<T extends EmailLogCountArgs>(
      args?: Subset<T, EmailLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailLogAggregateArgs>(args: Subset<T, EmailLogAggregateArgs>): Prisma.PrismaPromise<GetEmailLogAggregateType<T>>

    /**
     * Group by EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailLogGroupByArgs['orderBy'] }
        : { orderBy?: EmailLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailLog model
   */
  readonly fields: EmailLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends EmailLog$templateArgs<ExtArgs> = {}>(args?: Subset<T, EmailLog$templateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailLog model
   */ 
  interface EmailLogFieldRefs {
    readonly id: FieldRef<"EmailLog", 'String'>
    readonly templateId: FieldRef<"EmailLog", 'String'>
    readonly recipientEmail: FieldRef<"EmailLog", 'String'>
    readonly subject: FieldRef<"EmailLog", 'String'>
    readonly status: FieldRef<"EmailLog", 'String'>
    readonly provider: FieldRef<"EmailLog", 'String'>
    readonly providerMessageId: FieldRef<"EmailLog", 'String'>
    readonly openedAt: FieldRef<"EmailLog", 'DateTime'>
    readonly clickedAt: FieldRef<"EmailLog", 'DateTime'>
    readonly error: FieldRef<"EmailLog", 'String'>
    readonly metadata: FieldRef<"EmailLog", 'Json'>
    readonly createdAt: FieldRef<"EmailLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailLog findUnique
   */
  export type EmailLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog findUniqueOrThrow
   */
  export type EmailLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog findFirst
   */
  export type EmailLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog findFirstOrThrow
   */
  export type EmailLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog findMany
   */
  export type EmailLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLogs to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog create
   */
  export type EmailLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailLog.
     */
    data: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
  }

  /**
   * EmailLog createMany
   */
  export type EmailLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailLogs.
     */
    data: EmailLogCreateManyInput | EmailLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailLog createManyAndReturn
   */
  export type EmailLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailLogs.
     */
    data: EmailLogCreateManyInput | EmailLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailLog update
   */
  export type EmailLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailLog.
     */
    data: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
    /**
     * Choose, which EmailLog to update.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog updateMany
   */
  export type EmailLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailLogs.
     */
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailLogs to update
     */
    where?: EmailLogWhereInput
  }

  /**
   * EmailLog upsert
   */
  export type EmailLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailLog to update in case it exists.
     */
    where: EmailLogWhereUniqueInput
    /**
     * In case the EmailLog found by the `where` argument doesn't exist, create a new EmailLog with this data.
     */
    create: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
    /**
     * In case the EmailLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
  }

  /**
   * EmailLog delete
   */
  export type EmailLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter which EmailLog to delete.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog deleteMany
   */
  export type EmailLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLogs to delete
     */
    where?: EmailLogWhereInput
  }

  /**
   * EmailLog.template
   */
  export type EmailLog$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailLog without action
   */
  export type EmailLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
  }


  /**
   * Model EmailPreference
   */

  export type AggregateEmailPreference = {
    _count: EmailPreferenceCountAggregateOutputType | null
    _min: EmailPreferenceMinAggregateOutputType | null
    _max: EmailPreferenceMaxAggregateOutputType | null
  }

  export type EmailPreferenceMinAggregateOutputType = {
    userId: string | null
    marketing: boolean | null
    transactional: boolean | null
    security: boolean | null
    newsletter: boolean | null
    productUpdates: boolean | null
    unsubscribeToken: string | null
    updatedAt: Date | null
  }

  export type EmailPreferenceMaxAggregateOutputType = {
    userId: string | null
    marketing: boolean | null
    transactional: boolean | null
    security: boolean | null
    newsletter: boolean | null
    productUpdates: boolean | null
    unsubscribeToken: string | null
    updatedAt: Date | null
  }

  export type EmailPreferenceCountAggregateOutputType = {
    userId: number
    marketing: number
    transactional: number
    security: number
    newsletter: number
    productUpdates: number
    unsubscribeToken: number
    updatedAt: number
    _all: number
  }


  export type EmailPreferenceMinAggregateInputType = {
    userId?: true
    marketing?: true
    transactional?: true
    security?: true
    newsletter?: true
    productUpdates?: true
    unsubscribeToken?: true
    updatedAt?: true
  }

  export type EmailPreferenceMaxAggregateInputType = {
    userId?: true
    marketing?: true
    transactional?: true
    security?: true
    newsletter?: true
    productUpdates?: true
    unsubscribeToken?: true
    updatedAt?: true
  }

  export type EmailPreferenceCountAggregateInputType = {
    userId?: true
    marketing?: true
    transactional?: true
    security?: true
    newsletter?: true
    productUpdates?: true
    unsubscribeToken?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailPreference to aggregate.
     */
    where?: EmailPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailPreferences to fetch.
     */
    orderBy?: EmailPreferenceOrderByWithRelationInput | EmailPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailPreferences
    **/
    _count?: true | EmailPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailPreferenceMaxAggregateInputType
  }

  export type GetEmailPreferenceAggregateType<T extends EmailPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailPreference[P]>
      : GetScalarType<T[P], AggregateEmailPreference[P]>
  }




  export type EmailPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailPreferenceWhereInput
    orderBy?: EmailPreferenceOrderByWithAggregationInput | EmailPreferenceOrderByWithAggregationInput[]
    by: EmailPreferenceScalarFieldEnum[] | EmailPreferenceScalarFieldEnum
    having?: EmailPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailPreferenceCountAggregateInputType | true
    _min?: EmailPreferenceMinAggregateInputType
    _max?: EmailPreferenceMaxAggregateInputType
  }

  export type EmailPreferenceGroupByOutputType = {
    userId: string
    marketing: boolean
    transactional: boolean
    security: boolean
    newsletter: boolean
    productUpdates: boolean
    unsubscribeToken: string
    updatedAt: Date
    _count: EmailPreferenceCountAggregateOutputType | null
    _min: EmailPreferenceMinAggregateOutputType | null
    _max: EmailPreferenceMaxAggregateOutputType | null
  }

  type GetEmailPreferenceGroupByPayload<T extends EmailPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], EmailPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type EmailPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    marketing?: boolean
    transactional?: boolean
    security?: boolean
    newsletter?: boolean
    productUpdates?: boolean
    unsubscribeToken?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailPreference"]>

  export type EmailPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    marketing?: boolean
    transactional?: boolean
    security?: boolean
    newsletter?: boolean
    productUpdates?: boolean
    unsubscribeToken?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailPreference"]>

  export type EmailPreferenceSelectScalar = {
    userId?: boolean
    marketing?: boolean
    transactional?: boolean
    security?: boolean
    newsletter?: boolean
    productUpdates?: boolean
    unsubscribeToken?: boolean
    updatedAt?: boolean
  }

  export type EmailPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      marketing: boolean
      transactional: boolean
      security: boolean
      newsletter: boolean
      productUpdates: boolean
      unsubscribeToken: string
      updatedAt: Date
    }, ExtArgs["result"]["emailPreference"]>
    composites: {}
  }

  type EmailPreferenceGetPayload<S extends boolean | null | undefined | EmailPreferenceDefaultArgs> = $Result.GetResult<Prisma.$EmailPreferencePayload, S>

  type EmailPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailPreferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailPreferenceCountAggregateInputType | true
    }

  export interface EmailPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailPreference'], meta: { name: 'EmailPreference' } }
    /**
     * Find zero or one EmailPreference that matches the filter.
     * @param {EmailPreferenceFindUniqueArgs} args - Arguments to find a EmailPreference
     * @example
     * // Get one EmailPreference
     * const emailPreference = await prisma.emailPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailPreferenceFindUniqueArgs>(args: SelectSubset<T, EmailPreferenceFindUniqueArgs<ExtArgs>>): Prisma__EmailPreferenceClient<$Result.GetResult<Prisma.$EmailPreferencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailPreference that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailPreferenceFindUniqueOrThrowArgs} args - Arguments to find a EmailPreference
     * @example
     * // Get one EmailPreference
     * const emailPreference = await prisma.emailPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailPreferenceClient<$Result.GetResult<Prisma.$EmailPreferencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailPreferenceFindFirstArgs} args - Arguments to find a EmailPreference
     * @example
     * // Get one EmailPreference
     * const emailPreference = await prisma.emailPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailPreferenceFindFirstArgs>(args?: SelectSubset<T, EmailPreferenceFindFirstArgs<ExtArgs>>): Prisma__EmailPreferenceClient<$Result.GetResult<Prisma.$EmailPreferencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailPreferenceFindFirstOrThrowArgs} args - Arguments to find a EmailPreference
     * @example
     * // Get one EmailPreference
     * const emailPreference = await prisma.emailPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailPreferenceClient<$Result.GetResult<Prisma.$EmailPreferencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailPreferences
     * const emailPreferences = await prisma.emailPreference.findMany()
     * 
     * // Get first 10 EmailPreferences
     * const emailPreferences = await prisma.emailPreference.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const emailPreferenceWithUserIdOnly = await prisma.emailPreference.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends EmailPreferenceFindManyArgs>(args?: SelectSubset<T, EmailPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPreferencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailPreference.
     * @param {EmailPreferenceCreateArgs} args - Arguments to create a EmailPreference.
     * @example
     * // Create one EmailPreference
     * const EmailPreference = await prisma.emailPreference.create({
     *   data: {
     *     // ... data to create a EmailPreference
     *   }
     * })
     * 
     */
    create<T extends EmailPreferenceCreateArgs>(args: SelectSubset<T, EmailPreferenceCreateArgs<ExtArgs>>): Prisma__EmailPreferenceClient<$Result.GetResult<Prisma.$EmailPreferencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailPreferences.
     * @param {EmailPreferenceCreateManyArgs} args - Arguments to create many EmailPreferences.
     * @example
     * // Create many EmailPreferences
     * const emailPreference = await prisma.emailPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailPreferenceCreateManyArgs>(args?: SelectSubset<T, EmailPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailPreferences and returns the data saved in the database.
     * @param {EmailPreferenceCreateManyAndReturnArgs} args - Arguments to create many EmailPreferences.
     * @example
     * // Create many EmailPreferences
     * const emailPreference = await prisma.emailPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailPreferences and only return the `userId`
     * const emailPreferenceWithUserIdOnly = await prisma.emailPreference.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPreferencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailPreference.
     * @param {EmailPreferenceDeleteArgs} args - Arguments to delete one EmailPreference.
     * @example
     * // Delete one EmailPreference
     * const EmailPreference = await prisma.emailPreference.delete({
     *   where: {
     *     // ... filter to delete one EmailPreference
     *   }
     * })
     * 
     */
    delete<T extends EmailPreferenceDeleteArgs>(args: SelectSubset<T, EmailPreferenceDeleteArgs<ExtArgs>>): Prisma__EmailPreferenceClient<$Result.GetResult<Prisma.$EmailPreferencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailPreference.
     * @param {EmailPreferenceUpdateArgs} args - Arguments to update one EmailPreference.
     * @example
     * // Update one EmailPreference
     * const emailPreference = await prisma.emailPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailPreferenceUpdateArgs>(args: SelectSubset<T, EmailPreferenceUpdateArgs<ExtArgs>>): Prisma__EmailPreferenceClient<$Result.GetResult<Prisma.$EmailPreferencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailPreferences.
     * @param {EmailPreferenceDeleteManyArgs} args - Arguments to filter EmailPreferences to delete.
     * @example
     * // Delete a few EmailPreferences
     * const { count } = await prisma.emailPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailPreferenceDeleteManyArgs>(args?: SelectSubset<T, EmailPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailPreferences
     * const emailPreference = await prisma.emailPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailPreferenceUpdateManyArgs>(args: SelectSubset<T, EmailPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailPreference.
     * @param {EmailPreferenceUpsertArgs} args - Arguments to update or create a EmailPreference.
     * @example
     * // Update or create a EmailPreference
     * const emailPreference = await prisma.emailPreference.upsert({
     *   create: {
     *     // ... data to create a EmailPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailPreference we want to update
     *   }
     * })
     */
    upsert<T extends EmailPreferenceUpsertArgs>(args: SelectSubset<T, EmailPreferenceUpsertArgs<ExtArgs>>): Prisma__EmailPreferenceClient<$Result.GetResult<Prisma.$EmailPreferencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailPreferenceCountArgs} args - Arguments to filter EmailPreferences to count.
     * @example
     * // Count the number of EmailPreferences
     * const count = await prisma.emailPreference.count({
     *   where: {
     *     // ... the filter for the EmailPreferences we want to count
     *   }
     * })
    **/
    count<T extends EmailPreferenceCountArgs>(
      args?: Subset<T, EmailPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailPreferenceAggregateArgs>(args: Subset<T, EmailPreferenceAggregateArgs>): Prisma.PrismaPromise<GetEmailPreferenceAggregateType<T>>

    /**
     * Group by EmailPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: EmailPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailPreference model
   */
  readonly fields: EmailPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailPreference model
   */ 
  interface EmailPreferenceFieldRefs {
    readonly userId: FieldRef<"EmailPreference", 'String'>
    readonly marketing: FieldRef<"EmailPreference", 'Boolean'>
    readonly transactional: FieldRef<"EmailPreference", 'Boolean'>
    readonly security: FieldRef<"EmailPreference", 'Boolean'>
    readonly newsletter: FieldRef<"EmailPreference", 'Boolean'>
    readonly productUpdates: FieldRef<"EmailPreference", 'Boolean'>
    readonly unsubscribeToken: FieldRef<"EmailPreference", 'String'>
    readonly updatedAt: FieldRef<"EmailPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailPreference findUnique
   */
  export type EmailPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailPreference
     */
    select?: EmailPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which EmailPreference to fetch.
     */
    where: EmailPreferenceWhereUniqueInput
  }

  /**
   * EmailPreference findUniqueOrThrow
   */
  export type EmailPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailPreference
     */
    select?: EmailPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which EmailPreference to fetch.
     */
    where: EmailPreferenceWhereUniqueInput
  }

  /**
   * EmailPreference findFirst
   */
  export type EmailPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailPreference
     */
    select?: EmailPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which EmailPreference to fetch.
     */
    where?: EmailPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailPreferences to fetch.
     */
    orderBy?: EmailPreferenceOrderByWithRelationInput | EmailPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailPreferences.
     */
    cursor?: EmailPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailPreferences.
     */
    distinct?: EmailPreferenceScalarFieldEnum | EmailPreferenceScalarFieldEnum[]
  }

  /**
   * EmailPreference findFirstOrThrow
   */
  export type EmailPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailPreference
     */
    select?: EmailPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which EmailPreference to fetch.
     */
    where?: EmailPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailPreferences to fetch.
     */
    orderBy?: EmailPreferenceOrderByWithRelationInput | EmailPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailPreferences.
     */
    cursor?: EmailPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailPreferences.
     */
    distinct?: EmailPreferenceScalarFieldEnum | EmailPreferenceScalarFieldEnum[]
  }

  /**
   * EmailPreference findMany
   */
  export type EmailPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailPreference
     */
    select?: EmailPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which EmailPreferences to fetch.
     */
    where?: EmailPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailPreferences to fetch.
     */
    orderBy?: EmailPreferenceOrderByWithRelationInput | EmailPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailPreferences.
     */
    cursor?: EmailPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailPreferences.
     */
    skip?: number
    distinct?: EmailPreferenceScalarFieldEnum | EmailPreferenceScalarFieldEnum[]
  }

  /**
   * EmailPreference create
   */
  export type EmailPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailPreference
     */
    select?: EmailPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailPreference.
     */
    data: XOR<EmailPreferenceCreateInput, EmailPreferenceUncheckedCreateInput>
  }

  /**
   * EmailPreference createMany
   */
  export type EmailPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailPreferences.
     */
    data: EmailPreferenceCreateManyInput | EmailPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailPreference createManyAndReturn
   */
  export type EmailPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailPreference
     */
    select?: EmailPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailPreferences.
     */
    data: EmailPreferenceCreateManyInput | EmailPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailPreference update
   */
  export type EmailPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailPreference
     */
    select?: EmailPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailPreference.
     */
    data: XOR<EmailPreferenceUpdateInput, EmailPreferenceUncheckedUpdateInput>
    /**
     * Choose, which EmailPreference to update.
     */
    where: EmailPreferenceWhereUniqueInput
  }

  /**
   * EmailPreference updateMany
   */
  export type EmailPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailPreferences.
     */
    data: XOR<EmailPreferenceUpdateManyMutationInput, EmailPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which EmailPreferences to update
     */
    where?: EmailPreferenceWhereInput
  }

  /**
   * EmailPreference upsert
   */
  export type EmailPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailPreference
     */
    select?: EmailPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailPreference to update in case it exists.
     */
    where: EmailPreferenceWhereUniqueInput
    /**
     * In case the EmailPreference found by the `where` argument doesn't exist, create a new EmailPreference with this data.
     */
    create: XOR<EmailPreferenceCreateInput, EmailPreferenceUncheckedCreateInput>
    /**
     * In case the EmailPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailPreferenceUpdateInput, EmailPreferenceUncheckedUpdateInput>
  }

  /**
   * EmailPreference delete
   */
  export type EmailPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailPreference
     */
    select?: EmailPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailPreferenceInclude<ExtArgs> | null
    /**
     * Filter which EmailPreference to delete.
     */
    where: EmailPreferenceWhereUniqueInput
  }

  /**
   * EmailPreference deleteMany
   */
  export type EmailPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailPreferences to delete
     */
    where?: EmailPreferenceWhereInput
  }

  /**
   * EmailPreference without action
   */
  export type EmailPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailPreference
     */
    select?: EmailPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model Integration
   */

  export type AggregateIntegration = {
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  export type IntegrationMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    type: string | null
    name: string | null
    isActive: boolean | null
    lastSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    type: string | null
    name: string | null
    isActive: boolean | null
    lastSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCountAggregateOutputType = {
    id: number
    workspaceId: number
    type: number
    name: number
    config: number
    isActive: number
    lastSyncAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegrationMinAggregateInputType = {
    id?: true
    workspaceId?: true
    type?: true
    name?: true
    isActive?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    type?: true
    name?: true
    isActive?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCountAggregateInputType = {
    id?: true
    workspaceId?: true
    type?: true
    name?: true
    config?: true
    isActive?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integration to aggregate.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrations
    **/
    _count?: true | IntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMaxAggregateInputType
  }

  export type GetIntegrationAggregateType<T extends IntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration[P]>
      : GetScalarType<T[P], AggregateIntegration[P]>
  }




  export type IntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithAggregationInput | IntegrationOrderByWithAggregationInput[]
    by: IntegrationScalarFieldEnum[] | IntegrationScalarFieldEnum
    having?: IntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCountAggregateInputType | true
    _min?: IntegrationMinAggregateInputType
    _max?: IntegrationMaxAggregateInputType
  }

  export type IntegrationGroupByOutputType = {
    id: string
    workspaceId: string
    type: string
    name: string
    config: JsonValue
    isActive: boolean
    lastSyncAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  type GetIntegrationGroupByPayload<T extends IntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    isActive?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    isActive?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    isActive?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $IntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integration"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      type: string
      name: string
      config: Prisma.JsonValue
      isActive: boolean
      lastSyncAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integration"]>
    composites: {}
  }

  type IntegrationGetPayload<S extends boolean | null | undefined | IntegrationDefaultArgs> = $Result.GetResult<Prisma.$IntegrationPayload, S>

  type IntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntegrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntegrationCountAggregateInputType | true
    }

  export interface IntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integration'], meta: { name: 'Integration' } }
    /**
     * Find zero or one Integration that matches the filter.
     * @param {IntegrationFindUniqueArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationFindUniqueArgs>(args: SelectSubset<T, IntegrationFindUniqueArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Integration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntegrationFindUniqueOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Integration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationFindFirstArgs>(args?: SelectSubset<T, IntegrationFindFirstArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Integration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integration.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationWithIdOnly = await prisma.integration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationFindManyArgs>(args?: SelectSubset<T, IntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Integration.
     * @param {IntegrationCreateArgs} args - Arguments to create a Integration.
     * @example
     * // Create one Integration
     * const Integration = await prisma.integration.create({
     *   data: {
     *     // ... data to create a Integration
     *   }
     * })
     * 
     */
    create<T extends IntegrationCreateArgs>(args: SelectSubset<T, IntegrationCreateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Integrations.
     * @param {IntegrationCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationCreateManyArgs>(args?: SelectSubset<T, IntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrations and returns the data saved in the database.
     * @param {IntegrationCreateManyAndReturnArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Integration.
     * @param {IntegrationDeleteArgs} args - Arguments to delete one Integration.
     * @example
     * // Delete one Integration
     * const Integration = await prisma.integration.delete({
     *   where: {
     *     // ... filter to delete one Integration
     *   }
     * })
     * 
     */
    delete<T extends IntegrationDeleteArgs>(args: SelectSubset<T, IntegrationDeleteArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Integration.
     * @param {IntegrationUpdateArgs} args - Arguments to update one Integration.
     * @example
     * // Update one Integration
     * const integration = await prisma.integration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationUpdateArgs>(args: SelectSubset<T, IntegrationUpdateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Integrations.
     * @param {IntegrationDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationDeleteManyArgs>(args?: SelectSubset<T, IntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationUpdateManyArgs>(args: SelectSubset<T, IntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Integration.
     * @param {IntegrationUpsertArgs} args - Arguments to update or create a Integration.
     * @example
     * // Update or create a Integration
     * const integration = await prisma.integration.upsert({
     *   create: {
     *     // ... data to create a Integration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationUpsertArgs>(args: SelectSubset<T, IntegrationUpsertArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integration.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCountArgs>(
      args?: Subset<T, IntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationAggregateArgs>(args: Subset<T, IntegrationAggregateArgs>): Prisma.PrismaPromise<GetIntegrationAggregateType<T>>

    /**
     * Group by Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integration model
   */
  readonly fields: IntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integration model
   */ 
  interface IntegrationFieldRefs {
    readonly id: FieldRef<"Integration", 'String'>
    readonly workspaceId: FieldRef<"Integration", 'String'>
    readonly type: FieldRef<"Integration", 'String'>
    readonly name: FieldRef<"Integration", 'String'>
    readonly config: FieldRef<"Integration", 'Json'>
    readonly isActive: FieldRef<"Integration", 'Boolean'>
    readonly lastSyncAt: FieldRef<"Integration", 'DateTime'>
    readonly createdAt: FieldRef<"Integration", 'DateTime'>
    readonly updatedAt: FieldRef<"Integration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Integration findUnique
   */
  export type IntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findUniqueOrThrow
   */
  export type IntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findFirst
   */
  export type IntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findFirstOrThrow
   */
  export type IntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findMany
   */
  export type IntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration create
   */
  export type IntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a Integration.
     */
    data: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
  }

  /**
   * Integration createMany
   */
  export type IntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integration createManyAndReturn
   */
  export type IntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration update
   */
  export type IntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a Integration.
     */
    data: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
    /**
     * Choose, which Integration to update.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration updateMany
   */
  export type IntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
  }

  /**
   * Integration upsert
   */
  export type IntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the Integration to update in case it exists.
     */
    where: IntegrationWhereUniqueInput
    /**
     * In case the Integration found by the `where` argument doesn't exist, create a new Integration with this data.
     */
    create: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
    /**
     * In case the Integration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
  }

  /**
   * Integration delete
   */
  export type IntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter which Integration to delete.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration deleteMany
   */
  export type IntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to delete
     */
    where?: IntegrationWhereInput
  }

  /**
   * Integration without action
   */
  export type IntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceAutomation
   */

  export type AggregateWorkspaceAutomation = {
    _count: WorkspaceAutomationCountAggregateOutputType | null
    _avg: WorkspaceAutomationAvgAggregateOutputType | null
    _sum: WorkspaceAutomationSumAggregateOutputType | null
    _min: WorkspaceAutomationMinAggregateOutputType | null
    _max: WorkspaceAutomationMaxAggregateOutputType | null
  }

  export type WorkspaceAutomationAvgAggregateOutputType = {
    runCount: number | null
  }

  export type WorkspaceAutomationSumAggregateOutputType = {
    runCount: number | null
  }

  export type WorkspaceAutomationMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    lastRunAt: Date | null
    runCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceAutomationMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    lastRunAt: Date | null
    runCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceAutomationCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    description: number
    trigger: number
    actions: number
    isActive: number
    lastRunAt: number
    runCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceAutomationAvgAggregateInputType = {
    runCount?: true
  }

  export type WorkspaceAutomationSumAggregateInputType = {
    runCount?: true
  }

  export type WorkspaceAutomationMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    isActive?: true
    lastRunAt?: true
    runCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceAutomationMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    isActive?: true
    lastRunAt?: true
    runCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceAutomationCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    trigger?: true
    actions?: true
    isActive?: true
    lastRunAt?: true
    runCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceAutomationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceAutomation to aggregate.
     */
    where?: WorkspaceAutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceAutomations to fetch.
     */
    orderBy?: WorkspaceAutomationOrderByWithRelationInput | WorkspaceAutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceAutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceAutomations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceAutomations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceAutomations
    **/
    _count?: true | WorkspaceAutomationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkspaceAutomationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkspaceAutomationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceAutomationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceAutomationMaxAggregateInputType
  }

  export type GetWorkspaceAutomationAggregateType<T extends WorkspaceAutomationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceAutomation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceAutomation[P]>
      : GetScalarType<T[P], AggregateWorkspaceAutomation[P]>
  }




  export type WorkspaceAutomationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceAutomationWhereInput
    orderBy?: WorkspaceAutomationOrderByWithAggregationInput | WorkspaceAutomationOrderByWithAggregationInput[]
    by: WorkspaceAutomationScalarFieldEnum[] | WorkspaceAutomationScalarFieldEnum
    having?: WorkspaceAutomationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceAutomationCountAggregateInputType | true
    _avg?: WorkspaceAutomationAvgAggregateInputType
    _sum?: WorkspaceAutomationSumAggregateInputType
    _min?: WorkspaceAutomationMinAggregateInputType
    _max?: WorkspaceAutomationMaxAggregateInputType
  }

  export type WorkspaceAutomationGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    description: string | null
    trigger: JsonValue
    actions: JsonValue
    isActive: boolean
    lastRunAt: Date | null
    runCount: number
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceAutomationCountAggregateOutputType | null
    _avg: WorkspaceAutomationAvgAggregateOutputType | null
    _sum: WorkspaceAutomationSumAggregateOutputType | null
    _min: WorkspaceAutomationMinAggregateOutputType | null
    _max: WorkspaceAutomationMaxAggregateOutputType | null
  }

  type GetWorkspaceAutomationGroupByPayload<T extends WorkspaceAutomationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceAutomationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceAutomationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceAutomationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceAutomationGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceAutomationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    trigger?: boolean
    actions?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    runCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceAutomation"]>

  export type WorkspaceAutomationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    trigger?: boolean
    actions?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    runCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceAutomation"]>

  export type WorkspaceAutomationSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    trigger?: boolean
    actions?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    runCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceAutomationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceAutomationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WorkspaceAutomationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceAutomation"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      description: string | null
      trigger: Prisma.JsonValue
      actions: Prisma.JsonValue
      isActive: boolean
      lastRunAt: Date | null
      runCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspaceAutomation"]>
    composites: {}
  }

  type WorkspaceAutomationGetPayload<S extends boolean | null | undefined | WorkspaceAutomationDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceAutomationPayload, S>

  type WorkspaceAutomationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceAutomationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceAutomationCountAggregateInputType | true
    }

  export interface WorkspaceAutomationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceAutomation'], meta: { name: 'WorkspaceAutomation' } }
    /**
     * Find zero or one WorkspaceAutomation that matches the filter.
     * @param {WorkspaceAutomationFindUniqueArgs} args - Arguments to find a WorkspaceAutomation
     * @example
     * // Get one WorkspaceAutomation
     * const workspaceAutomation = await prisma.workspaceAutomation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceAutomationFindUniqueArgs>(args: SelectSubset<T, WorkspaceAutomationFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceAutomationClient<$Result.GetResult<Prisma.$WorkspaceAutomationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkspaceAutomation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceAutomationFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceAutomation
     * @example
     * // Get one WorkspaceAutomation
     * const workspaceAutomation = await prisma.workspaceAutomation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceAutomationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceAutomationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceAutomationClient<$Result.GetResult<Prisma.$WorkspaceAutomationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkspaceAutomation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAutomationFindFirstArgs} args - Arguments to find a WorkspaceAutomation
     * @example
     * // Get one WorkspaceAutomation
     * const workspaceAutomation = await prisma.workspaceAutomation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceAutomationFindFirstArgs>(args?: SelectSubset<T, WorkspaceAutomationFindFirstArgs<ExtArgs>>): Prisma__WorkspaceAutomationClient<$Result.GetResult<Prisma.$WorkspaceAutomationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkspaceAutomation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAutomationFindFirstOrThrowArgs} args - Arguments to find a WorkspaceAutomation
     * @example
     * // Get one WorkspaceAutomation
     * const workspaceAutomation = await prisma.workspaceAutomation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceAutomationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceAutomationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceAutomationClient<$Result.GetResult<Prisma.$WorkspaceAutomationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkspaceAutomations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAutomationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceAutomations
     * const workspaceAutomations = await prisma.workspaceAutomation.findMany()
     * 
     * // Get first 10 WorkspaceAutomations
     * const workspaceAutomations = await prisma.workspaceAutomation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceAutomationWithIdOnly = await prisma.workspaceAutomation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceAutomationFindManyArgs>(args?: SelectSubset<T, WorkspaceAutomationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceAutomationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkspaceAutomation.
     * @param {WorkspaceAutomationCreateArgs} args - Arguments to create a WorkspaceAutomation.
     * @example
     * // Create one WorkspaceAutomation
     * const WorkspaceAutomation = await prisma.workspaceAutomation.create({
     *   data: {
     *     // ... data to create a WorkspaceAutomation
     *   }
     * })
     * 
     */
    create<T extends WorkspaceAutomationCreateArgs>(args: SelectSubset<T, WorkspaceAutomationCreateArgs<ExtArgs>>): Prisma__WorkspaceAutomationClient<$Result.GetResult<Prisma.$WorkspaceAutomationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkspaceAutomations.
     * @param {WorkspaceAutomationCreateManyArgs} args - Arguments to create many WorkspaceAutomations.
     * @example
     * // Create many WorkspaceAutomations
     * const workspaceAutomation = await prisma.workspaceAutomation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceAutomationCreateManyArgs>(args?: SelectSubset<T, WorkspaceAutomationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceAutomations and returns the data saved in the database.
     * @param {WorkspaceAutomationCreateManyAndReturnArgs} args - Arguments to create many WorkspaceAutomations.
     * @example
     * // Create many WorkspaceAutomations
     * const workspaceAutomation = await prisma.workspaceAutomation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceAutomations and only return the `id`
     * const workspaceAutomationWithIdOnly = await prisma.workspaceAutomation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceAutomationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceAutomationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceAutomationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkspaceAutomation.
     * @param {WorkspaceAutomationDeleteArgs} args - Arguments to delete one WorkspaceAutomation.
     * @example
     * // Delete one WorkspaceAutomation
     * const WorkspaceAutomation = await prisma.workspaceAutomation.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceAutomation
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceAutomationDeleteArgs>(args: SelectSubset<T, WorkspaceAutomationDeleteArgs<ExtArgs>>): Prisma__WorkspaceAutomationClient<$Result.GetResult<Prisma.$WorkspaceAutomationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkspaceAutomation.
     * @param {WorkspaceAutomationUpdateArgs} args - Arguments to update one WorkspaceAutomation.
     * @example
     * // Update one WorkspaceAutomation
     * const workspaceAutomation = await prisma.workspaceAutomation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceAutomationUpdateArgs>(args: SelectSubset<T, WorkspaceAutomationUpdateArgs<ExtArgs>>): Prisma__WorkspaceAutomationClient<$Result.GetResult<Prisma.$WorkspaceAutomationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkspaceAutomations.
     * @param {WorkspaceAutomationDeleteManyArgs} args - Arguments to filter WorkspaceAutomations to delete.
     * @example
     * // Delete a few WorkspaceAutomations
     * const { count } = await prisma.workspaceAutomation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceAutomationDeleteManyArgs>(args?: SelectSubset<T, WorkspaceAutomationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceAutomations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAutomationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceAutomations
     * const workspaceAutomation = await prisma.workspaceAutomation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceAutomationUpdateManyArgs>(args: SelectSubset<T, WorkspaceAutomationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkspaceAutomation.
     * @param {WorkspaceAutomationUpsertArgs} args - Arguments to update or create a WorkspaceAutomation.
     * @example
     * // Update or create a WorkspaceAutomation
     * const workspaceAutomation = await prisma.workspaceAutomation.upsert({
     *   create: {
     *     // ... data to create a WorkspaceAutomation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceAutomation we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceAutomationUpsertArgs>(args: SelectSubset<T, WorkspaceAutomationUpsertArgs<ExtArgs>>): Prisma__WorkspaceAutomationClient<$Result.GetResult<Prisma.$WorkspaceAutomationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkspaceAutomations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAutomationCountArgs} args - Arguments to filter WorkspaceAutomations to count.
     * @example
     * // Count the number of WorkspaceAutomations
     * const count = await prisma.workspaceAutomation.count({
     *   where: {
     *     // ... the filter for the WorkspaceAutomations we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceAutomationCountArgs>(
      args?: Subset<T, WorkspaceAutomationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceAutomationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceAutomation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAutomationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAutomationAggregateArgs>(args: Subset<T, WorkspaceAutomationAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAutomationAggregateType<T>>

    /**
     * Group by WorkspaceAutomation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAutomationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceAutomationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceAutomationGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceAutomationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceAutomationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceAutomationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceAutomation model
   */
  readonly fields: WorkspaceAutomationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceAutomation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceAutomationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceAutomation model
   */ 
  interface WorkspaceAutomationFieldRefs {
    readonly id: FieldRef<"WorkspaceAutomation", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceAutomation", 'String'>
    readonly name: FieldRef<"WorkspaceAutomation", 'String'>
    readonly description: FieldRef<"WorkspaceAutomation", 'String'>
    readonly trigger: FieldRef<"WorkspaceAutomation", 'Json'>
    readonly actions: FieldRef<"WorkspaceAutomation", 'Json'>
    readonly isActive: FieldRef<"WorkspaceAutomation", 'Boolean'>
    readonly lastRunAt: FieldRef<"WorkspaceAutomation", 'DateTime'>
    readonly runCount: FieldRef<"WorkspaceAutomation", 'Int'>
    readonly createdAt: FieldRef<"WorkspaceAutomation", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkspaceAutomation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceAutomation findUnique
   */
  export type WorkspaceAutomationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceAutomation
     */
    select?: WorkspaceAutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceAutomationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceAutomation to fetch.
     */
    where: WorkspaceAutomationWhereUniqueInput
  }

  /**
   * WorkspaceAutomation findUniqueOrThrow
   */
  export type WorkspaceAutomationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceAutomation
     */
    select?: WorkspaceAutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceAutomationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceAutomation to fetch.
     */
    where: WorkspaceAutomationWhereUniqueInput
  }

  /**
   * WorkspaceAutomation findFirst
   */
  export type WorkspaceAutomationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceAutomation
     */
    select?: WorkspaceAutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceAutomationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceAutomation to fetch.
     */
    where?: WorkspaceAutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceAutomations to fetch.
     */
    orderBy?: WorkspaceAutomationOrderByWithRelationInput | WorkspaceAutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceAutomations.
     */
    cursor?: WorkspaceAutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceAutomations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceAutomations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceAutomations.
     */
    distinct?: WorkspaceAutomationScalarFieldEnum | WorkspaceAutomationScalarFieldEnum[]
  }

  /**
   * WorkspaceAutomation findFirstOrThrow
   */
  export type WorkspaceAutomationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceAutomation
     */
    select?: WorkspaceAutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceAutomationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceAutomation to fetch.
     */
    where?: WorkspaceAutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceAutomations to fetch.
     */
    orderBy?: WorkspaceAutomationOrderByWithRelationInput | WorkspaceAutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceAutomations.
     */
    cursor?: WorkspaceAutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceAutomations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceAutomations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceAutomations.
     */
    distinct?: WorkspaceAutomationScalarFieldEnum | WorkspaceAutomationScalarFieldEnum[]
  }

  /**
   * WorkspaceAutomation findMany
   */
  export type WorkspaceAutomationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceAutomation
     */
    select?: WorkspaceAutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceAutomationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceAutomations to fetch.
     */
    where?: WorkspaceAutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceAutomations to fetch.
     */
    orderBy?: WorkspaceAutomationOrderByWithRelationInput | WorkspaceAutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceAutomations.
     */
    cursor?: WorkspaceAutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceAutomations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceAutomations.
     */
    skip?: number
    distinct?: WorkspaceAutomationScalarFieldEnum | WorkspaceAutomationScalarFieldEnum[]
  }

  /**
   * WorkspaceAutomation create
   */
  export type WorkspaceAutomationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceAutomation
     */
    select?: WorkspaceAutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceAutomationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceAutomation.
     */
    data: XOR<WorkspaceAutomationCreateInput, WorkspaceAutomationUncheckedCreateInput>
  }

  /**
   * WorkspaceAutomation createMany
   */
  export type WorkspaceAutomationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceAutomations.
     */
    data: WorkspaceAutomationCreateManyInput | WorkspaceAutomationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceAutomation createManyAndReturn
   */
  export type WorkspaceAutomationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceAutomation
     */
    select?: WorkspaceAutomationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkspaceAutomations.
     */
    data: WorkspaceAutomationCreateManyInput | WorkspaceAutomationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceAutomationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceAutomation update
   */
  export type WorkspaceAutomationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceAutomation
     */
    select?: WorkspaceAutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceAutomationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceAutomation.
     */
    data: XOR<WorkspaceAutomationUpdateInput, WorkspaceAutomationUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceAutomation to update.
     */
    where: WorkspaceAutomationWhereUniqueInput
  }

  /**
   * WorkspaceAutomation updateMany
   */
  export type WorkspaceAutomationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceAutomations.
     */
    data: XOR<WorkspaceAutomationUpdateManyMutationInput, WorkspaceAutomationUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceAutomations to update
     */
    where?: WorkspaceAutomationWhereInput
  }

  /**
   * WorkspaceAutomation upsert
   */
  export type WorkspaceAutomationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceAutomation
     */
    select?: WorkspaceAutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceAutomationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceAutomation to update in case it exists.
     */
    where: WorkspaceAutomationWhereUniqueInput
    /**
     * In case the WorkspaceAutomation found by the `where` argument doesn't exist, create a new WorkspaceAutomation with this data.
     */
    create: XOR<WorkspaceAutomationCreateInput, WorkspaceAutomationUncheckedCreateInput>
    /**
     * In case the WorkspaceAutomation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceAutomationUpdateInput, WorkspaceAutomationUncheckedUpdateInput>
  }

  /**
   * WorkspaceAutomation delete
   */
  export type WorkspaceAutomationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceAutomation
     */
    select?: WorkspaceAutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceAutomationInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceAutomation to delete.
     */
    where: WorkspaceAutomationWhereUniqueInput
  }

  /**
   * WorkspaceAutomation deleteMany
   */
  export type WorkspaceAutomationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceAutomations to delete
     */
    where?: WorkspaceAutomationWhereInput
  }

  /**
   * WorkspaceAutomation without action
   */
  export type WorkspaceAutomationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceAutomation
     */
    select?: WorkspaceAutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceAutomationInclude<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookAvgAggregateOutputType = {
    failureCount: number | null
  }

  export type WebhookSumAggregateOutputType = {
    failureCount: number | null
  }

  export type WebhookMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    lastTriggeredAt: Date | null
    failureCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    lastTriggeredAt: Date | null
    failureCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    workspaceId: number
    url: number
    events: number
    secret: number
    isActive: number
    lastTriggeredAt: number
    failureCount: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookAvgAggregateInputType = {
    failureCount?: true
  }

  export type WebhookSumAggregateInputType = {
    failureCount?: true
  }

  export type WebhookMinAggregateInputType = {
    id?: true
    workspaceId?: true
    url?: true
    secret?: true
    isActive?: true
    lastTriggeredAt?: true
    failureCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    url?: true
    secret?: true
    isActive?: true
    lastTriggeredAt?: true
    failureCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    workspaceId?: true
    url?: true
    events?: true
    secret?: true
    isActive?: true
    lastTriggeredAt?: true
    failureCount?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _avg?: WebhookAvgAggregateInputType
    _sum?: WebhookSumAggregateInputType
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: string
    workspaceId: string
    url: string
    events: string[]
    secret: string
    isActive: boolean
    lastTriggeredAt: Date | null
    failureCount: number
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    lastTriggeredAt?: boolean
    failureCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    lastTriggeredAt?: boolean
    failureCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    lastTriggeredAt?: boolean
    failureCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebhookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      url: string
      events: string[]
      secret: string
      isActive: boolean
      lastTriggeredAt: Date | null
      failureCount: number
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */ 
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'String'>
    readonly workspaceId: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly events: FieldRef<"Webhook", 'String[]'>
    readonly secret: FieldRef<"Webhook", 'String'>
    readonly isActive: FieldRef<"Webhook", 'Boolean'>
    readonly lastTriggeredAt: FieldRef<"Webhook", 'DateTime'>
    readonly failureCount: FieldRef<"Webhook", 'Int'>
    readonly metadata: FieldRef<"Webhook", 'Json'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
    readonly updatedAt: FieldRef<"Webhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
  }


  /**
   * Model CustomField
   */

  export type AggregateCustomField = {
    _count: CustomFieldCountAggregateOutputType | null
    _avg: CustomFieldAvgAggregateOutputType | null
    _sum: CustomFieldSumAggregateOutputType | null
    _min: CustomFieldMinAggregateOutputType | null
    _max: CustomFieldMaxAggregateOutputType | null
  }

  export type CustomFieldAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CustomFieldSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CustomFieldMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    fieldType: string | null
    isRequired: boolean | null
    defaultValue: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomFieldMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    fieldType: string | null
    isRequired: boolean | null
    defaultValue: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomFieldCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    fieldType: number
    isRequired: number
    options: number
    defaultValue: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomFieldAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CustomFieldSumAggregateInputType = {
    sortOrder?: true
  }

  export type CustomFieldMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    fieldType?: true
    isRequired?: true
    defaultValue?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomFieldMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    fieldType?: true
    isRequired?: true
    defaultValue?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomFieldCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    fieldType?: true
    isRequired?: true
    options?: true
    defaultValue?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomField to aggregate.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomFields
    **/
    _count?: true | CustomFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomFieldMaxAggregateInputType
  }

  export type GetCustomFieldAggregateType<T extends CustomFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomField[P]>
      : GetScalarType<T[P], AggregateCustomField[P]>
  }




  export type CustomFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldWhereInput
    orderBy?: CustomFieldOrderByWithAggregationInput | CustomFieldOrderByWithAggregationInput[]
    by: CustomFieldScalarFieldEnum[] | CustomFieldScalarFieldEnum
    having?: CustomFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomFieldCountAggregateInputType | true
    _avg?: CustomFieldAvgAggregateInputType
    _sum?: CustomFieldSumAggregateInputType
    _min?: CustomFieldMinAggregateInputType
    _max?: CustomFieldMaxAggregateInputType
  }

  export type CustomFieldGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    fieldType: string
    isRequired: boolean
    options: JsonValue | null
    defaultValue: string | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: CustomFieldCountAggregateOutputType | null
    _avg: CustomFieldAvgAggregateOutputType | null
    _sum: CustomFieldSumAggregateOutputType | null
    _min: CustomFieldMinAggregateOutputType | null
    _max: CustomFieldMaxAggregateOutputType | null
  }

  type GetCustomFieldGroupByPayload<T extends CustomFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomFieldGroupByOutputType[P]>
            : GetScalarType<T[P], CustomFieldGroupByOutputType[P]>
        }
      >
    >


  export type CustomFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    fieldType?: boolean
    isRequired?: boolean
    options?: boolean
    defaultValue?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customField"]>

  export type CustomFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    fieldType?: boolean
    isRequired?: boolean
    options?: boolean
    defaultValue?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customField"]>

  export type CustomFieldSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    fieldType?: boolean
    isRequired?: boolean
    options?: boolean
    defaultValue?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type CustomFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $CustomFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomField"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      fieldType: string
      isRequired: boolean
      options: Prisma.JsonValue | null
      defaultValue: string | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customField"]>
    composites: {}
  }

  type CustomFieldGetPayload<S extends boolean | null | undefined | CustomFieldDefaultArgs> = $Result.GetResult<Prisma.$CustomFieldPayload, S>

  type CustomFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomFieldFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomFieldCountAggregateInputType | true
    }

  export interface CustomFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomField'], meta: { name: 'CustomField' } }
    /**
     * Find zero or one CustomField that matches the filter.
     * @param {CustomFieldFindUniqueArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomFieldFindUniqueArgs>(args: SelectSubset<T, CustomFieldFindUniqueArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomField that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomFieldFindUniqueOrThrowArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindFirstArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomFieldFindFirstArgs>(args?: SelectSubset<T, CustomFieldFindFirstArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindFirstOrThrowArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomFields
     * const customFields = await prisma.customField.findMany()
     * 
     * // Get first 10 CustomFields
     * const customFields = await prisma.customField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customFieldWithIdOnly = await prisma.customField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomFieldFindManyArgs>(args?: SelectSubset<T, CustomFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomField.
     * @param {CustomFieldCreateArgs} args - Arguments to create a CustomField.
     * @example
     * // Create one CustomField
     * const CustomField = await prisma.customField.create({
     *   data: {
     *     // ... data to create a CustomField
     *   }
     * })
     * 
     */
    create<T extends CustomFieldCreateArgs>(args: SelectSubset<T, CustomFieldCreateArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomFields.
     * @param {CustomFieldCreateManyArgs} args - Arguments to create many CustomFields.
     * @example
     * // Create many CustomFields
     * const customField = await prisma.customField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomFieldCreateManyArgs>(args?: SelectSubset<T, CustomFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomFields and returns the data saved in the database.
     * @param {CustomFieldCreateManyAndReturnArgs} args - Arguments to create many CustomFields.
     * @example
     * // Create many CustomFields
     * const customField = await prisma.customField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomFields and only return the `id`
     * const customFieldWithIdOnly = await prisma.customField.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomField.
     * @param {CustomFieldDeleteArgs} args - Arguments to delete one CustomField.
     * @example
     * // Delete one CustomField
     * const CustomField = await prisma.customField.delete({
     *   where: {
     *     // ... filter to delete one CustomField
     *   }
     * })
     * 
     */
    delete<T extends CustomFieldDeleteArgs>(args: SelectSubset<T, CustomFieldDeleteArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomField.
     * @param {CustomFieldUpdateArgs} args - Arguments to update one CustomField.
     * @example
     * // Update one CustomField
     * const customField = await prisma.customField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomFieldUpdateArgs>(args: SelectSubset<T, CustomFieldUpdateArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomFields.
     * @param {CustomFieldDeleteManyArgs} args - Arguments to filter CustomFields to delete.
     * @example
     * // Delete a few CustomFields
     * const { count } = await prisma.customField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomFieldDeleteManyArgs>(args?: SelectSubset<T, CustomFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomFields
     * const customField = await prisma.customField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomFieldUpdateManyArgs>(args: SelectSubset<T, CustomFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomField.
     * @param {CustomFieldUpsertArgs} args - Arguments to update or create a CustomField.
     * @example
     * // Update or create a CustomField
     * const customField = await prisma.customField.upsert({
     *   create: {
     *     // ... data to create a CustomField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomField we want to update
     *   }
     * })
     */
    upsert<T extends CustomFieldUpsertArgs>(args: SelectSubset<T, CustomFieldUpsertArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldCountArgs} args - Arguments to filter CustomFields to count.
     * @example
     * // Count the number of CustomFields
     * const count = await prisma.customField.count({
     *   where: {
     *     // ... the filter for the CustomFields we want to count
     *   }
     * })
    **/
    count<T extends CustomFieldCountArgs>(
      args?: Subset<T, CustomFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomFieldAggregateArgs>(args: Subset<T, CustomFieldAggregateArgs>): Prisma.PrismaPromise<GetCustomFieldAggregateType<T>>

    /**
     * Group by CustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomFieldGroupByArgs['orderBy'] }
        : { orderBy?: CustomFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomField model
   */
  readonly fields: CustomFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomField model
   */ 
  interface CustomFieldFieldRefs {
    readonly id: FieldRef<"CustomField", 'String'>
    readonly workspaceId: FieldRef<"CustomField", 'String'>
    readonly name: FieldRef<"CustomField", 'String'>
    readonly fieldType: FieldRef<"CustomField", 'String'>
    readonly isRequired: FieldRef<"CustomField", 'Boolean'>
    readonly options: FieldRef<"CustomField", 'Json'>
    readonly defaultValue: FieldRef<"CustomField", 'String'>
    readonly sortOrder: FieldRef<"CustomField", 'Int'>
    readonly createdAt: FieldRef<"CustomField", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomField findUnique
   */
  export type CustomFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField findUniqueOrThrow
   */
  export type CustomFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField findFirst
   */
  export type CustomFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFields.
     */
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * CustomField findFirstOrThrow
   */
  export type CustomFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFields.
     */
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * CustomField findMany
   */
  export type CustomFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomFields to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * CustomField create
   */
  export type CustomFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomField.
     */
    data: XOR<CustomFieldCreateInput, CustomFieldUncheckedCreateInput>
  }

  /**
   * CustomField createMany
   */
  export type CustomFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomFields.
     */
    data: CustomFieldCreateManyInput | CustomFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomField createManyAndReturn
   */
  export type CustomFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomFields.
     */
    data: CustomFieldCreateManyInput | CustomFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomField update
   */
  export type CustomFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomField.
     */
    data: XOR<CustomFieldUpdateInput, CustomFieldUncheckedUpdateInput>
    /**
     * Choose, which CustomField to update.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField updateMany
   */
  export type CustomFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomFields.
     */
    data: XOR<CustomFieldUpdateManyMutationInput, CustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which CustomFields to update
     */
    where?: CustomFieldWhereInput
  }

  /**
   * CustomField upsert
   */
  export type CustomFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomField to update in case it exists.
     */
    where: CustomFieldWhereUniqueInput
    /**
     * In case the CustomField found by the `where` argument doesn't exist, create a new CustomField with this data.
     */
    create: XOR<CustomFieldCreateInput, CustomFieldUncheckedCreateInput>
    /**
     * In case the CustomField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomFieldUpdateInput, CustomFieldUncheckedUpdateInput>
  }

  /**
   * CustomField delete
   */
  export type CustomFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter which CustomField to delete.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField deleteMany
   */
  export type CustomFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomFields to delete
     */
    where?: CustomFieldWhereInput
  }

  /**
   * CustomField without action
   */
  export type CustomFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    color: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    color: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    color: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    color: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      color: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly workspaceId: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model AiAgent
   */

  export type AggregateAiAgent = {
    _count: AiAgentCountAggregateOutputType | null
    _avg: AiAgentAvgAggregateOutputType | null
    _sum: AiAgentSumAggregateOutputType | null
    _min: AiAgentMinAggregateOutputType | null
    _max: AiAgentMaxAggregateOutputType | null
  }

  export type AiAgentAvgAggregateOutputType = {
    temperature: number | null
    maxTokens: number | null
  }

  export type AiAgentSumAggregateOutputType = {
    temperature: number | null
    maxTokens: number | null
  }

  export type AiAgentMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    systemPrompt: string | null
    model: string | null
    temperature: number | null
    maxTokens: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiAgentMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    systemPrompt: string | null
    model: string | null
    temperature: number | null
    maxTokens: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiAgentCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    description: number
    systemPrompt: number
    model: number
    temperature: number
    maxTokens: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiAgentAvgAggregateInputType = {
    temperature?: true
    maxTokens?: true
  }

  export type AiAgentSumAggregateInputType = {
    temperature?: true
    maxTokens?: true
  }

  export type AiAgentMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    systemPrompt?: true
    model?: true
    temperature?: true
    maxTokens?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiAgentMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    systemPrompt?: true
    model?: true
    temperature?: true
    maxTokens?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiAgentCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    systemPrompt?: true
    model?: true
    temperature?: true
    maxTokens?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiAgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiAgent to aggregate.
     */
    where?: AiAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAgents to fetch.
     */
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiAgents
    **/
    _count?: true | AiAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiAgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiAgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiAgentMaxAggregateInputType
  }

  export type GetAiAgentAggregateType<T extends AiAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAiAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiAgent[P]>
      : GetScalarType<T[P], AggregateAiAgent[P]>
  }




  export type AiAgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiAgentWhereInput
    orderBy?: AiAgentOrderByWithAggregationInput | AiAgentOrderByWithAggregationInput[]
    by: AiAgentScalarFieldEnum[] | AiAgentScalarFieldEnum
    having?: AiAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiAgentCountAggregateInputType | true
    _avg?: AiAgentAvgAggregateInputType
    _sum?: AiAgentSumAggregateInputType
    _min?: AiAgentMinAggregateInputType
    _max?: AiAgentMaxAggregateInputType
  }

  export type AiAgentGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    description: string | null
    systemPrompt: string
    model: string
    temperature: number
    maxTokens: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AiAgentCountAggregateOutputType | null
    _avg: AiAgentAvgAggregateOutputType | null
    _sum: AiAgentSumAggregateOutputType | null
    _min: AiAgentMinAggregateOutputType | null
    _max: AiAgentMaxAggregateOutputType | null
  }

  type GetAiAgentGroupByPayload<T extends AiAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiAgentGroupByOutputType[P]>
            : GetScalarType<T[P], AiAgentGroupByOutputType[P]>
        }
      >
    >


  export type AiAgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    model?: boolean
    temperature?: boolean
    maxTokens?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    conversations?: boolean | AiAgent$conversationsArgs<ExtArgs>
    _count?: boolean | AiAgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiAgent"]>

  export type AiAgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    model?: boolean
    temperature?: boolean
    maxTokens?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiAgent"]>

  export type AiAgentSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    model?: boolean
    temperature?: boolean
    maxTokens?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AiAgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    conversations?: boolean | AiAgent$conversationsArgs<ExtArgs>
    _count?: boolean | AiAgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AiAgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $AiAgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiAgent"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      conversations: Prisma.$AiConversationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      description: string | null
      systemPrompt: string
      model: string
      temperature: number
      maxTokens: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiAgent"]>
    composites: {}
  }

  type AiAgentGetPayload<S extends boolean | null | undefined | AiAgentDefaultArgs> = $Result.GetResult<Prisma.$AiAgentPayload, S>

  type AiAgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiAgentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiAgentCountAggregateInputType | true
    }

  export interface AiAgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiAgent'], meta: { name: 'AiAgent' } }
    /**
     * Find zero or one AiAgent that matches the filter.
     * @param {AiAgentFindUniqueArgs} args - Arguments to find a AiAgent
     * @example
     * // Get one AiAgent
     * const aiAgent = await prisma.aiAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiAgentFindUniqueArgs>(args: SelectSubset<T, AiAgentFindUniqueArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiAgent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiAgentFindUniqueOrThrowArgs} args - Arguments to find a AiAgent
     * @example
     * // Get one AiAgent
     * const aiAgent = await prisma.aiAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiAgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AiAgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentFindFirstArgs} args - Arguments to find a AiAgent
     * @example
     * // Get one AiAgent
     * const aiAgent = await prisma.aiAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiAgentFindFirstArgs>(args?: SelectSubset<T, AiAgentFindFirstArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiAgent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentFindFirstOrThrowArgs} args - Arguments to find a AiAgent
     * @example
     * // Get one AiAgent
     * const aiAgent = await prisma.aiAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiAgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AiAgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiAgents
     * const aiAgents = await prisma.aiAgent.findMany()
     * 
     * // Get first 10 AiAgents
     * const aiAgents = await prisma.aiAgent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiAgentWithIdOnly = await prisma.aiAgent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiAgentFindManyArgs>(args?: SelectSubset<T, AiAgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiAgent.
     * @param {AiAgentCreateArgs} args - Arguments to create a AiAgent.
     * @example
     * // Create one AiAgent
     * const AiAgent = await prisma.aiAgent.create({
     *   data: {
     *     // ... data to create a AiAgent
     *   }
     * })
     * 
     */
    create<T extends AiAgentCreateArgs>(args: SelectSubset<T, AiAgentCreateArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiAgents.
     * @param {AiAgentCreateManyArgs} args - Arguments to create many AiAgents.
     * @example
     * // Create many AiAgents
     * const aiAgent = await prisma.aiAgent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiAgentCreateManyArgs>(args?: SelectSubset<T, AiAgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiAgents and returns the data saved in the database.
     * @param {AiAgentCreateManyAndReturnArgs} args - Arguments to create many AiAgents.
     * @example
     * // Create many AiAgents
     * const aiAgent = await prisma.aiAgent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiAgents and only return the `id`
     * const aiAgentWithIdOnly = await prisma.aiAgent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiAgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AiAgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AiAgent.
     * @param {AiAgentDeleteArgs} args - Arguments to delete one AiAgent.
     * @example
     * // Delete one AiAgent
     * const AiAgent = await prisma.aiAgent.delete({
     *   where: {
     *     // ... filter to delete one AiAgent
     *   }
     * })
     * 
     */
    delete<T extends AiAgentDeleteArgs>(args: SelectSubset<T, AiAgentDeleteArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiAgent.
     * @param {AiAgentUpdateArgs} args - Arguments to update one AiAgent.
     * @example
     * // Update one AiAgent
     * const aiAgent = await prisma.aiAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiAgentUpdateArgs>(args: SelectSubset<T, AiAgentUpdateArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiAgents.
     * @param {AiAgentDeleteManyArgs} args - Arguments to filter AiAgents to delete.
     * @example
     * // Delete a few AiAgents
     * const { count } = await prisma.aiAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiAgentDeleteManyArgs>(args?: SelectSubset<T, AiAgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiAgents
     * const aiAgent = await prisma.aiAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiAgentUpdateManyArgs>(args: SelectSubset<T, AiAgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiAgent.
     * @param {AiAgentUpsertArgs} args - Arguments to update or create a AiAgent.
     * @example
     * // Update or create a AiAgent
     * const aiAgent = await prisma.aiAgent.upsert({
     *   create: {
     *     // ... data to create a AiAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiAgent we want to update
     *   }
     * })
     */
    upsert<T extends AiAgentUpsertArgs>(args: SelectSubset<T, AiAgentUpsertArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentCountArgs} args - Arguments to filter AiAgents to count.
     * @example
     * // Count the number of AiAgents
     * const count = await prisma.aiAgent.count({
     *   where: {
     *     // ... the filter for the AiAgents we want to count
     *   }
     * })
    **/
    count<T extends AiAgentCountArgs>(
      args?: Subset<T, AiAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiAgentAggregateArgs>(args: Subset<T, AiAgentAggregateArgs>): Prisma.PrismaPromise<GetAiAgentAggregateType<T>>

    /**
     * Group by AiAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiAgentGroupByArgs['orderBy'] }
        : { orderBy?: AiAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiAgent model
   */
  readonly fields: AiAgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiAgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    conversations<T extends AiAgent$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, AiAgent$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiAgent model
   */ 
  interface AiAgentFieldRefs {
    readonly id: FieldRef<"AiAgent", 'String'>
    readonly workspaceId: FieldRef<"AiAgent", 'String'>
    readonly name: FieldRef<"AiAgent", 'String'>
    readonly description: FieldRef<"AiAgent", 'String'>
    readonly systemPrompt: FieldRef<"AiAgent", 'String'>
    readonly model: FieldRef<"AiAgent", 'String'>
    readonly temperature: FieldRef<"AiAgent", 'Float'>
    readonly maxTokens: FieldRef<"AiAgent", 'Int'>
    readonly isActive: FieldRef<"AiAgent", 'Boolean'>
    readonly createdAt: FieldRef<"AiAgent", 'DateTime'>
    readonly updatedAt: FieldRef<"AiAgent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiAgent findUnique
   */
  export type AiAgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgent to fetch.
     */
    where: AiAgentWhereUniqueInput
  }

  /**
   * AiAgent findUniqueOrThrow
   */
  export type AiAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgent to fetch.
     */
    where: AiAgentWhereUniqueInput
  }

  /**
   * AiAgent findFirst
   */
  export type AiAgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgent to fetch.
     */
    where?: AiAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAgents to fetch.
     */
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiAgents.
     */
    cursor?: AiAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiAgents.
     */
    distinct?: AiAgentScalarFieldEnum | AiAgentScalarFieldEnum[]
  }

  /**
   * AiAgent findFirstOrThrow
   */
  export type AiAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgent to fetch.
     */
    where?: AiAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAgents to fetch.
     */
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiAgents.
     */
    cursor?: AiAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiAgents.
     */
    distinct?: AiAgentScalarFieldEnum | AiAgentScalarFieldEnum[]
  }

  /**
   * AiAgent findMany
   */
  export type AiAgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgents to fetch.
     */
    where?: AiAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAgents to fetch.
     */
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiAgents.
     */
    cursor?: AiAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAgents.
     */
    skip?: number
    distinct?: AiAgentScalarFieldEnum | AiAgentScalarFieldEnum[]
  }

  /**
   * AiAgent create
   */
  export type AiAgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a AiAgent.
     */
    data: XOR<AiAgentCreateInput, AiAgentUncheckedCreateInput>
  }

  /**
   * AiAgent createMany
   */
  export type AiAgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiAgents.
     */
    data: AiAgentCreateManyInput | AiAgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiAgent createManyAndReturn
   */
  export type AiAgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AiAgents.
     */
    data: AiAgentCreateManyInput | AiAgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiAgent update
   */
  export type AiAgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a AiAgent.
     */
    data: XOR<AiAgentUpdateInput, AiAgentUncheckedUpdateInput>
    /**
     * Choose, which AiAgent to update.
     */
    where: AiAgentWhereUniqueInput
  }

  /**
   * AiAgent updateMany
   */
  export type AiAgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiAgents.
     */
    data: XOR<AiAgentUpdateManyMutationInput, AiAgentUncheckedUpdateManyInput>
    /**
     * Filter which AiAgents to update
     */
    where?: AiAgentWhereInput
  }

  /**
   * AiAgent upsert
   */
  export type AiAgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the AiAgent to update in case it exists.
     */
    where: AiAgentWhereUniqueInput
    /**
     * In case the AiAgent found by the `where` argument doesn't exist, create a new AiAgent with this data.
     */
    create: XOR<AiAgentCreateInput, AiAgentUncheckedCreateInput>
    /**
     * In case the AiAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiAgentUpdateInput, AiAgentUncheckedUpdateInput>
  }

  /**
   * AiAgent delete
   */
  export type AiAgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter which AiAgent to delete.
     */
    where: AiAgentWhereUniqueInput
  }

  /**
   * AiAgent deleteMany
   */
  export type AiAgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiAgents to delete
     */
    where?: AiAgentWhereInput
  }

  /**
   * AiAgent.conversations
   */
  export type AiAgent$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    where?: AiConversationWhereInput
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    cursor?: AiConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiConversationScalarFieldEnum | AiConversationScalarFieldEnum[]
  }

  /**
   * AiAgent without action
   */
  export type AiAgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
  }


  /**
   * Model AiConversation
   */

  export type AggregateAiConversation = {
    _count: AiConversationCountAggregateOutputType | null
    _min: AiConversationMinAggregateOutputType | null
    _max: AiConversationMaxAggregateOutputType | null
  }

  export type AiConversationMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    userId: string | null
    title: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiConversationMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    userId: string | null
    title: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiConversationCountAggregateOutputType = {
    id: number
    agentId: number
    userId: number
    title: number
    context: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiConversationMinAggregateInputType = {
    id?: true
    agentId?: true
    userId?: true
    title?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiConversationMaxAggregateInputType = {
    id?: true
    agentId?: true
    userId?: true
    title?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiConversationCountAggregateInputType = {
    id?: true
    agentId?: true
    userId?: true
    title?: true
    context?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiConversation to aggregate.
     */
    where?: AiConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiConversations to fetch.
     */
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiConversations
    **/
    _count?: true | AiConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiConversationMaxAggregateInputType
  }

  export type GetAiConversationAggregateType<T extends AiConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateAiConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiConversation[P]>
      : GetScalarType<T[P], AggregateAiConversation[P]>
  }




  export type AiConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiConversationWhereInput
    orderBy?: AiConversationOrderByWithAggregationInput | AiConversationOrderByWithAggregationInput[]
    by: AiConversationScalarFieldEnum[] | AiConversationScalarFieldEnum
    having?: AiConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiConversationCountAggregateInputType | true
    _min?: AiConversationMinAggregateInputType
    _max?: AiConversationMaxAggregateInputType
  }

  export type AiConversationGroupByOutputType = {
    id: string
    agentId: string
    userId: string
    title: string | null
    context: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AiConversationCountAggregateOutputType | null
    _min: AiConversationMinAggregateOutputType | null
    _max: AiConversationMaxAggregateOutputType | null
  }

  type GetAiConversationGroupByPayload<T extends AiConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiConversationGroupByOutputType[P]>
            : GetScalarType<T[P], AiConversationGroupByOutputType[P]>
        }
      >
    >


  export type AiConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    userId?: boolean
    title?: boolean
    context?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
    messages?: boolean | AiConversation$messagesArgs<ExtArgs>
    _count?: boolean | AiConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiConversation"]>

  export type AiConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    userId?: boolean
    title?: boolean
    context?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiConversation"]>

  export type AiConversationSelectScalar = {
    id?: boolean
    agentId?: boolean
    userId?: boolean
    title?: boolean
    context?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AiConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
    messages?: boolean | AiConversation$messagesArgs<ExtArgs>
    _count?: boolean | AiConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AiConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }

  export type $AiConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiConversation"
    objects: {
      agent: Prisma.$AiAgentPayload<ExtArgs>
      messages: Prisma.$AiMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      userId: string
      title: string | null
      context: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiConversation"]>
    composites: {}
  }

  type AiConversationGetPayload<S extends boolean | null | undefined | AiConversationDefaultArgs> = $Result.GetResult<Prisma.$AiConversationPayload, S>

  type AiConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiConversationCountAggregateInputType | true
    }

  export interface AiConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiConversation'], meta: { name: 'AiConversation' } }
    /**
     * Find zero or one AiConversation that matches the filter.
     * @param {AiConversationFindUniqueArgs} args - Arguments to find a AiConversation
     * @example
     * // Get one AiConversation
     * const aiConversation = await prisma.aiConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiConversationFindUniqueArgs>(args: SelectSubset<T, AiConversationFindUniqueArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiConversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiConversationFindUniqueOrThrowArgs} args - Arguments to find a AiConversation
     * @example
     * // Get one AiConversation
     * const aiConversation = await prisma.aiConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, AiConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationFindFirstArgs} args - Arguments to find a AiConversation
     * @example
     * // Get one AiConversation
     * const aiConversation = await prisma.aiConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiConversationFindFirstArgs>(args?: SelectSubset<T, AiConversationFindFirstArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationFindFirstOrThrowArgs} args - Arguments to find a AiConversation
     * @example
     * // Get one AiConversation
     * const aiConversation = await prisma.aiConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, AiConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiConversations
     * const aiConversations = await prisma.aiConversation.findMany()
     * 
     * // Get first 10 AiConversations
     * const aiConversations = await prisma.aiConversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiConversationWithIdOnly = await prisma.aiConversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiConversationFindManyArgs>(args?: SelectSubset<T, AiConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiConversation.
     * @param {AiConversationCreateArgs} args - Arguments to create a AiConversation.
     * @example
     * // Create one AiConversation
     * const AiConversation = await prisma.aiConversation.create({
     *   data: {
     *     // ... data to create a AiConversation
     *   }
     * })
     * 
     */
    create<T extends AiConversationCreateArgs>(args: SelectSubset<T, AiConversationCreateArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiConversations.
     * @param {AiConversationCreateManyArgs} args - Arguments to create many AiConversations.
     * @example
     * // Create many AiConversations
     * const aiConversation = await prisma.aiConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiConversationCreateManyArgs>(args?: SelectSubset<T, AiConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiConversations and returns the data saved in the database.
     * @param {AiConversationCreateManyAndReturnArgs} args - Arguments to create many AiConversations.
     * @example
     * // Create many AiConversations
     * const aiConversation = await prisma.aiConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiConversations and only return the `id`
     * const aiConversationWithIdOnly = await prisma.aiConversation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, AiConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AiConversation.
     * @param {AiConversationDeleteArgs} args - Arguments to delete one AiConversation.
     * @example
     * // Delete one AiConversation
     * const AiConversation = await prisma.aiConversation.delete({
     *   where: {
     *     // ... filter to delete one AiConversation
     *   }
     * })
     * 
     */
    delete<T extends AiConversationDeleteArgs>(args: SelectSubset<T, AiConversationDeleteArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiConversation.
     * @param {AiConversationUpdateArgs} args - Arguments to update one AiConversation.
     * @example
     * // Update one AiConversation
     * const aiConversation = await prisma.aiConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiConversationUpdateArgs>(args: SelectSubset<T, AiConversationUpdateArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiConversations.
     * @param {AiConversationDeleteManyArgs} args - Arguments to filter AiConversations to delete.
     * @example
     * // Delete a few AiConversations
     * const { count } = await prisma.aiConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiConversationDeleteManyArgs>(args?: SelectSubset<T, AiConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiConversations
     * const aiConversation = await prisma.aiConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiConversationUpdateManyArgs>(args: SelectSubset<T, AiConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiConversation.
     * @param {AiConversationUpsertArgs} args - Arguments to update or create a AiConversation.
     * @example
     * // Update or create a AiConversation
     * const aiConversation = await prisma.aiConversation.upsert({
     *   create: {
     *     // ... data to create a AiConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiConversation we want to update
     *   }
     * })
     */
    upsert<T extends AiConversationUpsertArgs>(args: SelectSubset<T, AiConversationUpsertArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationCountArgs} args - Arguments to filter AiConversations to count.
     * @example
     * // Count the number of AiConversations
     * const count = await prisma.aiConversation.count({
     *   where: {
     *     // ... the filter for the AiConversations we want to count
     *   }
     * })
    **/
    count<T extends AiConversationCountArgs>(
      args?: Subset<T, AiConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiConversationAggregateArgs>(args: Subset<T, AiConversationAggregateArgs>): Prisma.PrismaPromise<GetAiConversationAggregateType<T>>

    /**
     * Group by AiConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiConversationGroupByArgs['orderBy'] }
        : { orderBy?: AiConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiConversation model
   */
  readonly fields: AiConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AiAgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiAgentDefaultArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends AiConversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, AiConversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiConversation model
   */ 
  interface AiConversationFieldRefs {
    readonly id: FieldRef<"AiConversation", 'String'>
    readonly agentId: FieldRef<"AiConversation", 'String'>
    readonly userId: FieldRef<"AiConversation", 'String'>
    readonly title: FieldRef<"AiConversation", 'String'>
    readonly context: FieldRef<"AiConversation", 'Json'>
    readonly isActive: FieldRef<"AiConversation", 'Boolean'>
    readonly createdAt: FieldRef<"AiConversation", 'DateTime'>
    readonly updatedAt: FieldRef<"AiConversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiConversation findUnique
   */
  export type AiConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversation to fetch.
     */
    where: AiConversationWhereUniqueInput
  }

  /**
   * AiConversation findUniqueOrThrow
   */
  export type AiConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversation to fetch.
     */
    where: AiConversationWhereUniqueInput
  }

  /**
   * AiConversation findFirst
   */
  export type AiConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversation to fetch.
     */
    where?: AiConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiConversations to fetch.
     */
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiConversations.
     */
    cursor?: AiConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiConversations.
     */
    distinct?: AiConversationScalarFieldEnum | AiConversationScalarFieldEnum[]
  }

  /**
   * AiConversation findFirstOrThrow
   */
  export type AiConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversation to fetch.
     */
    where?: AiConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiConversations to fetch.
     */
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiConversations.
     */
    cursor?: AiConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiConversations.
     */
    distinct?: AiConversationScalarFieldEnum | AiConversationScalarFieldEnum[]
  }

  /**
   * AiConversation findMany
   */
  export type AiConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversations to fetch.
     */
    where?: AiConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiConversations to fetch.
     */
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiConversations.
     */
    cursor?: AiConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiConversations.
     */
    skip?: number
    distinct?: AiConversationScalarFieldEnum | AiConversationScalarFieldEnum[]
  }

  /**
   * AiConversation create
   */
  export type AiConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a AiConversation.
     */
    data: XOR<AiConversationCreateInput, AiConversationUncheckedCreateInput>
  }

  /**
   * AiConversation createMany
   */
  export type AiConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiConversations.
     */
    data: AiConversationCreateManyInput | AiConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiConversation createManyAndReturn
   */
  export type AiConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AiConversations.
     */
    data: AiConversationCreateManyInput | AiConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiConversation update
   */
  export type AiConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a AiConversation.
     */
    data: XOR<AiConversationUpdateInput, AiConversationUncheckedUpdateInput>
    /**
     * Choose, which AiConversation to update.
     */
    where: AiConversationWhereUniqueInput
  }

  /**
   * AiConversation updateMany
   */
  export type AiConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiConversations.
     */
    data: XOR<AiConversationUpdateManyMutationInput, AiConversationUncheckedUpdateManyInput>
    /**
     * Filter which AiConversations to update
     */
    where?: AiConversationWhereInput
  }

  /**
   * AiConversation upsert
   */
  export type AiConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the AiConversation to update in case it exists.
     */
    where: AiConversationWhereUniqueInput
    /**
     * In case the AiConversation found by the `where` argument doesn't exist, create a new AiConversation with this data.
     */
    create: XOR<AiConversationCreateInput, AiConversationUncheckedCreateInput>
    /**
     * In case the AiConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiConversationUpdateInput, AiConversationUncheckedUpdateInput>
  }

  /**
   * AiConversation delete
   */
  export type AiConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter which AiConversation to delete.
     */
    where: AiConversationWhereUniqueInput
  }

  /**
   * AiConversation deleteMany
   */
  export type AiConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiConversations to delete
     */
    where?: AiConversationWhereInput
  }

  /**
   * AiConversation.messages
   */
  export type AiConversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    where?: AiMessageWhereInput
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    cursor?: AiMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiMessageScalarFieldEnum | AiMessageScalarFieldEnum[]
  }

  /**
   * AiConversation without action
   */
  export type AiConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
  }


  /**
   * Model AiMessage
   */

  export type AggregateAiMessage = {
    _count: AiMessageCountAggregateOutputType | null
    _avg: AiMessageAvgAggregateOutputType | null
    _sum: AiMessageSumAggregateOutputType | null
    _min: AiMessageMinAggregateOutputType | null
    _max: AiMessageMaxAggregateOutputType | null
  }

  export type AiMessageAvgAggregateOutputType = {
    tokensUsed: number | null
  }

  export type AiMessageSumAggregateOutputType = {
    tokensUsed: number | null
  }

  export type AiMessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: string | null
    content: string | null
    tokensUsed: number | null
    createdAt: Date | null
  }

  export type AiMessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: string | null
    content: string | null
    tokensUsed: number | null
    createdAt: Date | null
  }

  export type AiMessageCountAggregateOutputType = {
    id: number
    conversationId: number
    role: number
    content: number
    tokensUsed: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AiMessageAvgAggregateInputType = {
    tokensUsed?: true
  }

  export type AiMessageSumAggregateInputType = {
    tokensUsed?: true
  }

  export type AiMessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    tokensUsed?: true
    createdAt?: true
  }

  export type AiMessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    tokensUsed?: true
    createdAt?: true
  }

  export type AiMessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    tokensUsed?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AiMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiMessage to aggregate.
     */
    where?: AiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMessages to fetch.
     */
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiMessages
    **/
    _count?: true | AiMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiMessageMaxAggregateInputType
  }

  export type GetAiMessageAggregateType<T extends AiMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateAiMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiMessage[P]>
      : GetScalarType<T[P], AggregateAiMessage[P]>
  }




  export type AiMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiMessageWhereInput
    orderBy?: AiMessageOrderByWithAggregationInput | AiMessageOrderByWithAggregationInput[]
    by: AiMessageScalarFieldEnum[] | AiMessageScalarFieldEnum
    having?: AiMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiMessageCountAggregateInputType | true
    _avg?: AiMessageAvgAggregateInputType
    _sum?: AiMessageSumAggregateInputType
    _min?: AiMessageMinAggregateInputType
    _max?: AiMessageMaxAggregateInputType
  }

  export type AiMessageGroupByOutputType = {
    id: string
    conversationId: string
    role: string
    content: string
    tokensUsed: number | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AiMessageCountAggregateOutputType | null
    _avg: AiMessageAvgAggregateOutputType | null
    _sum: AiMessageSumAggregateOutputType | null
    _min: AiMessageMinAggregateOutputType | null
    _max: AiMessageMaxAggregateOutputType | null
  }

  type GetAiMessageGroupByPayload<T extends AiMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiMessageGroupByOutputType[P]>
            : GetScalarType<T[P], AiMessageGroupByOutputType[P]>
        }
      >
    >


  export type AiMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    tokensUsed?: boolean
    metadata?: boolean
    createdAt?: boolean
    conversation?: boolean | AiConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiMessage"]>

  export type AiMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    tokensUsed?: boolean
    metadata?: boolean
    createdAt?: boolean
    conversation?: boolean | AiConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiMessage"]>

  export type AiMessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    tokensUsed?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AiMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | AiConversationDefaultArgs<ExtArgs>
  }
  export type AiMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | AiConversationDefaultArgs<ExtArgs>
  }

  export type $AiMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiMessage"
    objects: {
      conversation: Prisma.$AiConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      role: string
      content: string
      tokensUsed: number | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["aiMessage"]>
    composites: {}
  }

  type AiMessageGetPayload<S extends boolean | null | undefined | AiMessageDefaultArgs> = $Result.GetResult<Prisma.$AiMessagePayload, S>

  type AiMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiMessageCountAggregateInputType | true
    }

  export interface AiMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiMessage'], meta: { name: 'AiMessage' } }
    /**
     * Find zero or one AiMessage that matches the filter.
     * @param {AiMessageFindUniqueArgs} args - Arguments to find a AiMessage
     * @example
     * // Get one AiMessage
     * const aiMessage = await prisma.aiMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiMessageFindUniqueArgs>(args: SelectSubset<T, AiMessageFindUniqueArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiMessageFindUniqueOrThrowArgs} args - Arguments to find a AiMessage
     * @example
     * // Get one AiMessage
     * const aiMessage = await prisma.aiMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, AiMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageFindFirstArgs} args - Arguments to find a AiMessage
     * @example
     * // Get one AiMessage
     * const aiMessage = await prisma.aiMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiMessageFindFirstArgs>(args?: SelectSubset<T, AiMessageFindFirstArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageFindFirstOrThrowArgs} args - Arguments to find a AiMessage
     * @example
     * // Get one AiMessage
     * const aiMessage = await prisma.aiMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, AiMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiMessages
     * const aiMessages = await prisma.aiMessage.findMany()
     * 
     * // Get first 10 AiMessages
     * const aiMessages = await prisma.aiMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiMessageWithIdOnly = await prisma.aiMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiMessageFindManyArgs>(args?: SelectSubset<T, AiMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiMessage.
     * @param {AiMessageCreateArgs} args - Arguments to create a AiMessage.
     * @example
     * // Create one AiMessage
     * const AiMessage = await prisma.aiMessage.create({
     *   data: {
     *     // ... data to create a AiMessage
     *   }
     * })
     * 
     */
    create<T extends AiMessageCreateArgs>(args: SelectSubset<T, AiMessageCreateArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiMessages.
     * @param {AiMessageCreateManyArgs} args - Arguments to create many AiMessages.
     * @example
     * // Create many AiMessages
     * const aiMessage = await prisma.aiMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiMessageCreateManyArgs>(args?: SelectSubset<T, AiMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiMessages and returns the data saved in the database.
     * @param {AiMessageCreateManyAndReturnArgs} args - Arguments to create many AiMessages.
     * @example
     * // Create many AiMessages
     * const aiMessage = await prisma.aiMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiMessages and only return the `id`
     * const aiMessageWithIdOnly = await prisma.aiMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, AiMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AiMessage.
     * @param {AiMessageDeleteArgs} args - Arguments to delete one AiMessage.
     * @example
     * // Delete one AiMessage
     * const AiMessage = await prisma.aiMessage.delete({
     *   where: {
     *     // ... filter to delete one AiMessage
     *   }
     * })
     * 
     */
    delete<T extends AiMessageDeleteArgs>(args: SelectSubset<T, AiMessageDeleteArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiMessage.
     * @param {AiMessageUpdateArgs} args - Arguments to update one AiMessage.
     * @example
     * // Update one AiMessage
     * const aiMessage = await prisma.aiMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiMessageUpdateArgs>(args: SelectSubset<T, AiMessageUpdateArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiMessages.
     * @param {AiMessageDeleteManyArgs} args - Arguments to filter AiMessages to delete.
     * @example
     * // Delete a few AiMessages
     * const { count } = await prisma.aiMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiMessageDeleteManyArgs>(args?: SelectSubset<T, AiMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiMessages
     * const aiMessage = await prisma.aiMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiMessageUpdateManyArgs>(args: SelectSubset<T, AiMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiMessage.
     * @param {AiMessageUpsertArgs} args - Arguments to update or create a AiMessage.
     * @example
     * // Update or create a AiMessage
     * const aiMessage = await prisma.aiMessage.upsert({
     *   create: {
     *     // ... data to create a AiMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiMessage we want to update
     *   }
     * })
     */
    upsert<T extends AiMessageUpsertArgs>(args: SelectSubset<T, AiMessageUpsertArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageCountArgs} args - Arguments to filter AiMessages to count.
     * @example
     * // Count the number of AiMessages
     * const count = await prisma.aiMessage.count({
     *   where: {
     *     // ... the filter for the AiMessages we want to count
     *   }
     * })
    **/
    count<T extends AiMessageCountArgs>(
      args?: Subset<T, AiMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiMessageAggregateArgs>(args: Subset<T, AiMessageAggregateArgs>): Prisma.PrismaPromise<GetAiMessageAggregateType<T>>

    /**
     * Group by AiMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiMessageGroupByArgs['orderBy'] }
        : { orderBy?: AiMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiMessage model
   */
  readonly fields: AiMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends AiConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiConversationDefaultArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiMessage model
   */ 
  interface AiMessageFieldRefs {
    readonly id: FieldRef<"AiMessage", 'String'>
    readonly conversationId: FieldRef<"AiMessage", 'String'>
    readonly role: FieldRef<"AiMessage", 'String'>
    readonly content: FieldRef<"AiMessage", 'String'>
    readonly tokensUsed: FieldRef<"AiMessage", 'Int'>
    readonly metadata: FieldRef<"AiMessage", 'Json'>
    readonly createdAt: FieldRef<"AiMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiMessage findUnique
   */
  export type AiMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessage to fetch.
     */
    where: AiMessageWhereUniqueInput
  }

  /**
   * AiMessage findUniqueOrThrow
   */
  export type AiMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessage to fetch.
     */
    where: AiMessageWhereUniqueInput
  }

  /**
   * AiMessage findFirst
   */
  export type AiMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessage to fetch.
     */
    where?: AiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMessages to fetch.
     */
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiMessages.
     */
    cursor?: AiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiMessages.
     */
    distinct?: AiMessageScalarFieldEnum | AiMessageScalarFieldEnum[]
  }

  /**
   * AiMessage findFirstOrThrow
   */
  export type AiMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessage to fetch.
     */
    where?: AiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMessages to fetch.
     */
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiMessages.
     */
    cursor?: AiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiMessages.
     */
    distinct?: AiMessageScalarFieldEnum | AiMessageScalarFieldEnum[]
  }

  /**
   * AiMessage findMany
   */
  export type AiMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessages to fetch.
     */
    where?: AiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMessages to fetch.
     */
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiMessages.
     */
    cursor?: AiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMessages.
     */
    skip?: number
    distinct?: AiMessageScalarFieldEnum | AiMessageScalarFieldEnum[]
  }

  /**
   * AiMessage create
   */
  export type AiMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a AiMessage.
     */
    data: XOR<AiMessageCreateInput, AiMessageUncheckedCreateInput>
  }

  /**
   * AiMessage createMany
   */
  export type AiMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiMessages.
     */
    data: AiMessageCreateManyInput | AiMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiMessage createManyAndReturn
   */
  export type AiMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AiMessages.
     */
    data: AiMessageCreateManyInput | AiMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiMessage update
   */
  export type AiMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a AiMessage.
     */
    data: XOR<AiMessageUpdateInput, AiMessageUncheckedUpdateInput>
    /**
     * Choose, which AiMessage to update.
     */
    where: AiMessageWhereUniqueInput
  }

  /**
   * AiMessage updateMany
   */
  export type AiMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiMessages.
     */
    data: XOR<AiMessageUpdateManyMutationInput, AiMessageUncheckedUpdateManyInput>
    /**
     * Filter which AiMessages to update
     */
    where?: AiMessageWhereInput
  }

  /**
   * AiMessage upsert
   */
  export type AiMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the AiMessage to update in case it exists.
     */
    where: AiMessageWhereUniqueInput
    /**
     * In case the AiMessage found by the `where` argument doesn't exist, create a new AiMessage with this data.
     */
    create: XOR<AiMessageCreateInput, AiMessageUncheckedCreateInput>
    /**
     * In case the AiMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiMessageUpdateInput, AiMessageUncheckedUpdateInput>
  }

  /**
   * AiMessage delete
   */
  export type AiMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter which AiMessage to delete.
     */
    where: AiMessageWhereUniqueInput
  }

  /**
   * AiMessage deleteMany
   */
  export type AiMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiMessages to delete
     */
    where?: AiMessageWhereInput
  }

  /**
   * AiMessage without action
   */
  export type AiMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
  }


  /**
   * Model AiTokenUsage
   */

  export type AggregateAiTokenUsage = {
    _count: AiTokenUsageCountAggregateOutputType | null
    _avg: AiTokenUsageAvgAggregateOutputType | null
    _sum: AiTokenUsageSumAggregateOutputType | null
    _min: AiTokenUsageMinAggregateOutputType | null
    _max: AiTokenUsageMaxAggregateOutputType | null
  }

  export type AiTokenUsageAvgAggregateOutputType = {
    tokensUsed: number | null
    cost: Decimal | null
  }

  export type AiTokenUsageSumAggregateOutputType = {
    tokensUsed: number | null
    cost: Decimal | null
  }

  export type AiTokenUsageMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    provider: string | null
    model: string | null
    tokensUsed: number | null
    cost: Decimal | null
    purpose: string | null
    createdAt: Date | null
  }

  export type AiTokenUsageMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    provider: string | null
    model: string | null
    tokensUsed: number | null
    cost: Decimal | null
    purpose: string | null
    createdAt: Date | null
  }

  export type AiTokenUsageCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    provider: number
    model: number
    tokensUsed: number
    cost: number
    purpose: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AiTokenUsageAvgAggregateInputType = {
    tokensUsed?: true
    cost?: true
  }

  export type AiTokenUsageSumAggregateInputType = {
    tokensUsed?: true
    cost?: true
  }

  export type AiTokenUsageMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    provider?: true
    model?: true
    tokensUsed?: true
    cost?: true
    purpose?: true
    createdAt?: true
  }

  export type AiTokenUsageMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    provider?: true
    model?: true
    tokensUsed?: true
    cost?: true
    purpose?: true
    createdAt?: true
  }

  export type AiTokenUsageCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    provider?: true
    model?: true
    tokensUsed?: true
    cost?: true
    purpose?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AiTokenUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiTokenUsage to aggregate.
     */
    where?: AiTokenUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiTokenUsages to fetch.
     */
    orderBy?: AiTokenUsageOrderByWithRelationInput | AiTokenUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiTokenUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiTokenUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiTokenUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiTokenUsages
    **/
    _count?: true | AiTokenUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiTokenUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiTokenUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiTokenUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiTokenUsageMaxAggregateInputType
  }

  export type GetAiTokenUsageAggregateType<T extends AiTokenUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateAiTokenUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiTokenUsage[P]>
      : GetScalarType<T[P], AggregateAiTokenUsage[P]>
  }




  export type AiTokenUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiTokenUsageWhereInput
    orderBy?: AiTokenUsageOrderByWithAggregationInput | AiTokenUsageOrderByWithAggregationInput[]
    by: AiTokenUsageScalarFieldEnum[] | AiTokenUsageScalarFieldEnum
    having?: AiTokenUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiTokenUsageCountAggregateInputType | true
    _avg?: AiTokenUsageAvgAggregateInputType
    _sum?: AiTokenUsageSumAggregateInputType
    _min?: AiTokenUsageMinAggregateInputType
    _max?: AiTokenUsageMaxAggregateInputType
  }

  export type AiTokenUsageGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string
    provider: string
    model: string
    tokensUsed: number
    cost: Decimal
    purpose: string
    metadata: JsonValue | null
    createdAt: Date
    _count: AiTokenUsageCountAggregateOutputType | null
    _avg: AiTokenUsageAvgAggregateOutputType | null
    _sum: AiTokenUsageSumAggregateOutputType | null
    _min: AiTokenUsageMinAggregateOutputType | null
    _max: AiTokenUsageMaxAggregateOutputType | null
  }

  type GetAiTokenUsageGroupByPayload<T extends AiTokenUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiTokenUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiTokenUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiTokenUsageGroupByOutputType[P]>
            : GetScalarType<T[P], AiTokenUsageGroupByOutputType[P]>
        }
      >
    >


  export type AiTokenUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    provider?: boolean
    model?: boolean
    tokensUsed?: boolean
    cost?: boolean
    purpose?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiTokenUsage"]>

  export type AiTokenUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    provider?: boolean
    model?: boolean
    tokensUsed?: boolean
    cost?: boolean
    purpose?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiTokenUsage"]>

  export type AiTokenUsageSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    provider?: boolean
    model?: boolean
    tokensUsed?: boolean
    cost?: boolean
    purpose?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AiTokenUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AiTokenUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AiTokenUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiTokenUsage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string
      provider: string
      model: string
      tokensUsed: number
      cost: Prisma.Decimal
      purpose: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["aiTokenUsage"]>
    composites: {}
  }

  type AiTokenUsageGetPayload<S extends boolean | null | undefined | AiTokenUsageDefaultArgs> = $Result.GetResult<Prisma.$AiTokenUsagePayload, S>

  type AiTokenUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiTokenUsageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiTokenUsageCountAggregateInputType | true
    }

  export interface AiTokenUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiTokenUsage'], meta: { name: 'AiTokenUsage' } }
    /**
     * Find zero or one AiTokenUsage that matches the filter.
     * @param {AiTokenUsageFindUniqueArgs} args - Arguments to find a AiTokenUsage
     * @example
     * // Get one AiTokenUsage
     * const aiTokenUsage = await prisma.aiTokenUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiTokenUsageFindUniqueArgs>(args: SelectSubset<T, AiTokenUsageFindUniqueArgs<ExtArgs>>): Prisma__AiTokenUsageClient<$Result.GetResult<Prisma.$AiTokenUsagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiTokenUsage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiTokenUsageFindUniqueOrThrowArgs} args - Arguments to find a AiTokenUsage
     * @example
     * // Get one AiTokenUsage
     * const aiTokenUsage = await prisma.aiTokenUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiTokenUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, AiTokenUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiTokenUsageClient<$Result.GetResult<Prisma.$AiTokenUsagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiTokenUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTokenUsageFindFirstArgs} args - Arguments to find a AiTokenUsage
     * @example
     * // Get one AiTokenUsage
     * const aiTokenUsage = await prisma.aiTokenUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiTokenUsageFindFirstArgs>(args?: SelectSubset<T, AiTokenUsageFindFirstArgs<ExtArgs>>): Prisma__AiTokenUsageClient<$Result.GetResult<Prisma.$AiTokenUsagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiTokenUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTokenUsageFindFirstOrThrowArgs} args - Arguments to find a AiTokenUsage
     * @example
     * // Get one AiTokenUsage
     * const aiTokenUsage = await prisma.aiTokenUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiTokenUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, AiTokenUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiTokenUsageClient<$Result.GetResult<Prisma.$AiTokenUsagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiTokenUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTokenUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiTokenUsages
     * const aiTokenUsages = await prisma.aiTokenUsage.findMany()
     * 
     * // Get first 10 AiTokenUsages
     * const aiTokenUsages = await prisma.aiTokenUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiTokenUsageWithIdOnly = await prisma.aiTokenUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiTokenUsageFindManyArgs>(args?: SelectSubset<T, AiTokenUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiTokenUsagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiTokenUsage.
     * @param {AiTokenUsageCreateArgs} args - Arguments to create a AiTokenUsage.
     * @example
     * // Create one AiTokenUsage
     * const AiTokenUsage = await prisma.aiTokenUsage.create({
     *   data: {
     *     // ... data to create a AiTokenUsage
     *   }
     * })
     * 
     */
    create<T extends AiTokenUsageCreateArgs>(args: SelectSubset<T, AiTokenUsageCreateArgs<ExtArgs>>): Prisma__AiTokenUsageClient<$Result.GetResult<Prisma.$AiTokenUsagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiTokenUsages.
     * @param {AiTokenUsageCreateManyArgs} args - Arguments to create many AiTokenUsages.
     * @example
     * // Create many AiTokenUsages
     * const aiTokenUsage = await prisma.aiTokenUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiTokenUsageCreateManyArgs>(args?: SelectSubset<T, AiTokenUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiTokenUsages and returns the data saved in the database.
     * @param {AiTokenUsageCreateManyAndReturnArgs} args - Arguments to create many AiTokenUsages.
     * @example
     * // Create many AiTokenUsages
     * const aiTokenUsage = await prisma.aiTokenUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiTokenUsages and only return the `id`
     * const aiTokenUsageWithIdOnly = await prisma.aiTokenUsage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiTokenUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, AiTokenUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiTokenUsagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AiTokenUsage.
     * @param {AiTokenUsageDeleteArgs} args - Arguments to delete one AiTokenUsage.
     * @example
     * // Delete one AiTokenUsage
     * const AiTokenUsage = await prisma.aiTokenUsage.delete({
     *   where: {
     *     // ... filter to delete one AiTokenUsage
     *   }
     * })
     * 
     */
    delete<T extends AiTokenUsageDeleteArgs>(args: SelectSubset<T, AiTokenUsageDeleteArgs<ExtArgs>>): Prisma__AiTokenUsageClient<$Result.GetResult<Prisma.$AiTokenUsagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiTokenUsage.
     * @param {AiTokenUsageUpdateArgs} args - Arguments to update one AiTokenUsage.
     * @example
     * // Update one AiTokenUsage
     * const aiTokenUsage = await prisma.aiTokenUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiTokenUsageUpdateArgs>(args: SelectSubset<T, AiTokenUsageUpdateArgs<ExtArgs>>): Prisma__AiTokenUsageClient<$Result.GetResult<Prisma.$AiTokenUsagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiTokenUsages.
     * @param {AiTokenUsageDeleteManyArgs} args - Arguments to filter AiTokenUsages to delete.
     * @example
     * // Delete a few AiTokenUsages
     * const { count } = await prisma.aiTokenUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiTokenUsageDeleteManyArgs>(args?: SelectSubset<T, AiTokenUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiTokenUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTokenUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiTokenUsages
     * const aiTokenUsage = await prisma.aiTokenUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiTokenUsageUpdateManyArgs>(args: SelectSubset<T, AiTokenUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiTokenUsage.
     * @param {AiTokenUsageUpsertArgs} args - Arguments to update or create a AiTokenUsage.
     * @example
     * // Update or create a AiTokenUsage
     * const aiTokenUsage = await prisma.aiTokenUsage.upsert({
     *   create: {
     *     // ... data to create a AiTokenUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiTokenUsage we want to update
     *   }
     * })
     */
    upsert<T extends AiTokenUsageUpsertArgs>(args: SelectSubset<T, AiTokenUsageUpsertArgs<ExtArgs>>): Prisma__AiTokenUsageClient<$Result.GetResult<Prisma.$AiTokenUsagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiTokenUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTokenUsageCountArgs} args - Arguments to filter AiTokenUsages to count.
     * @example
     * // Count the number of AiTokenUsages
     * const count = await prisma.aiTokenUsage.count({
     *   where: {
     *     // ... the filter for the AiTokenUsages we want to count
     *   }
     * })
    **/
    count<T extends AiTokenUsageCountArgs>(
      args?: Subset<T, AiTokenUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiTokenUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiTokenUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTokenUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiTokenUsageAggregateArgs>(args: Subset<T, AiTokenUsageAggregateArgs>): Prisma.PrismaPromise<GetAiTokenUsageAggregateType<T>>

    /**
     * Group by AiTokenUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTokenUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiTokenUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiTokenUsageGroupByArgs['orderBy'] }
        : { orderBy?: AiTokenUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiTokenUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiTokenUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiTokenUsage model
   */
  readonly fields: AiTokenUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiTokenUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiTokenUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiTokenUsage model
   */ 
  interface AiTokenUsageFieldRefs {
    readonly id: FieldRef<"AiTokenUsage", 'String'>
    readonly userId: FieldRef<"AiTokenUsage", 'String'>
    readonly workspaceId: FieldRef<"AiTokenUsage", 'String'>
    readonly provider: FieldRef<"AiTokenUsage", 'String'>
    readonly model: FieldRef<"AiTokenUsage", 'String'>
    readonly tokensUsed: FieldRef<"AiTokenUsage", 'Int'>
    readonly cost: FieldRef<"AiTokenUsage", 'Decimal'>
    readonly purpose: FieldRef<"AiTokenUsage", 'String'>
    readonly metadata: FieldRef<"AiTokenUsage", 'Json'>
    readonly createdAt: FieldRef<"AiTokenUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiTokenUsage findUnique
   */
  export type AiTokenUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTokenUsage
     */
    select?: AiTokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTokenUsageInclude<ExtArgs> | null
    /**
     * Filter, which AiTokenUsage to fetch.
     */
    where: AiTokenUsageWhereUniqueInput
  }

  /**
   * AiTokenUsage findUniqueOrThrow
   */
  export type AiTokenUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTokenUsage
     */
    select?: AiTokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTokenUsageInclude<ExtArgs> | null
    /**
     * Filter, which AiTokenUsage to fetch.
     */
    where: AiTokenUsageWhereUniqueInput
  }

  /**
   * AiTokenUsage findFirst
   */
  export type AiTokenUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTokenUsage
     */
    select?: AiTokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTokenUsageInclude<ExtArgs> | null
    /**
     * Filter, which AiTokenUsage to fetch.
     */
    where?: AiTokenUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiTokenUsages to fetch.
     */
    orderBy?: AiTokenUsageOrderByWithRelationInput | AiTokenUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiTokenUsages.
     */
    cursor?: AiTokenUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiTokenUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiTokenUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiTokenUsages.
     */
    distinct?: AiTokenUsageScalarFieldEnum | AiTokenUsageScalarFieldEnum[]
  }

  /**
   * AiTokenUsage findFirstOrThrow
   */
  export type AiTokenUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTokenUsage
     */
    select?: AiTokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTokenUsageInclude<ExtArgs> | null
    /**
     * Filter, which AiTokenUsage to fetch.
     */
    where?: AiTokenUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiTokenUsages to fetch.
     */
    orderBy?: AiTokenUsageOrderByWithRelationInput | AiTokenUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiTokenUsages.
     */
    cursor?: AiTokenUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiTokenUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiTokenUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiTokenUsages.
     */
    distinct?: AiTokenUsageScalarFieldEnum | AiTokenUsageScalarFieldEnum[]
  }

  /**
   * AiTokenUsage findMany
   */
  export type AiTokenUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTokenUsage
     */
    select?: AiTokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTokenUsageInclude<ExtArgs> | null
    /**
     * Filter, which AiTokenUsages to fetch.
     */
    where?: AiTokenUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiTokenUsages to fetch.
     */
    orderBy?: AiTokenUsageOrderByWithRelationInput | AiTokenUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiTokenUsages.
     */
    cursor?: AiTokenUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiTokenUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiTokenUsages.
     */
    skip?: number
    distinct?: AiTokenUsageScalarFieldEnum | AiTokenUsageScalarFieldEnum[]
  }

  /**
   * AiTokenUsage create
   */
  export type AiTokenUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTokenUsage
     */
    select?: AiTokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTokenUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a AiTokenUsage.
     */
    data: XOR<AiTokenUsageCreateInput, AiTokenUsageUncheckedCreateInput>
  }

  /**
   * AiTokenUsage createMany
   */
  export type AiTokenUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiTokenUsages.
     */
    data: AiTokenUsageCreateManyInput | AiTokenUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiTokenUsage createManyAndReturn
   */
  export type AiTokenUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTokenUsage
     */
    select?: AiTokenUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AiTokenUsages.
     */
    data: AiTokenUsageCreateManyInput | AiTokenUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTokenUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiTokenUsage update
   */
  export type AiTokenUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTokenUsage
     */
    select?: AiTokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTokenUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a AiTokenUsage.
     */
    data: XOR<AiTokenUsageUpdateInput, AiTokenUsageUncheckedUpdateInput>
    /**
     * Choose, which AiTokenUsage to update.
     */
    where: AiTokenUsageWhereUniqueInput
  }

  /**
   * AiTokenUsage updateMany
   */
  export type AiTokenUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiTokenUsages.
     */
    data: XOR<AiTokenUsageUpdateManyMutationInput, AiTokenUsageUncheckedUpdateManyInput>
    /**
     * Filter which AiTokenUsages to update
     */
    where?: AiTokenUsageWhereInput
  }

  /**
   * AiTokenUsage upsert
   */
  export type AiTokenUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTokenUsage
     */
    select?: AiTokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTokenUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the AiTokenUsage to update in case it exists.
     */
    where: AiTokenUsageWhereUniqueInput
    /**
     * In case the AiTokenUsage found by the `where` argument doesn't exist, create a new AiTokenUsage with this data.
     */
    create: XOR<AiTokenUsageCreateInput, AiTokenUsageUncheckedCreateInput>
    /**
     * In case the AiTokenUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiTokenUsageUpdateInput, AiTokenUsageUncheckedUpdateInput>
  }

  /**
   * AiTokenUsage delete
   */
  export type AiTokenUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTokenUsage
     */
    select?: AiTokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTokenUsageInclude<ExtArgs> | null
    /**
     * Filter which AiTokenUsage to delete.
     */
    where: AiTokenUsageWhereUniqueInput
  }

  /**
   * AiTokenUsage deleteMany
   */
  export type AiTokenUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiTokenUsages to delete
     */
    where?: AiTokenUsageWhereInput
  }

  /**
   * AiTokenUsage without action
   */
  export type AiTokenUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTokenUsage
     */
    select?: AiTokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTokenUsageInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isSystem: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isSystem: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isSystem: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly isSystem: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    resource: string | null
    action: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    resource: string | null
    action: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    resource: number
    action: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    resource?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    resource?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    resource?: true
    action?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    resource: string
    action: string
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      resource: string
      action: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly resource: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    roleId: string
    permissionId: string
    createdAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
  }

  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      permissionId: string
      createdAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model UsageTracking
   */

  export type AggregateUsageTracking = {
    _count: UsageTrackingCountAggregateOutputType | null
    _avg: UsageTrackingAvgAggregateOutputType | null
    _sum: UsageTrackingSumAggregateOutputType | null
    _min: UsageTrackingMinAggregateOutputType | null
    _max: UsageTrackingMaxAggregateOutputType | null
  }

  export type UsageTrackingAvgAggregateOutputType = {
    quantity: number | null
  }

  export type UsageTrackingSumAggregateOutputType = {
    quantity: number | null
  }

  export type UsageTrackingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    resourceType: string | null
    resourceId: string | null
    action: string | null
    quantity: number | null
    timestamp: Date | null
  }

  export type UsageTrackingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    resourceType: string | null
    resourceId: string | null
    action: string | null
    quantity: number | null
    timestamp: Date | null
  }

  export type UsageTrackingCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    resourceType: number
    resourceId: number
    action: number
    quantity: number
    metadata: number
    timestamp: number
    _all: number
  }


  export type UsageTrackingAvgAggregateInputType = {
    quantity?: true
  }

  export type UsageTrackingSumAggregateInputType = {
    quantity?: true
  }

  export type UsageTrackingMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    resourceType?: true
    resourceId?: true
    action?: true
    quantity?: true
    timestamp?: true
  }

  export type UsageTrackingMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    resourceType?: true
    resourceId?: true
    action?: true
    quantity?: true
    timestamp?: true
  }

  export type UsageTrackingCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    resourceType?: true
    resourceId?: true
    action?: true
    quantity?: true
    metadata?: true
    timestamp?: true
    _all?: true
  }

  export type UsageTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageTracking to aggregate.
     */
    where?: UsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageTrackings to fetch.
     */
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageTrackings
    **/
    _count?: true | UsageTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageTrackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageTrackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageTrackingMaxAggregateInputType
  }

  export type GetUsageTrackingAggregateType<T extends UsageTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageTracking[P]>
      : GetScalarType<T[P], AggregateUsageTracking[P]>
  }




  export type UsageTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageTrackingWhereInput
    orderBy?: UsageTrackingOrderByWithAggregationInput | UsageTrackingOrderByWithAggregationInput[]
    by: UsageTrackingScalarFieldEnum[] | UsageTrackingScalarFieldEnum
    having?: UsageTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageTrackingCountAggregateInputType | true
    _avg?: UsageTrackingAvgAggregateInputType
    _sum?: UsageTrackingSumAggregateInputType
    _min?: UsageTrackingMinAggregateInputType
    _max?: UsageTrackingMaxAggregateInputType
  }

  export type UsageTrackingGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string
    resourceType: string
    resourceId: string
    action: string
    quantity: number
    metadata: JsonValue | null
    timestamp: Date
    _count: UsageTrackingCountAggregateOutputType | null
    _avg: UsageTrackingAvgAggregateOutputType | null
    _sum: UsageTrackingSumAggregateOutputType | null
    _min: UsageTrackingMinAggregateOutputType | null
    _max: UsageTrackingMaxAggregateOutputType | null
  }

  type GetUsageTrackingGroupByPayload<T extends UsageTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], UsageTrackingGroupByOutputType[P]>
        }
      >
    >


  export type UsageTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    resourceType?: boolean
    resourceId?: boolean
    action?: boolean
    quantity?: boolean
    metadata?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["usageTracking"]>

  export type UsageTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    resourceType?: boolean
    resourceId?: boolean
    action?: boolean
    quantity?: boolean
    metadata?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["usageTracking"]>

  export type UsageTrackingSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    resourceType?: boolean
    resourceId?: boolean
    action?: boolean
    quantity?: boolean
    metadata?: boolean
    timestamp?: boolean
  }


  export type $UsageTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageTracking"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string
      resourceType: string
      resourceId: string
      action: string
      quantity: number
      metadata: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["usageTracking"]>
    composites: {}
  }

  type UsageTrackingGetPayload<S extends boolean | null | undefined | UsageTrackingDefaultArgs> = $Result.GetResult<Prisma.$UsageTrackingPayload, S>

  type UsageTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsageTrackingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsageTrackingCountAggregateInputType | true
    }

  export interface UsageTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageTracking'], meta: { name: 'UsageTracking' } }
    /**
     * Find zero or one UsageTracking that matches the filter.
     * @param {UsageTrackingFindUniqueArgs} args - Arguments to find a UsageTracking
     * @example
     * // Get one UsageTracking
     * const usageTracking = await prisma.usageTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageTrackingFindUniqueArgs>(args: SelectSubset<T, UsageTrackingFindUniqueArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsageTracking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsageTrackingFindUniqueOrThrowArgs} args - Arguments to find a UsageTracking
     * @example
     * // Get one UsageTracking
     * const usageTracking = await prisma.usageTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsageTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingFindFirstArgs} args - Arguments to find a UsageTracking
     * @example
     * // Get one UsageTracking
     * const usageTracking = await prisma.usageTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageTrackingFindFirstArgs>(args?: SelectSubset<T, UsageTrackingFindFirstArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsageTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingFindFirstOrThrowArgs} args - Arguments to find a UsageTracking
     * @example
     * // Get one UsageTracking
     * const usageTracking = await prisma.usageTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsageTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageTrackings
     * const usageTrackings = await prisma.usageTracking.findMany()
     * 
     * // Get first 10 UsageTrackings
     * const usageTrackings = await prisma.usageTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageTrackingWithIdOnly = await prisma.usageTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageTrackingFindManyArgs>(args?: SelectSubset<T, UsageTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsageTracking.
     * @param {UsageTrackingCreateArgs} args - Arguments to create a UsageTracking.
     * @example
     * // Create one UsageTracking
     * const UsageTracking = await prisma.usageTracking.create({
     *   data: {
     *     // ... data to create a UsageTracking
     *   }
     * })
     * 
     */
    create<T extends UsageTrackingCreateArgs>(args: SelectSubset<T, UsageTrackingCreateArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsageTrackings.
     * @param {UsageTrackingCreateManyArgs} args - Arguments to create many UsageTrackings.
     * @example
     * // Create many UsageTrackings
     * const usageTracking = await prisma.usageTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageTrackingCreateManyArgs>(args?: SelectSubset<T, UsageTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageTrackings and returns the data saved in the database.
     * @param {UsageTrackingCreateManyAndReturnArgs} args - Arguments to create many UsageTrackings.
     * @example
     * // Create many UsageTrackings
     * const usageTracking = await prisma.usageTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageTrackings and only return the `id`
     * const usageTrackingWithIdOnly = await prisma.usageTracking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsageTracking.
     * @param {UsageTrackingDeleteArgs} args - Arguments to delete one UsageTracking.
     * @example
     * // Delete one UsageTracking
     * const UsageTracking = await prisma.usageTracking.delete({
     *   where: {
     *     // ... filter to delete one UsageTracking
     *   }
     * })
     * 
     */
    delete<T extends UsageTrackingDeleteArgs>(args: SelectSubset<T, UsageTrackingDeleteArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsageTracking.
     * @param {UsageTrackingUpdateArgs} args - Arguments to update one UsageTracking.
     * @example
     * // Update one UsageTracking
     * const usageTracking = await prisma.usageTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageTrackingUpdateArgs>(args: SelectSubset<T, UsageTrackingUpdateArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsageTrackings.
     * @param {UsageTrackingDeleteManyArgs} args - Arguments to filter UsageTrackings to delete.
     * @example
     * // Delete a few UsageTrackings
     * const { count } = await prisma.usageTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageTrackingDeleteManyArgs>(args?: SelectSubset<T, UsageTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageTrackings
     * const usageTracking = await prisma.usageTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageTrackingUpdateManyArgs>(args: SelectSubset<T, UsageTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageTracking.
     * @param {UsageTrackingUpsertArgs} args - Arguments to update or create a UsageTracking.
     * @example
     * // Update or create a UsageTracking
     * const usageTracking = await prisma.usageTracking.upsert({
     *   create: {
     *     // ... data to create a UsageTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageTracking we want to update
     *   }
     * })
     */
    upsert<T extends UsageTrackingUpsertArgs>(args: SelectSubset<T, UsageTrackingUpsertArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsageTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingCountArgs} args - Arguments to filter UsageTrackings to count.
     * @example
     * // Count the number of UsageTrackings
     * const count = await prisma.usageTracking.count({
     *   where: {
     *     // ... the filter for the UsageTrackings we want to count
     *   }
     * })
    **/
    count<T extends UsageTrackingCountArgs>(
      args?: Subset<T, UsageTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageTrackingAggregateArgs>(args: Subset<T, UsageTrackingAggregateArgs>): Prisma.PrismaPromise<GetUsageTrackingAggregateType<T>>

    /**
     * Group by UsageTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageTrackingGroupByArgs['orderBy'] }
        : { orderBy?: UsageTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageTracking model
   */
  readonly fields: UsageTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageTracking model
   */ 
  interface UsageTrackingFieldRefs {
    readonly id: FieldRef<"UsageTracking", 'String'>
    readonly userId: FieldRef<"UsageTracking", 'String'>
    readonly workspaceId: FieldRef<"UsageTracking", 'String'>
    readonly resourceType: FieldRef<"UsageTracking", 'String'>
    readonly resourceId: FieldRef<"UsageTracking", 'String'>
    readonly action: FieldRef<"UsageTracking", 'String'>
    readonly quantity: FieldRef<"UsageTracking", 'Int'>
    readonly metadata: FieldRef<"UsageTracking", 'Json'>
    readonly timestamp: FieldRef<"UsageTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageTracking findUnique
   */
  export type UsageTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Filter, which UsageTracking to fetch.
     */
    where: UsageTrackingWhereUniqueInput
  }

  /**
   * UsageTracking findUniqueOrThrow
   */
  export type UsageTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Filter, which UsageTracking to fetch.
     */
    where: UsageTrackingWhereUniqueInput
  }

  /**
   * UsageTracking findFirst
   */
  export type UsageTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Filter, which UsageTracking to fetch.
     */
    where?: UsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageTrackings to fetch.
     */
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageTrackings.
     */
    cursor?: UsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageTrackings.
     */
    distinct?: UsageTrackingScalarFieldEnum | UsageTrackingScalarFieldEnum[]
  }

  /**
   * UsageTracking findFirstOrThrow
   */
  export type UsageTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Filter, which UsageTracking to fetch.
     */
    where?: UsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageTrackings to fetch.
     */
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageTrackings.
     */
    cursor?: UsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageTrackings.
     */
    distinct?: UsageTrackingScalarFieldEnum | UsageTrackingScalarFieldEnum[]
  }

  /**
   * UsageTracking findMany
   */
  export type UsageTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Filter, which UsageTrackings to fetch.
     */
    where?: UsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageTrackings to fetch.
     */
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageTrackings.
     */
    cursor?: UsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageTrackings.
     */
    skip?: number
    distinct?: UsageTrackingScalarFieldEnum | UsageTrackingScalarFieldEnum[]
  }

  /**
   * UsageTracking create
   */
  export type UsageTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * The data needed to create a UsageTracking.
     */
    data: XOR<UsageTrackingCreateInput, UsageTrackingUncheckedCreateInput>
  }

  /**
   * UsageTracking createMany
   */
  export type UsageTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageTrackings.
     */
    data: UsageTrackingCreateManyInput | UsageTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageTracking createManyAndReturn
   */
  export type UsageTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsageTrackings.
     */
    data: UsageTrackingCreateManyInput | UsageTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageTracking update
   */
  export type UsageTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * The data needed to update a UsageTracking.
     */
    data: XOR<UsageTrackingUpdateInput, UsageTrackingUncheckedUpdateInput>
    /**
     * Choose, which UsageTracking to update.
     */
    where: UsageTrackingWhereUniqueInput
  }

  /**
   * UsageTracking updateMany
   */
  export type UsageTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageTrackings.
     */
    data: XOR<UsageTrackingUpdateManyMutationInput, UsageTrackingUncheckedUpdateManyInput>
    /**
     * Filter which UsageTrackings to update
     */
    where?: UsageTrackingWhereInput
  }

  /**
   * UsageTracking upsert
   */
  export type UsageTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * The filter to search for the UsageTracking to update in case it exists.
     */
    where: UsageTrackingWhereUniqueInput
    /**
     * In case the UsageTracking found by the `where` argument doesn't exist, create a new UsageTracking with this data.
     */
    create: XOR<UsageTrackingCreateInput, UsageTrackingUncheckedCreateInput>
    /**
     * In case the UsageTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageTrackingUpdateInput, UsageTrackingUncheckedUpdateInput>
  }

  /**
   * UsageTracking delete
   */
  export type UsageTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Filter which UsageTracking to delete.
     */
    where: UsageTrackingWhereUniqueInput
  }

  /**
   * UsageTracking deleteMany
   */
  export type UsageTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageTrackings to delete
     */
    where?: UsageTrackingWhereInput
  }

  /**
   * UsageTracking without action
   */
  export type UsageTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
  }


  /**
   * Model UsageReport
   */

  export type AggregateUsageReport = {
    _count: UsageReportCountAggregateOutputType | null
    _avg: UsageReportAvgAggregateOutputType | null
    _sum: UsageReportSumAggregateOutputType | null
    _min: UsageReportMinAggregateOutputType | null
    _max: UsageReportMaxAggregateOutputType | null
  }

  export type UsageReportAvgAggregateOutputType = {
    totalUploads: number | null
    totalMinutes: number | null
    totalStorage: number | null
  }

  export type UsageReportSumAggregateOutputType = {
    totalUploads: number | null
    totalMinutes: number | null
    totalStorage: bigint | null
  }

  export type UsageReportMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    reportType: string | null
    periodStart: Date | null
    periodEnd: Date | null
    totalUploads: number | null
    totalMinutes: number | null
    totalStorage: bigint | null
    generatedAt: Date | null
  }

  export type UsageReportMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    reportType: string | null
    periodStart: Date | null
    periodEnd: Date | null
    totalUploads: number | null
    totalMinutes: number | null
    totalStorage: bigint | null
    generatedAt: Date | null
  }

  export type UsageReportCountAggregateOutputType = {
    id: number
    workspaceId: number
    reportType: number
    periodStart: number
    periodEnd: number
    totalUploads: number
    totalMinutes: number
    totalStorage: number
    reportData: number
    generatedAt: number
    _all: number
  }


  export type UsageReportAvgAggregateInputType = {
    totalUploads?: true
    totalMinutes?: true
    totalStorage?: true
  }

  export type UsageReportSumAggregateInputType = {
    totalUploads?: true
    totalMinutes?: true
    totalStorage?: true
  }

  export type UsageReportMinAggregateInputType = {
    id?: true
    workspaceId?: true
    reportType?: true
    periodStart?: true
    periodEnd?: true
    totalUploads?: true
    totalMinutes?: true
    totalStorage?: true
    generatedAt?: true
  }

  export type UsageReportMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    reportType?: true
    periodStart?: true
    periodEnd?: true
    totalUploads?: true
    totalMinutes?: true
    totalStorage?: true
    generatedAt?: true
  }

  export type UsageReportCountAggregateInputType = {
    id?: true
    workspaceId?: true
    reportType?: true
    periodStart?: true
    periodEnd?: true
    totalUploads?: true
    totalMinutes?: true
    totalStorage?: true
    reportData?: true
    generatedAt?: true
    _all?: true
  }

  export type UsageReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageReport to aggregate.
     */
    where?: UsageReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageReports to fetch.
     */
    orderBy?: UsageReportOrderByWithRelationInput | UsageReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageReports
    **/
    _count?: true | UsageReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageReportMaxAggregateInputType
  }

  export type GetUsageReportAggregateType<T extends UsageReportAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageReport[P]>
      : GetScalarType<T[P], AggregateUsageReport[P]>
  }




  export type UsageReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageReportWhereInput
    orderBy?: UsageReportOrderByWithAggregationInput | UsageReportOrderByWithAggregationInput[]
    by: UsageReportScalarFieldEnum[] | UsageReportScalarFieldEnum
    having?: UsageReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageReportCountAggregateInputType | true
    _avg?: UsageReportAvgAggregateInputType
    _sum?: UsageReportSumAggregateInputType
    _min?: UsageReportMinAggregateInputType
    _max?: UsageReportMaxAggregateInputType
  }

  export type UsageReportGroupByOutputType = {
    id: string
    workspaceId: string
    reportType: string
    periodStart: Date
    periodEnd: Date
    totalUploads: number
    totalMinutes: number
    totalStorage: bigint
    reportData: JsonValue
    generatedAt: Date
    _count: UsageReportCountAggregateOutputType | null
    _avg: UsageReportAvgAggregateOutputType | null
    _sum: UsageReportSumAggregateOutputType | null
    _min: UsageReportMinAggregateOutputType | null
    _max: UsageReportMaxAggregateOutputType | null
  }

  type GetUsageReportGroupByPayload<T extends UsageReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageReportGroupByOutputType[P]>
            : GetScalarType<T[P], UsageReportGroupByOutputType[P]>
        }
      >
    >


  export type UsageReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    reportType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalUploads?: boolean
    totalMinutes?: boolean
    totalStorage?: boolean
    reportData?: boolean
    generatedAt?: boolean
  }, ExtArgs["result"]["usageReport"]>

  export type UsageReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    reportType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalUploads?: boolean
    totalMinutes?: boolean
    totalStorage?: boolean
    reportData?: boolean
    generatedAt?: boolean
  }, ExtArgs["result"]["usageReport"]>

  export type UsageReportSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    reportType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalUploads?: boolean
    totalMinutes?: boolean
    totalStorage?: boolean
    reportData?: boolean
    generatedAt?: boolean
  }


  export type $UsageReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      reportType: string
      periodStart: Date
      periodEnd: Date
      totalUploads: number
      totalMinutes: number
      totalStorage: bigint
      reportData: Prisma.JsonValue
      generatedAt: Date
    }, ExtArgs["result"]["usageReport"]>
    composites: {}
  }

  type UsageReportGetPayload<S extends boolean | null | undefined | UsageReportDefaultArgs> = $Result.GetResult<Prisma.$UsageReportPayload, S>

  type UsageReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsageReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsageReportCountAggregateInputType | true
    }

  export interface UsageReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageReport'], meta: { name: 'UsageReport' } }
    /**
     * Find zero or one UsageReport that matches the filter.
     * @param {UsageReportFindUniqueArgs} args - Arguments to find a UsageReport
     * @example
     * // Get one UsageReport
     * const usageReport = await prisma.usageReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageReportFindUniqueArgs>(args: SelectSubset<T, UsageReportFindUniqueArgs<ExtArgs>>): Prisma__UsageReportClient<$Result.GetResult<Prisma.$UsageReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsageReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsageReportFindUniqueOrThrowArgs} args - Arguments to find a UsageReport
     * @example
     * // Get one UsageReport
     * const usageReport = await prisma.usageReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageReportFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageReportClient<$Result.GetResult<Prisma.$UsageReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsageReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageReportFindFirstArgs} args - Arguments to find a UsageReport
     * @example
     * // Get one UsageReport
     * const usageReport = await prisma.usageReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageReportFindFirstArgs>(args?: SelectSubset<T, UsageReportFindFirstArgs<ExtArgs>>): Prisma__UsageReportClient<$Result.GetResult<Prisma.$UsageReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsageReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageReportFindFirstOrThrowArgs} args - Arguments to find a UsageReport
     * @example
     * // Get one UsageReport
     * const usageReport = await prisma.usageReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageReportFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageReportClient<$Result.GetResult<Prisma.$UsageReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsageReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageReports
     * const usageReports = await prisma.usageReport.findMany()
     * 
     * // Get first 10 UsageReports
     * const usageReports = await prisma.usageReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageReportWithIdOnly = await prisma.usageReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageReportFindManyArgs>(args?: SelectSubset<T, UsageReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsageReport.
     * @param {UsageReportCreateArgs} args - Arguments to create a UsageReport.
     * @example
     * // Create one UsageReport
     * const UsageReport = await prisma.usageReport.create({
     *   data: {
     *     // ... data to create a UsageReport
     *   }
     * })
     * 
     */
    create<T extends UsageReportCreateArgs>(args: SelectSubset<T, UsageReportCreateArgs<ExtArgs>>): Prisma__UsageReportClient<$Result.GetResult<Prisma.$UsageReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsageReports.
     * @param {UsageReportCreateManyArgs} args - Arguments to create many UsageReports.
     * @example
     * // Create many UsageReports
     * const usageReport = await prisma.usageReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageReportCreateManyArgs>(args?: SelectSubset<T, UsageReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageReports and returns the data saved in the database.
     * @param {UsageReportCreateManyAndReturnArgs} args - Arguments to create many UsageReports.
     * @example
     * // Create many UsageReports
     * const usageReport = await prisma.usageReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageReports and only return the `id`
     * const usageReportWithIdOnly = await prisma.usageReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageReportCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsageReport.
     * @param {UsageReportDeleteArgs} args - Arguments to delete one UsageReport.
     * @example
     * // Delete one UsageReport
     * const UsageReport = await prisma.usageReport.delete({
     *   where: {
     *     // ... filter to delete one UsageReport
     *   }
     * })
     * 
     */
    delete<T extends UsageReportDeleteArgs>(args: SelectSubset<T, UsageReportDeleteArgs<ExtArgs>>): Prisma__UsageReportClient<$Result.GetResult<Prisma.$UsageReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsageReport.
     * @param {UsageReportUpdateArgs} args - Arguments to update one UsageReport.
     * @example
     * // Update one UsageReport
     * const usageReport = await prisma.usageReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageReportUpdateArgs>(args: SelectSubset<T, UsageReportUpdateArgs<ExtArgs>>): Prisma__UsageReportClient<$Result.GetResult<Prisma.$UsageReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsageReports.
     * @param {UsageReportDeleteManyArgs} args - Arguments to filter UsageReports to delete.
     * @example
     * // Delete a few UsageReports
     * const { count } = await prisma.usageReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageReportDeleteManyArgs>(args?: SelectSubset<T, UsageReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageReports
     * const usageReport = await prisma.usageReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageReportUpdateManyArgs>(args: SelectSubset<T, UsageReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageReport.
     * @param {UsageReportUpsertArgs} args - Arguments to update or create a UsageReport.
     * @example
     * // Update or create a UsageReport
     * const usageReport = await prisma.usageReport.upsert({
     *   create: {
     *     // ... data to create a UsageReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageReport we want to update
     *   }
     * })
     */
    upsert<T extends UsageReportUpsertArgs>(args: SelectSubset<T, UsageReportUpsertArgs<ExtArgs>>): Prisma__UsageReportClient<$Result.GetResult<Prisma.$UsageReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsageReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageReportCountArgs} args - Arguments to filter UsageReports to count.
     * @example
     * // Count the number of UsageReports
     * const count = await prisma.usageReport.count({
     *   where: {
     *     // ... the filter for the UsageReports we want to count
     *   }
     * })
    **/
    count<T extends UsageReportCountArgs>(
      args?: Subset<T, UsageReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageReportAggregateArgs>(args: Subset<T, UsageReportAggregateArgs>): Prisma.PrismaPromise<GetUsageReportAggregateType<T>>

    /**
     * Group by UsageReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageReportGroupByArgs['orderBy'] }
        : { orderBy?: UsageReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageReport model
   */
  readonly fields: UsageReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageReport model
   */ 
  interface UsageReportFieldRefs {
    readonly id: FieldRef<"UsageReport", 'String'>
    readonly workspaceId: FieldRef<"UsageReport", 'String'>
    readonly reportType: FieldRef<"UsageReport", 'String'>
    readonly periodStart: FieldRef<"UsageReport", 'DateTime'>
    readonly periodEnd: FieldRef<"UsageReport", 'DateTime'>
    readonly totalUploads: FieldRef<"UsageReport", 'Int'>
    readonly totalMinutes: FieldRef<"UsageReport", 'Int'>
    readonly totalStorage: FieldRef<"UsageReport", 'BigInt'>
    readonly reportData: FieldRef<"UsageReport", 'Json'>
    readonly generatedAt: FieldRef<"UsageReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageReport findUnique
   */
  export type UsageReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageReport
     */
    select?: UsageReportSelect<ExtArgs> | null
    /**
     * Filter, which UsageReport to fetch.
     */
    where: UsageReportWhereUniqueInput
  }

  /**
   * UsageReport findUniqueOrThrow
   */
  export type UsageReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageReport
     */
    select?: UsageReportSelect<ExtArgs> | null
    /**
     * Filter, which UsageReport to fetch.
     */
    where: UsageReportWhereUniqueInput
  }

  /**
   * UsageReport findFirst
   */
  export type UsageReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageReport
     */
    select?: UsageReportSelect<ExtArgs> | null
    /**
     * Filter, which UsageReport to fetch.
     */
    where?: UsageReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageReports to fetch.
     */
    orderBy?: UsageReportOrderByWithRelationInput | UsageReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageReports.
     */
    cursor?: UsageReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageReports.
     */
    distinct?: UsageReportScalarFieldEnum | UsageReportScalarFieldEnum[]
  }

  /**
   * UsageReport findFirstOrThrow
   */
  export type UsageReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageReport
     */
    select?: UsageReportSelect<ExtArgs> | null
    /**
     * Filter, which UsageReport to fetch.
     */
    where?: UsageReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageReports to fetch.
     */
    orderBy?: UsageReportOrderByWithRelationInput | UsageReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageReports.
     */
    cursor?: UsageReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageReports.
     */
    distinct?: UsageReportScalarFieldEnum | UsageReportScalarFieldEnum[]
  }

  /**
   * UsageReport findMany
   */
  export type UsageReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageReport
     */
    select?: UsageReportSelect<ExtArgs> | null
    /**
     * Filter, which UsageReports to fetch.
     */
    where?: UsageReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageReports to fetch.
     */
    orderBy?: UsageReportOrderByWithRelationInput | UsageReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageReports.
     */
    cursor?: UsageReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageReports.
     */
    skip?: number
    distinct?: UsageReportScalarFieldEnum | UsageReportScalarFieldEnum[]
  }

  /**
   * UsageReport create
   */
  export type UsageReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageReport
     */
    select?: UsageReportSelect<ExtArgs> | null
    /**
     * The data needed to create a UsageReport.
     */
    data: XOR<UsageReportCreateInput, UsageReportUncheckedCreateInput>
  }

  /**
   * UsageReport createMany
   */
  export type UsageReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageReports.
     */
    data: UsageReportCreateManyInput | UsageReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageReport createManyAndReturn
   */
  export type UsageReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageReport
     */
    select?: UsageReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsageReports.
     */
    data: UsageReportCreateManyInput | UsageReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageReport update
   */
  export type UsageReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageReport
     */
    select?: UsageReportSelect<ExtArgs> | null
    /**
     * The data needed to update a UsageReport.
     */
    data: XOR<UsageReportUpdateInput, UsageReportUncheckedUpdateInput>
    /**
     * Choose, which UsageReport to update.
     */
    where: UsageReportWhereUniqueInput
  }

  /**
   * UsageReport updateMany
   */
  export type UsageReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageReports.
     */
    data: XOR<UsageReportUpdateManyMutationInput, UsageReportUncheckedUpdateManyInput>
    /**
     * Filter which UsageReports to update
     */
    where?: UsageReportWhereInput
  }

  /**
   * UsageReport upsert
   */
  export type UsageReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageReport
     */
    select?: UsageReportSelect<ExtArgs> | null
    /**
     * The filter to search for the UsageReport to update in case it exists.
     */
    where: UsageReportWhereUniqueInput
    /**
     * In case the UsageReport found by the `where` argument doesn't exist, create a new UsageReport with this data.
     */
    create: XOR<UsageReportCreateInput, UsageReportUncheckedCreateInput>
    /**
     * In case the UsageReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageReportUpdateInput, UsageReportUncheckedUpdateInput>
  }

  /**
   * UsageReport delete
   */
  export type UsageReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageReport
     */
    select?: UsageReportSelect<ExtArgs> | null
    /**
     * Filter which UsageReport to delete.
     */
    where: UsageReportWhereUniqueInput
  }

  /**
   * UsageReport deleteMany
   */
  export type UsageReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageReports to delete
     */
    where?: UsageReportWhereInput
  }

  /**
   * UsageReport without action
   */
  export type UsageReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageReport
     */
    select?: UsageReportSelect<ExtArgs> | null
  }


  /**
   * Model PaymentGatewayConfig
   */

  export type AggregatePaymentGatewayConfig = {
    _count: PaymentGatewayConfigCountAggregateOutputType | null
    _min: PaymentGatewayConfigMinAggregateOutputType | null
    _max: PaymentGatewayConfigMaxAggregateOutputType | null
  }

  export type PaymentGatewayConfigMinAggregateOutputType = {
    id: string | null
    provider: string | null
    environment: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentGatewayConfigMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    environment: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentGatewayConfigCountAggregateOutputType = {
    id: number
    provider: number
    environment: number
    isActive: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentGatewayConfigMinAggregateInputType = {
    id?: true
    provider?: true
    environment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentGatewayConfigMaxAggregateInputType = {
    id?: true
    provider?: true
    environment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentGatewayConfigCountAggregateInputType = {
    id?: true
    provider?: true
    environment?: true
    isActive?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentGatewayConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentGatewayConfig to aggregate.
     */
    where?: PaymentGatewayConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentGatewayConfigs to fetch.
     */
    orderBy?: PaymentGatewayConfigOrderByWithRelationInput | PaymentGatewayConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentGatewayConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentGatewayConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentGatewayConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentGatewayConfigs
    **/
    _count?: true | PaymentGatewayConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentGatewayConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentGatewayConfigMaxAggregateInputType
  }

  export type GetPaymentGatewayConfigAggregateType<T extends PaymentGatewayConfigAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentGatewayConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentGatewayConfig[P]>
      : GetScalarType<T[P], AggregatePaymentGatewayConfig[P]>
  }




  export type PaymentGatewayConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentGatewayConfigWhereInput
    orderBy?: PaymentGatewayConfigOrderByWithAggregationInput | PaymentGatewayConfigOrderByWithAggregationInput[]
    by: PaymentGatewayConfigScalarFieldEnum[] | PaymentGatewayConfigScalarFieldEnum
    having?: PaymentGatewayConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentGatewayConfigCountAggregateInputType | true
    _min?: PaymentGatewayConfigMinAggregateInputType
    _max?: PaymentGatewayConfigMaxAggregateInputType
  }

  export type PaymentGatewayConfigGroupByOutputType = {
    id: string
    provider: string
    environment: string
    isActive: boolean
    config: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PaymentGatewayConfigCountAggregateOutputType | null
    _min: PaymentGatewayConfigMinAggregateOutputType | null
    _max: PaymentGatewayConfigMaxAggregateOutputType | null
  }

  type GetPaymentGatewayConfigGroupByPayload<T extends PaymentGatewayConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGatewayConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGatewayConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGatewayConfigGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGatewayConfigGroupByOutputType[P]>
        }
      >
    >


  export type PaymentGatewayConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    environment?: boolean
    isActive?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentGatewayConfig"]>

  export type PaymentGatewayConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    environment?: boolean
    isActive?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentGatewayConfig"]>

  export type PaymentGatewayConfigSelectScalar = {
    id?: boolean
    provider?: boolean
    environment?: boolean
    isActive?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PaymentGatewayConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentGatewayConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      environment: string
      isActive: boolean
      config: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentGatewayConfig"]>
    composites: {}
  }

  type PaymentGatewayConfigGetPayload<S extends boolean | null | undefined | PaymentGatewayConfigDefaultArgs> = $Result.GetResult<Prisma.$PaymentGatewayConfigPayload, S>

  type PaymentGatewayConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentGatewayConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentGatewayConfigCountAggregateInputType | true
    }

  export interface PaymentGatewayConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentGatewayConfig'], meta: { name: 'PaymentGatewayConfig' } }
    /**
     * Find zero or one PaymentGatewayConfig that matches the filter.
     * @param {PaymentGatewayConfigFindUniqueArgs} args - Arguments to find a PaymentGatewayConfig
     * @example
     * // Get one PaymentGatewayConfig
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentGatewayConfigFindUniqueArgs>(args: SelectSubset<T, PaymentGatewayConfigFindUniqueArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentGatewayConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentGatewayConfigFindUniqueOrThrowArgs} args - Arguments to find a PaymentGatewayConfig
     * @example
     * // Get one PaymentGatewayConfig
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentGatewayConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentGatewayConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentGatewayConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigFindFirstArgs} args - Arguments to find a PaymentGatewayConfig
     * @example
     * // Get one PaymentGatewayConfig
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentGatewayConfigFindFirstArgs>(args?: SelectSubset<T, PaymentGatewayConfigFindFirstArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentGatewayConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigFindFirstOrThrowArgs} args - Arguments to find a PaymentGatewayConfig
     * @example
     * // Get one PaymentGatewayConfig
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentGatewayConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentGatewayConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentGatewayConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentGatewayConfigs
     * const paymentGatewayConfigs = await prisma.paymentGatewayConfig.findMany()
     * 
     * // Get first 10 PaymentGatewayConfigs
     * const paymentGatewayConfigs = await prisma.paymentGatewayConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentGatewayConfigWithIdOnly = await prisma.paymentGatewayConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentGatewayConfigFindManyArgs>(args?: SelectSubset<T, PaymentGatewayConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentGatewayConfig.
     * @param {PaymentGatewayConfigCreateArgs} args - Arguments to create a PaymentGatewayConfig.
     * @example
     * // Create one PaymentGatewayConfig
     * const PaymentGatewayConfig = await prisma.paymentGatewayConfig.create({
     *   data: {
     *     // ... data to create a PaymentGatewayConfig
     *   }
     * })
     * 
     */
    create<T extends PaymentGatewayConfigCreateArgs>(args: SelectSubset<T, PaymentGatewayConfigCreateArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentGatewayConfigs.
     * @param {PaymentGatewayConfigCreateManyArgs} args - Arguments to create many PaymentGatewayConfigs.
     * @example
     * // Create many PaymentGatewayConfigs
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentGatewayConfigCreateManyArgs>(args?: SelectSubset<T, PaymentGatewayConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentGatewayConfigs and returns the data saved in the database.
     * @param {PaymentGatewayConfigCreateManyAndReturnArgs} args - Arguments to create many PaymentGatewayConfigs.
     * @example
     * // Create many PaymentGatewayConfigs
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentGatewayConfigs and only return the `id`
     * const paymentGatewayConfigWithIdOnly = await prisma.paymentGatewayConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentGatewayConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentGatewayConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentGatewayConfig.
     * @param {PaymentGatewayConfigDeleteArgs} args - Arguments to delete one PaymentGatewayConfig.
     * @example
     * // Delete one PaymentGatewayConfig
     * const PaymentGatewayConfig = await prisma.paymentGatewayConfig.delete({
     *   where: {
     *     // ... filter to delete one PaymentGatewayConfig
     *   }
     * })
     * 
     */
    delete<T extends PaymentGatewayConfigDeleteArgs>(args: SelectSubset<T, PaymentGatewayConfigDeleteArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentGatewayConfig.
     * @param {PaymentGatewayConfigUpdateArgs} args - Arguments to update one PaymentGatewayConfig.
     * @example
     * // Update one PaymentGatewayConfig
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentGatewayConfigUpdateArgs>(args: SelectSubset<T, PaymentGatewayConfigUpdateArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentGatewayConfigs.
     * @param {PaymentGatewayConfigDeleteManyArgs} args - Arguments to filter PaymentGatewayConfigs to delete.
     * @example
     * // Delete a few PaymentGatewayConfigs
     * const { count } = await prisma.paymentGatewayConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentGatewayConfigDeleteManyArgs>(args?: SelectSubset<T, PaymentGatewayConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentGatewayConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentGatewayConfigs
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentGatewayConfigUpdateManyArgs>(args: SelectSubset<T, PaymentGatewayConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentGatewayConfig.
     * @param {PaymentGatewayConfigUpsertArgs} args - Arguments to update or create a PaymentGatewayConfig.
     * @example
     * // Update or create a PaymentGatewayConfig
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.upsert({
     *   create: {
     *     // ... data to create a PaymentGatewayConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentGatewayConfig we want to update
     *   }
     * })
     */
    upsert<T extends PaymentGatewayConfigUpsertArgs>(args: SelectSubset<T, PaymentGatewayConfigUpsertArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentGatewayConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigCountArgs} args - Arguments to filter PaymentGatewayConfigs to count.
     * @example
     * // Count the number of PaymentGatewayConfigs
     * const count = await prisma.paymentGatewayConfig.count({
     *   where: {
     *     // ... the filter for the PaymentGatewayConfigs we want to count
     *   }
     * })
    **/
    count<T extends PaymentGatewayConfigCountArgs>(
      args?: Subset<T, PaymentGatewayConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentGatewayConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentGatewayConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentGatewayConfigAggregateArgs>(args: Subset<T, PaymentGatewayConfigAggregateArgs>): Prisma.PrismaPromise<GetPaymentGatewayConfigAggregateType<T>>

    /**
     * Group by PaymentGatewayConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGatewayConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGatewayConfigGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGatewayConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGatewayConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGatewayConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentGatewayConfig model
   */
  readonly fields: PaymentGatewayConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentGatewayConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentGatewayConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentGatewayConfig model
   */ 
  interface PaymentGatewayConfigFieldRefs {
    readonly id: FieldRef<"PaymentGatewayConfig", 'String'>
    readonly provider: FieldRef<"PaymentGatewayConfig", 'String'>
    readonly environment: FieldRef<"PaymentGatewayConfig", 'String'>
    readonly isActive: FieldRef<"PaymentGatewayConfig", 'Boolean'>
    readonly config: FieldRef<"PaymentGatewayConfig", 'Json'>
    readonly createdAt: FieldRef<"PaymentGatewayConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentGatewayConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentGatewayConfig findUnique
   */
  export type PaymentGatewayConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Filter, which PaymentGatewayConfig to fetch.
     */
    where: PaymentGatewayConfigWhereUniqueInput
  }

  /**
   * PaymentGatewayConfig findUniqueOrThrow
   */
  export type PaymentGatewayConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Filter, which PaymentGatewayConfig to fetch.
     */
    where: PaymentGatewayConfigWhereUniqueInput
  }

  /**
   * PaymentGatewayConfig findFirst
   */
  export type PaymentGatewayConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Filter, which PaymentGatewayConfig to fetch.
     */
    where?: PaymentGatewayConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentGatewayConfigs to fetch.
     */
    orderBy?: PaymentGatewayConfigOrderByWithRelationInput | PaymentGatewayConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentGatewayConfigs.
     */
    cursor?: PaymentGatewayConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentGatewayConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentGatewayConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentGatewayConfigs.
     */
    distinct?: PaymentGatewayConfigScalarFieldEnum | PaymentGatewayConfigScalarFieldEnum[]
  }

  /**
   * PaymentGatewayConfig findFirstOrThrow
   */
  export type PaymentGatewayConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Filter, which PaymentGatewayConfig to fetch.
     */
    where?: PaymentGatewayConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentGatewayConfigs to fetch.
     */
    orderBy?: PaymentGatewayConfigOrderByWithRelationInput | PaymentGatewayConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentGatewayConfigs.
     */
    cursor?: PaymentGatewayConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentGatewayConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentGatewayConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentGatewayConfigs.
     */
    distinct?: PaymentGatewayConfigScalarFieldEnum | PaymentGatewayConfigScalarFieldEnum[]
  }

  /**
   * PaymentGatewayConfig findMany
   */
  export type PaymentGatewayConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Filter, which PaymentGatewayConfigs to fetch.
     */
    where?: PaymentGatewayConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentGatewayConfigs to fetch.
     */
    orderBy?: PaymentGatewayConfigOrderByWithRelationInput | PaymentGatewayConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentGatewayConfigs.
     */
    cursor?: PaymentGatewayConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentGatewayConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentGatewayConfigs.
     */
    skip?: number
    distinct?: PaymentGatewayConfigScalarFieldEnum | PaymentGatewayConfigScalarFieldEnum[]
  }

  /**
   * PaymentGatewayConfig create
   */
  export type PaymentGatewayConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a PaymentGatewayConfig.
     */
    data: XOR<PaymentGatewayConfigCreateInput, PaymentGatewayConfigUncheckedCreateInput>
  }

  /**
   * PaymentGatewayConfig createMany
   */
  export type PaymentGatewayConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentGatewayConfigs.
     */
    data: PaymentGatewayConfigCreateManyInput | PaymentGatewayConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentGatewayConfig createManyAndReturn
   */
  export type PaymentGatewayConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentGatewayConfigs.
     */
    data: PaymentGatewayConfigCreateManyInput | PaymentGatewayConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentGatewayConfig update
   */
  export type PaymentGatewayConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a PaymentGatewayConfig.
     */
    data: XOR<PaymentGatewayConfigUpdateInput, PaymentGatewayConfigUncheckedUpdateInput>
    /**
     * Choose, which PaymentGatewayConfig to update.
     */
    where: PaymentGatewayConfigWhereUniqueInput
  }

  /**
   * PaymentGatewayConfig updateMany
   */
  export type PaymentGatewayConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentGatewayConfigs.
     */
    data: XOR<PaymentGatewayConfigUpdateManyMutationInput, PaymentGatewayConfigUncheckedUpdateManyInput>
    /**
     * Filter which PaymentGatewayConfigs to update
     */
    where?: PaymentGatewayConfigWhereInput
  }

  /**
   * PaymentGatewayConfig upsert
   */
  export type PaymentGatewayConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the PaymentGatewayConfig to update in case it exists.
     */
    where: PaymentGatewayConfigWhereUniqueInput
    /**
     * In case the PaymentGatewayConfig found by the `where` argument doesn't exist, create a new PaymentGatewayConfig with this data.
     */
    create: XOR<PaymentGatewayConfigCreateInput, PaymentGatewayConfigUncheckedCreateInput>
    /**
     * In case the PaymentGatewayConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentGatewayConfigUpdateInput, PaymentGatewayConfigUncheckedUpdateInput>
  }

  /**
   * PaymentGatewayConfig delete
   */
  export type PaymentGatewayConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Filter which PaymentGatewayConfig to delete.
     */
    where: PaymentGatewayConfigWhereUniqueInput
  }

  /**
   * PaymentGatewayConfig deleteMany
   */
  export type PaymentGatewayConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentGatewayConfigs to delete
     */
    where?: PaymentGatewayConfigWhereInput
  }

  /**
   * PaymentGatewayConfig without action
   */
  export type PaymentGatewayConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
  }


  /**
   * Model PlanPricing
   */

  export type AggregatePlanPricing = {
    _count: PlanPricingCountAggregateOutputType | null
    _avg: PlanPricingAvgAggregateOutputType | null
    _sum: PlanPricingSumAggregateOutputType | null
    _min: PlanPricingMinAggregateOutputType | null
    _max: PlanPricingMaxAggregateOutputType | null
  }

  export type PlanPricingAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type PlanPricingSumAggregateOutputType = {
    price: Decimal | null
  }

  export type PlanPricingMinAggregateOutputType = {
    id: string | null
    planId: string | null
    currency: string | null
    price: Decimal | null
    interval: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanPricingMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    currency: string | null
    price: Decimal | null
    interval: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanPricingCountAggregateOutputType = {
    id: number
    planId: number
    currency: number
    price: number
    interval: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanPricingAvgAggregateInputType = {
    price?: true
  }

  export type PlanPricingSumAggregateInputType = {
    price?: true
  }

  export type PlanPricingMinAggregateInputType = {
    id?: true
    planId?: true
    currency?: true
    price?: true
    interval?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanPricingMaxAggregateInputType = {
    id?: true
    planId?: true
    currency?: true
    price?: true
    interval?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanPricingCountAggregateInputType = {
    id?: true
    planId?: true
    currency?: true
    price?: true
    interval?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanPricingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanPricing to aggregate.
     */
    where?: PlanPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPricings to fetch.
     */
    orderBy?: PlanPricingOrderByWithRelationInput | PlanPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanPricings
    **/
    _count?: true | PlanPricingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanPricingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanPricingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanPricingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanPricingMaxAggregateInputType
  }

  export type GetPlanPricingAggregateType<T extends PlanPricingAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanPricing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanPricing[P]>
      : GetScalarType<T[P], AggregatePlanPricing[P]>
  }




  export type PlanPricingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanPricingWhereInput
    orderBy?: PlanPricingOrderByWithAggregationInput | PlanPricingOrderByWithAggregationInput[]
    by: PlanPricingScalarFieldEnum[] | PlanPricingScalarFieldEnum
    having?: PlanPricingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanPricingCountAggregateInputType | true
    _avg?: PlanPricingAvgAggregateInputType
    _sum?: PlanPricingSumAggregateInputType
    _min?: PlanPricingMinAggregateInputType
    _max?: PlanPricingMaxAggregateInputType
  }

  export type PlanPricingGroupByOutputType = {
    id: string
    planId: string
    currency: string
    price: Decimal
    interval: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlanPricingCountAggregateOutputType | null
    _avg: PlanPricingAvgAggregateOutputType | null
    _sum: PlanPricingSumAggregateOutputType | null
    _min: PlanPricingMinAggregateOutputType | null
    _max: PlanPricingMaxAggregateOutputType | null
  }

  type GetPlanPricingGroupByPayload<T extends PlanPricingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanPricingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanPricingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanPricingGroupByOutputType[P]>
            : GetScalarType<T[P], PlanPricingGroupByOutputType[P]>
        }
      >
    >


  export type PlanPricingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    currency?: boolean
    price?: boolean
    interval?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planPricing"]>

  export type PlanPricingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    currency?: boolean
    price?: boolean
    interval?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planPricing"]>

  export type PlanPricingSelectScalar = {
    id?: boolean
    planId?: boolean
    currency?: boolean
    price?: boolean
    interval?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanPricingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }
  export type PlanPricingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $PlanPricingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanPricing"
    objects: {
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      currency: string
      price: Prisma.Decimal
      interval: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planPricing"]>
    composites: {}
  }

  type PlanPricingGetPayload<S extends boolean | null | undefined | PlanPricingDefaultArgs> = $Result.GetResult<Prisma.$PlanPricingPayload, S>

  type PlanPricingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanPricingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanPricingCountAggregateInputType | true
    }

  export interface PlanPricingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanPricing'], meta: { name: 'PlanPricing' } }
    /**
     * Find zero or one PlanPricing that matches the filter.
     * @param {PlanPricingFindUniqueArgs} args - Arguments to find a PlanPricing
     * @example
     * // Get one PlanPricing
     * const planPricing = await prisma.planPricing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanPricingFindUniqueArgs>(args: SelectSubset<T, PlanPricingFindUniqueArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlanPricing that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanPricingFindUniqueOrThrowArgs} args - Arguments to find a PlanPricing
     * @example
     * // Get one PlanPricing
     * const planPricing = await prisma.planPricing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanPricingFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanPricingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlanPricing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingFindFirstArgs} args - Arguments to find a PlanPricing
     * @example
     * // Get one PlanPricing
     * const planPricing = await prisma.planPricing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanPricingFindFirstArgs>(args?: SelectSubset<T, PlanPricingFindFirstArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlanPricing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingFindFirstOrThrowArgs} args - Arguments to find a PlanPricing
     * @example
     * // Get one PlanPricing
     * const planPricing = await prisma.planPricing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanPricingFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanPricingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlanPricings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanPricings
     * const planPricings = await prisma.planPricing.findMany()
     * 
     * // Get first 10 PlanPricings
     * const planPricings = await prisma.planPricing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planPricingWithIdOnly = await prisma.planPricing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanPricingFindManyArgs>(args?: SelectSubset<T, PlanPricingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlanPricing.
     * @param {PlanPricingCreateArgs} args - Arguments to create a PlanPricing.
     * @example
     * // Create one PlanPricing
     * const PlanPricing = await prisma.planPricing.create({
     *   data: {
     *     // ... data to create a PlanPricing
     *   }
     * })
     * 
     */
    create<T extends PlanPricingCreateArgs>(args: SelectSubset<T, PlanPricingCreateArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlanPricings.
     * @param {PlanPricingCreateManyArgs} args - Arguments to create many PlanPricings.
     * @example
     * // Create many PlanPricings
     * const planPricing = await prisma.planPricing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanPricingCreateManyArgs>(args?: SelectSubset<T, PlanPricingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanPricings and returns the data saved in the database.
     * @param {PlanPricingCreateManyAndReturnArgs} args - Arguments to create many PlanPricings.
     * @example
     * // Create many PlanPricings
     * const planPricing = await prisma.planPricing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanPricings and only return the `id`
     * const planPricingWithIdOnly = await prisma.planPricing.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanPricingCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanPricingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlanPricing.
     * @param {PlanPricingDeleteArgs} args - Arguments to delete one PlanPricing.
     * @example
     * // Delete one PlanPricing
     * const PlanPricing = await prisma.planPricing.delete({
     *   where: {
     *     // ... filter to delete one PlanPricing
     *   }
     * })
     * 
     */
    delete<T extends PlanPricingDeleteArgs>(args: SelectSubset<T, PlanPricingDeleteArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlanPricing.
     * @param {PlanPricingUpdateArgs} args - Arguments to update one PlanPricing.
     * @example
     * // Update one PlanPricing
     * const planPricing = await prisma.planPricing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanPricingUpdateArgs>(args: SelectSubset<T, PlanPricingUpdateArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlanPricings.
     * @param {PlanPricingDeleteManyArgs} args - Arguments to filter PlanPricings to delete.
     * @example
     * // Delete a few PlanPricings
     * const { count } = await prisma.planPricing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanPricingDeleteManyArgs>(args?: SelectSubset<T, PlanPricingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanPricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanPricings
     * const planPricing = await prisma.planPricing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanPricingUpdateManyArgs>(args: SelectSubset<T, PlanPricingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanPricing.
     * @param {PlanPricingUpsertArgs} args - Arguments to update or create a PlanPricing.
     * @example
     * // Update or create a PlanPricing
     * const planPricing = await prisma.planPricing.upsert({
     *   create: {
     *     // ... data to create a PlanPricing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanPricing we want to update
     *   }
     * })
     */
    upsert<T extends PlanPricingUpsertArgs>(args: SelectSubset<T, PlanPricingUpsertArgs<ExtArgs>>): Prisma__PlanPricingClient<$Result.GetResult<Prisma.$PlanPricingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlanPricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingCountArgs} args - Arguments to filter PlanPricings to count.
     * @example
     * // Count the number of PlanPricings
     * const count = await prisma.planPricing.count({
     *   where: {
     *     // ... the filter for the PlanPricings we want to count
     *   }
     * })
    **/
    count<T extends PlanPricingCountArgs>(
      args?: Subset<T, PlanPricingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanPricingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanPricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanPricingAggregateArgs>(args: Subset<T, PlanPricingAggregateArgs>): Prisma.PrismaPromise<GetPlanPricingAggregateType<T>>

    /**
     * Group by PlanPricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPricingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanPricingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanPricingGroupByArgs['orderBy'] }
        : { orderBy?: PlanPricingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanPricingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanPricingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanPricing model
   */
  readonly fields: PlanPricingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanPricing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanPricingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanPricing model
   */ 
  interface PlanPricingFieldRefs {
    readonly id: FieldRef<"PlanPricing", 'String'>
    readonly planId: FieldRef<"PlanPricing", 'String'>
    readonly currency: FieldRef<"PlanPricing", 'String'>
    readonly price: FieldRef<"PlanPricing", 'Decimal'>
    readonly interval: FieldRef<"PlanPricing", 'String'>
    readonly isActive: FieldRef<"PlanPricing", 'Boolean'>
    readonly createdAt: FieldRef<"PlanPricing", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanPricing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanPricing findUnique
   */
  export type PlanPricingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * Filter, which PlanPricing to fetch.
     */
    where: PlanPricingWhereUniqueInput
  }

  /**
   * PlanPricing findUniqueOrThrow
   */
  export type PlanPricingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * Filter, which PlanPricing to fetch.
     */
    where: PlanPricingWhereUniqueInput
  }

  /**
   * PlanPricing findFirst
   */
  export type PlanPricingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * Filter, which PlanPricing to fetch.
     */
    where?: PlanPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPricings to fetch.
     */
    orderBy?: PlanPricingOrderByWithRelationInput | PlanPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanPricings.
     */
    cursor?: PlanPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanPricings.
     */
    distinct?: PlanPricingScalarFieldEnum | PlanPricingScalarFieldEnum[]
  }

  /**
   * PlanPricing findFirstOrThrow
   */
  export type PlanPricingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * Filter, which PlanPricing to fetch.
     */
    where?: PlanPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPricings to fetch.
     */
    orderBy?: PlanPricingOrderByWithRelationInput | PlanPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanPricings.
     */
    cursor?: PlanPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanPricings.
     */
    distinct?: PlanPricingScalarFieldEnum | PlanPricingScalarFieldEnum[]
  }

  /**
   * PlanPricing findMany
   */
  export type PlanPricingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * Filter, which PlanPricings to fetch.
     */
    where?: PlanPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPricings to fetch.
     */
    orderBy?: PlanPricingOrderByWithRelationInput | PlanPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanPricings.
     */
    cursor?: PlanPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPricings.
     */
    skip?: number
    distinct?: PlanPricingScalarFieldEnum | PlanPricingScalarFieldEnum[]
  }

  /**
   * PlanPricing create
   */
  export type PlanPricingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanPricing.
     */
    data: XOR<PlanPricingCreateInput, PlanPricingUncheckedCreateInput>
  }

  /**
   * PlanPricing createMany
   */
  export type PlanPricingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanPricings.
     */
    data: PlanPricingCreateManyInput | PlanPricingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanPricing createManyAndReturn
   */
  export type PlanPricingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlanPricings.
     */
    data: PlanPricingCreateManyInput | PlanPricingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanPricing update
   */
  export type PlanPricingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanPricing.
     */
    data: XOR<PlanPricingUpdateInput, PlanPricingUncheckedUpdateInput>
    /**
     * Choose, which PlanPricing to update.
     */
    where: PlanPricingWhereUniqueInput
  }

  /**
   * PlanPricing updateMany
   */
  export type PlanPricingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanPricings.
     */
    data: XOR<PlanPricingUpdateManyMutationInput, PlanPricingUncheckedUpdateManyInput>
    /**
     * Filter which PlanPricings to update
     */
    where?: PlanPricingWhereInput
  }

  /**
   * PlanPricing upsert
   */
  export type PlanPricingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanPricing to update in case it exists.
     */
    where: PlanPricingWhereUniqueInput
    /**
     * In case the PlanPricing found by the `where` argument doesn't exist, create a new PlanPricing with this data.
     */
    create: XOR<PlanPricingCreateInput, PlanPricingUncheckedCreateInput>
    /**
     * In case the PlanPricing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanPricingUpdateInput, PlanPricingUncheckedUpdateInput>
  }

  /**
   * PlanPricing delete
   */
  export type PlanPricingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
    /**
     * Filter which PlanPricing to delete.
     */
    where: PlanPricingWhereUniqueInput
  }

  /**
   * PlanPricing deleteMany
   */
  export type PlanPricingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanPricings to delete
     */
    where?: PlanPricingWhereInput
  }

  /**
   * PlanPricing without action
   */
  export type PlanPricingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPricing
     */
    select?: PlanPricingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPricingInclude<ExtArgs> | null
  }


  /**
   * Model EwayTransaction
   */

  export type AggregateEwayTransaction = {
    _count: EwayTransactionCountAggregateOutputType | null
    _avg: EwayTransactionAvgAggregateOutputType | null
    _sum: EwayTransactionSumAggregateOutputType | null
    _min: EwayTransactionMinAggregateOutputType | null
    _max: EwayTransactionMaxAggregateOutputType | null
  }

  export type EwayTransactionAvgAggregateOutputType = {
    amount: Decimal | null
    beagleScore: number | null
  }

  export type EwayTransactionSumAggregateOutputType = {
    amount: Decimal | null
    beagleScore: number | null
  }

  export type EwayTransactionMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    customerToken: string | null
    amount: Decimal | null
    currency: string | null
    status: string | null
    transactionStatus: string | null
    responseCode: string | null
    responseMessage: string | null
    authCode: string | null
    beagleScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EwayTransactionMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    customerToken: string | null
    amount: Decimal | null
    currency: string | null
    status: string | null
    transactionStatus: string | null
    responseCode: string | null
    responseMessage: string | null
    authCode: string | null
    beagleScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EwayTransactionCountAggregateOutputType = {
    id: number
    transactionId: number
    customerToken: number
    amount: number
    currency: number
    status: number
    transactionStatus: number
    responseCode: number
    responseMessage: number
    authCode: number
    beagleScore: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EwayTransactionAvgAggregateInputType = {
    amount?: true
    beagleScore?: true
  }

  export type EwayTransactionSumAggregateInputType = {
    amount?: true
    beagleScore?: true
  }

  export type EwayTransactionMinAggregateInputType = {
    id?: true
    transactionId?: true
    customerToken?: true
    amount?: true
    currency?: true
    status?: true
    transactionStatus?: true
    responseCode?: true
    responseMessage?: true
    authCode?: true
    beagleScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EwayTransactionMaxAggregateInputType = {
    id?: true
    transactionId?: true
    customerToken?: true
    amount?: true
    currency?: true
    status?: true
    transactionStatus?: true
    responseCode?: true
    responseMessage?: true
    authCode?: true
    beagleScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EwayTransactionCountAggregateInputType = {
    id?: true
    transactionId?: true
    customerToken?: true
    amount?: true
    currency?: true
    status?: true
    transactionStatus?: true
    responseCode?: true
    responseMessage?: true
    authCode?: true
    beagleScore?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EwayTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayTransaction to aggregate.
     */
    where?: EwayTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayTransactions to fetch.
     */
    orderBy?: EwayTransactionOrderByWithRelationInput | EwayTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EwayTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EwayTransactions
    **/
    _count?: true | EwayTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EwayTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EwayTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EwayTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EwayTransactionMaxAggregateInputType
  }

  export type GetEwayTransactionAggregateType<T extends EwayTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateEwayTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEwayTransaction[P]>
      : GetScalarType<T[P], AggregateEwayTransaction[P]>
  }




  export type EwayTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayTransactionWhereInput
    orderBy?: EwayTransactionOrderByWithAggregationInput | EwayTransactionOrderByWithAggregationInput[]
    by: EwayTransactionScalarFieldEnum[] | EwayTransactionScalarFieldEnum
    having?: EwayTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EwayTransactionCountAggregateInputType | true
    _avg?: EwayTransactionAvgAggregateInputType
    _sum?: EwayTransactionSumAggregateInputType
    _min?: EwayTransactionMinAggregateInputType
    _max?: EwayTransactionMaxAggregateInputType
  }

  export type EwayTransactionGroupByOutputType = {
    id: string
    transactionId: string
    customerToken: string | null
    amount: Decimal
    currency: string
    status: string
    transactionStatus: string
    responseCode: string | null
    responseMessage: string | null
    authCode: string | null
    beagleScore: number | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: EwayTransactionCountAggregateOutputType | null
    _avg: EwayTransactionAvgAggregateOutputType | null
    _sum: EwayTransactionSumAggregateOutputType | null
    _min: EwayTransactionMinAggregateOutputType | null
    _max: EwayTransactionMaxAggregateOutputType | null
  }

  type GetEwayTransactionGroupByPayload<T extends EwayTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EwayTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EwayTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EwayTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], EwayTransactionGroupByOutputType[P]>
        }
      >
    >


  export type EwayTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    customerToken?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    transactionStatus?: boolean
    responseCode?: boolean
    responseMessage?: boolean
    authCode?: boolean
    beagleScore?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ewayCustomer?: boolean | EwayTransaction$ewayCustomerArgs<ExtArgs>
  }, ExtArgs["result"]["ewayTransaction"]>

  export type EwayTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    customerToken?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    transactionStatus?: boolean
    responseCode?: boolean
    responseMessage?: boolean
    authCode?: boolean
    beagleScore?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ewayCustomer?: boolean | EwayTransaction$ewayCustomerArgs<ExtArgs>
  }, ExtArgs["result"]["ewayTransaction"]>

  export type EwayTransactionSelectScalar = {
    id?: boolean
    transactionId?: boolean
    customerToken?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    transactionStatus?: boolean
    responseCode?: boolean
    responseMessage?: boolean
    authCode?: boolean
    beagleScore?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EwayTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ewayCustomer?: boolean | EwayTransaction$ewayCustomerArgs<ExtArgs>
  }
  export type EwayTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ewayCustomer?: boolean | EwayTransaction$ewayCustomerArgs<ExtArgs>
  }

  export type $EwayTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EwayTransaction"
    objects: {
      ewayCustomer: Prisma.$EwayCustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      customerToken: string | null
      amount: Prisma.Decimal
      currency: string
      status: string
      transactionStatus: string
      responseCode: string | null
      responseMessage: string | null
      authCode: string | null
      beagleScore: number | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ewayTransaction"]>
    composites: {}
  }

  type EwayTransactionGetPayload<S extends boolean | null | undefined | EwayTransactionDefaultArgs> = $Result.GetResult<Prisma.$EwayTransactionPayload, S>

  type EwayTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EwayTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EwayTransactionCountAggregateInputType | true
    }

  export interface EwayTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EwayTransaction'], meta: { name: 'EwayTransaction' } }
    /**
     * Find zero or one EwayTransaction that matches the filter.
     * @param {EwayTransactionFindUniqueArgs} args - Arguments to find a EwayTransaction
     * @example
     * // Get one EwayTransaction
     * const ewayTransaction = await prisma.ewayTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EwayTransactionFindUniqueArgs>(args: SelectSubset<T, EwayTransactionFindUniqueArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EwayTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EwayTransactionFindUniqueOrThrowArgs} args - Arguments to find a EwayTransaction
     * @example
     * // Get one EwayTransaction
     * const ewayTransaction = await prisma.ewayTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EwayTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, EwayTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EwayTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionFindFirstArgs} args - Arguments to find a EwayTransaction
     * @example
     * // Get one EwayTransaction
     * const ewayTransaction = await prisma.ewayTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EwayTransactionFindFirstArgs>(args?: SelectSubset<T, EwayTransactionFindFirstArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EwayTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionFindFirstOrThrowArgs} args - Arguments to find a EwayTransaction
     * @example
     * // Get one EwayTransaction
     * const ewayTransaction = await prisma.ewayTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EwayTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, EwayTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EwayTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EwayTransactions
     * const ewayTransactions = await prisma.ewayTransaction.findMany()
     * 
     * // Get first 10 EwayTransactions
     * const ewayTransactions = await prisma.ewayTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ewayTransactionWithIdOnly = await prisma.ewayTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EwayTransactionFindManyArgs>(args?: SelectSubset<T, EwayTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EwayTransaction.
     * @param {EwayTransactionCreateArgs} args - Arguments to create a EwayTransaction.
     * @example
     * // Create one EwayTransaction
     * const EwayTransaction = await prisma.ewayTransaction.create({
     *   data: {
     *     // ... data to create a EwayTransaction
     *   }
     * })
     * 
     */
    create<T extends EwayTransactionCreateArgs>(args: SelectSubset<T, EwayTransactionCreateArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EwayTransactions.
     * @param {EwayTransactionCreateManyArgs} args - Arguments to create many EwayTransactions.
     * @example
     * // Create many EwayTransactions
     * const ewayTransaction = await prisma.ewayTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EwayTransactionCreateManyArgs>(args?: SelectSubset<T, EwayTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EwayTransactions and returns the data saved in the database.
     * @param {EwayTransactionCreateManyAndReturnArgs} args - Arguments to create many EwayTransactions.
     * @example
     * // Create many EwayTransactions
     * const ewayTransaction = await prisma.ewayTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EwayTransactions and only return the `id`
     * const ewayTransactionWithIdOnly = await prisma.ewayTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EwayTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, EwayTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EwayTransaction.
     * @param {EwayTransactionDeleteArgs} args - Arguments to delete one EwayTransaction.
     * @example
     * // Delete one EwayTransaction
     * const EwayTransaction = await prisma.ewayTransaction.delete({
     *   where: {
     *     // ... filter to delete one EwayTransaction
     *   }
     * })
     * 
     */
    delete<T extends EwayTransactionDeleteArgs>(args: SelectSubset<T, EwayTransactionDeleteArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EwayTransaction.
     * @param {EwayTransactionUpdateArgs} args - Arguments to update one EwayTransaction.
     * @example
     * // Update one EwayTransaction
     * const ewayTransaction = await prisma.ewayTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EwayTransactionUpdateArgs>(args: SelectSubset<T, EwayTransactionUpdateArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EwayTransactions.
     * @param {EwayTransactionDeleteManyArgs} args - Arguments to filter EwayTransactions to delete.
     * @example
     * // Delete a few EwayTransactions
     * const { count } = await prisma.ewayTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EwayTransactionDeleteManyArgs>(args?: SelectSubset<T, EwayTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EwayTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EwayTransactions
     * const ewayTransaction = await prisma.ewayTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EwayTransactionUpdateManyArgs>(args: SelectSubset<T, EwayTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EwayTransaction.
     * @param {EwayTransactionUpsertArgs} args - Arguments to update or create a EwayTransaction.
     * @example
     * // Update or create a EwayTransaction
     * const ewayTransaction = await prisma.ewayTransaction.upsert({
     *   create: {
     *     // ... data to create a EwayTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EwayTransaction we want to update
     *   }
     * })
     */
    upsert<T extends EwayTransactionUpsertArgs>(args: SelectSubset<T, EwayTransactionUpsertArgs<ExtArgs>>): Prisma__EwayTransactionClient<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EwayTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionCountArgs} args - Arguments to filter EwayTransactions to count.
     * @example
     * // Count the number of EwayTransactions
     * const count = await prisma.ewayTransaction.count({
     *   where: {
     *     // ... the filter for the EwayTransactions we want to count
     *   }
     * })
    **/
    count<T extends EwayTransactionCountArgs>(
      args?: Subset<T, EwayTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EwayTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EwayTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EwayTransactionAggregateArgs>(args: Subset<T, EwayTransactionAggregateArgs>): Prisma.PrismaPromise<GetEwayTransactionAggregateType<T>>

    /**
     * Group by EwayTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EwayTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EwayTransactionGroupByArgs['orderBy'] }
        : { orderBy?: EwayTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EwayTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEwayTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EwayTransaction model
   */
  readonly fields: EwayTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EwayTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EwayTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ewayCustomer<T extends EwayTransaction$ewayCustomerArgs<ExtArgs> = {}>(args?: Subset<T, EwayTransaction$ewayCustomerArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EwayTransaction model
   */ 
  interface EwayTransactionFieldRefs {
    readonly id: FieldRef<"EwayTransaction", 'String'>
    readonly transactionId: FieldRef<"EwayTransaction", 'String'>
    readonly customerToken: FieldRef<"EwayTransaction", 'String'>
    readonly amount: FieldRef<"EwayTransaction", 'Decimal'>
    readonly currency: FieldRef<"EwayTransaction", 'String'>
    readonly status: FieldRef<"EwayTransaction", 'String'>
    readonly transactionStatus: FieldRef<"EwayTransaction", 'String'>
    readonly responseCode: FieldRef<"EwayTransaction", 'String'>
    readonly responseMessage: FieldRef<"EwayTransaction", 'String'>
    readonly authCode: FieldRef<"EwayTransaction", 'String'>
    readonly beagleScore: FieldRef<"EwayTransaction", 'Int'>
    readonly metadata: FieldRef<"EwayTransaction", 'Json'>
    readonly createdAt: FieldRef<"EwayTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"EwayTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EwayTransaction findUnique
   */
  export type EwayTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * Filter, which EwayTransaction to fetch.
     */
    where: EwayTransactionWhereUniqueInput
  }

  /**
   * EwayTransaction findUniqueOrThrow
   */
  export type EwayTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * Filter, which EwayTransaction to fetch.
     */
    where: EwayTransactionWhereUniqueInput
  }

  /**
   * EwayTransaction findFirst
   */
  export type EwayTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * Filter, which EwayTransaction to fetch.
     */
    where?: EwayTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayTransactions to fetch.
     */
    orderBy?: EwayTransactionOrderByWithRelationInput | EwayTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayTransactions.
     */
    cursor?: EwayTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayTransactions.
     */
    distinct?: EwayTransactionScalarFieldEnum | EwayTransactionScalarFieldEnum[]
  }

  /**
   * EwayTransaction findFirstOrThrow
   */
  export type EwayTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * Filter, which EwayTransaction to fetch.
     */
    where?: EwayTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayTransactions to fetch.
     */
    orderBy?: EwayTransactionOrderByWithRelationInput | EwayTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayTransactions.
     */
    cursor?: EwayTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayTransactions.
     */
    distinct?: EwayTransactionScalarFieldEnum | EwayTransactionScalarFieldEnum[]
  }

  /**
   * EwayTransaction findMany
   */
  export type EwayTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * Filter, which EwayTransactions to fetch.
     */
    where?: EwayTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayTransactions to fetch.
     */
    orderBy?: EwayTransactionOrderByWithRelationInput | EwayTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EwayTransactions.
     */
    cursor?: EwayTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayTransactions.
     */
    skip?: number
    distinct?: EwayTransactionScalarFieldEnum | EwayTransactionScalarFieldEnum[]
  }

  /**
   * EwayTransaction create
   */
  export type EwayTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a EwayTransaction.
     */
    data: XOR<EwayTransactionCreateInput, EwayTransactionUncheckedCreateInput>
  }

  /**
   * EwayTransaction createMany
   */
  export type EwayTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EwayTransactions.
     */
    data: EwayTransactionCreateManyInput | EwayTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EwayTransaction createManyAndReturn
   */
  export type EwayTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EwayTransactions.
     */
    data: EwayTransactionCreateManyInput | EwayTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EwayTransaction update
   */
  export type EwayTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a EwayTransaction.
     */
    data: XOR<EwayTransactionUpdateInput, EwayTransactionUncheckedUpdateInput>
    /**
     * Choose, which EwayTransaction to update.
     */
    where: EwayTransactionWhereUniqueInput
  }

  /**
   * EwayTransaction updateMany
   */
  export type EwayTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EwayTransactions.
     */
    data: XOR<EwayTransactionUpdateManyMutationInput, EwayTransactionUncheckedUpdateManyInput>
    /**
     * Filter which EwayTransactions to update
     */
    where?: EwayTransactionWhereInput
  }

  /**
   * EwayTransaction upsert
   */
  export type EwayTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the EwayTransaction to update in case it exists.
     */
    where: EwayTransactionWhereUniqueInput
    /**
     * In case the EwayTransaction found by the `where` argument doesn't exist, create a new EwayTransaction with this data.
     */
    create: XOR<EwayTransactionCreateInput, EwayTransactionUncheckedCreateInput>
    /**
     * In case the EwayTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EwayTransactionUpdateInput, EwayTransactionUncheckedUpdateInput>
  }

  /**
   * EwayTransaction delete
   */
  export type EwayTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    /**
     * Filter which EwayTransaction to delete.
     */
    where: EwayTransactionWhereUniqueInput
  }

  /**
   * EwayTransaction deleteMany
   */
  export type EwayTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayTransactions to delete
     */
    where?: EwayTransactionWhereInput
  }

  /**
   * EwayTransaction.ewayCustomer
   */
  export type EwayTransaction$ewayCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    where?: EwayCustomerWhereInput
  }

  /**
   * EwayTransaction without action
   */
  export type EwayTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
  }


  /**
   * Model EwayCustomer
   */

  export type AggregateEwayCustomer = {
    _count: EwayCustomerCountAggregateOutputType | null
    _min: EwayCustomerMinAggregateOutputType | null
    _max: EwayCustomerMaxAggregateOutputType | null
  }

  export type EwayCustomerMinAggregateOutputType = {
    id: string | null
    customerToken: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    cardNumber: string | null
    cardName: string | null
    cardExpiryMonth: string | null
    cardExpiryYear: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EwayCustomerMaxAggregateOutputType = {
    id: string | null
    customerToken: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    cardNumber: string | null
    cardName: string | null
    cardExpiryMonth: string | null
    cardExpiryYear: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EwayCustomerCountAggregateOutputType = {
    id: number
    customerToken: number
    firstName: number
    lastName: number
    email: number
    phone: number
    address: number
    cardNumber: number
    cardName: number
    cardExpiryMonth: number
    cardExpiryYear: number
    isActive: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EwayCustomerMinAggregateInputType = {
    id?: true
    customerToken?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    cardNumber?: true
    cardName?: true
    cardExpiryMonth?: true
    cardExpiryYear?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EwayCustomerMaxAggregateInputType = {
    id?: true
    customerToken?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    cardNumber?: true
    cardName?: true
    cardExpiryMonth?: true
    cardExpiryYear?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EwayCustomerCountAggregateInputType = {
    id?: true
    customerToken?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    address?: true
    cardNumber?: true
    cardName?: true
    cardExpiryMonth?: true
    cardExpiryYear?: true
    isActive?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EwayCustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayCustomer to aggregate.
     */
    where?: EwayCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayCustomers to fetch.
     */
    orderBy?: EwayCustomerOrderByWithRelationInput | EwayCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EwayCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EwayCustomers
    **/
    _count?: true | EwayCustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EwayCustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EwayCustomerMaxAggregateInputType
  }

  export type GetEwayCustomerAggregateType<T extends EwayCustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateEwayCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEwayCustomer[P]>
      : GetScalarType<T[P], AggregateEwayCustomer[P]>
  }




  export type EwayCustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayCustomerWhereInput
    orderBy?: EwayCustomerOrderByWithAggregationInput | EwayCustomerOrderByWithAggregationInput[]
    by: EwayCustomerScalarFieldEnum[] | EwayCustomerScalarFieldEnum
    having?: EwayCustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EwayCustomerCountAggregateInputType | true
    _min?: EwayCustomerMinAggregateInputType
    _max?: EwayCustomerMaxAggregateInputType
  }

  export type EwayCustomerGroupByOutputType = {
    id: string
    customerToken: string
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    address: JsonValue | null
    cardNumber: string | null
    cardName: string | null
    cardExpiryMonth: string | null
    cardExpiryYear: string | null
    isActive: boolean
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: EwayCustomerCountAggregateOutputType | null
    _min: EwayCustomerMinAggregateOutputType | null
    _max: EwayCustomerMaxAggregateOutputType | null
  }

  type GetEwayCustomerGroupByPayload<T extends EwayCustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EwayCustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EwayCustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EwayCustomerGroupByOutputType[P]>
            : GetScalarType<T[P], EwayCustomerGroupByOutputType[P]>
        }
      >
    >


  export type EwayCustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerToken?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    cardNumber?: boolean
    cardName?: boolean
    cardExpiryMonth?: boolean
    cardExpiryYear?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | EwayCustomer$transactionsArgs<ExtArgs>
    recurringSchedules?: boolean | EwayCustomer$recurringSchedulesArgs<ExtArgs>
    _count?: boolean | EwayCustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ewayCustomer"]>

  export type EwayCustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerToken?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    cardNumber?: boolean
    cardName?: boolean
    cardExpiryMonth?: boolean
    cardExpiryYear?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ewayCustomer"]>

  export type EwayCustomerSelectScalar = {
    id?: boolean
    customerToken?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    cardNumber?: boolean
    cardName?: boolean
    cardExpiryMonth?: boolean
    cardExpiryYear?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EwayCustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | EwayCustomer$transactionsArgs<ExtArgs>
    recurringSchedules?: boolean | EwayCustomer$recurringSchedulesArgs<ExtArgs>
    _count?: boolean | EwayCustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EwayCustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EwayCustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EwayCustomer"
    objects: {
      transactions: Prisma.$EwayTransactionPayload<ExtArgs>[]
      recurringSchedules: Prisma.$EwayRecurringSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerToken: string
      firstName: string | null
      lastName: string | null
      email: string | null
      phone: string | null
      address: Prisma.JsonValue | null
      cardNumber: string | null
      cardName: string | null
      cardExpiryMonth: string | null
      cardExpiryYear: string | null
      isActive: boolean
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ewayCustomer"]>
    composites: {}
  }

  type EwayCustomerGetPayload<S extends boolean | null | undefined | EwayCustomerDefaultArgs> = $Result.GetResult<Prisma.$EwayCustomerPayload, S>

  type EwayCustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EwayCustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EwayCustomerCountAggregateInputType | true
    }

  export interface EwayCustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EwayCustomer'], meta: { name: 'EwayCustomer' } }
    /**
     * Find zero or one EwayCustomer that matches the filter.
     * @param {EwayCustomerFindUniqueArgs} args - Arguments to find a EwayCustomer
     * @example
     * // Get one EwayCustomer
     * const ewayCustomer = await prisma.ewayCustomer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EwayCustomerFindUniqueArgs>(args: SelectSubset<T, EwayCustomerFindUniqueArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EwayCustomer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EwayCustomerFindUniqueOrThrowArgs} args - Arguments to find a EwayCustomer
     * @example
     * // Get one EwayCustomer
     * const ewayCustomer = await prisma.ewayCustomer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EwayCustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, EwayCustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EwayCustomer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerFindFirstArgs} args - Arguments to find a EwayCustomer
     * @example
     * // Get one EwayCustomer
     * const ewayCustomer = await prisma.ewayCustomer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EwayCustomerFindFirstArgs>(args?: SelectSubset<T, EwayCustomerFindFirstArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EwayCustomer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerFindFirstOrThrowArgs} args - Arguments to find a EwayCustomer
     * @example
     * // Get one EwayCustomer
     * const ewayCustomer = await prisma.ewayCustomer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EwayCustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, EwayCustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EwayCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EwayCustomers
     * const ewayCustomers = await prisma.ewayCustomer.findMany()
     * 
     * // Get first 10 EwayCustomers
     * const ewayCustomers = await prisma.ewayCustomer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ewayCustomerWithIdOnly = await prisma.ewayCustomer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EwayCustomerFindManyArgs>(args?: SelectSubset<T, EwayCustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EwayCustomer.
     * @param {EwayCustomerCreateArgs} args - Arguments to create a EwayCustomer.
     * @example
     * // Create one EwayCustomer
     * const EwayCustomer = await prisma.ewayCustomer.create({
     *   data: {
     *     // ... data to create a EwayCustomer
     *   }
     * })
     * 
     */
    create<T extends EwayCustomerCreateArgs>(args: SelectSubset<T, EwayCustomerCreateArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EwayCustomers.
     * @param {EwayCustomerCreateManyArgs} args - Arguments to create many EwayCustomers.
     * @example
     * // Create many EwayCustomers
     * const ewayCustomer = await prisma.ewayCustomer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EwayCustomerCreateManyArgs>(args?: SelectSubset<T, EwayCustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EwayCustomers and returns the data saved in the database.
     * @param {EwayCustomerCreateManyAndReturnArgs} args - Arguments to create many EwayCustomers.
     * @example
     * // Create many EwayCustomers
     * const ewayCustomer = await prisma.ewayCustomer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EwayCustomers and only return the `id`
     * const ewayCustomerWithIdOnly = await prisma.ewayCustomer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EwayCustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, EwayCustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EwayCustomer.
     * @param {EwayCustomerDeleteArgs} args - Arguments to delete one EwayCustomer.
     * @example
     * // Delete one EwayCustomer
     * const EwayCustomer = await prisma.ewayCustomer.delete({
     *   where: {
     *     // ... filter to delete one EwayCustomer
     *   }
     * })
     * 
     */
    delete<T extends EwayCustomerDeleteArgs>(args: SelectSubset<T, EwayCustomerDeleteArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EwayCustomer.
     * @param {EwayCustomerUpdateArgs} args - Arguments to update one EwayCustomer.
     * @example
     * // Update one EwayCustomer
     * const ewayCustomer = await prisma.ewayCustomer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EwayCustomerUpdateArgs>(args: SelectSubset<T, EwayCustomerUpdateArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EwayCustomers.
     * @param {EwayCustomerDeleteManyArgs} args - Arguments to filter EwayCustomers to delete.
     * @example
     * // Delete a few EwayCustomers
     * const { count } = await prisma.ewayCustomer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EwayCustomerDeleteManyArgs>(args?: SelectSubset<T, EwayCustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EwayCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EwayCustomers
     * const ewayCustomer = await prisma.ewayCustomer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EwayCustomerUpdateManyArgs>(args: SelectSubset<T, EwayCustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EwayCustomer.
     * @param {EwayCustomerUpsertArgs} args - Arguments to update or create a EwayCustomer.
     * @example
     * // Update or create a EwayCustomer
     * const ewayCustomer = await prisma.ewayCustomer.upsert({
     *   create: {
     *     // ... data to create a EwayCustomer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EwayCustomer we want to update
     *   }
     * })
     */
    upsert<T extends EwayCustomerUpsertArgs>(args: SelectSubset<T, EwayCustomerUpsertArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EwayCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerCountArgs} args - Arguments to filter EwayCustomers to count.
     * @example
     * // Count the number of EwayCustomers
     * const count = await prisma.ewayCustomer.count({
     *   where: {
     *     // ... the filter for the EwayCustomers we want to count
     *   }
     * })
    **/
    count<T extends EwayCustomerCountArgs>(
      args?: Subset<T, EwayCustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EwayCustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EwayCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EwayCustomerAggregateArgs>(args: Subset<T, EwayCustomerAggregateArgs>): Prisma.PrismaPromise<GetEwayCustomerAggregateType<T>>

    /**
     * Group by EwayCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayCustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EwayCustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EwayCustomerGroupByArgs['orderBy'] }
        : { orderBy?: EwayCustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EwayCustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEwayCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EwayCustomer model
   */
  readonly fields: EwayCustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EwayCustomer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EwayCustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends EwayCustomer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, EwayCustomer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    recurringSchedules<T extends EwayCustomer$recurringSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, EwayCustomer$recurringSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EwayCustomer model
   */ 
  interface EwayCustomerFieldRefs {
    readonly id: FieldRef<"EwayCustomer", 'String'>
    readonly customerToken: FieldRef<"EwayCustomer", 'String'>
    readonly firstName: FieldRef<"EwayCustomer", 'String'>
    readonly lastName: FieldRef<"EwayCustomer", 'String'>
    readonly email: FieldRef<"EwayCustomer", 'String'>
    readonly phone: FieldRef<"EwayCustomer", 'String'>
    readonly address: FieldRef<"EwayCustomer", 'Json'>
    readonly cardNumber: FieldRef<"EwayCustomer", 'String'>
    readonly cardName: FieldRef<"EwayCustomer", 'String'>
    readonly cardExpiryMonth: FieldRef<"EwayCustomer", 'String'>
    readonly cardExpiryYear: FieldRef<"EwayCustomer", 'String'>
    readonly isActive: FieldRef<"EwayCustomer", 'Boolean'>
    readonly metadata: FieldRef<"EwayCustomer", 'Json'>
    readonly createdAt: FieldRef<"EwayCustomer", 'DateTime'>
    readonly updatedAt: FieldRef<"EwayCustomer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EwayCustomer findUnique
   */
  export type EwayCustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * Filter, which EwayCustomer to fetch.
     */
    where: EwayCustomerWhereUniqueInput
  }

  /**
   * EwayCustomer findUniqueOrThrow
   */
  export type EwayCustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * Filter, which EwayCustomer to fetch.
     */
    where: EwayCustomerWhereUniqueInput
  }

  /**
   * EwayCustomer findFirst
   */
  export type EwayCustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * Filter, which EwayCustomer to fetch.
     */
    where?: EwayCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayCustomers to fetch.
     */
    orderBy?: EwayCustomerOrderByWithRelationInput | EwayCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayCustomers.
     */
    cursor?: EwayCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayCustomers.
     */
    distinct?: EwayCustomerScalarFieldEnum | EwayCustomerScalarFieldEnum[]
  }

  /**
   * EwayCustomer findFirstOrThrow
   */
  export type EwayCustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * Filter, which EwayCustomer to fetch.
     */
    where?: EwayCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayCustomers to fetch.
     */
    orderBy?: EwayCustomerOrderByWithRelationInput | EwayCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayCustomers.
     */
    cursor?: EwayCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayCustomers.
     */
    distinct?: EwayCustomerScalarFieldEnum | EwayCustomerScalarFieldEnum[]
  }

  /**
   * EwayCustomer findMany
   */
  export type EwayCustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * Filter, which EwayCustomers to fetch.
     */
    where?: EwayCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayCustomers to fetch.
     */
    orderBy?: EwayCustomerOrderByWithRelationInput | EwayCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EwayCustomers.
     */
    cursor?: EwayCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayCustomers.
     */
    skip?: number
    distinct?: EwayCustomerScalarFieldEnum | EwayCustomerScalarFieldEnum[]
  }

  /**
   * EwayCustomer create
   */
  export type EwayCustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a EwayCustomer.
     */
    data: XOR<EwayCustomerCreateInput, EwayCustomerUncheckedCreateInput>
  }

  /**
   * EwayCustomer createMany
   */
  export type EwayCustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EwayCustomers.
     */
    data: EwayCustomerCreateManyInput | EwayCustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EwayCustomer createManyAndReturn
   */
  export type EwayCustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EwayCustomers.
     */
    data: EwayCustomerCreateManyInput | EwayCustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EwayCustomer update
   */
  export type EwayCustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a EwayCustomer.
     */
    data: XOR<EwayCustomerUpdateInput, EwayCustomerUncheckedUpdateInput>
    /**
     * Choose, which EwayCustomer to update.
     */
    where: EwayCustomerWhereUniqueInput
  }

  /**
   * EwayCustomer updateMany
   */
  export type EwayCustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EwayCustomers.
     */
    data: XOR<EwayCustomerUpdateManyMutationInput, EwayCustomerUncheckedUpdateManyInput>
    /**
     * Filter which EwayCustomers to update
     */
    where?: EwayCustomerWhereInput
  }

  /**
   * EwayCustomer upsert
   */
  export type EwayCustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the EwayCustomer to update in case it exists.
     */
    where: EwayCustomerWhereUniqueInput
    /**
     * In case the EwayCustomer found by the `where` argument doesn't exist, create a new EwayCustomer with this data.
     */
    create: XOR<EwayCustomerCreateInput, EwayCustomerUncheckedCreateInput>
    /**
     * In case the EwayCustomer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EwayCustomerUpdateInput, EwayCustomerUncheckedUpdateInput>
  }

  /**
   * EwayCustomer delete
   */
  export type EwayCustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
    /**
     * Filter which EwayCustomer to delete.
     */
    where: EwayCustomerWhereUniqueInput
  }

  /**
   * EwayCustomer deleteMany
   */
  export type EwayCustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayCustomers to delete
     */
    where?: EwayCustomerWhereInput
  }

  /**
   * EwayCustomer.transactions
   */
  export type EwayCustomer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayTransaction
     */
    select?: EwayTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayTransactionInclude<ExtArgs> | null
    where?: EwayTransactionWhereInput
    orderBy?: EwayTransactionOrderByWithRelationInput | EwayTransactionOrderByWithRelationInput[]
    cursor?: EwayTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EwayTransactionScalarFieldEnum | EwayTransactionScalarFieldEnum[]
  }

  /**
   * EwayCustomer.recurringSchedules
   */
  export type EwayCustomer$recurringSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    where?: EwayRecurringScheduleWhereInput
    orderBy?: EwayRecurringScheduleOrderByWithRelationInput | EwayRecurringScheduleOrderByWithRelationInput[]
    cursor?: EwayRecurringScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EwayRecurringScheduleScalarFieldEnum | EwayRecurringScheduleScalarFieldEnum[]
  }

  /**
   * EwayCustomer without action
   */
  export type EwayCustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayCustomer
     */
    select?: EwayCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayCustomerInclude<ExtArgs> | null
  }


  /**
   * Model EwayRecurringSchedule
   */

  export type AggregateEwayRecurringSchedule = {
    _count: EwayRecurringScheduleCountAggregateOutputType | null
    _avg: EwayRecurringScheduleAvgAggregateOutputType | null
    _sum: EwayRecurringScheduleSumAggregateOutputType | null
    _min: EwayRecurringScheduleMinAggregateOutputType | null
    _max: EwayRecurringScheduleMaxAggregateOutputType | null
  }

  export type EwayRecurringScheduleAvgAggregateOutputType = {
    amount: Decimal | null
    paymentCount: number | null
    maxPayments: number | null
  }

  export type EwayRecurringScheduleSumAggregateOutputType = {
    amount: Decimal | null
    paymentCount: number | null
    maxPayments: number | null
  }

  export type EwayRecurringScheduleMinAggregateOutputType = {
    id: string | null
    customerToken: string | null
    interval: string | null
    amount: Decimal | null
    currency: string | null
    status: string | null
    nextPayment: Date | null
    lastPayment: Date | null
    paymentCount: number | null
    maxPayments: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EwayRecurringScheduleMaxAggregateOutputType = {
    id: string | null
    customerToken: string | null
    interval: string | null
    amount: Decimal | null
    currency: string | null
    status: string | null
    nextPayment: Date | null
    lastPayment: Date | null
    paymentCount: number | null
    maxPayments: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EwayRecurringScheduleCountAggregateOutputType = {
    id: number
    customerToken: number
    interval: number
    amount: number
    currency: number
    status: number
    nextPayment: number
    lastPayment: number
    paymentCount: number
    maxPayments: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EwayRecurringScheduleAvgAggregateInputType = {
    amount?: true
    paymentCount?: true
    maxPayments?: true
  }

  export type EwayRecurringScheduleSumAggregateInputType = {
    amount?: true
    paymentCount?: true
    maxPayments?: true
  }

  export type EwayRecurringScheduleMinAggregateInputType = {
    id?: true
    customerToken?: true
    interval?: true
    amount?: true
    currency?: true
    status?: true
    nextPayment?: true
    lastPayment?: true
    paymentCount?: true
    maxPayments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EwayRecurringScheduleMaxAggregateInputType = {
    id?: true
    customerToken?: true
    interval?: true
    amount?: true
    currency?: true
    status?: true
    nextPayment?: true
    lastPayment?: true
    paymentCount?: true
    maxPayments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EwayRecurringScheduleCountAggregateInputType = {
    id?: true
    customerToken?: true
    interval?: true
    amount?: true
    currency?: true
    status?: true
    nextPayment?: true
    lastPayment?: true
    paymentCount?: true
    maxPayments?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EwayRecurringScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayRecurringSchedule to aggregate.
     */
    where?: EwayRecurringScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayRecurringSchedules to fetch.
     */
    orderBy?: EwayRecurringScheduleOrderByWithRelationInput | EwayRecurringScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EwayRecurringScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayRecurringSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayRecurringSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EwayRecurringSchedules
    **/
    _count?: true | EwayRecurringScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EwayRecurringScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EwayRecurringScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EwayRecurringScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EwayRecurringScheduleMaxAggregateInputType
  }

  export type GetEwayRecurringScheduleAggregateType<T extends EwayRecurringScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateEwayRecurringSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEwayRecurringSchedule[P]>
      : GetScalarType<T[P], AggregateEwayRecurringSchedule[P]>
  }




  export type EwayRecurringScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayRecurringScheduleWhereInput
    orderBy?: EwayRecurringScheduleOrderByWithAggregationInput | EwayRecurringScheduleOrderByWithAggregationInput[]
    by: EwayRecurringScheduleScalarFieldEnum[] | EwayRecurringScheduleScalarFieldEnum
    having?: EwayRecurringScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EwayRecurringScheduleCountAggregateInputType | true
    _avg?: EwayRecurringScheduleAvgAggregateInputType
    _sum?: EwayRecurringScheduleSumAggregateInputType
    _min?: EwayRecurringScheduleMinAggregateInputType
    _max?: EwayRecurringScheduleMaxAggregateInputType
  }

  export type EwayRecurringScheduleGroupByOutputType = {
    id: string
    customerToken: string
    interval: string
    amount: Decimal
    currency: string
    status: string
    nextPayment: Date
    lastPayment: Date | null
    paymentCount: number
    maxPayments: number | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: EwayRecurringScheduleCountAggregateOutputType | null
    _avg: EwayRecurringScheduleAvgAggregateOutputType | null
    _sum: EwayRecurringScheduleSumAggregateOutputType | null
    _min: EwayRecurringScheduleMinAggregateOutputType | null
    _max: EwayRecurringScheduleMaxAggregateOutputType | null
  }

  type GetEwayRecurringScheduleGroupByPayload<T extends EwayRecurringScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EwayRecurringScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EwayRecurringScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EwayRecurringScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], EwayRecurringScheduleGroupByOutputType[P]>
        }
      >
    >


  export type EwayRecurringScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerToken?: boolean
    interval?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    nextPayment?: boolean
    lastPayment?: boolean
    paymentCount?: boolean
    maxPayments?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ewayCustomer?: boolean | EwayCustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ewayRecurringSchedule"]>

  export type EwayRecurringScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerToken?: boolean
    interval?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    nextPayment?: boolean
    lastPayment?: boolean
    paymentCount?: boolean
    maxPayments?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ewayCustomer?: boolean | EwayCustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ewayRecurringSchedule"]>

  export type EwayRecurringScheduleSelectScalar = {
    id?: boolean
    customerToken?: boolean
    interval?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    nextPayment?: boolean
    lastPayment?: boolean
    paymentCount?: boolean
    maxPayments?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EwayRecurringScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ewayCustomer?: boolean | EwayCustomerDefaultArgs<ExtArgs>
  }
  export type EwayRecurringScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ewayCustomer?: boolean | EwayCustomerDefaultArgs<ExtArgs>
  }

  export type $EwayRecurringSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EwayRecurringSchedule"
    objects: {
      ewayCustomer: Prisma.$EwayCustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerToken: string
      interval: string
      amount: Prisma.Decimal
      currency: string
      status: string
      nextPayment: Date
      lastPayment: Date | null
      paymentCount: number
      maxPayments: number | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ewayRecurringSchedule"]>
    composites: {}
  }

  type EwayRecurringScheduleGetPayload<S extends boolean | null | undefined | EwayRecurringScheduleDefaultArgs> = $Result.GetResult<Prisma.$EwayRecurringSchedulePayload, S>

  type EwayRecurringScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EwayRecurringScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EwayRecurringScheduleCountAggregateInputType | true
    }

  export interface EwayRecurringScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EwayRecurringSchedule'], meta: { name: 'EwayRecurringSchedule' } }
    /**
     * Find zero or one EwayRecurringSchedule that matches the filter.
     * @param {EwayRecurringScheduleFindUniqueArgs} args - Arguments to find a EwayRecurringSchedule
     * @example
     * // Get one EwayRecurringSchedule
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EwayRecurringScheduleFindUniqueArgs>(args: SelectSubset<T, EwayRecurringScheduleFindUniqueArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EwayRecurringSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EwayRecurringScheduleFindUniqueOrThrowArgs} args - Arguments to find a EwayRecurringSchedule
     * @example
     * // Get one EwayRecurringSchedule
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EwayRecurringScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, EwayRecurringScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EwayRecurringSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleFindFirstArgs} args - Arguments to find a EwayRecurringSchedule
     * @example
     * // Get one EwayRecurringSchedule
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EwayRecurringScheduleFindFirstArgs>(args?: SelectSubset<T, EwayRecurringScheduleFindFirstArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EwayRecurringSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleFindFirstOrThrowArgs} args - Arguments to find a EwayRecurringSchedule
     * @example
     * // Get one EwayRecurringSchedule
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EwayRecurringScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, EwayRecurringScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EwayRecurringSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EwayRecurringSchedules
     * const ewayRecurringSchedules = await prisma.ewayRecurringSchedule.findMany()
     * 
     * // Get first 10 EwayRecurringSchedules
     * const ewayRecurringSchedules = await prisma.ewayRecurringSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ewayRecurringScheduleWithIdOnly = await prisma.ewayRecurringSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EwayRecurringScheduleFindManyArgs>(args?: SelectSubset<T, EwayRecurringScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EwayRecurringSchedule.
     * @param {EwayRecurringScheduleCreateArgs} args - Arguments to create a EwayRecurringSchedule.
     * @example
     * // Create one EwayRecurringSchedule
     * const EwayRecurringSchedule = await prisma.ewayRecurringSchedule.create({
     *   data: {
     *     // ... data to create a EwayRecurringSchedule
     *   }
     * })
     * 
     */
    create<T extends EwayRecurringScheduleCreateArgs>(args: SelectSubset<T, EwayRecurringScheduleCreateArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EwayRecurringSchedules.
     * @param {EwayRecurringScheduleCreateManyArgs} args - Arguments to create many EwayRecurringSchedules.
     * @example
     * // Create many EwayRecurringSchedules
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EwayRecurringScheduleCreateManyArgs>(args?: SelectSubset<T, EwayRecurringScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EwayRecurringSchedules and returns the data saved in the database.
     * @param {EwayRecurringScheduleCreateManyAndReturnArgs} args - Arguments to create many EwayRecurringSchedules.
     * @example
     * // Create many EwayRecurringSchedules
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EwayRecurringSchedules and only return the `id`
     * const ewayRecurringScheduleWithIdOnly = await prisma.ewayRecurringSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EwayRecurringScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, EwayRecurringScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EwayRecurringSchedule.
     * @param {EwayRecurringScheduleDeleteArgs} args - Arguments to delete one EwayRecurringSchedule.
     * @example
     * // Delete one EwayRecurringSchedule
     * const EwayRecurringSchedule = await prisma.ewayRecurringSchedule.delete({
     *   where: {
     *     // ... filter to delete one EwayRecurringSchedule
     *   }
     * })
     * 
     */
    delete<T extends EwayRecurringScheduleDeleteArgs>(args: SelectSubset<T, EwayRecurringScheduleDeleteArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EwayRecurringSchedule.
     * @param {EwayRecurringScheduleUpdateArgs} args - Arguments to update one EwayRecurringSchedule.
     * @example
     * // Update one EwayRecurringSchedule
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EwayRecurringScheduleUpdateArgs>(args: SelectSubset<T, EwayRecurringScheduleUpdateArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EwayRecurringSchedules.
     * @param {EwayRecurringScheduleDeleteManyArgs} args - Arguments to filter EwayRecurringSchedules to delete.
     * @example
     * // Delete a few EwayRecurringSchedules
     * const { count } = await prisma.ewayRecurringSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EwayRecurringScheduleDeleteManyArgs>(args?: SelectSubset<T, EwayRecurringScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EwayRecurringSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EwayRecurringSchedules
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EwayRecurringScheduleUpdateManyArgs>(args: SelectSubset<T, EwayRecurringScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EwayRecurringSchedule.
     * @param {EwayRecurringScheduleUpsertArgs} args - Arguments to update or create a EwayRecurringSchedule.
     * @example
     * // Update or create a EwayRecurringSchedule
     * const ewayRecurringSchedule = await prisma.ewayRecurringSchedule.upsert({
     *   create: {
     *     // ... data to create a EwayRecurringSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EwayRecurringSchedule we want to update
     *   }
     * })
     */
    upsert<T extends EwayRecurringScheduleUpsertArgs>(args: SelectSubset<T, EwayRecurringScheduleUpsertArgs<ExtArgs>>): Prisma__EwayRecurringScheduleClient<$Result.GetResult<Prisma.$EwayRecurringSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EwayRecurringSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleCountArgs} args - Arguments to filter EwayRecurringSchedules to count.
     * @example
     * // Count the number of EwayRecurringSchedules
     * const count = await prisma.ewayRecurringSchedule.count({
     *   where: {
     *     // ... the filter for the EwayRecurringSchedules we want to count
     *   }
     * })
    **/
    count<T extends EwayRecurringScheduleCountArgs>(
      args?: Subset<T, EwayRecurringScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EwayRecurringScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EwayRecurringSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EwayRecurringScheduleAggregateArgs>(args: Subset<T, EwayRecurringScheduleAggregateArgs>): Prisma.PrismaPromise<GetEwayRecurringScheduleAggregateType<T>>

    /**
     * Group by EwayRecurringSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayRecurringScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EwayRecurringScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EwayRecurringScheduleGroupByArgs['orderBy'] }
        : { orderBy?: EwayRecurringScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EwayRecurringScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEwayRecurringScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EwayRecurringSchedule model
   */
  readonly fields: EwayRecurringScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EwayRecurringSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EwayRecurringScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ewayCustomer<T extends EwayCustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EwayCustomerDefaultArgs<ExtArgs>>): Prisma__EwayCustomerClient<$Result.GetResult<Prisma.$EwayCustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EwayRecurringSchedule model
   */ 
  interface EwayRecurringScheduleFieldRefs {
    readonly id: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly customerToken: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly interval: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly amount: FieldRef<"EwayRecurringSchedule", 'Decimal'>
    readonly currency: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly status: FieldRef<"EwayRecurringSchedule", 'String'>
    readonly nextPayment: FieldRef<"EwayRecurringSchedule", 'DateTime'>
    readonly lastPayment: FieldRef<"EwayRecurringSchedule", 'DateTime'>
    readonly paymentCount: FieldRef<"EwayRecurringSchedule", 'Int'>
    readonly maxPayments: FieldRef<"EwayRecurringSchedule", 'Int'>
    readonly metadata: FieldRef<"EwayRecurringSchedule", 'Json'>
    readonly createdAt: FieldRef<"EwayRecurringSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"EwayRecurringSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EwayRecurringSchedule findUnique
   */
  export type EwayRecurringScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EwayRecurringSchedule to fetch.
     */
    where: EwayRecurringScheduleWhereUniqueInput
  }

  /**
   * EwayRecurringSchedule findUniqueOrThrow
   */
  export type EwayRecurringScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EwayRecurringSchedule to fetch.
     */
    where: EwayRecurringScheduleWhereUniqueInput
  }

  /**
   * EwayRecurringSchedule findFirst
   */
  export type EwayRecurringScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EwayRecurringSchedule to fetch.
     */
    where?: EwayRecurringScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayRecurringSchedules to fetch.
     */
    orderBy?: EwayRecurringScheduleOrderByWithRelationInput | EwayRecurringScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayRecurringSchedules.
     */
    cursor?: EwayRecurringScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayRecurringSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayRecurringSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayRecurringSchedules.
     */
    distinct?: EwayRecurringScheduleScalarFieldEnum | EwayRecurringScheduleScalarFieldEnum[]
  }

  /**
   * EwayRecurringSchedule findFirstOrThrow
   */
  export type EwayRecurringScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EwayRecurringSchedule to fetch.
     */
    where?: EwayRecurringScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayRecurringSchedules to fetch.
     */
    orderBy?: EwayRecurringScheduleOrderByWithRelationInput | EwayRecurringScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayRecurringSchedules.
     */
    cursor?: EwayRecurringScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayRecurringSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayRecurringSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayRecurringSchedules.
     */
    distinct?: EwayRecurringScheduleScalarFieldEnum | EwayRecurringScheduleScalarFieldEnum[]
  }

  /**
   * EwayRecurringSchedule findMany
   */
  export type EwayRecurringScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EwayRecurringSchedules to fetch.
     */
    where?: EwayRecurringScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayRecurringSchedules to fetch.
     */
    orderBy?: EwayRecurringScheduleOrderByWithRelationInput | EwayRecurringScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EwayRecurringSchedules.
     */
    cursor?: EwayRecurringScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayRecurringSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayRecurringSchedules.
     */
    skip?: number
    distinct?: EwayRecurringScheduleScalarFieldEnum | EwayRecurringScheduleScalarFieldEnum[]
  }

  /**
   * EwayRecurringSchedule create
   */
  export type EwayRecurringScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a EwayRecurringSchedule.
     */
    data: XOR<EwayRecurringScheduleCreateInput, EwayRecurringScheduleUncheckedCreateInput>
  }

  /**
   * EwayRecurringSchedule createMany
   */
  export type EwayRecurringScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EwayRecurringSchedules.
     */
    data: EwayRecurringScheduleCreateManyInput | EwayRecurringScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EwayRecurringSchedule createManyAndReturn
   */
  export type EwayRecurringScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EwayRecurringSchedules.
     */
    data: EwayRecurringScheduleCreateManyInput | EwayRecurringScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EwayRecurringSchedule update
   */
  export type EwayRecurringScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a EwayRecurringSchedule.
     */
    data: XOR<EwayRecurringScheduleUpdateInput, EwayRecurringScheduleUncheckedUpdateInput>
    /**
     * Choose, which EwayRecurringSchedule to update.
     */
    where: EwayRecurringScheduleWhereUniqueInput
  }

  /**
   * EwayRecurringSchedule updateMany
   */
  export type EwayRecurringScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EwayRecurringSchedules.
     */
    data: XOR<EwayRecurringScheduleUpdateManyMutationInput, EwayRecurringScheduleUncheckedUpdateManyInput>
    /**
     * Filter which EwayRecurringSchedules to update
     */
    where?: EwayRecurringScheduleWhereInput
  }

  /**
   * EwayRecurringSchedule upsert
   */
  export type EwayRecurringScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the EwayRecurringSchedule to update in case it exists.
     */
    where: EwayRecurringScheduleWhereUniqueInput
    /**
     * In case the EwayRecurringSchedule found by the `where` argument doesn't exist, create a new EwayRecurringSchedule with this data.
     */
    create: XOR<EwayRecurringScheduleCreateInput, EwayRecurringScheduleUncheckedCreateInput>
    /**
     * In case the EwayRecurringSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EwayRecurringScheduleUpdateInput, EwayRecurringScheduleUncheckedUpdateInput>
  }

  /**
   * EwayRecurringSchedule delete
   */
  export type EwayRecurringScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
    /**
     * Filter which EwayRecurringSchedule to delete.
     */
    where: EwayRecurringScheduleWhereUniqueInput
  }

  /**
   * EwayRecurringSchedule deleteMany
   */
  export type EwayRecurringScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayRecurringSchedules to delete
     */
    where?: EwayRecurringScheduleWhereInput
  }

  /**
   * EwayRecurringSchedule without action
   */
  export type EwayRecurringScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayRecurringSchedule
     */
    select?: EwayRecurringScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EwayRecurringScheduleInclude<ExtArgs> | null
  }


  /**
   * Model EwayWebhookEvent
   */

  export type AggregateEwayWebhookEvent = {
    _count: EwayWebhookEventCountAggregateOutputType | null
    _avg: EwayWebhookEventAvgAggregateOutputType | null
    _sum: EwayWebhookEventSumAggregateOutputType | null
    _min: EwayWebhookEventMinAggregateOutputType | null
    _max: EwayWebhookEventMaxAggregateOutputType | null
  }

  export type EwayWebhookEventAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type EwayWebhookEventSumAggregateOutputType = {
    retryCount: number | null
  }

  export type EwayWebhookEventMinAggregateOutputType = {
    id: string | null
    eventType: string | null
    transactionId: string | null
    customerToken: string | null
    processed: boolean | null
    processedAt: Date | null
    error: string | null
    retryCount: number | null
    createdAt: Date | null
  }

  export type EwayWebhookEventMaxAggregateOutputType = {
    id: string | null
    eventType: string | null
    transactionId: string | null
    customerToken: string | null
    processed: boolean | null
    processedAt: Date | null
    error: string | null
    retryCount: number | null
    createdAt: Date | null
  }

  export type EwayWebhookEventCountAggregateOutputType = {
    id: number
    eventType: number
    transactionId: number
    customerToken: number
    payload: number
    processed: number
    processedAt: number
    error: number
    retryCount: number
    createdAt: number
    _all: number
  }


  export type EwayWebhookEventAvgAggregateInputType = {
    retryCount?: true
  }

  export type EwayWebhookEventSumAggregateInputType = {
    retryCount?: true
  }

  export type EwayWebhookEventMinAggregateInputType = {
    id?: true
    eventType?: true
    transactionId?: true
    customerToken?: true
    processed?: true
    processedAt?: true
    error?: true
    retryCount?: true
    createdAt?: true
  }

  export type EwayWebhookEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    transactionId?: true
    customerToken?: true
    processed?: true
    processedAt?: true
    error?: true
    retryCount?: true
    createdAt?: true
  }

  export type EwayWebhookEventCountAggregateInputType = {
    id?: true
    eventType?: true
    transactionId?: true
    customerToken?: true
    payload?: true
    processed?: true
    processedAt?: true
    error?: true
    retryCount?: true
    createdAt?: true
    _all?: true
  }

  export type EwayWebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayWebhookEvent to aggregate.
     */
    where?: EwayWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayWebhookEvents to fetch.
     */
    orderBy?: EwayWebhookEventOrderByWithRelationInput | EwayWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EwayWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EwayWebhookEvents
    **/
    _count?: true | EwayWebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EwayWebhookEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EwayWebhookEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EwayWebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EwayWebhookEventMaxAggregateInputType
  }

  export type GetEwayWebhookEventAggregateType<T extends EwayWebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateEwayWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEwayWebhookEvent[P]>
      : GetScalarType<T[P], AggregateEwayWebhookEvent[P]>
  }




  export type EwayWebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwayWebhookEventWhereInput
    orderBy?: EwayWebhookEventOrderByWithAggregationInput | EwayWebhookEventOrderByWithAggregationInput[]
    by: EwayWebhookEventScalarFieldEnum[] | EwayWebhookEventScalarFieldEnum
    having?: EwayWebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EwayWebhookEventCountAggregateInputType | true
    _avg?: EwayWebhookEventAvgAggregateInputType
    _sum?: EwayWebhookEventSumAggregateInputType
    _min?: EwayWebhookEventMinAggregateInputType
    _max?: EwayWebhookEventMaxAggregateInputType
  }

  export type EwayWebhookEventGroupByOutputType = {
    id: string
    eventType: string
    transactionId: string | null
    customerToken: string | null
    payload: JsonValue
    processed: boolean
    processedAt: Date | null
    error: string | null
    retryCount: number
    createdAt: Date
    _count: EwayWebhookEventCountAggregateOutputType | null
    _avg: EwayWebhookEventAvgAggregateOutputType | null
    _sum: EwayWebhookEventSumAggregateOutputType | null
    _min: EwayWebhookEventMinAggregateOutputType | null
    _max: EwayWebhookEventMaxAggregateOutputType | null
  }

  type GetEwayWebhookEventGroupByPayload<T extends EwayWebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EwayWebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EwayWebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EwayWebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], EwayWebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type EwayWebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    transactionId?: boolean
    customerToken?: boolean
    payload?: boolean
    processed?: boolean
    processedAt?: boolean
    error?: boolean
    retryCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ewayWebhookEvent"]>

  export type EwayWebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    transactionId?: boolean
    customerToken?: boolean
    payload?: boolean
    processed?: boolean
    processedAt?: boolean
    error?: boolean
    retryCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ewayWebhookEvent"]>

  export type EwayWebhookEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    transactionId?: boolean
    customerToken?: boolean
    payload?: boolean
    processed?: boolean
    processedAt?: boolean
    error?: boolean
    retryCount?: boolean
    createdAt?: boolean
  }


  export type $EwayWebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EwayWebhookEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: string
      transactionId: string | null
      customerToken: string | null
      payload: Prisma.JsonValue
      processed: boolean
      processedAt: Date | null
      error: string | null
      retryCount: number
      createdAt: Date
    }, ExtArgs["result"]["ewayWebhookEvent"]>
    composites: {}
  }

  type EwayWebhookEventGetPayload<S extends boolean | null | undefined | EwayWebhookEventDefaultArgs> = $Result.GetResult<Prisma.$EwayWebhookEventPayload, S>

  type EwayWebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EwayWebhookEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EwayWebhookEventCountAggregateInputType | true
    }

  export interface EwayWebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EwayWebhookEvent'], meta: { name: 'EwayWebhookEvent' } }
    /**
     * Find zero or one EwayWebhookEvent that matches the filter.
     * @param {EwayWebhookEventFindUniqueArgs} args - Arguments to find a EwayWebhookEvent
     * @example
     * // Get one EwayWebhookEvent
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EwayWebhookEventFindUniqueArgs>(args: SelectSubset<T, EwayWebhookEventFindUniqueArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EwayWebhookEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EwayWebhookEventFindUniqueOrThrowArgs} args - Arguments to find a EwayWebhookEvent
     * @example
     * // Get one EwayWebhookEvent
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EwayWebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, EwayWebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EwayWebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventFindFirstArgs} args - Arguments to find a EwayWebhookEvent
     * @example
     * // Get one EwayWebhookEvent
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EwayWebhookEventFindFirstArgs>(args?: SelectSubset<T, EwayWebhookEventFindFirstArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EwayWebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventFindFirstOrThrowArgs} args - Arguments to find a EwayWebhookEvent
     * @example
     * // Get one EwayWebhookEvent
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EwayWebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, EwayWebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EwayWebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EwayWebhookEvents
     * const ewayWebhookEvents = await prisma.ewayWebhookEvent.findMany()
     * 
     * // Get first 10 EwayWebhookEvents
     * const ewayWebhookEvents = await prisma.ewayWebhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ewayWebhookEventWithIdOnly = await prisma.ewayWebhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EwayWebhookEventFindManyArgs>(args?: SelectSubset<T, EwayWebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EwayWebhookEvent.
     * @param {EwayWebhookEventCreateArgs} args - Arguments to create a EwayWebhookEvent.
     * @example
     * // Create one EwayWebhookEvent
     * const EwayWebhookEvent = await prisma.ewayWebhookEvent.create({
     *   data: {
     *     // ... data to create a EwayWebhookEvent
     *   }
     * })
     * 
     */
    create<T extends EwayWebhookEventCreateArgs>(args: SelectSubset<T, EwayWebhookEventCreateArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EwayWebhookEvents.
     * @param {EwayWebhookEventCreateManyArgs} args - Arguments to create many EwayWebhookEvents.
     * @example
     * // Create many EwayWebhookEvents
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EwayWebhookEventCreateManyArgs>(args?: SelectSubset<T, EwayWebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EwayWebhookEvents and returns the data saved in the database.
     * @param {EwayWebhookEventCreateManyAndReturnArgs} args - Arguments to create many EwayWebhookEvents.
     * @example
     * // Create many EwayWebhookEvents
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EwayWebhookEvents and only return the `id`
     * const ewayWebhookEventWithIdOnly = await prisma.ewayWebhookEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EwayWebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, EwayWebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EwayWebhookEvent.
     * @param {EwayWebhookEventDeleteArgs} args - Arguments to delete one EwayWebhookEvent.
     * @example
     * // Delete one EwayWebhookEvent
     * const EwayWebhookEvent = await prisma.ewayWebhookEvent.delete({
     *   where: {
     *     // ... filter to delete one EwayWebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends EwayWebhookEventDeleteArgs>(args: SelectSubset<T, EwayWebhookEventDeleteArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EwayWebhookEvent.
     * @param {EwayWebhookEventUpdateArgs} args - Arguments to update one EwayWebhookEvent.
     * @example
     * // Update one EwayWebhookEvent
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EwayWebhookEventUpdateArgs>(args: SelectSubset<T, EwayWebhookEventUpdateArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EwayWebhookEvents.
     * @param {EwayWebhookEventDeleteManyArgs} args - Arguments to filter EwayWebhookEvents to delete.
     * @example
     * // Delete a few EwayWebhookEvents
     * const { count } = await prisma.ewayWebhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EwayWebhookEventDeleteManyArgs>(args?: SelectSubset<T, EwayWebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EwayWebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EwayWebhookEvents
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EwayWebhookEventUpdateManyArgs>(args: SelectSubset<T, EwayWebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EwayWebhookEvent.
     * @param {EwayWebhookEventUpsertArgs} args - Arguments to update or create a EwayWebhookEvent.
     * @example
     * // Update or create a EwayWebhookEvent
     * const ewayWebhookEvent = await prisma.ewayWebhookEvent.upsert({
     *   create: {
     *     // ... data to create a EwayWebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EwayWebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends EwayWebhookEventUpsertArgs>(args: SelectSubset<T, EwayWebhookEventUpsertArgs<ExtArgs>>): Prisma__EwayWebhookEventClient<$Result.GetResult<Prisma.$EwayWebhookEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EwayWebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventCountArgs} args - Arguments to filter EwayWebhookEvents to count.
     * @example
     * // Count the number of EwayWebhookEvents
     * const count = await prisma.ewayWebhookEvent.count({
     *   where: {
     *     // ... the filter for the EwayWebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends EwayWebhookEventCountArgs>(
      args?: Subset<T, EwayWebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EwayWebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EwayWebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EwayWebhookEventAggregateArgs>(args: Subset<T, EwayWebhookEventAggregateArgs>): Prisma.PrismaPromise<GetEwayWebhookEventAggregateType<T>>

    /**
     * Group by EwayWebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwayWebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EwayWebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EwayWebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: EwayWebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EwayWebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEwayWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EwayWebhookEvent model
   */
  readonly fields: EwayWebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EwayWebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EwayWebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EwayWebhookEvent model
   */ 
  interface EwayWebhookEventFieldRefs {
    readonly id: FieldRef<"EwayWebhookEvent", 'String'>
    readonly eventType: FieldRef<"EwayWebhookEvent", 'String'>
    readonly transactionId: FieldRef<"EwayWebhookEvent", 'String'>
    readonly customerToken: FieldRef<"EwayWebhookEvent", 'String'>
    readonly payload: FieldRef<"EwayWebhookEvent", 'Json'>
    readonly processed: FieldRef<"EwayWebhookEvent", 'Boolean'>
    readonly processedAt: FieldRef<"EwayWebhookEvent", 'DateTime'>
    readonly error: FieldRef<"EwayWebhookEvent", 'String'>
    readonly retryCount: FieldRef<"EwayWebhookEvent", 'Int'>
    readonly createdAt: FieldRef<"EwayWebhookEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EwayWebhookEvent findUnique
   */
  export type EwayWebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which EwayWebhookEvent to fetch.
     */
    where: EwayWebhookEventWhereUniqueInput
  }

  /**
   * EwayWebhookEvent findUniqueOrThrow
   */
  export type EwayWebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which EwayWebhookEvent to fetch.
     */
    where: EwayWebhookEventWhereUniqueInput
  }

  /**
   * EwayWebhookEvent findFirst
   */
  export type EwayWebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which EwayWebhookEvent to fetch.
     */
    where?: EwayWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayWebhookEvents to fetch.
     */
    orderBy?: EwayWebhookEventOrderByWithRelationInput | EwayWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayWebhookEvents.
     */
    cursor?: EwayWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayWebhookEvents.
     */
    distinct?: EwayWebhookEventScalarFieldEnum | EwayWebhookEventScalarFieldEnum[]
  }

  /**
   * EwayWebhookEvent findFirstOrThrow
   */
  export type EwayWebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which EwayWebhookEvent to fetch.
     */
    where?: EwayWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayWebhookEvents to fetch.
     */
    orderBy?: EwayWebhookEventOrderByWithRelationInput | EwayWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwayWebhookEvents.
     */
    cursor?: EwayWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwayWebhookEvents.
     */
    distinct?: EwayWebhookEventScalarFieldEnum | EwayWebhookEventScalarFieldEnum[]
  }

  /**
   * EwayWebhookEvent findMany
   */
  export type EwayWebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which EwayWebhookEvents to fetch.
     */
    where?: EwayWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwayWebhookEvents to fetch.
     */
    orderBy?: EwayWebhookEventOrderByWithRelationInput | EwayWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EwayWebhookEvents.
     */
    cursor?: EwayWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwayWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwayWebhookEvents.
     */
    skip?: number
    distinct?: EwayWebhookEventScalarFieldEnum | EwayWebhookEventScalarFieldEnum[]
  }

  /**
   * EwayWebhookEvent create
   */
  export type EwayWebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * The data needed to create a EwayWebhookEvent.
     */
    data: XOR<EwayWebhookEventCreateInput, EwayWebhookEventUncheckedCreateInput>
  }

  /**
   * EwayWebhookEvent createMany
   */
  export type EwayWebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EwayWebhookEvents.
     */
    data: EwayWebhookEventCreateManyInput | EwayWebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EwayWebhookEvent createManyAndReturn
   */
  export type EwayWebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EwayWebhookEvents.
     */
    data: EwayWebhookEventCreateManyInput | EwayWebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EwayWebhookEvent update
   */
  export type EwayWebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * The data needed to update a EwayWebhookEvent.
     */
    data: XOR<EwayWebhookEventUpdateInput, EwayWebhookEventUncheckedUpdateInput>
    /**
     * Choose, which EwayWebhookEvent to update.
     */
    where: EwayWebhookEventWhereUniqueInput
  }

  /**
   * EwayWebhookEvent updateMany
   */
  export type EwayWebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EwayWebhookEvents.
     */
    data: XOR<EwayWebhookEventUpdateManyMutationInput, EwayWebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which EwayWebhookEvents to update
     */
    where?: EwayWebhookEventWhereInput
  }

  /**
   * EwayWebhookEvent upsert
   */
  export type EwayWebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * The filter to search for the EwayWebhookEvent to update in case it exists.
     */
    where: EwayWebhookEventWhereUniqueInput
    /**
     * In case the EwayWebhookEvent found by the `where` argument doesn't exist, create a new EwayWebhookEvent with this data.
     */
    create: XOR<EwayWebhookEventCreateInput, EwayWebhookEventUncheckedCreateInput>
    /**
     * In case the EwayWebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EwayWebhookEventUpdateInput, EwayWebhookEventUncheckedUpdateInput>
  }

  /**
   * EwayWebhookEvent delete
   */
  export type EwayWebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
    /**
     * Filter which EwayWebhookEvent to delete.
     */
    where: EwayWebhookEventWhereUniqueInput
  }

  /**
   * EwayWebhookEvent deleteMany
   */
  export type EwayWebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwayWebhookEvents to delete
     */
    where?: EwayWebhookEventWhereInput
  }

  /**
   * EwayWebhookEvent without action
   */
  export type EwayWebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwayWebhookEvent
     */
    select?: EwayWebhookEventSelect<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    key: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    key: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    key: number
    value: number
    description: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    key?: true
    description?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    key?: true
    description?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    key?: true
    value?: true
    description?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    key: string
    value: JsonValue
    description: string | null
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }


  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: Prisma.JsonValue
      description: string | null
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const systemConfigWithKeyOnly = await prisma.systemConfig.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `key`
     * const systemConfigWithKeyOnly = await prisma.systemConfig.createManyAndReturn({ 
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */ 
  interface SystemConfigFieldRefs {
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'Json'>
    readonly description: FieldRef<"SystemConfig", 'String'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
  }


  /**
   * Model HealthCheck
   */

  export type AggregateHealthCheck = {
    _count: HealthCheckCountAggregateOutputType | null
    _avg: HealthCheckAvgAggregateOutputType | null
    _sum: HealthCheckSumAggregateOutputType | null
    _min: HealthCheckMinAggregateOutputType | null
    _max: HealthCheckMaxAggregateOutputType | null
  }

  export type HealthCheckAvgAggregateOutputType = {
    responseTime: number | null
  }

  export type HealthCheckSumAggregateOutputType = {
    responseTime: number | null
  }

  export type HealthCheckMinAggregateOutputType = {
    id: string | null
    service: string | null
    status: string | null
    responseTime: number | null
    checkedAt: Date | null
  }

  export type HealthCheckMaxAggregateOutputType = {
    id: string | null
    service: string | null
    status: string | null
    responseTime: number | null
    checkedAt: Date | null
  }

  export type HealthCheckCountAggregateOutputType = {
    id: number
    service: number
    status: number
    responseTime: number
    details: number
    checkedAt: number
    _all: number
  }


  export type HealthCheckAvgAggregateInputType = {
    responseTime?: true
  }

  export type HealthCheckSumAggregateInputType = {
    responseTime?: true
  }

  export type HealthCheckMinAggregateInputType = {
    id?: true
    service?: true
    status?: true
    responseTime?: true
    checkedAt?: true
  }

  export type HealthCheckMaxAggregateInputType = {
    id?: true
    service?: true
    status?: true
    responseTime?: true
    checkedAt?: true
  }

  export type HealthCheckCountAggregateInputType = {
    id?: true
    service?: true
    status?: true
    responseTime?: true
    details?: true
    checkedAt?: true
    _all?: true
  }

  export type HealthCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthCheck to aggregate.
     */
    where?: HealthCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthChecks to fetch.
     */
    orderBy?: HealthCheckOrderByWithRelationInput | HealthCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthChecks
    **/
    _count?: true | HealthCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HealthCheckAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HealthCheckSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthCheckMaxAggregateInputType
  }

  export type GetHealthCheckAggregateType<T extends HealthCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthCheck[P]>
      : GetScalarType<T[P], AggregateHealthCheck[P]>
  }




  export type HealthCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthCheckWhereInput
    orderBy?: HealthCheckOrderByWithAggregationInput | HealthCheckOrderByWithAggregationInput[]
    by: HealthCheckScalarFieldEnum[] | HealthCheckScalarFieldEnum
    having?: HealthCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthCheckCountAggregateInputType | true
    _avg?: HealthCheckAvgAggregateInputType
    _sum?: HealthCheckSumAggregateInputType
    _min?: HealthCheckMinAggregateInputType
    _max?: HealthCheckMaxAggregateInputType
  }

  export type HealthCheckGroupByOutputType = {
    id: string
    service: string
    status: string
    responseTime: number
    details: JsonValue | null
    checkedAt: Date
    _count: HealthCheckCountAggregateOutputType | null
    _avg: HealthCheckAvgAggregateOutputType | null
    _sum: HealthCheckSumAggregateOutputType | null
    _min: HealthCheckMinAggregateOutputType | null
    _max: HealthCheckMaxAggregateOutputType | null
  }

  type GetHealthCheckGroupByPayload<T extends HealthCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthCheckGroupByOutputType[P]>
            : GetScalarType<T[P], HealthCheckGroupByOutputType[P]>
        }
      >
    >


  export type HealthCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    status?: boolean
    responseTime?: boolean
    details?: boolean
    checkedAt?: boolean
  }, ExtArgs["result"]["healthCheck"]>

  export type HealthCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    status?: boolean
    responseTime?: boolean
    details?: boolean
    checkedAt?: boolean
  }, ExtArgs["result"]["healthCheck"]>

  export type HealthCheckSelectScalar = {
    id?: boolean
    service?: boolean
    status?: boolean
    responseTime?: boolean
    details?: boolean
    checkedAt?: boolean
  }


  export type $HealthCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthCheck"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service: string
      status: string
      responseTime: number
      details: Prisma.JsonValue | null
      checkedAt: Date
    }, ExtArgs["result"]["healthCheck"]>
    composites: {}
  }

  type HealthCheckGetPayload<S extends boolean | null | undefined | HealthCheckDefaultArgs> = $Result.GetResult<Prisma.$HealthCheckPayload, S>

  type HealthCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthCheckFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthCheckCountAggregateInputType | true
    }

  export interface HealthCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthCheck'], meta: { name: 'HealthCheck' } }
    /**
     * Find zero or one HealthCheck that matches the filter.
     * @param {HealthCheckFindUniqueArgs} args - Arguments to find a HealthCheck
     * @example
     * // Get one HealthCheck
     * const healthCheck = await prisma.healthCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthCheckFindUniqueArgs>(args: SelectSubset<T, HealthCheckFindUniqueArgs<ExtArgs>>): Prisma__HealthCheckClient<$Result.GetResult<Prisma.$HealthCheckPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HealthCheck that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HealthCheckFindUniqueOrThrowArgs} args - Arguments to find a HealthCheck
     * @example
     * // Get one HealthCheck
     * const healthCheck = await prisma.healthCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthCheckClient<$Result.GetResult<Prisma.$HealthCheckPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HealthCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthCheckFindFirstArgs} args - Arguments to find a HealthCheck
     * @example
     * // Get one HealthCheck
     * const healthCheck = await prisma.healthCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthCheckFindFirstArgs>(args?: SelectSubset<T, HealthCheckFindFirstArgs<ExtArgs>>): Prisma__HealthCheckClient<$Result.GetResult<Prisma.$HealthCheckPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HealthCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthCheckFindFirstOrThrowArgs} args - Arguments to find a HealthCheck
     * @example
     * // Get one HealthCheck
     * const healthCheck = await prisma.healthCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthCheckClient<$Result.GetResult<Prisma.$HealthCheckPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HealthChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthChecks
     * const healthChecks = await prisma.healthCheck.findMany()
     * 
     * // Get first 10 HealthChecks
     * const healthChecks = await prisma.healthCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthCheckWithIdOnly = await prisma.healthCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthCheckFindManyArgs>(args?: SelectSubset<T, HealthCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthCheckPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HealthCheck.
     * @param {HealthCheckCreateArgs} args - Arguments to create a HealthCheck.
     * @example
     * // Create one HealthCheck
     * const HealthCheck = await prisma.healthCheck.create({
     *   data: {
     *     // ... data to create a HealthCheck
     *   }
     * })
     * 
     */
    create<T extends HealthCheckCreateArgs>(args: SelectSubset<T, HealthCheckCreateArgs<ExtArgs>>): Prisma__HealthCheckClient<$Result.GetResult<Prisma.$HealthCheckPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HealthChecks.
     * @param {HealthCheckCreateManyArgs} args - Arguments to create many HealthChecks.
     * @example
     * // Create many HealthChecks
     * const healthCheck = await prisma.healthCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthCheckCreateManyArgs>(args?: SelectSubset<T, HealthCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthChecks and returns the data saved in the database.
     * @param {HealthCheckCreateManyAndReturnArgs} args - Arguments to create many HealthChecks.
     * @example
     * // Create many HealthChecks
     * const healthCheck = await prisma.healthCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthChecks and only return the `id`
     * const healthCheckWithIdOnly = await prisma.healthCheck.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthCheckPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HealthCheck.
     * @param {HealthCheckDeleteArgs} args - Arguments to delete one HealthCheck.
     * @example
     * // Delete one HealthCheck
     * const HealthCheck = await prisma.healthCheck.delete({
     *   where: {
     *     // ... filter to delete one HealthCheck
     *   }
     * })
     * 
     */
    delete<T extends HealthCheckDeleteArgs>(args: SelectSubset<T, HealthCheckDeleteArgs<ExtArgs>>): Prisma__HealthCheckClient<$Result.GetResult<Prisma.$HealthCheckPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HealthCheck.
     * @param {HealthCheckUpdateArgs} args - Arguments to update one HealthCheck.
     * @example
     * // Update one HealthCheck
     * const healthCheck = await prisma.healthCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthCheckUpdateArgs>(args: SelectSubset<T, HealthCheckUpdateArgs<ExtArgs>>): Prisma__HealthCheckClient<$Result.GetResult<Prisma.$HealthCheckPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HealthChecks.
     * @param {HealthCheckDeleteManyArgs} args - Arguments to filter HealthChecks to delete.
     * @example
     * // Delete a few HealthChecks
     * const { count } = await prisma.healthCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthCheckDeleteManyArgs>(args?: SelectSubset<T, HealthCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthChecks
     * const healthCheck = await prisma.healthCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthCheckUpdateManyArgs>(args: SelectSubset<T, HealthCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthCheck.
     * @param {HealthCheckUpsertArgs} args - Arguments to update or create a HealthCheck.
     * @example
     * // Update or create a HealthCheck
     * const healthCheck = await prisma.healthCheck.upsert({
     *   create: {
     *     // ... data to create a HealthCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthCheck we want to update
     *   }
     * })
     */
    upsert<T extends HealthCheckUpsertArgs>(args: SelectSubset<T, HealthCheckUpsertArgs<ExtArgs>>): Prisma__HealthCheckClient<$Result.GetResult<Prisma.$HealthCheckPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HealthChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthCheckCountArgs} args - Arguments to filter HealthChecks to count.
     * @example
     * // Count the number of HealthChecks
     * const count = await prisma.healthCheck.count({
     *   where: {
     *     // ... the filter for the HealthChecks we want to count
     *   }
     * })
    **/
    count<T extends HealthCheckCountArgs>(
      args?: Subset<T, HealthCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthCheckAggregateArgs>(args: Subset<T, HealthCheckAggregateArgs>): Prisma.PrismaPromise<GetHealthCheckAggregateType<T>>

    /**
     * Group by HealthCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthCheckGroupByArgs['orderBy'] }
        : { orderBy?: HealthCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthCheck model
   */
  readonly fields: HealthCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthCheck model
   */ 
  interface HealthCheckFieldRefs {
    readonly id: FieldRef<"HealthCheck", 'String'>
    readonly service: FieldRef<"HealthCheck", 'String'>
    readonly status: FieldRef<"HealthCheck", 'String'>
    readonly responseTime: FieldRef<"HealthCheck", 'Int'>
    readonly details: FieldRef<"HealthCheck", 'Json'>
    readonly checkedAt: FieldRef<"HealthCheck", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthCheck findUnique
   */
  export type HealthCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCheck
     */
    select?: HealthCheckSelect<ExtArgs> | null
    /**
     * Filter, which HealthCheck to fetch.
     */
    where: HealthCheckWhereUniqueInput
  }

  /**
   * HealthCheck findUniqueOrThrow
   */
  export type HealthCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCheck
     */
    select?: HealthCheckSelect<ExtArgs> | null
    /**
     * Filter, which HealthCheck to fetch.
     */
    where: HealthCheckWhereUniqueInput
  }

  /**
   * HealthCheck findFirst
   */
  export type HealthCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCheck
     */
    select?: HealthCheckSelect<ExtArgs> | null
    /**
     * Filter, which HealthCheck to fetch.
     */
    where?: HealthCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthChecks to fetch.
     */
    orderBy?: HealthCheckOrderByWithRelationInput | HealthCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthChecks.
     */
    cursor?: HealthCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthChecks.
     */
    distinct?: HealthCheckScalarFieldEnum | HealthCheckScalarFieldEnum[]
  }

  /**
   * HealthCheck findFirstOrThrow
   */
  export type HealthCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCheck
     */
    select?: HealthCheckSelect<ExtArgs> | null
    /**
     * Filter, which HealthCheck to fetch.
     */
    where?: HealthCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthChecks to fetch.
     */
    orderBy?: HealthCheckOrderByWithRelationInput | HealthCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthChecks.
     */
    cursor?: HealthCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthChecks.
     */
    distinct?: HealthCheckScalarFieldEnum | HealthCheckScalarFieldEnum[]
  }

  /**
   * HealthCheck findMany
   */
  export type HealthCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCheck
     */
    select?: HealthCheckSelect<ExtArgs> | null
    /**
     * Filter, which HealthChecks to fetch.
     */
    where?: HealthCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthChecks to fetch.
     */
    orderBy?: HealthCheckOrderByWithRelationInput | HealthCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthChecks.
     */
    cursor?: HealthCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthChecks.
     */
    skip?: number
    distinct?: HealthCheckScalarFieldEnum | HealthCheckScalarFieldEnum[]
  }

  /**
   * HealthCheck create
   */
  export type HealthCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCheck
     */
    select?: HealthCheckSelect<ExtArgs> | null
    /**
     * The data needed to create a HealthCheck.
     */
    data: XOR<HealthCheckCreateInput, HealthCheckUncheckedCreateInput>
  }

  /**
   * HealthCheck createMany
   */
  export type HealthCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthChecks.
     */
    data: HealthCheckCreateManyInput | HealthCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthCheck createManyAndReturn
   */
  export type HealthCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCheck
     */
    select?: HealthCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HealthChecks.
     */
    data: HealthCheckCreateManyInput | HealthCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthCheck update
   */
  export type HealthCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCheck
     */
    select?: HealthCheckSelect<ExtArgs> | null
    /**
     * The data needed to update a HealthCheck.
     */
    data: XOR<HealthCheckUpdateInput, HealthCheckUncheckedUpdateInput>
    /**
     * Choose, which HealthCheck to update.
     */
    where: HealthCheckWhereUniqueInput
  }

  /**
   * HealthCheck updateMany
   */
  export type HealthCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthChecks.
     */
    data: XOR<HealthCheckUpdateManyMutationInput, HealthCheckUncheckedUpdateManyInput>
    /**
     * Filter which HealthChecks to update
     */
    where?: HealthCheckWhereInput
  }

  /**
   * HealthCheck upsert
   */
  export type HealthCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCheck
     */
    select?: HealthCheckSelect<ExtArgs> | null
    /**
     * The filter to search for the HealthCheck to update in case it exists.
     */
    where: HealthCheckWhereUniqueInput
    /**
     * In case the HealthCheck found by the `where` argument doesn't exist, create a new HealthCheck with this data.
     */
    create: XOR<HealthCheckCreateInput, HealthCheckUncheckedCreateInput>
    /**
     * In case the HealthCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthCheckUpdateInput, HealthCheckUncheckedUpdateInput>
  }

  /**
   * HealthCheck delete
   */
  export type HealthCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCheck
     */
    select?: HealthCheckSelect<ExtArgs> | null
    /**
     * Filter which HealthCheck to delete.
     */
    where: HealthCheckWhereUniqueInput
  }

  /**
   * HealthCheck deleteMany
   */
  export type HealthCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthChecks to delete
     */
    where?: HealthCheckWhereInput
  }

  /**
   * HealthCheck without action
   */
  export type HealthCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCheck
     */
    select?: HealthCheckSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    role: 'role',
    firstName: 'firstName',
    lastName: 'lastName',
    avatar: 'avatar',
    phoneNumber: 'phoneNumber',
    timezone: 'timezone',
    lastLoginAt: 'lastLoginAt',
    emailVerified: 'emailVerified',
    emailVerifiedAt: 'emailVerifiedAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenHash: 'tokenHash',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    revokedAt: 'revokedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const WorkspaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    logo: 'logo',
    website: 'website',
    industry: 'industry',
    size: 'size',
    isActive: 'isActive',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  export const WorkspaceUserScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    userId: 'userId',
    role: 'role',
    permissions: 'permissions',
    joinedAt: 'joinedAt',
    lastActiveAt: 'lastActiveAt'
  };

  export type WorkspaceUserScalarFieldEnum = (typeof WorkspaceUserScalarFieldEnum)[keyof typeof WorkspaceUserScalarFieldEnum]


  export const WorkspaceInvitationScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    email: 'email',
    role: 'role',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    acceptedAt: 'acceptedAt'
  };

  export type WorkspaceInvitationScalarFieldEnum = (typeof WorkspaceInvitationScalarFieldEnum)[keyof typeof WorkspaceInvitationScalarFieldEnum]


  export const AudioUploadScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    originalFileName: 'originalFileName',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    uploadStatus: 'uploadStatus',
    uploadProgress: 'uploadProgress',
    storageProvider: 'storageProvider',
    storagePath: 'storagePath',
    storageUrl: 'storageUrl',
    cdnUrl: 'cdnUrl',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AudioUploadScalarFieldEnum = (typeof AudioUploadScalarFieldEnum)[keyof typeof AudioUploadScalarFieldEnum]


  export const ProcessingJobScalarFieldEnum: {
    id: 'id',
    uploadId: 'uploadId',
    jobType: 'jobType',
    status: 'status',
    priority: 'priority',
    progress: 'progress',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    error: 'error',
    result: 'result',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProcessingJobScalarFieldEnum = (typeof ProcessingJobScalarFieldEnum)[keyof typeof ProcessingJobScalarFieldEnum]


  export const AudioHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    processingJobId: 'processingJobId',
    title: 'title',
    audioUrl: 'audioUrl',
    fileSizeBytes: 'fileSizeBytes',
    durationSeconds: 'durationSeconds',
    transcript: 'transcript',
    summary: 'summary',
    keyMoments: 'keyMoments',
    processingOptions: 'processingOptions',
    language: 'language',
    confidence: 'confidence',
    speakers: 'speakers',
    tags: 'tags',
    createdAt: 'createdAt'
  };

  export type AudioHistoryScalarFieldEnum = (typeof AudioHistoryScalarFieldEnum)[keyof typeof AudioHistoryScalarFieldEnum]


  export const AudioSegmentScalarFieldEnum: {
    id: 'id',
    audioHistoryId: 'audioHistoryId',
    userId: 'userId',
    startTime: 'startTime',
    endTime: 'endTime',
    text: 'text',
    speaker: 'speaker',
    confidence: 'confidence',
    keywords: 'keywords',
    sentiment: 'sentiment',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AudioSegmentScalarFieldEnum = (typeof AudioSegmentScalarFieldEnum)[keyof typeof AudioSegmentScalarFieldEnum]


  export const AudioChunkScalarFieldEnum: {
    id: 'id',
    uploadId: 'uploadId',
    chunkIndex: 'chunkIndex',
    startByte: 'startByte',
    endByte: 'endByte',
    size: 'size',
    storageKey: 'storageKey',
    checksum: 'checksum',
    uploadedAt: 'uploadedAt',
    createdAt: 'createdAt'
  };

  export type AudioChunkScalarFieldEnum = (typeof AudioChunkScalarFieldEnum)[keyof typeof AudioChunkScalarFieldEnum]


  export const StorageProviderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    endpoint: 'endpoint',
    region: 'region',
    bucket: 'bucket',
    cdnEndpoint: 'cdnEndpoint',
    isActive: 'isActive',
    isDefault: 'isDefault',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StorageProviderScalarFieldEnum = (typeof StorageProviderScalarFieldEnum)[keyof typeof StorageProviderScalarFieldEnum]


  export const FileStorageScalarFieldEnum: {
    id: 'id',
    uploadId: 'uploadId',
    providerId: 'providerId',
    storageKey: 'storageKey',
    fileName: 'fileName',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    checksum: 'checksum',
    publicUrl: 'publicUrl',
    cdnUrl: 'cdnUrl',
    expiresAt: 'expiresAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    lastAccessedAt: 'lastAccessedAt'
  };

  export type FileStorageScalarFieldEnum = (typeof FileStorageScalarFieldEnum)[keyof typeof FileStorageScalarFieldEnum]


  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    tier: 'tier',
    price: 'price',
    currency: 'currency',
    billingPeriod: 'billingPeriod',
    features: 'features',
    quotas: 'quotas',
    isActive: 'isActive',
    isPublic: 'isPublic',
    trialDays: 'trialDays',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


  export const WorkspaceSubscriptionScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    planId: 'planId',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelledAt: 'cancelledAt',
    cancelReason: 'cancelReason',
    trialEnd: 'trialEnd',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceSubscriptionScalarFieldEnum = (typeof WorkspaceSubscriptionScalarFieldEnum)[keyof typeof WorkspaceSubscriptionScalarFieldEnum]


  export const BillingRecordScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    invoiceNumber: 'invoiceNumber',
    invoiceUrl: 'invoiceUrl',
    paymentMethod: 'paymentMethod',
    paymentIntentId: 'paymentIntentId',
    failureReason: 'failureReason',
    paidAt: 'paidAt',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type BillingRecordScalarFieldEnum = (typeof BillingRecordScalarFieldEnum)[keyof typeof BillingRecordScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    type: 'type',
    provider: 'provider',
    isDefault: 'isDefault',
    lastFour: 'lastFour',
    expiryMonth: 'expiryMonth',
    expiryYear: 'expiryYear',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const ApiKeyManagementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    keyHash: 'keyHash',
    keyPrefix: 'keyPrefix',
    encryptedKey: 'encryptedKey',
    isActive: 'isActive',
    lastUsedAt: 'lastUsedAt',
    usageCount: 'usageCount',
    expiresAt: 'expiresAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiKeyManagementScalarFieldEnum = (typeof ApiKeyManagementScalarFieldEnum)[keyof typeof ApiKeyManagementScalarFieldEnum]


  export const ApiKeyUsageLogScalarFieldEnum: {
    id: 'id',
    apiKeyId: 'apiKeyId',
    endpoint: 'endpoint',
    method: 'method',
    statusCode: 'statusCode',
    responseTime: 'responseTime',
    tokensUsed: 'tokensUsed',
    cost: 'cost',
    error: 'error',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ApiKeyUsageLogScalarFieldEnum = (typeof ApiKeyUsageLogScalarFieldEnum)[keyof typeof ApiKeyUsageLogScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    userId: 'userId',
    openaiApiKeyEncrypted: 'openaiApiKeyEncrypted',
    elevenlabsApiKeyEncrypted: 'elevenlabsApiKeyEncrypted',
    preferredLanguage: 'preferredLanguage',
    summaryQuality: 'summaryQuality',
    theme: 'theme',
    notifications: 'notifications',
    privacy: 'privacy',
    settingsJson: 'settingsJson',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const UsageMetricScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    metricType: 'metricType',
    value: 'value',
    period: 'period',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type UsageMetricScalarFieldEnum = (typeof UsageMetricScalarFieldEnum)[keyof typeof UsageMetricScalarFieldEnum]


  export const UserQuotaScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    quotaType: 'quotaType',
    used: 'used',
    limit: 'limit',
    resetPeriod: 'resetPeriod',
    nextResetAt: 'nextResetAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserQuotaScalarFieldEnum = (typeof UserQuotaScalarFieldEnum)[keyof typeof UserQuotaScalarFieldEnum]


  export const StorageQuotaScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    totalBytes: 'totalBytes',
    usedBytes: 'usedBytes',
    fileCount: 'fileCount',
    lastCalculated: 'lastCalculated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StorageQuotaScalarFieldEnum = (typeof StorageQuotaScalarFieldEnum)[keyof typeof StorageQuotaScalarFieldEnum]


  export const UsageRecordScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    recordType: 'recordType',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalCost: 'totalCost',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type UsageRecordScalarFieldEnum = (typeof UsageRecordScalarFieldEnum)[keyof typeof UsageRecordScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    changes: 'changes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SecurityEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventType: 'eventType',
    severity: 'severity',
    description: 'description',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    metadata: 'metadata',
    resolved: 'resolved',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy',
    createdAt: 'createdAt'
  };

  export type SecurityEventScalarFieldEnum = (typeof SecurityEventScalarFieldEnum)[keyof typeof SecurityEventScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    actionUrl: 'actionUrl',
    read: 'read',
    readAt: 'readAt',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    htmlContent: 'htmlContent',
    textContent: 'textContent',
    variables: 'variables',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const EmailLogScalarFieldEnum: {
    id: 'id',
    templateId: 'templateId',
    recipientEmail: 'recipientEmail',
    subject: 'subject',
    status: 'status',
    provider: 'provider',
    providerMessageId: 'providerMessageId',
    openedAt: 'openedAt',
    clickedAt: 'clickedAt',
    error: 'error',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type EmailLogScalarFieldEnum = (typeof EmailLogScalarFieldEnum)[keyof typeof EmailLogScalarFieldEnum]


  export const EmailPreferenceScalarFieldEnum: {
    userId: 'userId',
    marketing: 'marketing',
    transactional: 'transactional',
    security: 'security',
    newsletter: 'newsletter',
    productUpdates: 'productUpdates',
    unsubscribeToken: 'unsubscribeToken',
    updatedAt: 'updatedAt'
  };

  export type EmailPreferenceScalarFieldEnum = (typeof EmailPreferenceScalarFieldEnum)[keyof typeof EmailPreferenceScalarFieldEnum]


  export const IntegrationScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    type: 'type',
    name: 'name',
    config: 'config',
    isActive: 'isActive',
    lastSyncAt: 'lastSyncAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


  export const WorkspaceAutomationScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    trigger: 'trigger',
    actions: 'actions',
    isActive: 'isActive',
    lastRunAt: 'lastRunAt',
    runCount: 'runCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceAutomationScalarFieldEnum = (typeof WorkspaceAutomationScalarFieldEnum)[keyof typeof WorkspaceAutomationScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    url: 'url',
    events: 'events',
    secret: 'secret',
    isActive: 'isActive',
    lastTriggeredAt: 'lastTriggeredAt',
    failureCount: 'failureCount',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const CustomFieldScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    fieldType: 'fieldType',
    isRequired: 'isRequired',
    options: 'options',
    defaultValue: 'defaultValue',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomFieldScalarFieldEnum = (typeof CustomFieldScalarFieldEnum)[keyof typeof CustomFieldScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    color: 'color',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const AiAgentScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    systemPrompt: 'systemPrompt',
    model: 'model',
    temperature: 'temperature',
    maxTokens: 'maxTokens',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiAgentScalarFieldEnum = (typeof AiAgentScalarFieldEnum)[keyof typeof AiAgentScalarFieldEnum]


  export const AiConversationScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    userId: 'userId',
    title: 'title',
    context: 'context',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiConversationScalarFieldEnum = (typeof AiConversationScalarFieldEnum)[keyof typeof AiConversationScalarFieldEnum]


  export const AiMessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    role: 'role',
    content: 'content',
    tokensUsed: 'tokensUsed',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AiMessageScalarFieldEnum = (typeof AiMessageScalarFieldEnum)[keyof typeof AiMessageScalarFieldEnum]


  export const AiTokenUsageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    provider: 'provider',
    model: 'model',
    tokensUsed: 'tokensUsed',
    cost: 'cost',
    purpose: 'purpose',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AiTokenUsageScalarFieldEnum = (typeof AiTokenUsageScalarFieldEnum)[keyof typeof AiTokenUsageScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isSystem: 'isSystem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    resource: 'resource',
    action: 'action',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const UsageTrackingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    action: 'action',
    quantity: 'quantity',
    metadata: 'metadata',
    timestamp: 'timestamp'
  };

  export type UsageTrackingScalarFieldEnum = (typeof UsageTrackingScalarFieldEnum)[keyof typeof UsageTrackingScalarFieldEnum]


  export const UsageReportScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    reportType: 'reportType',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    totalUploads: 'totalUploads',
    totalMinutes: 'totalMinutes',
    totalStorage: 'totalStorage',
    reportData: 'reportData',
    generatedAt: 'generatedAt'
  };

  export type UsageReportScalarFieldEnum = (typeof UsageReportScalarFieldEnum)[keyof typeof UsageReportScalarFieldEnum]


  export const PaymentGatewayConfigScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    environment: 'environment',
    isActive: 'isActive',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentGatewayConfigScalarFieldEnum = (typeof PaymentGatewayConfigScalarFieldEnum)[keyof typeof PaymentGatewayConfigScalarFieldEnum]


  export const PlanPricingScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    currency: 'currency',
    price: 'price',
    interval: 'interval',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanPricingScalarFieldEnum = (typeof PlanPricingScalarFieldEnum)[keyof typeof PlanPricingScalarFieldEnum]


  export const EwayTransactionScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    customerToken: 'customerToken',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    transactionStatus: 'transactionStatus',
    responseCode: 'responseCode',
    responseMessage: 'responseMessage',
    authCode: 'authCode',
    beagleScore: 'beagleScore',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EwayTransactionScalarFieldEnum = (typeof EwayTransactionScalarFieldEnum)[keyof typeof EwayTransactionScalarFieldEnum]


  export const EwayCustomerScalarFieldEnum: {
    id: 'id',
    customerToken: 'customerToken',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    address: 'address',
    cardNumber: 'cardNumber',
    cardName: 'cardName',
    cardExpiryMonth: 'cardExpiryMonth',
    cardExpiryYear: 'cardExpiryYear',
    isActive: 'isActive',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EwayCustomerScalarFieldEnum = (typeof EwayCustomerScalarFieldEnum)[keyof typeof EwayCustomerScalarFieldEnum]


  export const EwayRecurringScheduleScalarFieldEnum: {
    id: 'id',
    customerToken: 'customerToken',
    interval: 'interval',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    nextPayment: 'nextPayment',
    lastPayment: 'lastPayment',
    paymentCount: 'paymentCount',
    maxPayments: 'maxPayments',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EwayRecurringScheduleScalarFieldEnum = (typeof EwayRecurringScheduleScalarFieldEnum)[keyof typeof EwayRecurringScheduleScalarFieldEnum]


  export const EwayWebhookEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    transactionId: 'transactionId',
    customerToken: 'customerToken',
    payload: 'payload',
    processed: 'processed',
    processedAt: 'processedAt',
    error: 'error',
    retryCount: 'retryCount',
    createdAt: 'createdAt'
  };

  export type EwayWebhookEventScalarFieldEnum = (typeof EwayWebhookEventScalarFieldEnum)[keyof typeof EwayWebhookEventScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    key: 'key',
    value: 'value',
    description: 'description',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const HealthCheckScalarFieldEnum: {
    id: 'id',
    service: 'service',
    status: 'status',
    responseTime: 'responseTime',
    details: 'details',
    checkedAt: 'checkedAt'
  };

  export type HealthCheckScalarFieldEnum = (typeof HealthCheckScalarFieldEnum)[keyof typeof HealthCheckScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    workspaces?: WorkspaceUserListRelationFilter
    audioHistory?: AudioHistoryListRelationFilter
    audioUploads?: AudioUploadListRelationFilter
    apiKeys?: ApiKeyManagementListRelationFilter
    sessions?: SessionListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    settings?: XOR<UserSettingsNullableRelationFilter, UserSettingsWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    securityEvents?: SecurityEventListRelationFilter
    notifications?: NotificationListRelationFilter
    audioSegments?: AudioSegmentListRelationFilter
    emailPreferences?: XOR<EmailPreferenceNullableRelationFilter, EmailPreferenceWhereInput> | null
    quotaUsage?: UserQuotaListRelationFilter
    aiTokenUsage?: AiTokenUsageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    timezone?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaces?: WorkspaceUserOrderByRelationAggregateInput
    audioHistory?: AudioHistoryOrderByRelationAggregateInput
    audioUploads?: AudioUploadOrderByRelationAggregateInput
    apiKeys?: ApiKeyManagementOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    settings?: UserSettingsOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    securityEvents?: SecurityEventOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    audioSegments?: AudioSegmentOrderByRelationAggregateInput
    emailPreferences?: EmailPreferenceOrderByWithRelationInput
    quotaUsage?: UserQuotaOrderByRelationAggregateInput
    aiTokenUsage?: AiTokenUsageOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    workspaces?: WorkspaceUserListRelationFilter
    audioHistory?: AudioHistoryListRelationFilter
    audioUploads?: AudioUploadListRelationFilter
    apiKeys?: ApiKeyManagementListRelationFilter
    sessions?: SessionListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    settings?: XOR<UserSettingsNullableRelationFilter, UserSettingsWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    securityEvents?: SecurityEventListRelationFilter
    notifications?: NotificationListRelationFilter
    audioSegments?: AudioSegmentListRelationFilter
    emailPreferences?: XOR<EmailPreferenceNullableRelationFilter, EmailPreferenceWhereInput> | null
    quotaUsage?: UserQuotaListRelationFilter
    aiTokenUsage?: AiTokenUsageListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    timezone?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringWithAggregatesFilter<"User"> | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    tokenHash?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "tokenHash">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    tokenHash?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
  }

  export type WorkspaceWhereInput = {
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    id?: StringFilter<"Workspace"> | string
    name?: StringFilter<"Workspace"> | string
    slug?: StringFilter<"Workspace"> | string
    description?: StringNullableFilter<"Workspace"> | string | null
    logo?: StringNullableFilter<"Workspace"> | string | null
    website?: StringNullableFilter<"Workspace"> | string | null
    industry?: StringNullableFilter<"Workspace"> | string | null
    size?: StringNullableFilter<"Workspace"> | string | null
    isActive?: BoolFilter<"Workspace"> | boolean
    settings?: JsonFilter<"Workspace">
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    users?: WorkspaceUserListRelationFilter
    invitations?: WorkspaceInvitationListRelationFilter
    audioHistory?: AudioHistoryListRelationFilter
    audioUploads?: AudioUploadListRelationFilter
    subscriptions?: WorkspaceSubscriptionListRelationFilter
    storageQuotas?: StorageQuotaListRelationFilter
    integrations?: IntegrationListRelationFilter
    automations?: WorkspaceAutomationListRelationFilter
    webhooks?: WebhookListRelationFilter
    customFields?: CustomFieldListRelationFilter
    tags?: TagListRelationFilter
    aiAgents?: AiAgentListRelationFilter
  }

  export type WorkspaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    isActive?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: WorkspaceUserOrderByRelationAggregateInput
    invitations?: WorkspaceInvitationOrderByRelationAggregateInput
    audioHistory?: AudioHistoryOrderByRelationAggregateInput
    audioUploads?: AudioUploadOrderByRelationAggregateInput
    subscriptions?: WorkspaceSubscriptionOrderByRelationAggregateInput
    storageQuotas?: StorageQuotaOrderByRelationAggregateInput
    integrations?: IntegrationOrderByRelationAggregateInput
    automations?: WorkspaceAutomationOrderByRelationAggregateInput
    webhooks?: WebhookOrderByRelationAggregateInput
    customFields?: CustomFieldOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    aiAgents?: AiAgentOrderByRelationAggregateInput
  }

  export type WorkspaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    name?: StringFilter<"Workspace"> | string
    description?: StringNullableFilter<"Workspace"> | string | null
    logo?: StringNullableFilter<"Workspace"> | string | null
    website?: StringNullableFilter<"Workspace"> | string | null
    industry?: StringNullableFilter<"Workspace"> | string | null
    size?: StringNullableFilter<"Workspace"> | string | null
    isActive?: BoolFilter<"Workspace"> | boolean
    settings?: JsonFilter<"Workspace">
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    users?: WorkspaceUserListRelationFilter
    invitations?: WorkspaceInvitationListRelationFilter
    audioHistory?: AudioHistoryListRelationFilter
    audioUploads?: AudioUploadListRelationFilter
    subscriptions?: WorkspaceSubscriptionListRelationFilter
    storageQuotas?: StorageQuotaListRelationFilter
    integrations?: IntegrationListRelationFilter
    automations?: WorkspaceAutomationListRelationFilter
    webhooks?: WebhookListRelationFilter
    customFields?: CustomFieldListRelationFilter
    tags?: TagListRelationFilter
    aiAgents?: AiAgentListRelationFilter
  }, "id" | "slug">

  export type WorkspaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    isActive?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceCountOrderByAggregateInput
    _max?: WorkspaceMaxOrderByAggregateInput
    _min?: WorkspaceMinOrderByAggregateInput
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    OR?: WorkspaceScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workspace"> | string
    name?: StringWithAggregatesFilter<"Workspace"> | string
    slug?: StringWithAggregatesFilter<"Workspace"> | string
    description?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    website?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    industry?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    size?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    isActive?: BoolWithAggregatesFilter<"Workspace"> | boolean
    settings?: JsonWithAggregatesFilter<"Workspace">
    createdAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
  }

  export type WorkspaceUserWhereInput = {
    AND?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    OR?: WorkspaceUserWhereInput[]
    NOT?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    id?: StringFilter<"WorkspaceUser"> | string
    workspaceId?: StringFilter<"WorkspaceUser"> | string
    userId?: StringFilter<"WorkspaceUser"> | string
    role?: StringFilter<"WorkspaceUser"> | string
    permissions?: JsonFilter<"WorkspaceUser">
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    lastActiveAt?: DateTimeNullableFilter<"WorkspaceUser"> | Date | string | null
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WorkspaceUserOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type WorkspaceUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_userId?: WorkspaceUserWorkspaceIdUserIdCompoundUniqueInput
    AND?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    OR?: WorkspaceUserWhereInput[]
    NOT?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    workspaceId?: StringFilter<"WorkspaceUser"> | string
    userId?: StringFilter<"WorkspaceUser"> | string
    role?: StringFilter<"WorkspaceUser"> | string
    permissions?: JsonFilter<"WorkspaceUser">
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    lastActiveAt?: DateTimeNullableFilter<"WorkspaceUser"> | Date | string | null
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "workspaceId_userId">

  export type WorkspaceUserOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    _count?: WorkspaceUserCountOrderByAggregateInput
    _max?: WorkspaceUserMaxOrderByAggregateInput
    _min?: WorkspaceUserMinOrderByAggregateInput
  }

  export type WorkspaceUserScalarWhereWithAggregatesInput = {
    AND?: WorkspaceUserScalarWhereWithAggregatesInput | WorkspaceUserScalarWhereWithAggregatesInput[]
    OR?: WorkspaceUserScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceUserScalarWhereWithAggregatesInput | WorkspaceUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    userId?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    role?: StringWithAggregatesFilter<"WorkspaceUser"> | string
    permissions?: JsonWithAggregatesFilter<"WorkspaceUser">
    joinedAt?: DateTimeWithAggregatesFilter<"WorkspaceUser"> | Date | string
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"WorkspaceUser"> | Date | string | null
  }

  export type WorkspaceInvitationWhereInput = {
    AND?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    OR?: WorkspaceInvitationWhereInput[]
    NOT?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    id?: StringFilter<"WorkspaceInvitation"> | string
    workspaceId?: StringFilter<"WorkspaceInvitation"> | string
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: StringFilter<"WorkspaceInvitation"> | string
    token?: StringFilter<"WorkspaceInvitation"> | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"WorkspaceInvitation"> | Date | string | null
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type WorkspaceInvitationOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type WorkspaceInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    OR?: WorkspaceInvitationWhereInput[]
    NOT?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    workspaceId?: StringFilter<"WorkspaceInvitation"> | string
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: StringFilter<"WorkspaceInvitation"> | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"WorkspaceInvitation"> | Date | string | null
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id" | "token">

  export type WorkspaceInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    _count?: WorkspaceInvitationCountOrderByAggregateInput
    _max?: WorkspaceInvitationMaxOrderByAggregateInput
    _min?: WorkspaceInvitationMinOrderByAggregateInput
  }

  export type WorkspaceInvitationScalarWhereWithAggregatesInput = {
    AND?: WorkspaceInvitationScalarWhereWithAggregatesInput | WorkspaceInvitationScalarWhereWithAggregatesInput[]
    OR?: WorkspaceInvitationScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceInvitationScalarWhereWithAggregatesInput | WorkspaceInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    email?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    role?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    token?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"WorkspaceInvitation"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"WorkspaceInvitation"> | Date | string | null
  }

  export type AudioUploadWhereInput = {
    AND?: AudioUploadWhereInput | AudioUploadWhereInput[]
    OR?: AudioUploadWhereInput[]
    NOT?: AudioUploadWhereInput | AudioUploadWhereInput[]
    id?: StringFilter<"AudioUpload"> | string
    userId?: StringFilter<"AudioUpload"> | string
    workspaceId?: StringFilter<"AudioUpload"> | string
    originalFileName?: StringFilter<"AudioUpload"> | string
    fileSize?: BigIntFilter<"AudioUpload"> | bigint | number
    mimeType?: StringFilter<"AudioUpload"> | string
    uploadStatus?: StringFilter<"AudioUpload"> | string
    uploadProgress?: FloatFilter<"AudioUpload"> | number
    storageProvider?: StringFilter<"AudioUpload"> | string
    storagePath?: StringNullableFilter<"AudioUpload"> | string | null
    storageUrl?: StringNullableFilter<"AudioUpload"> | string | null
    cdnUrl?: StringNullableFilter<"AudioUpload"> | string | null
    metadata?: JsonFilter<"AudioUpload">
    createdAt?: DateTimeFilter<"AudioUpload"> | Date | string
    updatedAt?: DateTimeFilter<"AudioUpload"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    processingJobs?: ProcessingJobListRelationFilter
    audioChunks?: AudioChunkListRelationFilter
    fileStorage?: XOR<FileStorageNullableRelationFilter, FileStorageWhereInput> | null
  }

  export type AudioUploadOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    originalFileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadStatus?: SortOrder
    uploadProgress?: SortOrder
    storageProvider?: SortOrder
    storagePath?: SortOrderInput | SortOrder
    storageUrl?: SortOrderInput | SortOrder
    cdnUrl?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    processingJobs?: ProcessingJobOrderByRelationAggregateInput
    audioChunks?: AudioChunkOrderByRelationAggregateInput
    fileStorage?: FileStorageOrderByWithRelationInput
  }

  export type AudioUploadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AudioUploadWhereInput | AudioUploadWhereInput[]
    OR?: AudioUploadWhereInput[]
    NOT?: AudioUploadWhereInput | AudioUploadWhereInput[]
    userId?: StringFilter<"AudioUpload"> | string
    workspaceId?: StringFilter<"AudioUpload"> | string
    originalFileName?: StringFilter<"AudioUpload"> | string
    fileSize?: BigIntFilter<"AudioUpload"> | bigint | number
    mimeType?: StringFilter<"AudioUpload"> | string
    uploadStatus?: StringFilter<"AudioUpload"> | string
    uploadProgress?: FloatFilter<"AudioUpload"> | number
    storageProvider?: StringFilter<"AudioUpload"> | string
    storagePath?: StringNullableFilter<"AudioUpload"> | string | null
    storageUrl?: StringNullableFilter<"AudioUpload"> | string | null
    cdnUrl?: StringNullableFilter<"AudioUpload"> | string | null
    metadata?: JsonFilter<"AudioUpload">
    createdAt?: DateTimeFilter<"AudioUpload"> | Date | string
    updatedAt?: DateTimeFilter<"AudioUpload"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    processingJobs?: ProcessingJobListRelationFilter
    audioChunks?: AudioChunkListRelationFilter
    fileStorage?: XOR<FileStorageNullableRelationFilter, FileStorageWhereInput> | null
  }, "id">

  export type AudioUploadOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    originalFileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadStatus?: SortOrder
    uploadProgress?: SortOrder
    storageProvider?: SortOrder
    storagePath?: SortOrderInput | SortOrder
    storageUrl?: SortOrderInput | SortOrder
    cdnUrl?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AudioUploadCountOrderByAggregateInput
    _avg?: AudioUploadAvgOrderByAggregateInput
    _max?: AudioUploadMaxOrderByAggregateInput
    _min?: AudioUploadMinOrderByAggregateInput
    _sum?: AudioUploadSumOrderByAggregateInput
  }

  export type AudioUploadScalarWhereWithAggregatesInput = {
    AND?: AudioUploadScalarWhereWithAggregatesInput | AudioUploadScalarWhereWithAggregatesInput[]
    OR?: AudioUploadScalarWhereWithAggregatesInput[]
    NOT?: AudioUploadScalarWhereWithAggregatesInput | AudioUploadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioUpload"> | string
    userId?: StringWithAggregatesFilter<"AudioUpload"> | string
    workspaceId?: StringWithAggregatesFilter<"AudioUpload"> | string
    originalFileName?: StringWithAggregatesFilter<"AudioUpload"> | string
    fileSize?: BigIntWithAggregatesFilter<"AudioUpload"> | bigint | number
    mimeType?: StringWithAggregatesFilter<"AudioUpload"> | string
    uploadStatus?: StringWithAggregatesFilter<"AudioUpload"> | string
    uploadProgress?: FloatWithAggregatesFilter<"AudioUpload"> | number
    storageProvider?: StringWithAggregatesFilter<"AudioUpload"> | string
    storagePath?: StringNullableWithAggregatesFilter<"AudioUpload"> | string | null
    storageUrl?: StringNullableWithAggregatesFilter<"AudioUpload"> | string | null
    cdnUrl?: StringNullableWithAggregatesFilter<"AudioUpload"> | string | null
    metadata?: JsonWithAggregatesFilter<"AudioUpload">
    createdAt?: DateTimeWithAggregatesFilter<"AudioUpload"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AudioUpload"> | Date | string
  }

  export type ProcessingJobWhereInput = {
    AND?: ProcessingJobWhereInput | ProcessingJobWhereInput[]
    OR?: ProcessingJobWhereInput[]
    NOT?: ProcessingJobWhereInput | ProcessingJobWhereInput[]
    id?: StringFilter<"ProcessingJob"> | string
    uploadId?: StringFilter<"ProcessingJob"> | string
    jobType?: StringFilter<"ProcessingJob"> | string
    status?: StringFilter<"ProcessingJob"> | string
    priority?: IntFilter<"ProcessingJob"> | number
    progress?: FloatFilter<"ProcessingJob"> | number
    startedAt?: DateTimeNullableFilter<"ProcessingJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProcessingJob"> | Date | string | null
    error?: StringNullableFilter<"ProcessingJob"> | string | null
    result?: JsonNullableFilter<"ProcessingJob">
    metadata?: JsonFilter<"ProcessingJob">
    createdAt?: DateTimeFilter<"ProcessingJob"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessingJob"> | Date | string
    upload?: XOR<AudioUploadRelationFilter, AudioUploadWhereInput>
    audioHistory?: XOR<AudioHistoryNullableRelationFilter, AudioHistoryWhereInput> | null
  }

  export type ProcessingJobOrderByWithRelationInput = {
    id?: SortOrder
    uploadId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    upload?: AudioUploadOrderByWithRelationInput
    audioHistory?: AudioHistoryOrderByWithRelationInput
  }

  export type ProcessingJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessingJobWhereInput | ProcessingJobWhereInput[]
    OR?: ProcessingJobWhereInput[]
    NOT?: ProcessingJobWhereInput | ProcessingJobWhereInput[]
    uploadId?: StringFilter<"ProcessingJob"> | string
    jobType?: StringFilter<"ProcessingJob"> | string
    status?: StringFilter<"ProcessingJob"> | string
    priority?: IntFilter<"ProcessingJob"> | number
    progress?: FloatFilter<"ProcessingJob"> | number
    startedAt?: DateTimeNullableFilter<"ProcessingJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProcessingJob"> | Date | string | null
    error?: StringNullableFilter<"ProcessingJob"> | string | null
    result?: JsonNullableFilter<"ProcessingJob">
    metadata?: JsonFilter<"ProcessingJob">
    createdAt?: DateTimeFilter<"ProcessingJob"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessingJob"> | Date | string
    upload?: XOR<AudioUploadRelationFilter, AudioUploadWhereInput>
    audioHistory?: XOR<AudioHistoryNullableRelationFilter, AudioHistoryWhereInput> | null
  }, "id">

  export type ProcessingJobOrderByWithAggregationInput = {
    id?: SortOrder
    uploadId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProcessingJobCountOrderByAggregateInput
    _avg?: ProcessingJobAvgOrderByAggregateInput
    _max?: ProcessingJobMaxOrderByAggregateInput
    _min?: ProcessingJobMinOrderByAggregateInput
    _sum?: ProcessingJobSumOrderByAggregateInput
  }

  export type ProcessingJobScalarWhereWithAggregatesInput = {
    AND?: ProcessingJobScalarWhereWithAggregatesInput | ProcessingJobScalarWhereWithAggregatesInput[]
    OR?: ProcessingJobScalarWhereWithAggregatesInput[]
    NOT?: ProcessingJobScalarWhereWithAggregatesInput | ProcessingJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProcessingJob"> | string
    uploadId?: StringWithAggregatesFilter<"ProcessingJob"> | string
    jobType?: StringWithAggregatesFilter<"ProcessingJob"> | string
    status?: StringWithAggregatesFilter<"ProcessingJob"> | string
    priority?: IntWithAggregatesFilter<"ProcessingJob"> | number
    progress?: FloatWithAggregatesFilter<"ProcessingJob"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"ProcessingJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ProcessingJob"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"ProcessingJob"> | string | null
    result?: JsonNullableWithAggregatesFilter<"ProcessingJob">
    metadata?: JsonWithAggregatesFilter<"ProcessingJob">
    createdAt?: DateTimeWithAggregatesFilter<"ProcessingJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProcessingJob"> | Date | string
  }

  export type AudioHistoryWhereInput = {
    AND?: AudioHistoryWhereInput | AudioHistoryWhereInput[]
    OR?: AudioHistoryWhereInput[]
    NOT?: AudioHistoryWhereInput | AudioHistoryWhereInput[]
    id?: StringFilter<"AudioHistory"> | string
    userId?: StringFilter<"AudioHistory"> | string
    workspaceId?: StringNullableFilter<"AudioHistory"> | string | null
    processingJobId?: StringNullableFilter<"AudioHistory"> | string | null
    title?: StringNullableFilter<"AudioHistory"> | string | null
    audioUrl?: StringNullableFilter<"AudioHistory"> | string | null
    fileSizeBytes?: BigIntNullableFilter<"AudioHistory"> | bigint | number | null
    durationSeconds?: IntNullableFilter<"AudioHistory"> | number | null
    transcript?: StringNullableFilter<"AudioHistory"> | string | null
    summary?: StringNullableFilter<"AudioHistory"> | string | null
    keyMoments?: JsonNullableFilter<"AudioHistory">
    processingOptions?: JsonNullableFilter<"AudioHistory">
    language?: StringNullableFilter<"AudioHistory"> | string | null
    confidence?: FloatNullableFilter<"AudioHistory"> | number | null
    speakers?: IntNullableFilter<"AudioHistory"> | number | null
    tags?: StringNullableListFilter<"AudioHistory">
    createdAt?: DateTimeFilter<"AudioHistory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
    processingJob?: XOR<ProcessingJobNullableRelationFilter, ProcessingJobWhereInput> | null
    segments?: AudioSegmentListRelationFilter
  }

  export type AudioHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    processingJobId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    fileSizeBytes?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    keyMoments?: SortOrderInput | SortOrder
    processingOptions?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    speakers?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    processingJob?: ProcessingJobOrderByWithRelationInput
    segments?: AudioSegmentOrderByRelationAggregateInput
  }

  export type AudioHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    processingJobId?: string
    AND?: AudioHistoryWhereInput | AudioHistoryWhereInput[]
    OR?: AudioHistoryWhereInput[]
    NOT?: AudioHistoryWhereInput | AudioHistoryWhereInput[]
    userId?: StringFilter<"AudioHistory"> | string
    workspaceId?: StringNullableFilter<"AudioHistory"> | string | null
    title?: StringNullableFilter<"AudioHistory"> | string | null
    audioUrl?: StringNullableFilter<"AudioHistory"> | string | null
    fileSizeBytes?: BigIntNullableFilter<"AudioHistory"> | bigint | number | null
    durationSeconds?: IntNullableFilter<"AudioHistory"> | number | null
    transcript?: StringNullableFilter<"AudioHistory"> | string | null
    summary?: StringNullableFilter<"AudioHistory"> | string | null
    keyMoments?: JsonNullableFilter<"AudioHistory">
    processingOptions?: JsonNullableFilter<"AudioHistory">
    language?: StringNullableFilter<"AudioHistory"> | string | null
    confidence?: FloatNullableFilter<"AudioHistory"> | number | null
    speakers?: IntNullableFilter<"AudioHistory"> | number | null
    tags?: StringNullableListFilter<"AudioHistory">
    createdAt?: DateTimeFilter<"AudioHistory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
    processingJob?: XOR<ProcessingJobNullableRelationFilter, ProcessingJobWhereInput> | null
    segments?: AudioSegmentListRelationFilter
  }, "id" | "processingJobId">

  export type AudioHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    processingJobId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    fileSizeBytes?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    keyMoments?: SortOrderInput | SortOrder
    processingOptions?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    speakers?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    _count?: AudioHistoryCountOrderByAggregateInput
    _avg?: AudioHistoryAvgOrderByAggregateInput
    _max?: AudioHistoryMaxOrderByAggregateInput
    _min?: AudioHistoryMinOrderByAggregateInput
    _sum?: AudioHistorySumOrderByAggregateInput
  }

  export type AudioHistoryScalarWhereWithAggregatesInput = {
    AND?: AudioHistoryScalarWhereWithAggregatesInput | AudioHistoryScalarWhereWithAggregatesInput[]
    OR?: AudioHistoryScalarWhereWithAggregatesInput[]
    NOT?: AudioHistoryScalarWhereWithAggregatesInput | AudioHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioHistory"> | string
    userId?: StringWithAggregatesFilter<"AudioHistory"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    processingJobId?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    title?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    audioUrl?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    fileSizeBytes?: BigIntNullableWithAggregatesFilter<"AudioHistory"> | bigint | number | null
    durationSeconds?: IntNullableWithAggregatesFilter<"AudioHistory"> | number | null
    transcript?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    summary?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    keyMoments?: JsonNullableWithAggregatesFilter<"AudioHistory">
    processingOptions?: JsonNullableWithAggregatesFilter<"AudioHistory">
    language?: StringNullableWithAggregatesFilter<"AudioHistory"> | string | null
    confidence?: FloatNullableWithAggregatesFilter<"AudioHistory"> | number | null
    speakers?: IntNullableWithAggregatesFilter<"AudioHistory"> | number | null
    tags?: StringNullableListFilter<"AudioHistory">
    createdAt?: DateTimeWithAggregatesFilter<"AudioHistory"> | Date | string
  }

  export type AudioSegmentWhereInput = {
    AND?: AudioSegmentWhereInput | AudioSegmentWhereInput[]
    OR?: AudioSegmentWhereInput[]
    NOT?: AudioSegmentWhereInput | AudioSegmentWhereInput[]
    id?: StringFilter<"AudioSegment"> | string
    audioHistoryId?: StringFilter<"AudioSegment"> | string
    userId?: StringFilter<"AudioSegment"> | string
    startTime?: FloatFilter<"AudioSegment"> | number
    endTime?: FloatFilter<"AudioSegment"> | number
    text?: StringFilter<"AudioSegment"> | string
    speaker?: StringNullableFilter<"AudioSegment"> | string | null
    confidence?: FloatNullableFilter<"AudioSegment"> | number | null
    keywords?: StringNullableListFilter<"AudioSegment">
    sentiment?: StringNullableFilter<"AudioSegment"> | string | null
    metadata?: JsonFilter<"AudioSegment">
    createdAt?: DateTimeFilter<"AudioSegment"> | Date | string
    audioHistory?: XOR<AudioHistoryRelationFilter, AudioHistoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AudioSegmentOrderByWithRelationInput = {
    id?: SortOrder
    audioHistoryId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    text?: SortOrder
    speaker?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    keywords?: SortOrder
    sentiment?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    audioHistory?: AudioHistoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AudioSegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AudioSegmentWhereInput | AudioSegmentWhereInput[]
    OR?: AudioSegmentWhereInput[]
    NOT?: AudioSegmentWhereInput | AudioSegmentWhereInput[]
    audioHistoryId?: StringFilter<"AudioSegment"> | string
    userId?: StringFilter<"AudioSegment"> | string
    startTime?: FloatFilter<"AudioSegment"> | number
    endTime?: FloatFilter<"AudioSegment"> | number
    text?: StringFilter<"AudioSegment"> | string
    speaker?: StringNullableFilter<"AudioSegment"> | string | null
    confidence?: FloatNullableFilter<"AudioSegment"> | number | null
    keywords?: StringNullableListFilter<"AudioSegment">
    sentiment?: StringNullableFilter<"AudioSegment"> | string | null
    metadata?: JsonFilter<"AudioSegment">
    createdAt?: DateTimeFilter<"AudioSegment"> | Date | string
    audioHistory?: XOR<AudioHistoryRelationFilter, AudioHistoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AudioSegmentOrderByWithAggregationInput = {
    id?: SortOrder
    audioHistoryId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    text?: SortOrder
    speaker?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    keywords?: SortOrder
    sentiment?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: AudioSegmentCountOrderByAggregateInput
    _avg?: AudioSegmentAvgOrderByAggregateInput
    _max?: AudioSegmentMaxOrderByAggregateInput
    _min?: AudioSegmentMinOrderByAggregateInput
    _sum?: AudioSegmentSumOrderByAggregateInput
  }

  export type AudioSegmentScalarWhereWithAggregatesInput = {
    AND?: AudioSegmentScalarWhereWithAggregatesInput | AudioSegmentScalarWhereWithAggregatesInput[]
    OR?: AudioSegmentScalarWhereWithAggregatesInput[]
    NOT?: AudioSegmentScalarWhereWithAggregatesInput | AudioSegmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioSegment"> | string
    audioHistoryId?: StringWithAggregatesFilter<"AudioSegment"> | string
    userId?: StringWithAggregatesFilter<"AudioSegment"> | string
    startTime?: FloatWithAggregatesFilter<"AudioSegment"> | number
    endTime?: FloatWithAggregatesFilter<"AudioSegment"> | number
    text?: StringWithAggregatesFilter<"AudioSegment"> | string
    speaker?: StringNullableWithAggregatesFilter<"AudioSegment"> | string | null
    confidence?: FloatNullableWithAggregatesFilter<"AudioSegment"> | number | null
    keywords?: StringNullableListFilter<"AudioSegment">
    sentiment?: StringNullableWithAggregatesFilter<"AudioSegment"> | string | null
    metadata?: JsonWithAggregatesFilter<"AudioSegment">
    createdAt?: DateTimeWithAggregatesFilter<"AudioSegment"> | Date | string
  }

  export type AudioChunkWhereInput = {
    AND?: AudioChunkWhereInput | AudioChunkWhereInput[]
    OR?: AudioChunkWhereInput[]
    NOT?: AudioChunkWhereInput | AudioChunkWhereInput[]
    id?: StringFilter<"AudioChunk"> | string
    uploadId?: StringFilter<"AudioChunk"> | string
    chunkIndex?: IntFilter<"AudioChunk"> | number
    startByte?: BigIntFilter<"AudioChunk"> | bigint | number
    endByte?: BigIntFilter<"AudioChunk"> | bigint | number
    size?: BigIntFilter<"AudioChunk"> | bigint | number
    storageKey?: StringFilter<"AudioChunk"> | string
    checksum?: StringFilter<"AudioChunk"> | string
    uploadedAt?: DateTimeNullableFilter<"AudioChunk"> | Date | string | null
    createdAt?: DateTimeFilter<"AudioChunk"> | Date | string
    upload?: XOR<AudioUploadRelationFilter, AudioUploadWhereInput>
  }

  export type AudioChunkOrderByWithRelationInput = {
    id?: SortOrder
    uploadId?: SortOrder
    chunkIndex?: SortOrder
    startByte?: SortOrder
    endByte?: SortOrder
    size?: SortOrder
    storageKey?: SortOrder
    checksum?: SortOrder
    uploadedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    upload?: AudioUploadOrderByWithRelationInput
  }

  export type AudioChunkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uploadId_chunkIndex?: AudioChunkUploadIdChunkIndexCompoundUniqueInput
    AND?: AudioChunkWhereInput | AudioChunkWhereInput[]
    OR?: AudioChunkWhereInput[]
    NOT?: AudioChunkWhereInput | AudioChunkWhereInput[]
    uploadId?: StringFilter<"AudioChunk"> | string
    chunkIndex?: IntFilter<"AudioChunk"> | number
    startByte?: BigIntFilter<"AudioChunk"> | bigint | number
    endByte?: BigIntFilter<"AudioChunk"> | bigint | number
    size?: BigIntFilter<"AudioChunk"> | bigint | number
    storageKey?: StringFilter<"AudioChunk"> | string
    checksum?: StringFilter<"AudioChunk"> | string
    uploadedAt?: DateTimeNullableFilter<"AudioChunk"> | Date | string | null
    createdAt?: DateTimeFilter<"AudioChunk"> | Date | string
    upload?: XOR<AudioUploadRelationFilter, AudioUploadWhereInput>
  }, "id" | "uploadId_chunkIndex">

  export type AudioChunkOrderByWithAggregationInput = {
    id?: SortOrder
    uploadId?: SortOrder
    chunkIndex?: SortOrder
    startByte?: SortOrder
    endByte?: SortOrder
    size?: SortOrder
    storageKey?: SortOrder
    checksum?: SortOrder
    uploadedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AudioChunkCountOrderByAggregateInput
    _avg?: AudioChunkAvgOrderByAggregateInput
    _max?: AudioChunkMaxOrderByAggregateInput
    _min?: AudioChunkMinOrderByAggregateInput
    _sum?: AudioChunkSumOrderByAggregateInput
  }

  export type AudioChunkScalarWhereWithAggregatesInput = {
    AND?: AudioChunkScalarWhereWithAggregatesInput | AudioChunkScalarWhereWithAggregatesInput[]
    OR?: AudioChunkScalarWhereWithAggregatesInput[]
    NOT?: AudioChunkScalarWhereWithAggregatesInput | AudioChunkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioChunk"> | string
    uploadId?: StringWithAggregatesFilter<"AudioChunk"> | string
    chunkIndex?: IntWithAggregatesFilter<"AudioChunk"> | number
    startByte?: BigIntWithAggregatesFilter<"AudioChunk"> | bigint | number
    endByte?: BigIntWithAggregatesFilter<"AudioChunk"> | bigint | number
    size?: BigIntWithAggregatesFilter<"AudioChunk"> | bigint | number
    storageKey?: StringWithAggregatesFilter<"AudioChunk"> | string
    checksum?: StringWithAggregatesFilter<"AudioChunk"> | string
    uploadedAt?: DateTimeNullableWithAggregatesFilter<"AudioChunk"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AudioChunk"> | Date | string
  }

  export type StorageProviderWhereInput = {
    AND?: StorageProviderWhereInput | StorageProviderWhereInput[]
    OR?: StorageProviderWhereInput[]
    NOT?: StorageProviderWhereInput | StorageProviderWhereInput[]
    id?: StringFilter<"StorageProvider"> | string
    name?: StringFilter<"StorageProvider"> | string
    type?: StringFilter<"StorageProvider"> | string
    endpoint?: StringNullableFilter<"StorageProvider"> | string | null
    region?: StringNullableFilter<"StorageProvider"> | string | null
    bucket?: StringNullableFilter<"StorageProvider"> | string | null
    cdnEndpoint?: StringNullableFilter<"StorageProvider"> | string | null
    isActive?: BoolFilter<"StorageProvider"> | boolean
    isDefault?: BoolFilter<"StorageProvider"> | boolean
    config?: JsonFilter<"StorageProvider">
    createdAt?: DateTimeFilter<"StorageProvider"> | Date | string
    updatedAt?: DateTimeFilter<"StorageProvider"> | Date | string
    files?: FileStorageListRelationFilter
  }

  export type StorageProviderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    endpoint?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    bucket?: SortOrderInput | SortOrder
    cdnEndpoint?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    files?: FileStorageOrderByRelationAggregateInput
  }

  export type StorageProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: StorageProviderWhereInput | StorageProviderWhereInput[]
    OR?: StorageProviderWhereInput[]
    NOT?: StorageProviderWhereInput | StorageProviderWhereInput[]
    type?: StringFilter<"StorageProvider"> | string
    endpoint?: StringNullableFilter<"StorageProvider"> | string | null
    region?: StringNullableFilter<"StorageProvider"> | string | null
    bucket?: StringNullableFilter<"StorageProvider"> | string | null
    cdnEndpoint?: StringNullableFilter<"StorageProvider"> | string | null
    isActive?: BoolFilter<"StorageProvider"> | boolean
    isDefault?: BoolFilter<"StorageProvider"> | boolean
    config?: JsonFilter<"StorageProvider">
    createdAt?: DateTimeFilter<"StorageProvider"> | Date | string
    updatedAt?: DateTimeFilter<"StorageProvider"> | Date | string
    files?: FileStorageListRelationFilter
  }, "id" | "name">

  export type StorageProviderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    endpoint?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    bucket?: SortOrderInput | SortOrder
    cdnEndpoint?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StorageProviderCountOrderByAggregateInput
    _max?: StorageProviderMaxOrderByAggregateInput
    _min?: StorageProviderMinOrderByAggregateInput
  }

  export type StorageProviderScalarWhereWithAggregatesInput = {
    AND?: StorageProviderScalarWhereWithAggregatesInput | StorageProviderScalarWhereWithAggregatesInput[]
    OR?: StorageProviderScalarWhereWithAggregatesInput[]
    NOT?: StorageProviderScalarWhereWithAggregatesInput | StorageProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StorageProvider"> | string
    name?: StringWithAggregatesFilter<"StorageProvider"> | string
    type?: StringWithAggregatesFilter<"StorageProvider"> | string
    endpoint?: StringNullableWithAggregatesFilter<"StorageProvider"> | string | null
    region?: StringNullableWithAggregatesFilter<"StorageProvider"> | string | null
    bucket?: StringNullableWithAggregatesFilter<"StorageProvider"> | string | null
    cdnEndpoint?: StringNullableWithAggregatesFilter<"StorageProvider"> | string | null
    isActive?: BoolWithAggregatesFilter<"StorageProvider"> | boolean
    isDefault?: BoolWithAggregatesFilter<"StorageProvider"> | boolean
    config?: JsonWithAggregatesFilter<"StorageProvider">
    createdAt?: DateTimeWithAggregatesFilter<"StorageProvider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StorageProvider"> | Date | string
  }

  export type FileStorageWhereInput = {
    AND?: FileStorageWhereInput | FileStorageWhereInput[]
    OR?: FileStorageWhereInput[]
    NOT?: FileStorageWhereInput | FileStorageWhereInput[]
    id?: StringFilter<"FileStorage"> | string
    uploadId?: StringFilter<"FileStorage"> | string
    providerId?: StringFilter<"FileStorage"> | string
    storageKey?: StringFilter<"FileStorage"> | string
    fileName?: StringFilter<"FileStorage"> | string
    fileSize?: BigIntFilter<"FileStorage"> | bigint | number
    mimeType?: StringFilter<"FileStorage"> | string
    checksum?: StringFilter<"FileStorage"> | string
    publicUrl?: StringNullableFilter<"FileStorage"> | string | null
    cdnUrl?: StringNullableFilter<"FileStorage"> | string | null
    expiresAt?: DateTimeNullableFilter<"FileStorage"> | Date | string | null
    metadata?: JsonFilter<"FileStorage">
    createdAt?: DateTimeFilter<"FileStorage"> | Date | string
    lastAccessedAt?: DateTimeNullableFilter<"FileStorage"> | Date | string | null
    provider?: XOR<StorageProviderRelationFilter, StorageProviderWhereInput>
    upload?: XOR<AudioUploadRelationFilter, AudioUploadWhereInput>
  }

  export type FileStorageOrderByWithRelationInput = {
    id?: SortOrder
    uploadId?: SortOrder
    providerId?: SortOrder
    storageKey?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    checksum?: SortOrder
    publicUrl?: SortOrderInput | SortOrder
    cdnUrl?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    lastAccessedAt?: SortOrderInput | SortOrder
    provider?: StorageProviderOrderByWithRelationInput
    upload?: AudioUploadOrderByWithRelationInput
  }

  export type FileStorageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uploadId?: string
    storageKey?: string
    AND?: FileStorageWhereInput | FileStorageWhereInput[]
    OR?: FileStorageWhereInput[]
    NOT?: FileStorageWhereInput | FileStorageWhereInput[]
    providerId?: StringFilter<"FileStorage"> | string
    fileName?: StringFilter<"FileStorage"> | string
    fileSize?: BigIntFilter<"FileStorage"> | bigint | number
    mimeType?: StringFilter<"FileStorage"> | string
    checksum?: StringFilter<"FileStorage"> | string
    publicUrl?: StringNullableFilter<"FileStorage"> | string | null
    cdnUrl?: StringNullableFilter<"FileStorage"> | string | null
    expiresAt?: DateTimeNullableFilter<"FileStorage"> | Date | string | null
    metadata?: JsonFilter<"FileStorage">
    createdAt?: DateTimeFilter<"FileStorage"> | Date | string
    lastAccessedAt?: DateTimeNullableFilter<"FileStorage"> | Date | string | null
    provider?: XOR<StorageProviderRelationFilter, StorageProviderWhereInput>
    upload?: XOR<AudioUploadRelationFilter, AudioUploadWhereInput>
  }, "id" | "uploadId" | "storageKey">

  export type FileStorageOrderByWithAggregationInput = {
    id?: SortOrder
    uploadId?: SortOrder
    providerId?: SortOrder
    storageKey?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    checksum?: SortOrder
    publicUrl?: SortOrderInput | SortOrder
    cdnUrl?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    lastAccessedAt?: SortOrderInput | SortOrder
    _count?: FileStorageCountOrderByAggregateInput
    _avg?: FileStorageAvgOrderByAggregateInput
    _max?: FileStorageMaxOrderByAggregateInput
    _min?: FileStorageMinOrderByAggregateInput
    _sum?: FileStorageSumOrderByAggregateInput
  }

  export type FileStorageScalarWhereWithAggregatesInput = {
    AND?: FileStorageScalarWhereWithAggregatesInput | FileStorageScalarWhereWithAggregatesInput[]
    OR?: FileStorageScalarWhereWithAggregatesInput[]
    NOT?: FileStorageScalarWhereWithAggregatesInput | FileStorageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileStorage"> | string
    uploadId?: StringWithAggregatesFilter<"FileStorage"> | string
    providerId?: StringWithAggregatesFilter<"FileStorage"> | string
    storageKey?: StringWithAggregatesFilter<"FileStorage"> | string
    fileName?: StringWithAggregatesFilter<"FileStorage"> | string
    fileSize?: BigIntWithAggregatesFilter<"FileStorage"> | bigint | number
    mimeType?: StringWithAggregatesFilter<"FileStorage"> | string
    checksum?: StringWithAggregatesFilter<"FileStorage"> | string
    publicUrl?: StringNullableWithAggregatesFilter<"FileStorage"> | string | null
    cdnUrl?: StringNullableWithAggregatesFilter<"FileStorage"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"FileStorage"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"FileStorage">
    createdAt?: DateTimeWithAggregatesFilter<"FileStorage"> | Date | string
    lastAccessedAt?: DateTimeNullableWithAggregatesFilter<"FileStorage"> | Date | string | null
  }

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    id?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    displayName?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    tier?: StringFilter<"SubscriptionPlan"> | string
    price?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    billingPeriod?: StringFilter<"SubscriptionPlan"> | string
    features?: JsonFilter<"SubscriptionPlan">
    quotas?: JsonFilter<"SubscriptionPlan">
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    isPublic?: BoolFilter<"SubscriptionPlan"> | boolean
    trialDays?: IntFilter<"SubscriptionPlan"> | number
    sortOrder?: IntFilter<"SubscriptionPlan"> | number
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: WorkspaceSubscriptionListRelationFilter
    planPricing?: PlanPricingListRelationFilter
  }

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    tier?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingPeriod?: SortOrder
    features?: SortOrder
    quotas?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    trialDays?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: WorkspaceSubscriptionOrderByRelationAggregateInput
    planPricing?: PlanPricingOrderByRelationAggregateInput
  }

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    displayName?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    tier?: StringFilter<"SubscriptionPlan"> | string
    price?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    billingPeriod?: StringFilter<"SubscriptionPlan"> | string
    features?: JsonFilter<"SubscriptionPlan">
    quotas?: JsonFilter<"SubscriptionPlan">
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    isPublic?: BoolFilter<"SubscriptionPlan"> | boolean
    trialDays?: IntFilter<"SubscriptionPlan"> | number
    sortOrder?: IntFilter<"SubscriptionPlan"> | number
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: WorkspaceSubscriptionListRelationFilter
    planPricing?: PlanPricingListRelationFilter
  }, "id" | "name">

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    tier?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingPeriod?: SortOrder
    features?: SortOrder
    quotas?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    trialDays?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionPlanCountOrderByAggregateInput
    _avg?: SubscriptionPlanAvgOrderByAggregateInput
    _max?: SubscriptionPlanMaxOrderByAggregateInput
    _min?: SubscriptionPlanMinOrderByAggregateInput
    _sum?: SubscriptionPlanSumOrderByAggregateInput
  }

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    displayName?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    description?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    tier?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    price?: DecimalWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    billingPeriod?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    features?: JsonWithAggregatesFilter<"SubscriptionPlan">
    quotas?: JsonWithAggregatesFilter<"SubscriptionPlan">
    isActive?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    isPublic?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    trialDays?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    sortOrder?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
  }

  export type WorkspaceSubscriptionWhereInput = {
    AND?: WorkspaceSubscriptionWhereInput | WorkspaceSubscriptionWhereInput[]
    OR?: WorkspaceSubscriptionWhereInput[]
    NOT?: WorkspaceSubscriptionWhereInput | WorkspaceSubscriptionWhereInput[]
    id?: StringFilter<"WorkspaceSubscription"> | string
    workspaceId?: StringFilter<"WorkspaceSubscription"> | string
    planId?: StringFilter<"WorkspaceSubscription"> | string
    status?: StringFilter<"WorkspaceSubscription"> | string
    currentPeriodStart?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    trialEnd?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    metadata?: JsonFilter<"WorkspaceSubscription">
    createdAt?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
    billingRecords?: BillingRecordListRelationFilter
    usageRecords?: UsageRecordListRelationFilter
  }

  export type WorkspaceSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    plan?: SubscriptionPlanOrderByWithRelationInput
    billingRecords?: BillingRecordOrderByRelationAggregateInput
    usageRecords?: UsageRecordOrderByRelationAggregateInput
  }

  export type WorkspaceSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId?: string
    AND?: WorkspaceSubscriptionWhereInput | WorkspaceSubscriptionWhereInput[]
    OR?: WorkspaceSubscriptionWhereInput[]
    NOT?: WorkspaceSubscriptionWhereInput | WorkspaceSubscriptionWhereInput[]
    planId?: StringFilter<"WorkspaceSubscription"> | string
    status?: StringFilter<"WorkspaceSubscription"> | string
    currentPeriodStart?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    trialEnd?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    metadata?: JsonFilter<"WorkspaceSubscription">
    createdAt?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
    billingRecords?: BillingRecordListRelationFilter
    usageRecords?: UsageRecordListRelationFilter
  }, "id" | "workspaceId">

  export type WorkspaceSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceSubscriptionCountOrderByAggregateInput
    _max?: WorkspaceSubscriptionMaxOrderByAggregateInput
    _min?: WorkspaceSubscriptionMinOrderByAggregateInput
  }

  export type WorkspaceSubscriptionScalarWhereWithAggregatesInput = {
    AND?: WorkspaceSubscriptionScalarWhereWithAggregatesInput | WorkspaceSubscriptionScalarWhereWithAggregatesInput[]
    OR?: WorkspaceSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceSubscriptionScalarWhereWithAggregatesInput | WorkspaceSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceSubscription"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceSubscription"> | string
    planId?: StringWithAggregatesFilter<"WorkspaceSubscription"> | string
    status?: StringWithAggregatesFilter<"WorkspaceSubscription"> | string
    currentPeriodStart?: DateTimeWithAggregatesFilter<"WorkspaceSubscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"WorkspaceSubscription"> | Date | string
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"WorkspaceSubscription"> | Date | string | null
    cancelReason?: StringNullableWithAggregatesFilter<"WorkspaceSubscription"> | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter<"WorkspaceSubscription"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"WorkspaceSubscription">
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkspaceSubscription"> | Date | string
  }

  export type BillingRecordWhereInput = {
    AND?: BillingRecordWhereInput | BillingRecordWhereInput[]
    OR?: BillingRecordWhereInput[]
    NOT?: BillingRecordWhereInput | BillingRecordWhereInput[]
    id?: StringFilter<"BillingRecord"> | string
    subscriptionId?: StringFilter<"BillingRecord"> | string
    amount?: DecimalFilter<"BillingRecord"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"BillingRecord"> | string
    status?: StringFilter<"BillingRecord"> | string
    invoiceNumber?: StringNullableFilter<"BillingRecord"> | string | null
    invoiceUrl?: StringNullableFilter<"BillingRecord"> | string | null
    paymentMethod?: StringNullableFilter<"BillingRecord"> | string | null
    paymentIntentId?: StringNullableFilter<"BillingRecord"> | string | null
    failureReason?: StringNullableFilter<"BillingRecord"> | string | null
    paidAt?: DateTimeNullableFilter<"BillingRecord"> | Date | string | null
    metadata?: JsonFilter<"BillingRecord">
    createdAt?: DateTimeFilter<"BillingRecord"> | Date | string
    subscription?: XOR<WorkspaceSubscriptionRelationFilter, WorkspaceSubscriptionWhereInput>
  }

  export type BillingRecordOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    invoiceUrl?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    subscription?: WorkspaceSubscriptionOrderByWithRelationInput
  }

  export type BillingRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: BillingRecordWhereInput | BillingRecordWhereInput[]
    OR?: BillingRecordWhereInput[]
    NOT?: BillingRecordWhereInput | BillingRecordWhereInput[]
    subscriptionId?: StringFilter<"BillingRecord"> | string
    amount?: DecimalFilter<"BillingRecord"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"BillingRecord"> | string
    status?: StringFilter<"BillingRecord"> | string
    invoiceUrl?: StringNullableFilter<"BillingRecord"> | string | null
    paymentMethod?: StringNullableFilter<"BillingRecord"> | string | null
    paymentIntentId?: StringNullableFilter<"BillingRecord"> | string | null
    failureReason?: StringNullableFilter<"BillingRecord"> | string | null
    paidAt?: DateTimeNullableFilter<"BillingRecord"> | Date | string | null
    metadata?: JsonFilter<"BillingRecord">
    createdAt?: DateTimeFilter<"BillingRecord"> | Date | string
    subscription?: XOR<WorkspaceSubscriptionRelationFilter, WorkspaceSubscriptionWhereInput>
  }, "id" | "invoiceNumber">

  export type BillingRecordOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    invoiceUrl?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: BillingRecordCountOrderByAggregateInput
    _avg?: BillingRecordAvgOrderByAggregateInput
    _max?: BillingRecordMaxOrderByAggregateInput
    _min?: BillingRecordMinOrderByAggregateInput
    _sum?: BillingRecordSumOrderByAggregateInput
  }

  export type BillingRecordScalarWhereWithAggregatesInput = {
    AND?: BillingRecordScalarWhereWithAggregatesInput | BillingRecordScalarWhereWithAggregatesInput[]
    OR?: BillingRecordScalarWhereWithAggregatesInput[]
    NOT?: BillingRecordScalarWhereWithAggregatesInput | BillingRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingRecord"> | string
    subscriptionId?: StringWithAggregatesFilter<"BillingRecord"> | string
    amount?: DecimalWithAggregatesFilter<"BillingRecord"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"BillingRecord"> | string
    status?: StringWithAggregatesFilter<"BillingRecord"> | string
    invoiceNumber?: StringNullableWithAggregatesFilter<"BillingRecord"> | string | null
    invoiceUrl?: StringNullableWithAggregatesFilter<"BillingRecord"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"BillingRecord"> | string | null
    paymentIntentId?: StringNullableWithAggregatesFilter<"BillingRecord"> | string | null
    failureReason?: StringNullableWithAggregatesFilter<"BillingRecord"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"BillingRecord"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"BillingRecord">
    createdAt?: DateTimeWithAggregatesFilter<"BillingRecord"> | Date | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    workspaceId?: StringFilter<"PaymentMethod"> | string
    type?: StringFilter<"PaymentMethod"> | string
    provider?: StringFilter<"PaymentMethod"> | string
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    lastFour?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    metadata?: JsonFilter<"PaymentMethod">
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    lastFour?: SortOrderInput | SortOrder
    expiryMonth?: SortOrderInput | SortOrder
    expiryYear?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    workspaceId?: StringFilter<"PaymentMethod"> | string
    type?: StringFilter<"PaymentMethod"> | string
    provider?: StringFilter<"PaymentMethod"> | string
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    lastFour?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    metadata?: JsonFilter<"PaymentMethod">
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }, "id">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    lastFour?: SortOrderInput | SortOrder
    expiryMonth?: SortOrderInput | SortOrder
    expiryYear?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    workspaceId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    type?: StringWithAggregatesFilter<"PaymentMethod"> | string
    provider?: StringWithAggregatesFilter<"PaymentMethod"> | string
    isDefault?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    lastFour?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableWithAggregatesFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableWithAggregatesFilter<"PaymentMethod"> | number | null
    metadata?: JsonWithAggregatesFilter<"PaymentMethod">
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type ApiKeyManagementWhereInput = {
    AND?: ApiKeyManagementWhereInput | ApiKeyManagementWhereInput[]
    OR?: ApiKeyManagementWhereInput[]
    NOT?: ApiKeyManagementWhereInput | ApiKeyManagementWhereInput[]
    id?: StringFilter<"ApiKeyManagement"> | string
    userId?: StringFilter<"ApiKeyManagement"> | string
    provider?: StringFilter<"ApiKeyManagement"> | string
    keyHash?: StringFilter<"ApiKeyManagement"> | string
    keyPrefix?: StringFilter<"ApiKeyManagement"> | string
    encryptedKey?: StringFilter<"ApiKeyManagement"> | string
    isActive?: BoolFilter<"ApiKeyManagement"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"ApiKeyManagement"> | Date | string | null
    usageCount?: IntFilter<"ApiKeyManagement"> | number
    expiresAt?: DateTimeNullableFilter<"ApiKeyManagement"> | Date | string | null
    metadata?: JsonFilter<"ApiKeyManagement">
    createdAt?: DateTimeFilter<"ApiKeyManagement"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKeyManagement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    usageLogs?: ApiKeyUsageLogListRelationFilter
  }

  export type ApiKeyManagementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    encryptedKey?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    usageLogs?: ApiKeyUsageLogOrderByRelationAggregateInput
  }

  export type ApiKeyManagementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_provider?: ApiKeyManagementUserIdProviderCompoundUniqueInput
    AND?: ApiKeyManagementWhereInput | ApiKeyManagementWhereInput[]
    OR?: ApiKeyManagementWhereInput[]
    NOT?: ApiKeyManagementWhereInput | ApiKeyManagementWhereInput[]
    userId?: StringFilter<"ApiKeyManagement"> | string
    provider?: StringFilter<"ApiKeyManagement"> | string
    keyHash?: StringFilter<"ApiKeyManagement"> | string
    keyPrefix?: StringFilter<"ApiKeyManagement"> | string
    encryptedKey?: StringFilter<"ApiKeyManagement"> | string
    isActive?: BoolFilter<"ApiKeyManagement"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"ApiKeyManagement"> | Date | string | null
    usageCount?: IntFilter<"ApiKeyManagement"> | number
    expiresAt?: DateTimeNullableFilter<"ApiKeyManagement"> | Date | string | null
    metadata?: JsonFilter<"ApiKeyManagement">
    createdAt?: DateTimeFilter<"ApiKeyManagement"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKeyManagement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    usageLogs?: ApiKeyUsageLogListRelationFilter
  }, "id" | "userId_provider">

  export type ApiKeyManagementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    encryptedKey?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiKeyManagementCountOrderByAggregateInput
    _avg?: ApiKeyManagementAvgOrderByAggregateInput
    _max?: ApiKeyManagementMaxOrderByAggregateInput
    _min?: ApiKeyManagementMinOrderByAggregateInput
    _sum?: ApiKeyManagementSumOrderByAggregateInput
  }

  export type ApiKeyManagementScalarWhereWithAggregatesInput = {
    AND?: ApiKeyManagementScalarWhereWithAggregatesInput | ApiKeyManagementScalarWhereWithAggregatesInput[]
    OR?: ApiKeyManagementScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyManagementScalarWhereWithAggregatesInput | ApiKeyManagementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKeyManagement"> | string
    userId?: StringWithAggregatesFilter<"ApiKeyManagement"> | string
    provider?: StringWithAggregatesFilter<"ApiKeyManagement"> | string
    keyHash?: StringWithAggregatesFilter<"ApiKeyManagement"> | string
    keyPrefix?: StringWithAggregatesFilter<"ApiKeyManagement"> | string
    encryptedKey?: StringWithAggregatesFilter<"ApiKeyManagement"> | string
    isActive?: BoolWithAggregatesFilter<"ApiKeyManagement"> | boolean
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKeyManagement"> | Date | string | null
    usageCount?: IntWithAggregatesFilter<"ApiKeyManagement"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKeyManagement"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"ApiKeyManagement">
    createdAt?: DateTimeWithAggregatesFilter<"ApiKeyManagement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKeyManagement"> | Date | string
  }

  export type ApiKeyUsageLogWhereInput = {
    AND?: ApiKeyUsageLogWhereInput | ApiKeyUsageLogWhereInput[]
    OR?: ApiKeyUsageLogWhereInput[]
    NOT?: ApiKeyUsageLogWhereInput | ApiKeyUsageLogWhereInput[]
    id?: StringFilter<"ApiKeyUsageLog"> | string
    apiKeyId?: StringFilter<"ApiKeyUsageLog"> | string
    endpoint?: StringFilter<"ApiKeyUsageLog"> | string
    method?: StringFilter<"ApiKeyUsageLog"> | string
    statusCode?: IntFilter<"ApiKeyUsageLog"> | number
    responseTime?: IntFilter<"ApiKeyUsageLog"> | number
    tokensUsed?: IntNullableFilter<"ApiKeyUsageLog"> | number | null
    cost?: DecimalNullableFilter<"ApiKeyUsageLog"> | Decimal | DecimalJsLike | number | string | null
    error?: StringNullableFilter<"ApiKeyUsageLog"> | string | null
    metadata?: JsonFilter<"ApiKeyUsageLog">
    createdAt?: DateTimeFilter<"ApiKeyUsageLog"> | Date | string
    apiKey?: XOR<ApiKeyManagementRelationFilter, ApiKeyManagementWhereInput>
  }

  export type ApiKeyUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    tokensUsed?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    apiKey?: ApiKeyManagementOrderByWithRelationInput
  }

  export type ApiKeyUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiKeyUsageLogWhereInput | ApiKeyUsageLogWhereInput[]
    OR?: ApiKeyUsageLogWhereInput[]
    NOT?: ApiKeyUsageLogWhereInput | ApiKeyUsageLogWhereInput[]
    apiKeyId?: StringFilter<"ApiKeyUsageLog"> | string
    endpoint?: StringFilter<"ApiKeyUsageLog"> | string
    method?: StringFilter<"ApiKeyUsageLog"> | string
    statusCode?: IntFilter<"ApiKeyUsageLog"> | number
    responseTime?: IntFilter<"ApiKeyUsageLog"> | number
    tokensUsed?: IntNullableFilter<"ApiKeyUsageLog"> | number | null
    cost?: DecimalNullableFilter<"ApiKeyUsageLog"> | Decimal | DecimalJsLike | number | string | null
    error?: StringNullableFilter<"ApiKeyUsageLog"> | string | null
    metadata?: JsonFilter<"ApiKeyUsageLog">
    createdAt?: DateTimeFilter<"ApiKeyUsageLog"> | Date | string
    apiKey?: XOR<ApiKeyManagementRelationFilter, ApiKeyManagementWhereInput>
  }, "id">

  export type ApiKeyUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    tokensUsed?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: ApiKeyUsageLogCountOrderByAggregateInput
    _avg?: ApiKeyUsageLogAvgOrderByAggregateInput
    _max?: ApiKeyUsageLogMaxOrderByAggregateInput
    _min?: ApiKeyUsageLogMinOrderByAggregateInput
    _sum?: ApiKeyUsageLogSumOrderByAggregateInput
  }

  export type ApiKeyUsageLogScalarWhereWithAggregatesInput = {
    AND?: ApiKeyUsageLogScalarWhereWithAggregatesInput | ApiKeyUsageLogScalarWhereWithAggregatesInput[]
    OR?: ApiKeyUsageLogScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyUsageLogScalarWhereWithAggregatesInput | ApiKeyUsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKeyUsageLog"> | string
    apiKeyId?: StringWithAggregatesFilter<"ApiKeyUsageLog"> | string
    endpoint?: StringWithAggregatesFilter<"ApiKeyUsageLog"> | string
    method?: StringWithAggregatesFilter<"ApiKeyUsageLog"> | string
    statusCode?: IntWithAggregatesFilter<"ApiKeyUsageLog"> | number
    responseTime?: IntWithAggregatesFilter<"ApiKeyUsageLog"> | number
    tokensUsed?: IntNullableWithAggregatesFilter<"ApiKeyUsageLog"> | number | null
    cost?: DecimalNullableWithAggregatesFilter<"ApiKeyUsageLog"> | Decimal | DecimalJsLike | number | string | null
    error?: StringNullableWithAggregatesFilter<"ApiKeyUsageLog"> | string | null
    metadata?: JsonWithAggregatesFilter<"ApiKeyUsageLog">
    createdAt?: DateTimeWithAggregatesFilter<"ApiKeyUsageLog"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    userId?: StringFilter<"UserSettings"> | string
    openaiApiKeyEncrypted?: StringNullableFilter<"UserSettings"> | string | null
    elevenlabsApiKeyEncrypted?: StringNullableFilter<"UserSettings"> | string | null
    preferredLanguage?: StringFilter<"UserSettings"> | string
    summaryQuality?: StringFilter<"UserSettings"> | string
    theme?: StringFilter<"UserSettings"> | string
    notifications?: JsonFilter<"UserSettings">
    privacy?: JsonFilter<"UserSettings">
    settingsJson?: JsonFilter<"UserSettings">
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    userId?: SortOrder
    openaiApiKeyEncrypted?: SortOrderInput | SortOrder
    elevenlabsApiKeyEncrypted?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrder
    summaryQuality?: SortOrder
    theme?: SortOrder
    notifications?: SortOrder
    privacy?: SortOrder
    settingsJson?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    openaiApiKeyEncrypted?: StringNullableFilter<"UserSettings"> | string | null
    elevenlabsApiKeyEncrypted?: StringNullableFilter<"UserSettings"> | string | null
    preferredLanguage?: StringFilter<"UserSettings"> | string
    summaryQuality?: StringFilter<"UserSettings"> | string
    theme?: StringFilter<"UserSettings"> | string
    notifications?: JsonFilter<"UserSettings">
    privacy?: JsonFilter<"UserSettings">
    settingsJson?: JsonFilter<"UserSettings">
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    userId?: SortOrder
    openaiApiKeyEncrypted?: SortOrderInput | SortOrder
    elevenlabsApiKeyEncrypted?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrder
    summaryQuality?: SortOrder
    theme?: SortOrder
    notifications?: SortOrder
    privacy?: SortOrder
    settingsJson?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    openaiApiKeyEncrypted?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    elevenlabsApiKeyEncrypted?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    preferredLanguage?: StringWithAggregatesFilter<"UserSettings"> | string
    summaryQuality?: StringWithAggregatesFilter<"UserSettings"> | string
    theme?: StringWithAggregatesFilter<"UserSettings"> | string
    notifications?: JsonWithAggregatesFilter<"UserSettings">
    privacy?: JsonWithAggregatesFilter<"UserSettings">
    settingsJson?: JsonWithAggregatesFilter<"UserSettings">
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type UsageMetricWhereInput = {
    AND?: UsageMetricWhereInput | UsageMetricWhereInput[]
    OR?: UsageMetricWhereInput[]
    NOT?: UsageMetricWhereInput | UsageMetricWhereInput[]
    id?: StringFilter<"UsageMetric"> | string
    workspaceId?: StringFilter<"UsageMetric"> | string
    metricType?: StringFilter<"UsageMetric"> | string
    value?: BigIntFilter<"UsageMetric"> | bigint | number
    period?: StringFilter<"UsageMetric"> | string
    periodStart?: DateTimeFilter<"UsageMetric"> | Date | string
    periodEnd?: DateTimeFilter<"UsageMetric"> | Date | string
    metadata?: JsonFilter<"UsageMetric">
    createdAt?: DateTimeFilter<"UsageMetric"> | Date | string
  }

  export type UsageMetricOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_metricType_periodStart?: UsageMetricWorkspaceIdMetricTypePeriodStartCompoundUniqueInput
    AND?: UsageMetricWhereInput | UsageMetricWhereInput[]
    OR?: UsageMetricWhereInput[]
    NOT?: UsageMetricWhereInput | UsageMetricWhereInput[]
    workspaceId?: StringFilter<"UsageMetric"> | string
    metricType?: StringFilter<"UsageMetric"> | string
    value?: BigIntFilter<"UsageMetric"> | bigint | number
    period?: StringFilter<"UsageMetric"> | string
    periodStart?: DateTimeFilter<"UsageMetric"> | Date | string
    periodEnd?: DateTimeFilter<"UsageMetric"> | Date | string
    metadata?: JsonFilter<"UsageMetric">
    createdAt?: DateTimeFilter<"UsageMetric"> | Date | string
  }, "id" | "workspaceId_metricType_periodStart">

  export type UsageMetricOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: UsageMetricCountOrderByAggregateInput
    _avg?: UsageMetricAvgOrderByAggregateInput
    _max?: UsageMetricMaxOrderByAggregateInput
    _min?: UsageMetricMinOrderByAggregateInput
    _sum?: UsageMetricSumOrderByAggregateInput
  }

  export type UsageMetricScalarWhereWithAggregatesInput = {
    AND?: UsageMetricScalarWhereWithAggregatesInput | UsageMetricScalarWhereWithAggregatesInput[]
    OR?: UsageMetricScalarWhereWithAggregatesInput[]
    NOT?: UsageMetricScalarWhereWithAggregatesInput | UsageMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageMetric"> | string
    workspaceId?: StringWithAggregatesFilter<"UsageMetric"> | string
    metricType?: StringWithAggregatesFilter<"UsageMetric"> | string
    value?: BigIntWithAggregatesFilter<"UsageMetric"> | bigint | number
    period?: StringWithAggregatesFilter<"UsageMetric"> | string
    periodStart?: DateTimeWithAggregatesFilter<"UsageMetric"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"UsageMetric"> | Date | string
    metadata?: JsonWithAggregatesFilter<"UsageMetric">
    createdAt?: DateTimeWithAggregatesFilter<"UsageMetric"> | Date | string
  }

  export type UserQuotaWhereInput = {
    AND?: UserQuotaWhereInput | UserQuotaWhereInput[]
    OR?: UserQuotaWhereInput[]
    NOT?: UserQuotaWhereInput | UserQuotaWhereInput[]
    id?: StringFilter<"UserQuota"> | string
    userId?: StringFilter<"UserQuota"> | string
    workspaceId?: StringFilter<"UserQuota"> | string
    quotaType?: StringFilter<"UserQuota"> | string
    used?: BigIntFilter<"UserQuota"> | bigint | number
    limit?: BigIntFilter<"UserQuota"> | bigint | number
    resetPeriod?: StringFilter<"UserQuota"> | string
    nextResetAt?: DateTimeFilter<"UserQuota"> | Date | string
    createdAt?: DateTimeFilter<"UserQuota"> | Date | string
    updatedAt?: DateTimeFilter<"UserQuota"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserQuotaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    quotaType?: SortOrder
    used?: SortOrder
    limit?: SortOrder
    resetPeriod?: SortOrder
    nextResetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserQuotaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_workspaceId_quotaType?: UserQuotaUserIdWorkspaceIdQuotaTypeCompoundUniqueInput
    AND?: UserQuotaWhereInput | UserQuotaWhereInput[]
    OR?: UserQuotaWhereInput[]
    NOT?: UserQuotaWhereInput | UserQuotaWhereInput[]
    userId?: StringFilter<"UserQuota"> | string
    workspaceId?: StringFilter<"UserQuota"> | string
    quotaType?: StringFilter<"UserQuota"> | string
    used?: BigIntFilter<"UserQuota"> | bigint | number
    limit?: BigIntFilter<"UserQuota"> | bigint | number
    resetPeriod?: StringFilter<"UserQuota"> | string
    nextResetAt?: DateTimeFilter<"UserQuota"> | Date | string
    createdAt?: DateTimeFilter<"UserQuota"> | Date | string
    updatedAt?: DateTimeFilter<"UserQuota"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_workspaceId_quotaType">

  export type UserQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    quotaType?: SortOrder
    used?: SortOrder
    limit?: SortOrder
    resetPeriod?: SortOrder
    nextResetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserQuotaCountOrderByAggregateInput
    _avg?: UserQuotaAvgOrderByAggregateInput
    _max?: UserQuotaMaxOrderByAggregateInput
    _min?: UserQuotaMinOrderByAggregateInput
    _sum?: UserQuotaSumOrderByAggregateInput
  }

  export type UserQuotaScalarWhereWithAggregatesInput = {
    AND?: UserQuotaScalarWhereWithAggregatesInput | UserQuotaScalarWhereWithAggregatesInput[]
    OR?: UserQuotaScalarWhereWithAggregatesInput[]
    NOT?: UserQuotaScalarWhereWithAggregatesInput | UserQuotaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserQuota"> | string
    userId?: StringWithAggregatesFilter<"UserQuota"> | string
    workspaceId?: StringWithAggregatesFilter<"UserQuota"> | string
    quotaType?: StringWithAggregatesFilter<"UserQuota"> | string
    used?: BigIntWithAggregatesFilter<"UserQuota"> | bigint | number
    limit?: BigIntWithAggregatesFilter<"UserQuota"> | bigint | number
    resetPeriod?: StringWithAggregatesFilter<"UserQuota"> | string
    nextResetAt?: DateTimeWithAggregatesFilter<"UserQuota"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserQuota"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserQuota"> | Date | string
  }

  export type StorageQuotaWhereInput = {
    AND?: StorageQuotaWhereInput | StorageQuotaWhereInput[]
    OR?: StorageQuotaWhereInput[]
    NOT?: StorageQuotaWhereInput | StorageQuotaWhereInput[]
    id?: StringFilter<"StorageQuota"> | string
    workspaceId?: StringFilter<"StorageQuota"> | string
    totalBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    usedBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    fileCount?: IntFilter<"StorageQuota"> | number
    lastCalculated?: DateTimeFilter<"StorageQuota"> | Date | string
    createdAt?: DateTimeFilter<"StorageQuota"> | Date | string
    updatedAt?: DateTimeFilter<"StorageQuota"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type StorageQuotaOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    totalBytes?: SortOrder
    usedBytes?: SortOrder
    fileCount?: SortOrder
    lastCalculated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type StorageQuotaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId?: string
    AND?: StorageQuotaWhereInput | StorageQuotaWhereInput[]
    OR?: StorageQuotaWhereInput[]
    NOT?: StorageQuotaWhereInput | StorageQuotaWhereInput[]
    totalBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    usedBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    fileCount?: IntFilter<"StorageQuota"> | number
    lastCalculated?: DateTimeFilter<"StorageQuota"> | Date | string
    createdAt?: DateTimeFilter<"StorageQuota"> | Date | string
    updatedAt?: DateTimeFilter<"StorageQuota"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id" | "workspaceId">

  export type StorageQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    totalBytes?: SortOrder
    usedBytes?: SortOrder
    fileCount?: SortOrder
    lastCalculated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StorageQuotaCountOrderByAggregateInput
    _avg?: StorageQuotaAvgOrderByAggregateInput
    _max?: StorageQuotaMaxOrderByAggregateInput
    _min?: StorageQuotaMinOrderByAggregateInput
    _sum?: StorageQuotaSumOrderByAggregateInput
  }

  export type StorageQuotaScalarWhereWithAggregatesInput = {
    AND?: StorageQuotaScalarWhereWithAggregatesInput | StorageQuotaScalarWhereWithAggregatesInput[]
    OR?: StorageQuotaScalarWhereWithAggregatesInput[]
    NOT?: StorageQuotaScalarWhereWithAggregatesInput | StorageQuotaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StorageQuota"> | string
    workspaceId?: StringWithAggregatesFilter<"StorageQuota"> | string
    totalBytes?: BigIntWithAggregatesFilter<"StorageQuota"> | bigint | number
    usedBytes?: BigIntWithAggregatesFilter<"StorageQuota"> | bigint | number
    fileCount?: IntWithAggregatesFilter<"StorageQuota"> | number
    lastCalculated?: DateTimeWithAggregatesFilter<"StorageQuota"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"StorageQuota"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StorageQuota"> | Date | string
  }

  export type UsageRecordWhereInput = {
    AND?: UsageRecordWhereInput | UsageRecordWhereInput[]
    OR?: UsageRecordWhereInput[]
    NOT?: UsageRecordWhereInput | UsageRecordWhereInput[]
    id?: StringFilter<"UsageRecord"> | string
    subscriptionId?: StringFilter<"UsageRecord"> | string
    recordType?: StringFilter<"UsageRecord"> | string
    quantity?: BigIntFilter<"UsageRecord"> | bigint | number
    unitPrice?: DecimalNullableFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFilter<"UsageRecord"> | Date | string
    periodEnd?: DateTimeFilter<"UsageRecord"> | Date | string
    metadata?: JsonFilter<"UsageRecord">
    createdAt?: DateTimeFilter<"UsageRecord"> | Date | string
    subscription?: XOR<WorkspaceSubscriptionRelationFilter, WorkspaceSubscriptionWhereInput>
  }

  export type UsageRecordOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    recordType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    subscription?: WorkspaceSubscriptionOrderByWithRelationInput
  }

  export type UsageRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageRecordWhereInput | UsageRecordWhereInput[]
    OR?: UsageRecordWhereInput[]
    NOT?: UsageRecordWhereInput | UsageRecordWhereInput[]
    subscriptionId?: StringFilter<"UsageRecord"> | string
    recordType?: StringFilter<"UsageRecord"> | string
    quantity?: BigIntFilter<"UsageRecord"> | bigint | number
    unitPrice?: DecimalNullableFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFilter<"UsageRecord"> | Date | string
    periodEnd?: DateTimeFilter<"UsageRecord"> | Date | string
    metadata?: JsonFilter<"UsageRecord">
    createdAt?: DateTimeFilter<"UsageRecord"> | Date | string
    subscription?: XOR<WorkspaceSubscriptionRelationFilter, WorkspaceSubscriptionWhereInput>
  }, "id">

  export type UsageRecordOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    recordType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: UsageRecordCountOrderByAggregateInput
    _avg?: UsageRecordAvgOrderByAggregateInput
    _max?: UsageRecordMaxOrderByAggregateInput
    _min?: UsageRecordMinOrderByAggregateInput
    _sum?: UsageRecordSumOrderByAggregateInput
  }

  export type UsageRecordScalarWhereWithAggregatesInput = {
    AND?: UsageRecordScalarWhereWithAggregatesInput | UsageRecordScalarWhereWithAggregatesInput[]
    OR?: UsageRecordScalarWhereWithAggregatesInput[]
    NOT?: UsageRecordScalarWhereWithAggregatesInput | UsageRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageRecord"> | string
    subscriptionId?: StringWithAggregatesFilter<"UsageRecord"> | string
    recordType?: StringWithAggregatesFilter<"UsageRecord"> | string
    quantity?: BigIntWithAggregatesFilter<"UsageRecord"> | bigint | number
    unitPrice?: DecimalNullableWithAggregatesFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableWithAggregatesFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeWithAggregatesFilter<"UsageRecord"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"UsageRecord"> | Date | string
    metadata?: JsonWithAggregatesFilter<"UsageRecord">
    createdAt?: DateTimeWithAggregatesFilter<"UsageRecord"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    workspaceId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    workspaceId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    workspaceId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    workspaceId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    workspaceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type SecurityEventWhereInput = {
    AND?: SecurityEventWhereInput | SecurityEventWhereInput[]
    OR?: SecurityEventWhereInput[]
    NOT?: SecurityEventWhereInput | SecurityEventWhereInput[]
    id?: StringFilter<"SecurityEvent"> | string
    userId?: StringNullableFilter<"SecurityEvent"> | string | null
    eventType?: StringFilter<"SecurityEvent"> | string
    severity?: StringFilter<"SecurityEvent"> | string
    description?: StringFilter<"SecurityEvent"> | string
    ipAddress?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    metadata?: JsonFilter<"SecurityEvent">
    resolved?: BoolFilter<"SecurityEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"SecurityEvent"> | Date | string | null
    resolvedBy?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type SecurityEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SecurityEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityEventWhereInput | SecurityEventWhereInput[]
    OR?: SecurityEventWhereInput[]
    NOT?: SecurityEventWhereInput | SecurityEventWhereInput[]
    userId?: StringNullableFilter<"SecurityEvent"> | string | null
    eventType?: StringFilter<"SecurityEvent"> | string
    severity?: StringFilter<"SecurityEvent"> | string
    description?: StringFilter<"SecurityEvent"> | string
    ipAddress?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    metadata?: JsonFilter<"SecurityEvent">
    resolved?: BoolFilter<"SecurityEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"SecurityEvent"> | Date | string | null
    resolvedBy?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type SecurityEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SecurityEventCountOrderByAggregateInput
    _max?: SecurityEventMaxOrderByAggregateInput
    _min?: SecurityEventMinOrderByAggregateInput
  }

  export type SecurityEventScalarWhereWithAggregatesInput = {
    AND?: SecurityEventScalarWhereWithAggregatesInput | SecurityEventScalarWhereWithAggregatesInput[]
    OR?: SecurityEventScalarWhereWithAggregatesInput[]
    NOT?: SecurityEventScalarWhereWithAggregatesInput | SecurityEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityEvent"> | string
    userId?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    eventType?: StringWithAggregatesFilter<"SecurityEvent"> | string
    severity?: StringWithAggregatesFilter<"SecurityEvent"> | string
    description?: StringWithAggregatesFilter<"SecurityEvent"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    metadata?: JsonWithAggregatesFilter<"SecurityEvent">
    resolved?: BoolWithAggregatesFilter<"SecurityEvent"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"SecurityEvent"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecurityEvent"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    htmlContent?: StringFilter<"EmailTemplate"> | string
    textContent?: StringFilter<"EmailTemplate"> | string
    variables?: JsonFilter<"EmailTemplate">
    isActive?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    emailLogs?: EmailLogListRelationFilter
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    variables?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailLogs?: EmailLogOrderByRelationAggregateInput
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    subject?: StringFilter<"EmailTemplate"> | string
    htmlContent?: StringFilter<"EmailTemplate"> | string
    textContent?: StringFilter<"EmailTemplate"> | string
    variables?: JsonFilter<"EmailTemplate">
    isActive?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    emailLogs?: EmailLogListRelationFilter
  }, "id" | "name">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    variables?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    subject?: StringWithAggregatesFilter<"EmailTemplate"> | string
    htmlContent?: StringWithAggregatesFilter<"EmailTemplate"> | string
    textContent?: StringWithAggregatesFilter<"EmailTemplate"> | string
    variables?: JsonWithAggregatesFilter<"EmailTemplate">
    isActive?: BoolWithAggregatesFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
  }

  export type EmailLogWhereInput = {
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    id?: StringFilter<"EmailLog"> | string
    templateId?: StringNullableFilter<"EmailLog"> | string | null
    recipientEmail?: StringFilter<"EmailLog"> | string
    subject?: StringFilter<"EmailLog"> | string
    status?: StringFilter<"EmailLog"> | string
    provider?: StringFilter<"EmailLog"> | string
    providerMessageId?: StringNullableFilter<"EmailLog"> | string | null
    openedAt?: DateTimeNullableFilter<"EmailLog"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"EmailLog"> | Date | string | null
    error?: StringNullableFilter<"EmailLog"> | string | null
    metadata?: JsonFilter<"EmailLog">
    createdAt?: DateTimeFilter<"EmailLog"> | Date | string
    template?: XOR<EmailTemplateNullableRelationFilter, EmailTemplateWhereInput> | null
  }

  export type EmailLogOrderByWithRelationInput = {
    id?: SortOrder
    templateId?: SortOrderInput | SortOrder
    recipientEmail?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    providerMessageId?: SortOrderInput | SortOrder
    openedAt?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    template?: EmailTemplateOrderByWithRelationInput
  }

  export type EmailLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    templateId?: StringNullableFilter<"EmailLog"> | string | null
    recipientEmail?: StringFilter<"EmailLog"> | string
    subject?: StringFilter<"EmailLog"> | string
    status?: StringFilter<"EmailLog"> | string
    provider?: StringFilter<"EmailLog"> | string
    providerMessageId?: StringNullableFilter<"EmailLog"> | string | null
    openedAt?: DateTimeNullableFilter<"EmailLog"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"EmailLog"> | Date | string | null
    error?: StringNullableFilter<"EmailLog"> | string | null
    metadata?: JsonFilter<"EmailLog">
    createdAt?: DateTimeFilter<"EmailLog"> | Date | string
    template?: XOR<EmailTemplateNullableRelationFilter, EmailTemplateWhereInput> | null
  }, "id">

  export type EmailLogOrderByWithAggregationInput = {
    id?: SortOrder
    templateId?: SortOrderInput | SortOrder
    recipientEmail?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    providerMessageId?: SortOrderInput | SortOrder
    openedAt?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: EmailLogCountOrderByAggregateInput
    _max?: EmailLogMaxOrderByAggregateInput
    _min?: EmailLogMinOrderByAggregateInput
  }

  export type EmailLogScalarWhereWithAggregatesInput = {
    AND?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    OR?: EmailLogScalarWhereWithAggregatesInput[]
    NOT?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailLog"> | string
    templateId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    recipientEmail?: StringWithAggregatesFilter<"EmailLog"> | string
    subject?: StringWithAggregatesFilter<"EmailLog"> | string
    status?: StringWithAggregatesFilter<"EmailLog"> | string
    provider?: StringWithAggregatesFilter<"EmailLog"> | string
    providerMessageId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    openedAt?: DateTimeNullableWithAggregatesFilter<"EmailLog"> | Date | string | null
    clickedAt?: DateTimeNullableWithAggregatesFilter<"EmailLog"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    metadata?: JsonWithAggregatesFilter<"EmailLog">
    createdAt?: DateTimeWithAggregatesFilter<"EmailLog"> | Date | string
  }

  export type EmailPreferenceWhereInput = {
    AND?: EmailPreferenceWhereInput | EmailPreferenceWhereInput[]
    OR?: EmailPreferenceWhereInput[]
    NOT?: EmailPreferenceWhereInput | EmailPreferenceWhereInput[]
    userId?: StringFilter<"EmailPreference"> | string
    marketing?: BoolFilter<"EmailPreference"> | boolean
    transactional?: BoolFilter<"EmailPreference"> | boolean
    security?: BoolFilter<"EmailPreference"> | boolean
    newsletter?: BoolFilter<"EmailPreference"> | boolean
    productUpdates?: BoolFilter<"EmailPreference"> | boolean
    unsubscribeToken?: StringFilter<"EmailPreference"> | string
    updatedAt?: DateTimeFilter<"EmailPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EmailPreferenceOrderByWithRelationInput = {
    userId?: SortOrder
    marketing?: SortOrder
    transactional?: SortOrder
    security?: SortOrder
    newsletter?: SortOrder
    productUpdates?: SortOrder
    unsubscribeToken?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailPreferenceWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    unsubscribeToken?: string
    AND?: EmailPreferenceWhereInput | EmailPreferenceWhereInput[]
    OR?: EmailPreferenceWhereInput[]
    NOT?: EmailPreferenceWhereInput | EmailPreferenceWhereInput[]
    marketing?: BoolFilter<"EmailPreference"> | boolean
    transactional?: BoolFilter<"EmailPreference"> | boolean
    security?: BoolFilter<"EmailPreference"> | boolean
    newsletter?: BoolFilter<"EmailPreference"> | boolean
    productUpdates?: BoolFilter<"EmailPreference"> | boolean
    updatedAt?: DateTimeFilter<"EmailPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId" | "unsubscribeToken">

  export type EmailPreferenceOrderByWithAggregationInput = {
    userId?: SortOrder
    marketing?: SortOrder
    transactional?: SortOrder
    security?: SortOrder
    newsletter?: SortOrder
    productUpdates?: SortOrder
    unsubscribeToken?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailPreferenceCountOrderByAggregateInput
    _max?: EmailPreferenceMaxOrderByAggregateInput
    _min?: EmailPreferenceMinOrderByAggregateInput
  }

  export type EmailPreferenceScalarWhereWithAggregatesInput = {
    AND?: EmailPreferenceScalarWhereWithAggregatesInput | EmailPreferenceScalarWhereWithAggregatesInput[]
    OR?: EmailPreferenceScalarWhereWithAggregatesInput[]
    NOT?: EmailPreferenceScalarWhereWithAggregatesInput | EmailPreferenceScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"EmailPreference"> | string
    marketing?: BoolWithAggregatesFilter<"EmailPreference"> | boolean
    transactional?: BoolWithAggregatesFilter<"EmailPreference"> | boolean
    security?: BoolWithAggregatesFilter<"EmailPreference"> | boolean
    newsletter?: BoolWithAggregatesFilter<"EmailPreference"> | boolean
    productUpdates?: BoolWithAggregatesFilter<"EmailPreference"> | boolean
    unsubscribeToken?: StringWithAggregatesFilter<"EmailPreference"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailPreference"> | Date | string
  }

  export type IntegrationWhereInput = {
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    id?: StringFilter<"Integration"> | string
    workspaceId?: StringFilter<"Integration"> | string
    type?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    config?: JsonFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type IntegrationOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type IntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_type?: IntegrationWorkspaceIdTypeCompoundUniqueInput
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    workspaceId?: StringFilter<"Integration"> | string
    type?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    config?: JsonFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id" | "workspaceId_type">

  export type IntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegrationCountOrderByAggregateInput
    _max?: IntegrationMaxOrderByAggregateInput
    _min?: IntegrationMinOrderByAggregateInput
  }

  export type IntegrationScalarWhereWithAggregatesInput = {
    AND?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    OR?: IntegrationScalarWhereWithAggregatesInput[]
    NOT?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Integration"> | string
    workspaceId?: StringWithAggregatesFilter<"Integration"> | string
    type?: StringWithAggregatesFilter<"Integration"> | string
    name?: StringWithAggregatesFilter<"Integration"> | string
    config?: JsonWithAggregatesFilter<"Integration">
    isActive?: BoolWithAggregatesFilter<"Integration"> | boolean
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"Integration"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
  }

  export type WorkspaceAutomationWhereInput = {
    AND?: WorkspaceAutomationWhereInput | WorkspaceAutomationWhereInput[]
    OR?: WorkspaceAutomationWhereInput[]
    NOT?: WorkspaceAutomationWhereInput | WorkspaceAutomationWhereInput[]
    id?: StringFilter<"WorkspaceAutomation"> | string
    workspaceId?: StringFilter<"WorkspaceAutomation"> | string
    name?: StringFilter<"WorkspaceAutomation"> | string
    description?: StringNullableFilter<"WorkspaceAutomation"> | string | null
    trigger?: JsonFilter<"WorkspaceAutomation">
    actions?: JsonFilter<"WorkspaceAutomation">
    isActive?: BoolFilter<"WorkspaceAutomation"> | boolean
    lastRunAt?: DateTimeNullableFilter<"WorkspaceAutomation"> | Date | string | null
    runCount?: IntFilter<"WorkspaceAutomation"> | number
    createdAt?: DateTimeFilter<"WorkspaceAutomation"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceAutomation"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type WorkspaceAutomationOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    trigger?: SortOrder
    actions?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type WorkspaceAutomationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkspaceAutomationWhereInput | WorkspaceAutomationWhereInput[]
    OR?: WorkspaceAutomationWhereInput[]
    NOT?: WorkspaceAutomationWhereInput | WorkspaceAutomationWhereInput[]
    workspaceId?: StringFilter<"WorkspaceAutomation"> | string
    name?: StringFilter<"WorkspaceAutomation"> | string
    description?: StringNullableFilter<"WorkspaceAutomation"> | string | null
    trigger?: JsonFilter<"WorkspaceAutomation">
    actions?: JsonFilter<"WorkspaceAutomation">
    isActive?: BoolFilter<"WorkspaceAutomation"> | boolean
    lastRunAt?: DateTimeNullableFilter<"WorkspaceAutomation"> | Date | string | null
    runCount?: IntFilter<"WorkspaceAutomation"> | number
    createdAt?: DateTimeFilter<"WorkspaceAutomation"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceAutomation"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type WorkspaceAutomationOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    trigger?: SortOrder
    actions?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceAutomationCountOrderByAggregateInput
    _avg?: WorkspaceAutomationAvgOrderByAggregateInput
    _max?: WorkspaceAutomationMaxOrderByAggregateInput
    _min?: WorkspaceAutomationMinOrderByAggregateInput
    _sum?: WorkspaceAutomationSumOrderByAggregateInput
  }

  export type WorkspaceAutomationScalarWhereWithAggregatesInput = {
    AND?: WorkspaceAutomationScalarWhereWithAggregatesInput | WorkspaceAutomationScalarWhereWithAggregatesInput[]
    OR?: WorkspaceAutomationScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceAutomationScalarWhereWithAggregatesInput | WorkspaceAutomationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceAutomation"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceAutomation"> | string
    name?: StringWithAggregatesFilter<"WorkspaceAutomation"> | string
    description?: StringNullableWithAggregatesFilter<"WorkspaceAutomation"> | string | null
    trigger?: JsonWithAggregatesFilter<"WorkspaceAutomation">
    actions?: JsonWithAggregatesFilter<"WorkspaceAutomation">
    isActive?: BoolWithAggregatesFilter<"WorkspaceAutomation"> | boolean
    lastRunAt?: DateTimeNullableWithAggregatesFilter<"WorkspaceAutomation"> | Date | string | null
    runCount?: IntWithAggregatesFilter<"WorkspaceAutomation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceAutomation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkspaceAutomation"> | Date | string
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: StringFilter<"Webhook"> | string
    workspaceId?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringFilter<"Webhook"> | string
    isActive?: BoolFilter<"Webhook"> | boolean
    lastTriggeredAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    failureCount?: IntFilter<"Webhook"> | number
    metadata?: JsonFilter<"Webhook">
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    lastTriggeredAt?: SortOrderInput | SortOrder
    failureCount?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    workspaceId?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringFilter<"Webhook"> | string
    isActive?: BoolFilter<"Webhook"> | boolean
    lastTriggeredAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    failureCount?: IntFilter<"Webhook"> | number
    metadata?: JsonFilter<"Webhook">
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    lastTriggeredAt?: SortOrderInput | SortOrder
    failureCount?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _avg?: WebhookAvgOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
    _sum?: WebhookSumOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Webhook"> | string
    workspaceId?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringWithAggregatesFilter<"Webhook"> | string
    isActive?: BoolWithAggregatesFilter<"Webhook"> | boolean
    lastTriggeredAt?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    failureCount?: IntWithAggregatesFilter<"Webhook"> | number
    metadata?: JsonWithAggregatesFilter<"Webhook">
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
  }

  export type CustomFieldWhereInput = {
    AND?: CustomFieldWhereInput | CustomFieldWhereInput[]
    OR?: CustomFieldWhereInput[]
    NOT?: CustomFieldWhereInput | CustomFieldWhereInput[]
    id?: StringFilter<"CustomField"> | string
    workspaceId?: StringFilter<"CustomField"> | string
    name?: StringFilter<"CustomField"> | string
    fieldType?: StringFilter<"CustomField"> | string
    isRequired?: BoolFilter<"CustomField"> | boolean
    options?: JsonNullableFilter<"CustomField">
    defaultValue?: StringNullableFilter<"CustomField"> | string | null
    sortOrder?: IntFilter<"CustomField"> | number
    createdAt?: DateTimeFilter<"CustomField"> | Date | string
    updatedAt?: DateTimeFilter<"CustomField"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type CustomFieldOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    fieldType?: SortOrder
    isRequired?: SortOrder
    options?: SortOrderInput | SortOrder
    defaultValue?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type CustomFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_name?: CustomFieldWorkspaceIdNameCompoundUniqueInput
    AND?: CustomFieldWhereInput | CustomFieldWhereInput[]
    OR?: CustomFieldWhereInput[]
    NOT?: CustomFieldWhereInput | CustomFieldWhereInput[]
    workspaceId?: StringFilter<"CustomField"> | string
    name?: StringFilter<"CustomField"> | string
    fieldType?: StringFilter<"CustomField"> | string
    isRequired?: BoolFilter<"CustomField"> | boolean
    options?: JsonNullableFilter<"CustomField">
    defaultValue?: StringNullableFilter<"CustomField"> | string | null
    sortOrder?: IntFilter<"CustomField"> | number
    createdAt?: DateTimeFilter<"CustomField"> | Date | string
    updatedAt?: DateTimeFilter<"CustomField"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id" | "workspaceId_name">

  export type CustomFieldOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    fieldType?: SortOrder
    isRequired?: SortOrder
    options?: SortOrderInput | SortOrder
    defaultValue?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomFieldCountOrderByAggregateInput
    _avg?: CustomFieldAvgOrderByAggregateInput
    _max?: CustomFieldMaxOrderByAggregateInput
    _min?: CustomFieldMinOrderByAggregateInput
    _sum?: CustomFieldSumOrderByAggregateInput
  }

  export type CustomFieldScalarWhereWithAggregatesInput = {
    AND?: CustomFieldScalarWhereWithAggregatesInput | CustomFieldScalarWhereWithAggregatesInput[]
    OR?: CustomFieldScalarWhereWithAggregatesInput[]
    NOT?: CustomFieldScalarWhereWithAggregatesInput | CustomFieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomField"> | string
    workspaceId?: StringWithAggregatesFilter<"CustomField"> | string
    name?: StringWithAggregatesFilter<"CustomField"> | string
    fieldType?: StringWithAggregatesFilter<"CustomField"> | string
    isRequired?: BoolWithAggregatesFilter<"CustomField"> | boolean
    options?: JsonNullableWithAggregatesFilter<"CustomField">
    defaultValue?: StringNullableWithAggregatesFilter<"CustomField"> | string | null
    sortOrder?: IntWithAggregatesFilter<"CustomField"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CustomField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomField"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    workspaceId?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_name?: TagWorkspaceIdNameCompoundUniqueInput
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    workspaceId?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id" | "workspaceId_name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    workspaceId?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type AiAgentWhereInput = {
    AND?: AiAgentWhereInput | AiAgentWhereInput[]
    OR?: AiAgentWhereInput[]
    NOT?: AiAgentWhereInput | AiAgentWhereInput[]
    id?: StringFilter<"AiAgent"> | string
    workspaceId?: StringFilter<"AiAgent"> | string
    name?: StringFilter<"AiAgent"> | string
    description?: StringNullableFilter<"AiAgent"> | string | null
    systemPrompt?: StringFilter<"AiAgent"> | string
    model?: StringFilter<"AiAgent"> | string
    temperature?: FloatFilter<"AiAgent"> | number
    maxTokens?: IntFilter<"AiAgent"> | number
    isActive?: BoolFilter<"AiAgent"> | boolean
    createdAt?: DateTimeFilter<"AiAgent"> | Date | string
    updatedAt?: DateTimeFilter<"AiAgent"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    conversations?: AiConversationListRelationFilter
  }

  export type AiAgentOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    systemPrompt?: SortOrder
    model?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    conversations?: AiConversationOrderByRelationAggregateInput
  }

  export type AiAgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiAgentWhereInput | AiAgentWhereInput[]
    OR?: AiAgentWhereInput[]
    NOT?: AiAgentWhereInput | AiAgentWhereInput[]
    workspaceId?: StringFilter<"AiAgent"> | string
    name?: StringFilter<"AiAgent"> | string
    description?: StringNullableFilter<"AiAgent"> | string | null
    systemPrompt?: StringFilter<"AiAgent"> | string
    model?: StringFilter<"AiAgent"> | string
    temperature?: FloatFilter<"AiAgent"> | number
    maxTokens?: IntFilter<"AiAgent"> | number
    isActive?: BoolFilter<"AiAgent"> | boolean
    createdAt?: DateTimeFilter<"AiAgent"> | Date | string
    updatedAt?: DateTimeFilter<"AiAgent"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    conversations?: AiConversationListRelationFilter
  }, "id">

  export type AiAgentOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    systemPrompt?: SortOrder
    model?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiAgentCountOrderByAggregateInput
    _avg?: AiAgentAvgOrderByAggregateInput
    _max?: AiAgentMaxOrderByAggregateInput
    _min?: AiAgentMinOrderByAggregateInput
    _sum?: AiAgentSumOrderByAggregateInput
  }

  export type AiAgentScalarWhereWithAggregatesInput = {
    AND?: AiAgentScalarWhereWithAggregatesInput | AiAgentScalarWhereWithAggregatesInput[]
    OR?: AiAgentScalarWhereWithAggregatesInput[]
    NOT?: AiAgentScalarWhereWithAggregatesInput | AiAgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiAgent"> | string
    workspaceId?: StringWithAggregatesFilter<"AiAgent"> | string
    name?: StringWithAggregatesFilter<"AiAgent"> | string
    description?: StringNullableWithAggregatesFilter<"AiAgent"> | string | null
    systemPrompt?: StringWithAggregatesFilter<"AiAgent"> | string
    model?: StringWithAggregatesFilter<"AiAgent"> | string
    temperature?: FloatWithAggregatesFilter<"AiAgent"> | number
    maxTokens?: IntWithAggregatesFilter<"AiAgent"> | number
    isActive?: BoolWithAggregatesFilter<"AiAgent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AiAgent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiAgent"> | Date | string
  }

  export type AiConversationWhereInput = {
    AND?: AiConversationWhereInput | AiConversationWhereInput[]
    OR?: AiConversationWhereInput[]
    NOT?: AiConversationWhereInput | AiConversationWhereInput[]
    id?: StringFilter<"AiConversation"> | string
    agentId?: StringFilter<"AiConversation"> | string
    userId?: StringFilter<"AiConversation"> | string
    title?: StringNullableFilter<"AiConversation"> | string | null
    context?: JsonNullableFilter<"AiConversation">
    isActive?: BoolFilter<"AiConversation"> | boolean
    createdAt?: DateTimeFilter<"AiConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AiConversation"> | Date | string
    agent?: XOR<AiAgentRelationFilter, AiAgentWhereInput>
    messages?: AiMessageListRelationFilter
  }

  export type AiConversationOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AiAgentOrderByWithRelationInput
    messages?: AiMessageOrderByRelationAggregateInput
  }

  export type AiConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiConversationWhereInput | AiConversationWhereInput[]
    OR?: AiConversationWhereInput[]
    NOT?: AiConversationWhereInput | AiConversationWhereInput[]
    agentId?: StringFilter<"AiConversation"> | string
    userId?: StringFilter<"AiConversation"> | string
    title?: StringNullableFilter<"AiConversation"> | string | null
    context?: JsonNullableFilter<"AiConversation">
    isActive?: BoolFilter<"AiConversation"> | boolean
    createdAt?: DateTimeFilter<"AiConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AiConversation"> | Date | string
    agent?: XOR<AiAgentRelationFilter, AiAgentWhereInput>
    messages?: AiMessageListRelationFilter
  }, "id">

  export type AiConversationOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiConversationCountOrderByAggregateInput
    _max?: AiConversationMaxOrderByAggregateInput
    _min?: AiConversationMinOrderByAggregateInput
  }

  export type AiConversationScalarWhereWithAggregatesInput = {
    AND?: AiConversationScalarWhereWithAggregatesInput | AiConversationScalarWhereWithAggregatesInput[]
    OR?: AiConversationScalarWhereWithAggregatesInput[]
    NOT?: AiConversationScalarWhereWithAggregatesInput | AiConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiConversation"> | string
    agentId?: StringWithAggregatesFilter<"AiConversation"> | string
    userId?: StringWithAggregatesFilter<"AiConversation"> | string
    title?: StringNullableWithAggregatesFilter<"AiConversation"> | string | null
    context?: JsonNullableWithAggregatesFilter<"AiConversation">
    isActive?: BoolWithAggregatesFilter<"AiConversation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AiConversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiConversation"> | Date | string
  }

  export type AiMessageWhereInput = {
    AND?: AiMessageWhereInput | AiMessageWhereInput[]
    OR?: AiMessageWhereInput[]
    NOT?: AiMessageWhereInput | AiMessageWhereInput[]
    id?: StringFilter<"AiMessage"> | string
    conversationId?: StringFilter<"AiMessage"> | string
    role?: StringFilter<"AiMessage"> | string
    content?: StringFilter<"AiMessage"> | string
    tokensUsed?: IntNullableFilter<"AiMessage"> | number | null
    metadata?: JsonNullableFilter<"AiMessage">
    createdAt?: DateTimeFilter<"AiMessage"> | Date | string
    conversation?: XOR<AiConversationRelationFilter, AiConversationWhereInput>
  }

  export type AiMessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    tokensUsed?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: AiConversationOrderByWithRelationInput
  }

  export type AiMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiMessageWhereInput | AiMessageWhereInput[]
    OR?: AiMessageWhereInput[]
    NOT?: AiMessageWhereInput | AiMessageWhereInput[]
    conversationId?: StringFilter<"AiMessage"> | string
    role?: StringFilter<"AiMessage"> | string
    content?: StringFilter<"AiMessage"> | string
    tokensUsed?: IntNullableFilter<"AiMessage"> | number | null
    metadata?: JsonNullableFilter<"AiMessage">
    createdAt?: DateTimeFilter<"AiMessage"> | Date | string
    conversation?: XOR<AiConversationRelationFilter, AiConversationWhereInput>
  }, "id">

  export type AiMessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    tokensUsed?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AiMessageCountOrderByAggregateInput
    _avg?: AiMessageAvgOrderByAggregateInput
    _max?: AiMessageMaxOrderByAggregateInput
    _min?: AiMessageMinOrderByAggregateInput
    _sum?: AiMessageSumOrderByAggregateInput
  }

  export type AiMessageScalarWhereWithAggregatesInput = {
    AND?: AiMessageScalarWhereWithAggregatesInput | AiMessageScalarWhereWithAggregatesInput[]
    OR?: AiMessageScalarWhereWithAggregatesInput[]
    NOT?: AiMessageScalarWhereWithAggregatesInput | AiMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiMessage"> | string
    conversationId?: StringWithAggregatesFilter<"AiMessage"> | string
    role?: StringWithAggregatesFilter<"AiMessage"> | string
    content?: StringWithAggregatesFilter<"AiMessage"> | string
    tokensUsed?: IntNullableWithAggregatesFilter<"AiMessage"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"AiMessage">
    createdAt?: DateTimeWithAggregatesFilter<"AiMessage"> | Date | string
  }

  export type AiTokenUsageWhereInput = {
    AND?: AiTokenUsageWhereInput | AiTokenUsageWhereInput[]
    OR?: AiTokenUsageWhereInput[]
    NOT?: AiTokenUsageWhereInput | AiTokenUsageWhereInput[]
    id?: StringFilter<"AiTokenUsage"> | string
    userId?: StringFilter<"AiTokenUsage"> | string
    workspaceId?: StringFilter<"AiTokenUsage"> | string
    provider?: StringFilter<"AiTokenUsage"> | string
    model?: StringFilter<"AiTokenUsage"> | string
    tokensUsed?: IntFilter<"AiTokenUsage"> | number
    cost?: DecimalFilter<"AiTokenUsage"> | Decimal | DecimalJsLike | number | string
    purpose?: StringFilter<"AiTokenUsage"> | string
    metadata?: JsonNullableFilter<"AiTokenUsage">
    createdAt?: DateTimeFilter<"AiTokenUsage"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AiTokenUsageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    purpose?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AiTokenUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiTokenUsageWhereInput | AiTokenUsageWhereInput[]
    OR?: AiTokenUsageWhereInput[]
    NOT?: AiTokenUsageWhereInput | AiTokenUsageWhereInput[]
    userId?: StringFilter<"AiTokenUsage"> | string
    workspaceId?: StringFilter<"AiTokenUsage"> | string
    provider?: StringFilter<"AiTokenUsage"> | string
    model?: StringFilter<"AiTokenUsage"> | string
    tokensUsed?: IntFilter<"AiTokenUsage"> | number
    cost?: DecimalFilter<"AiTokenUsage"> | Decimal | DecimalJsLike | number | string
    purpose?: StringFilter<"AiTokenUsage"> | string
    metadata?: JsonNullableFilter<"AiTokenUsage">
    createdAt?: DateTimeFilter<"AiTokenUsage"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AiTokenUsageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    purpose?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AiTokenUsageCountOrderByAggregateInput
    _avg?: AiTokenUsageAvgOrderByAggregateInput
    _max?: AiTokenUsageMaxOrderByAggregateInput
    _min?: AiTokenUsageMinOrderByAggregateInput
    _sum?: AiTokenUsageSumOrderByAggregateInput
  }

  export type AiTokenUsageScalarWhereWithAggregatesInput = {
    AND?: AiTokenUsageScalarWhereWithAggregatesInput | AiTokenUsageScalarWhereWithAggregatesInput[]
    OR?: AiTokenUsageScalarWhereWithAggregatesInput[]
    NOT?: AiTokenUsageScalarWhereWithAggregatesInput | AiTokenUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiTokenUsage"> | string
    userId?: StringWithAggregatesFilter<"AiTokenUsage"> | string
    workspaceId?: StringWithAggregatesFilter<"AiTokenUsage"> | string
    provider?: StringWithAggregatesFilter<"AiTokenUsage"> | string
    model?: StringWithAggregatesFilter<"AiTokenUsage"> | string
    tokensUsed?: IntWithAggregatesFilter<"AiTokenUsage"> | number
    cost?: DecimalWithAggregatesFilter<"AiTokenUsage"> | Decimal | DecimalJsLike | number | string
    purpose?: StringWithAggregatesFilter<"AiTokenUsage"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AiTokenUsage">
    createdAt?: DateTimeWithAggregatesFilter<"AiTokenUsage"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isSystem?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    description?: StringNullableFilter<"Permission"> | string | null
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    resource?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolePermission"> | string
    roleId?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type UsageTrackingWhereInput = {
    AND?: UsageTrackingWhereInput | UsageTrackingWhereInput[]
    OR?: UsageTrackingWhereInput[]
    NOT?: UsageTrackingWhereInput | UsageTrackingWhereInput[]
    id?: StringFilter<"UsageTracking"> | string
    userId?: StringFilter<"UsageTracking"> | string
    workspaceId?: StringFilter<"UsageTracking"> | string
    resourceType?: StringFilter<"UsageTracking"> | string
    resourceId?: StringFilter<"UsageTracking"> | string
    action?: StringFilter<"UsageTracking"> | string
    quantity?: IntFilter<"UsageTracking"> | number
    metadata?: JsonNullableFilter<"UsageTracking">
    timestamp?: DateTimeFilter<"UsageTracking"> | Date | string
  }

  export type UsageTrackingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type UsageTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageTrackingWhereInput | UsageTrackingWhereInput[]
    OR?: UsageTrackingWhereInput[]
    NOT?: UsageTrackingWhereInput | UsageTrackingWhereInput[]
    userId?: StringFilter<"UsageTracking"> | string
    workspaceId?: StringFilter<"UsageTracking"> | string
    resourceType?: StringFilter<"UsageTracking"> | string
    resourceId?: StringFilter<"UsageTracking"> | string
    action?: StringFilter<"UsageTracking"> | string
    quantity?: IntFilter<"UsageTracking"> | number
    metadata?: JsonNullableFilter<"UsageTracking">
    timestamp?: DateTimeFilter<"UsageTracking"> | Date | string
  }, "id">

  export type UsageTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: UsageTrackingCountOrderByAggregateInput
    _avg?: UsageTrackingAvgOrderByAggregateInput
    _max?: UsageTrackingMaxOrderByAggregateInput
    _min?: UsageTrackingMinOrderByAggregateInput
    _sum?: UsageTrackingSumOrderByAggregateInput
  }

  export type UsageTrackingScalarWhereWithAggregatesInput = {
    AND?: UsageTrackingScalarWhereWithAggregatesInput | UsageTrackingScalarWhereWithAggregatesInput[]
    OR?: UsageTrackingScalarWhereWithAggregatesInput[]
    NOT?: UsageTrackingScalarWhereWithAggregatesInput | UsageTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageTracking"> | string
    userId?: StringWithAggregatesFilter<"UsageTracking"> | string
    workspaceId?: StringWithAggregatesFilter<"UsageTracking"> | string
    resourceType?: StringWithAggregatesFilter<"UsageTracking"> | string
    resourceId?: StringWithAggregatesFilter<"UsageTracking"> | string
    action?: StringWithAggregatesFilter<"UsageTracking"> | string
    quantity?: IntWithAggregatesFilter<"UsageTracking"> | number
    metadata?: JsonNullableWithAggregatesFilter<"UsageTracking">
    timestamp?: DateTimeWithAggregatesFilter<"UsageTracking"> | Date | string
  }

  export type UsageReportWhereInput = {
    AND?: UsageReportWhereInput | UsageReportWhereInput[]
    OR?: UsageReportWhereInput[]
    NOT?: UsageReportWhereInput | UsageReportWhereInput[]
    id?: StringFilter<"UsageReport"> | string
    workspaceId?: StringFilter<"UsageReport"> | string
    reportType?: StringFilter<"UsageReport"> | string
    periodStart?: DateTimeFilter<"UsageReport"> | Date | string
    periodEnd?: DateTimeFilter<"UsageReport"> | Date | string
    totalUploads?: IntFilter<"UsageReport"> | number
    totalMinutes?: IntFilter<"UsageReport"> | number
    totalStorage?: BigIntFilter<"UsageReport"> | bigint | number
    reportData?: JsonFilter<"UsageReport">
    generatedAt?: DateTimeFilter<"UsageReport"> | Date | string
  }

  export type UsageReportOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    reportType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalUploads?: SortOrder
    totalMinutes?: SortOrder
    totalStorage?: SortOrder
    reportData?: SortOrder
    generatedAt?: SortOrder
  }

  export type UsageReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_reportType_periodStart?: UsageReportWorkspaceIdReportTypePeriodStartCompoundUniqueInput
    AND?: UsageReportWhereInput | UsageReportWhereInput[]
    OR?: UsageReportWhereInput[]
    NOT?: UsageReportWhereInput | UsageReportWhereInput[]
    workspaceId?: StringFilter<"UsageReport"> | string
    reportType?: StringFilter<"UsageReport"> | string
    periodStart?: DateTimeFilter<"UsageReport"> | Date | string
    periodEnd?: DateTimeFilter<"UsageReport"> | Date | string
    totalUploads?: IntFilter<"UsageReport"> | number
    totalMinutes?: IntFilter<"UsageReport"> | number
    totalStorage?: BigIntFilter<"UsageReport"> | bigint | number
    reportData?: JsonFilter<"UsageReport">
    generatedAt?: DateTimeFilter<"UsageReport"> | Date | string
  }, "id" | "workspaceId_reportType_periodStart">

  export type UsageReportOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    reportType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalUploads?: SortOrder
    totalMinutes?: SortOrder
    totalStorage?: SortOrder
    reportData?: SortOrder
    generatedAt?: SortOrder
    _count?: UsageReportCountOrderByAggregateInput
    _avg?: UsageReportAvgOrderByAggregateInput
    _max?: UsageReportMaxOrderByAggregateInput
    _min?: UsageReportMinOrderByAggregateInput
    _sum?: UsageReportSumOrderByAggregateInput
  }

  export type UsageReportScalarWhereWithAggregatesInput = {
    AND?: UsageReportScalarWhereWithAggregatesInput | UsageReportScalarWhereWithAggregatesInput[]
    OR?: UsageReportScalarWhereWithAggregatesInput[]
    NOT?: UsageReportScalarWhereWithAggregatesInput | UsageReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageReport"> | string
    workspaceId?: StringWithAggregatesFilter<"UsageReport"> | string
    reportType?: StringWithAggregatesFilter<"UsageReport"> | string
    periodStart?: DateTimeWithAggregatesFilter<"UsageReport"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"UsageReport"> | Date | string
    totalUploads?: IntWithAggregatesFilter<"UsageReport"> | number
    totalMinutes?: IntWithAggregatesFilter<"UsageReport"> | number
    totalStorage?: BigIntWithAggregatesFilter<"UsageReport"> | bigint | number
    reportData?: JsonWithAggregatesFilter<"UsageReport">
    generatedAt?: DateTimeWithAggregatesFilter<"UsageReport"> | Date | string
  }

  export type PaymentGatewayConfigWhereInput = {
    AND?: PaymentGatewayConfigWhereInput | PaymentGatewayConfigWhereInput[]
    OR?: PaymentGatewayConfigWhereInput[]
    NOT?: PaymentGatewayConfigWhereInput | PaymentGatewayConfigWhereInput[]
    id?: StringFilter<"PaymentGatewayConfig"> | string
    provider?: StringFilter<"PaymentGatewayConfig"> | string
    environment?: StringFilter<"PaymentGatewayConfig"> | string
    isActive?: BoolFilter<"PaymentGatewayConfig"> | boolean
    config?: JsonFilter<"PaymentGatewayConfig">
    createdAt?: DateTimeFilter<"PaymentGatewayConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentGatewayConfig"> | Date | string
  }

  export type PaymentGatewayConfigOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentGatewayConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_environment?: PaymentGatewayConfigProviderEnvironmentCompoundUniqueInput
    AND?: PaymentGatewayConfigWhereInput | PaymentGatewayConfigWhereInput[]
    OR?: PaymentGatewayConfigWhereInput[]
    NOT?: PaymentGatewayConfigWhereInput | PaymentGatewayConfigWhereInput[]
    provider?: StringFilter<"PaymentGatewayConfig"> | string
    environment?: StringFilter<"PaymentGatewayConfig"> | string
    isActive?: BoolFilter<"PaymentGatewayConfig"> | boolean
    config?: JsonFilter<"PaymentGatewayConfig">
    createdAt?: DateTimeFilter<"PaymentGatewayConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentGatewayConfig"> | Date | string
  }, "id" | "provider_environment">

  export type PaymentGatewayConfigOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentGatewayConfigCountOrderByAggregateInput
    _max?: PaymentGatewayConfigMaxOrderByAggregateInput
    _min?: PaymentGatewayConfigMinOrderByAggregateInput
  }

  export type PaymentGatewayConfigScalarWhereWithAggregatesInput = {
    AND?: PaymentGatewayConfigScalarWhereWithAggregatesInput | PaymentGatewayConfigScalarWhereWithAggregatesInput[]
    OR?: PaymentGatewayConfigScalarWhereWithAggregatesInput[]
    NOT?: PaymentGatewayConfigScalarWhereWithAggregatesInput | PaymentGatewayConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentGatewayConfig"> | string
    provider?: StringWithAggregatesFilter<"PaymentGatewayConfig"> | string
    environment?: StringWithAggregatesFilter<"PaymentGatewayConfig"> | string
    isActive?: BoolWithAggregatesFilter<"PaymentGatewayConfig"> | boolean
    config?: JsonWithAggregatesFilter<"PaymentGatewayConfig">
    createdAt?: DateTimeWithAggregatesFilter<"PaymentGatewayConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentGatewayConfig"> | Date | string
  }

  export type PlanPricingWhereInput = {
    AND?: PlanPricingWhereInput | PlanPricingWhereInput[]
    OR?: PlanPricingWhereInput[]
    NOT?: PlanPricingWhereInput | PlanPricingWhereInput[]
    id?: StringFilter<"PlanPricing"> | string
    planId?: StringFilter<"PlanPricing"> | string
    currency?: StringFilter<"PlanPricing"> | string
    price?: DecimalFilter<"PlanPricing"> | Decimal | DecimalJsLike | number | string
    interval?: StringFilter<"PlanPricing"> | string
    isActive?: BoolFilter<"PlanPricing"> | boolean
    createdAt?: DateTimeFilter<"PlanPricing"> | Date | string
    updatedAt?: DateTimeFilter<"PlanPricing"> | Date | string
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
  }

  export type PlanPricingOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    price?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SubscriptionPlanOrderByWithRelationInput
  }

  export type PlanPricingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planId_currency_interval?: PlanPricingPlanIdCurrencyIntervalCompoundUniqueInput
    AND?: PlanPricingWhereInput | PlanPricingWhereInput[]
    OR?: PlanPricingWhereInput[]
    NOT?: PlanPricingWhereInput | PlanPricingWhereInput[]
    planId?: StringFilter<"PlanPricing"> | string
    currency?: StringFilter<"PlanPricing"> | string
    price?: DecimalFilter<"PlanPricing"> | Decimal | DecimalJsLike | number | string
    interval?: StringFilter<"PlanPricing"> | string
    isActive?: BoolFilter<"PlanPricing"> | boolean
    createdAt?: DateTimeFilter<"PlanPricing"> | Date | string
    updatedAt?: DateTimeFilter<"PlanPricing"> | Date | string
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
  }, "id" | "planId_currency_interval">

  export type PlanPricingOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    price?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanPricingCountOrderByAggregateInput
    _avg?: PlanPricingAvgOrderByAggregateInput
    _max?: PlanPricingMaxOrderByAggregateInput
    _min?: PlanPricingMinOrderByAggregateInput
    _sum?: PlanPricingSumOrderByAggregateInput
  }

  export type PlanPricingScalarWhereWithAggregatesInput = {
    AND?: PlanPricingScalarWhereWithAggregatesInput | PlanPricingScalarWhereWithAggregatesInput[]
    OR?: PlanPricingScalarWhereWithAggregatesInput[]
    NOT?: PlanPricingScalarWhereWithAggregatesInput | PlanPricingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanPricing"> | string
    planId?: StringWithAggregatesFilter<"PlanPricing"> | string
    currency?: StringWithAggregatesFilter<"PlanPricing"> | string
    price?: DecimalWithAggregatesFilter<"PlanPricing"> | Decimal | DecimalJsLike | number | string
    interval?: StringWithAggregatesFilter<"PlanPricing"> | string
    isActive?: BoolWithAggregatesFilter<"PlanPricing"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlanPricing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanPricing"> | Date | string
  }

  export type EwayTransactionWhereInput = {
    AND?: EwayTransactionWhereInput | EwayTransactionWhereInput[]
    OR?: EwayTransactionWhereInput[]
    NOT?: EwayTransactionWhereInput | EwayTransactionWhereInput[]
    id?: StringFilter<"EwayTransaction"> | string
    transactionId?: StringFilter<"EwayTransaction"> | string
    customerToken?: StringNullableFilter<"EwayTransaction"> | string | null
    amount?: DecimalFilter<"EwayTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"EwayTransaction"> | string
    status?: StringFilter<"EwayTransaction"> | string
    transactionStatus?: StringFilter<"EwayTransaction"> | string
    responseCode?: StringNullableFilter<"EwayTransaction"> | string | null
    responseMessage?: StringNullableFilter<"EwayTransaction"> | string | null
    authCode?: StringNullableFilter<"EwayTransaction"> | string | null
    beagleScore?: IntNullableFilter<"EwayTransaction"> | number | null
    metadata?: JsonFilter<"EwayTransaction">
    createdAt?: DateTimeFilter<"EwayTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"EwayTransaction"> | Date | string
    ewayCustomer?: XOR<EwayCustomerNullableRelationFilter, EwayCustomerWhereInput> | null
  }

  export type EwayTransactionOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerToken?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    transactionStatus?: SortOrder
    responseCode?: SortOrderInput | SortOrder
    responseMessage?: SortOrderInput | SortOrder
    authCode?: SortOrderInput | SortOrder
    beagleScore?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ewayCustomer?: EwayCustomerOrderByWithRelationInput
  }

  export type EwayTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: EwayTransactionWhereInput | EwayTransactionWhereInput[]
    OR?: EwayTransactionWhereInput[]
    NOT?: EwayTransactionWhereInput | EwayTransactionWhereInput[]
    customerToken?: StringNullableFilter<"EwayTransaction"> | string | null
    amount?: DecimalFilter<"EwayTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"EwayTransaction"> | string
    status?: StringFilter<"EwayTransaction"> | string
    transactionStatus?: StringFilter<"EwayTransaction"> | string
    responseCode?: StringNullableFilter<"EwayTransaction"> | string | null
    responseMessage?: StringNullableFilter<"EwayTransaction"> | string | null
    authCode?: StringNullableFilter<"EwayTransaction"> | string | null
    beagleScore?: IntNullableFilter<"EwayTransaction"> | number | null
    metadata?: JsonFilter<"EwayTransaction">
    createdAt?: DateTimeFilter<"EwayTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"EwayTransaction"> | Date | string
    ewayCustomer?: XOR<EwayCustomerNullableRelationFilter, EwayCustomerWhereInput> | null
  }, "id" | "transactionId">

  export type EwayTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerToken?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    transactionStatus?: SortOrder
    responseCode?: SortOrderInput | SortOrder
    responseMessage?: SortOrderInput | SortOrder
    authCode?: SortOrderInput | SortOrder
    beagleScore?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EwayTransactionCountOrderByAggregateInput
    _avg?: EwayTransactionAvgOrderByAggregateInput
    _max?: EwayTransactionMaxOrderByAggregateInput
    _min?: EwayTransactionMinOrderByAggregateInput
    _sum?: EwayTransactionSumOrderByAggregateInput
  }

  export type EwayTransactionScalarWhereWithAggregatesInput = {
    AND?: EwayTransactionScalarWhereWithAggregatesInput | EwayTransactionScalarWhereWithAggregatesInput[]
    OR?: EwayTransactionScalarWhereWithAggregatesInput[]
    NOT?: EwayTransactionScalarWhereWithAggregatesInput | EwayTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EwayTransaction"> | string
    transactionId?: StringWithAggregatesFilter<"EwayTransaction"> | string
    customerToken?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    amount?: DecimalWithAggregatesFilter<"EwayTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"EwayTransaction"> | string
    status?: StringWithAggregatesFilter<"EwayTransaction"> | string
    transactionStatus?: StringWithAggregatesFilter<"EwayTransaction"> | string
    responseCode?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    responseMessage?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    authCode?: StringNullableWithAggregatesFilter<"EwayTransaction"> | string | null
    beagleScore?: IntNullableWithAggregatesFilter<"EwayTransaction"> | number | null
    metadata?: JsonWithAggregatesFilter<"EwayTransaction">
    createdAt?: DateTimeWithAggregatesFilter<"EwayTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EwayTransaction"> | Date | string
  }

  export type EwayCustomerWhereInput = {
    AND?: EwayCustomerWhereInput | EwayCustomerWhereInput[]
    OR?: EwayCustomerWhereInput[]
    NOT?: EwayCustomerWhereInput | EwayCustomerWhereInput[]
    id?: StringFilter<"EwayCustomer"> | string
    customerToken?: StringFilter<"EwayCustomer"> | string
    firstName?: StringNullableFilter<"EwayCustomer"> | string | null
    lastName?: StringNullableFilter<"EwayCustomer"> | string | null
    email?: StringNullableFilter<"EwayCustomer"> | string | null
    phone?: StringNullableFilter<"EwayCustomer"> | string | null
    address?: JsonNullableFilter<"EwayCustomer">
    cardNumber?: StringNullableFilter<"EwayCustomer"> | string | null
    cardName?: StringNullableFilter<"EwayCustomer"> | string | null
    cardExpiryMonth?: StringNullableFilter<"EwayCustomer"> | string | null
    cardExpiryYear?: StringNullableFilter<"EwayCustomer"> | string | null
    isActive?: BoolFilter<"EwayCustomer"> | boolean
    metadata?: JsonFilter<"EwayCustomer">
    createdAt?: DateTimeFilter<"EwayCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"EwayCustomer"> | Date | string
    transactions?: EwayTransactionListRelationFilter
    recurringSchedules?: EwayRecurringScheduleListRelationFilter
  }

  export type EwayCustomerOrderByWithRelationInput = {
    id?: SortOrder
    customerToken?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    cardNumber?: SortOrderInput | SortOrder
    cardName?: SortOrderInput | SortOrder
    cardExpiryMonth?: SortOrderInput | SortOrder
    cardExpiryYear?: SortOrderInput | SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: EwayTransactionOrderByRelationAggregateInput
    recurringSchedules?: EwayRecurringScheduleOrderByRelationAggregateInput
  }

  export type EwayCustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerToken?: string
    AND?: EwayCustomerWhereInput | EwayCustomerWhereInput[]
    OR?: EwayCustomerWhereInput[]
    NOT?: EwayCustomerWhereInput | EwayCustomerWhereInput[]
    firstName?: StringNullableFilter<"EwayCustomer"> | string | null
    lastName?: StringNullableFilter<"EwayCustomer"> | string | null
    email?: StringNullableFilter<"EwayCustomer"> | string | null
    phone?: StringNullableFilter<"EwayCustomer"> | string | null
    address?: JsonNullableFilter<"EwayCustomer">
    cardNumber?: StringNullableFilter<"EwayCustomer"> | string | null
    cardName?: StringNullableFilter<"EwayCustomer"> | string | null
    cardExpiryMonth?: StringNullableFilter<"EwayCustomer"> | string | null
    cardExpiryYear?: StringNullableFilter<"EwayCustomer"> | string | null
    isActive?: BoolFilter<"EwayCustomer"> | boolean
    metadata?: JsonFilter<"EwayCustomer">
    createdAt?: DateTimeFilter<"EwayCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"EwayCustomer"> | Date | string
    transactions?: EwayTransactionListRelationFilter
    recurringSchedules?: EwayRecurringScheduleListRelationFilter
  }, "id" | "customerToken">

  export type EwayCustomerOrderByWithAggregationInput = {
    id?: SortOrder
    customerToken?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    cardNumber?: SortOrderInput | SortOrder
    cardName?: SortOrderInput | SortOrder
    cardExpiryMonth?: SortOrderInput | SortOrder
    cardExpiryYear?: SortOrderInput | SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EwayCustomerCountOrderByAggregateInput
    _max?: EwayCustomerMaxOrderByAggregateInput
    _min?: EwayCustomerMinOrderByAggregateInput
  }

  export type EwayCustomerScalarWhereWithAggregatesInput = {
    AND?: EwayCustomerScalarWhereWithAggregatesInput | EwayCustomerScalarWhereWithAggregatesInput[]
    OR?: EwayCustomerScalarWhereWithAggregatesInput[]
    NOT?: EwayCustomerScalarWhereWithAggregatesInput | EwayCustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EwayCustomer"> | string
    customerToken?: StringWithAggregatesFilter<"EwayCustomer"> | string
    firstName?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    email?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    address?: JsonNullableWithAggregatesFilter<"EwayCustomer">
    cardNumber?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    cardName?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    cardExpiryMonth?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    cardExpiryYear?: StringNullableWithAggregatesFilter<"EwayCustomer"> | string | null
    isActive?: BoolWithAggregatesFilter<"EwayCustomer"> | boolean
    metadata?: JsonWithAggregatesFilter<"EwayCustomer">
    createdAt?: DateTimeWithAggregatesFilter<"EwayCustomer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EwayCustomer"> | Date | string
  }

  export type EwayRecurringScheduleWhereInput = {
    AND?: EwayRecurringScheduleWhereInput | EwayRecurringScheduleWhereInput[]
    OR?: EwayRecurringScheduleWhereInput[]
    NOT?: EwayRecurringScheduleWhereInput | EwayRecurringScheduleWhereInput[]
    id?: StringFilter<"EwayRecurringSchedule"> | string
    customerToken?: StringFilter<"EwayRecurringSchedule"> | string
    interval?: StringFilter<"EwayRecurringSchedule"> | string
    amount?: DecimalFilter<"EwayRecurringSchedule"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"EwayRecurringSchedule"> | string
    status?: StringFilter<"EwayRecurringSchedule"> | string
    nextPayment?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    lastPayment?: DateTimeNullableFilter<"EwayRecurringSchedule"> | Date | string | null
    paymentCount?: IntFilter<"EwayRecurringSchedule"> | number
    maxPayments?: IntNullableFilter<"EwayRecurringSchedule"> | number | null
    metadata?: JsonFilter<"EwayRecurringSchedule">
    createdAt?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    ewayCustomer?: XOR<EwayCustomerRelationFilter, EwayCustomerWhereInput>
  }

  export type EwayRecurringScheduleOrderByWithRelationInput = {
    id?: SortOrder
    customerToken?: SortOrder
    interval?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    nextPayment?: SortOrder
    lastPayment?: SortOrderInput | SortOrder
    paymentCount?: SortOrder
    maxPayments?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ewayCustomer?: EwayCustomerOrderByWithRelationInput
  }

  export type EwayRecurringScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EwayRecurringScheduleWhereInput | EwayRecurringScheduleWhereInput[]
    OR?: EwayRecurringScheduleWhereInput[]
    NOT?: EwayRecurringScheduleWhereInput | EwayRecurringScheduleWhereInput[]
    customerToken?: StringFilter<"EwayRecurringSchedule"> | string
    interval?: StringFilter<"EwayRecurringSchedule"> | string
    amount?: DecimalFilter<"EwayRecurringSchedule"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"EwayRecurringSchedule"> | string
    status?: StringFilter<"EwayRecurringSchedule"> | string
    nextPayment?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    lastPayment?: DateTimeNullableFilter<"EwayRecurringSchedule"> | Date | string | null
    paymentCount?: IntFilter<"EwayRecurringSchedule"> | number
    maxPayments?: IntNullableFilter<"EwayRecurringSchedule"> | number | null
    metadata?: JsonFilter<"EwayRecurringSchedule">
    createdAt?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    ewayCustomer?: XOR<EwayCustomerRelationFilter, EwayCustomerWhereInput>
  }, "id">

  export type EwayRecurringScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    customerToken?: SortOrder
    interval?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    nextPayment?: SortOrder
    lastPayment?: SortOrderInput | SortOrder
    paymentCount?: SortOrder
    maxPayments?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EwayRecurringScheduleCountOrderByAggregateInput
    _avg?: EwayRecurringScheduleAvgOrderByAggregateInput
    _max?: EwayRecurringScheduleMaxOrderByAggregateInput
    _min?: EwayRecurringScheduleMinOrderByAggregateInput
    _sum?: EwayRecurringScheduleSumOrderByAggregateInput
  }

  export type EwayRecurringScheduleScalarWhereWithAggregatesInput = {
    AND?: EwayRecurringScheduleScalarWhereWithAggregatesInput | EwayRecurringScheduleScalarWhereWithAggregatesInput[]
    OR?: EwayRecurringScheduleScalarWhereWithAggregatesInput[]
    NOT?: EwayRecurringScheduleScalarWhereWithAggregatesInput | EwayRecurringScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EwayRecurringSchedule"> | string
    customerToken?: StringWithAggregatesFilter<"EwayRecurringSchedule"> | string
    interval?: StringWithAggregatesFilter<"EwayRecurringSchedule"> | string
    amount?: DecimalWithAggregatesFilter<"EwayRecurringSchedule"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"EwayRecurringSchedule"> | string
    status?: StringWithAggregatesFilter<"EwayRecurringSchedule"> | string
    nextPayment?: DateTimeWithAggregatesFilter<"EwayRecurringSchedule"> | Date | string
    lastPayment?: DateTimeNullableWithAggregatesFilter<"EwayRecurringSchedule"> | Date | string | null
    paymentCount?: IntWithAggregatesFilter<"EwayRecurringSchedule"> | number
    maxPayments?: IntNullableWithAggregatesFilter<"EwayRecurringSchedule"> | number | null
    metadata?: JsonWithAggregatesFilter<"EwayRecurringSchedule">
    createdAt?: DateTimeWithAggregatesFilter<"EwayRecurringSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EwayRecurringSchedule"> | Date | string
  }

  export type EwayWebhookEventWhereInput = {
    AND?: EwayWebhookEventWhereInput | EwayWebhookEventWhereInput[]
    OR?: EwayWebhookEventWhereInput[]
    NOT?: EwayWebhookEventWhereInput | EwayWebhookEventWhereInput[]
    id?: StringFilter<"EwayWebhookEvent"> | string
    eventType?: StringFilter<"EwayWebhookEvent"> | string
    transactionId?: StringNullableFilter<"EwayWebhookEvent"> | string | null
    customerToken?: StringNullableFilter<"EwayWebhookEvent"> | string | null
    payload?: JsonFilter<"EwayWebhookEvent">
    processed?: BoolFilter<"EwayWebhookEvent"> | boolean
    processedAt?: DateTimeNullableFilter<"EwayWebhookEvent"> | Date | string | null
    error?: StringNullableFilter<"EwayWebhookEvent"> | string | null
    retryCount?: IntFilter<"EwayWebhookEvent"> | number
    createdAt?: DateTimeFilter<"EwayWebhookEvent"> | Date | string
  }

  export type EwayWebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    customerToken?: SortOrderInput | SortOrder
    payload?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
  }

  export type EwayWebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EwayWebhookEventWhereInput | EwayWebhookEventWhereInput[]
    OR?: EwayWebhookEventWhereInput[]
    NOT?: EwayWebhookEventWhereInput | EwayWebhookEventWhereInput[]
    eventType?: StringFilter<"EwayWebhookEvent"> | string
    transactionId?: StringNullableFilter<"EwayWebhookEvent"> | string | null
    customerToken?: StringNullableFilter<"EwayWebhookEvent"> | string | null
    payload?: JsonFilter<"EwayWebhookEvent">
    processed?: BoolFilter<"EwayWebhookEvent"> | boolean
    processedAt?: DateTimeNullableFilter<"EwayWebhookEvent"> | Date | string | null
    error?: StringNullableFilter<"EwayWebhookEvent"> | string | null
    retryCount?: IntFilter<"EwayWebhookEvent"> | number
    createdAt?: DateTimeFilter<"EwayWebhookEvent"> | Date | string
  }, "id">

  export type EwayWebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    customerToken?: SortOrderInput | SortOrder
    payload?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    _count?: EwayWebhookEventCountOrderByAggregateInput
    _avg?: EwayWebhookEventAvgOrderByAggregateInput
    _max?: EwayWebhookEventMaxOrderByAggregateInput
    _min?: EwayWebhookEventMinOrderByAggregateInput
    _sum?: EwayWebhookEventSumOrderByAggregateInput
  }

  export type EwayWebhookEventScalarWhereWithAggregatesInput = {
    AND?: EwayWebhookEventScalarWhereWithAggregatesInput | EwayWebhookEventScalarWhereWithAggregatesInput[]
    OR?: EwayWebhookEventScalarWhereWithAggregatesInput[]
    NOT?: EwayWebhookEventScalarWhereWithAggregatesInput | EwayWebhookEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EwayWebhookEvent"> | string
    eventType?: StringWithAggregatesFilter<"EwayWebhookEvent"> | string
    transactionId?: StringNullableWithAggregatesFilter<"EwayWebhookEvent"> | string | null
    customerToken?: StringNullableWithAggregatesFilter<"EwayWebhookEvent"> | string | null
    payload?: JsonWithAggregatesFilter<"EwayWebhookEvent">
    processed?: BoolWithAggregatesFilter<"EwayWebhookEvent"> | boolean
    processedAt?: DateTimeNullableWithAggregatesFilter<"EwayWebhookEvent"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"EwayWebhookEvent"> | string | null
    retryCount?: IntWithAggregatesFilter<"EwayWebhookEvent"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EwayWebhookEvent"> | Date | string
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    key?: StringFilter<"SystemConfig"> | string
    value?: JsonFilter<"SystemConfig">
    description?: StringNullableFilter<"SystemConfig"> | string | null
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: JsonFilter<"SystemConfig">
    description?: StringNullableFilter<"SystemConfig"> | string | null
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "key">

  export type SystemConfigOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: JsonWithAggregatesFilter<"SystemConfig">
    description?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type HealthCheckWhereInput = {
    AND?: HealthCheckWhereInput | HealthCheckWhereInput[]
    OR?: HealthCheckWhereInput[]
    NOT?: HealthCheckWhereInput | HealthCheckWhereInput[]
    id?: StringFilter<"HealthCheck"> | string
    service?: StringFilter<"HealthCheck"> | string
    status?: StringFilter<"HealthCheck"> | string
    responseTime?: IntFilter<"HealthCheck"> | number
    details?: JsonNullableFilter<"HealthCheck">
    checkedAt?: DateTimeFilter<"HealthCheck"> | Date | string
  }

  export type HealthCheckOrderByWithRelationInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    details?: SortOrderInput | SortOrder
    checkedAt?: SortOrder
  }

  export type HealthCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HealthCheckWhereInput | HealthCheckWhereInput[]
    OR?: HealthCheckWhereInput[]
    NOT?: HealthCheckWhereInput | HealthCheckWhereInput[]
    service?: StringFilter<"HealthCheck"> | string
    status?: StringFilter<"HealthCheck"> | string
    responseTime?: IntFilter<"HealthCheck"> | number
    details?: JsonNullableFilter<"HealthCheck">
    checkedAt?: DateTimeFilter<"HealthCheck"> | Date | string
  }, "id">

  export type HealthCheckOrderByWithAggregationInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    details?: SortOrderInput | SortOrder
    checkedAt?: SortOrder
    _count?: HealthCheckCountOrderByAggregateInput
    _avg?: HealthCheckAvgOrderByAggregateInput
    _max?: HealthCheckMaxOrderByAggregateInput
    _min?: HealthCheckMinOrderByAggregateInput
    _sum?: HealthCheckSumOrderByAggregateInput
  }

  export type HealthCheckScalarWhereWithAggregatesInput = {
    AND?: HealthCheckScalarWhereWithAggregatesInput | HealthCheckScalarWhereWithAggregatesInput[]
    OR?: HealthCheckScalarWhereWithAggregatesInput[]
    NOT?: HealthCheckScalarWhereWithAggregatesInput | HealthCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HealthCheck"> | string
    service?: StringWithAggregatesFilter<"HealthCheck"> | string
    status?: StringWithAggregatesFilter<"HealthCheck"> | string
    responseTime?: IntWithAggregatesFilter<"HealthCheck"> | number
    details?: JsonNullableWithAggregatesFilter<"HealthCheck">
    checkedAt?: DateTimeWithAggregatesFilter<"HealthCheck"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldCreateNestedManyWithoutWorkspaceInput
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserCreateInput = {
    id?: string
    role?: string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutWorkspacesInput
  }

  export type WorkspaceUserUncheckedCreateInput = {
    id?: string
    workspaceId: string
    userId: string
    role?: string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string | null
  }

  export type WorkspaceUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
  }

  export type WorkspaceUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceUserCreateManyInput = {
    id?: string
    workspaceId: string
    userId: string
    role?: string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string | null
  }

  export type WorkspaceUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationCreateInput = {
    id?: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
  }

  export type WorkspaceInvitationUncheckedCreateInput = {
    id?: string
    workspaceId: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationCreateManyInput = {
    id?: string
    workspaceId: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioUploadCreateInput = {
    id?: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAudioUploadsInput
    workspace: WorkspaceCreateNestedOneWithoutAudioUploadsInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkCreateNestedManyWithoutUploadInput
    fileStorage?: FileStorageCreateNestedOneWithoutUploadInput
  }

  export type AudioUploadUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkUncheckedCreateNestedManyWithoutUploadInput
    fileStorage?: FileStorageUncheckedCreateNestedOneWithoutUploadInput
  }

  export type AudioUploadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioUploadsNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutAudioUploadsNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUpdateManyWithoutUploadNestedInput
    fileStorage?: FileStorageUpdateOneWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUncheckedUpdateManyWithoutUploadNestedInput
    fileStorage?: FileStorageUncheckedUpdateOneWithoutUploadNestedInput
  }

  export type AudioUploadCreateManyInput = {
    id?: string
    userId: string
    workspaceId: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioUploadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioUploadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessingJobCreateInput = {
    id?: string
    jobType: string
    status?: string
    priority?: number
    progress?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    upload: AudioUploadCreateNestedOneWithoutProcessingJobsInput
    audioHistory?: AudioHistoryCreateNestedOneWithoutProcessingJobInput
  }

  export type ProcessingJobUncheckedCreateInput = {
    id?: string
    uploadId: string
    jobType: string
    status?: string
    priority?: number
    progress?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    audioHistory?: AudioHistoryUncheckedCreateNestedOneWithoutProcessingJobInput
  }

  export type ProcessingJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upload?: AudioUploadUpdateOneRequiredWithoutProcessingJobsNestedInput
    audioHistory?: AudioHistoryUpdateOneWithoutProcessingJobNestedInput
  }

  export type ProcessingJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioHistory?: AudioHistoryUncheckedUpdateOneWithoutProcessingJobNestedInput
  }

  export type ProcessingJobCreateManyInput = {
    id?: string
    uploadId: string
    jobType: string
    status?: string
    priority?: number
    progress?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessingJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessingJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioHistoryCreateInput = {
    id?: string
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAudioHistoryInput
    workspace?: WorkspaceCreateNestedOneWithoutAudioHistoryInput
    processingJob?: ProcessingJobCreateNestedOneWithoutAudioHistoryInput
    segments?: AudioSegmentCreateNestedManyWithoutAudioHistoryInput
  }

  export type AudioHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    processingJobId?: string | null
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
    segments?: AudioSegmentUncheckedCreateNestedManyWithoutAudioHistoryInput
  }

  export type AudioHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioHistoryNestedInput
    workspace?: WorkspaceUpdateOneWithoutAudioHistoryNestedInput
    processingJob?: ProcessingJobUpdateOneWithoutAudioHistoryNestedInput
    segments?: AudioSegmentUpdateManyWithoutAudioHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    processingJobId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segments?: AudioSegmentUncheckedUpdateManyWithoutAudioHistoryNestedInput
  }

  export type AudioHistoryCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    processingJobId?: string | null
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
  }

  export type AudioHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    processingJobId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioSegmentCreateInput = {
    id?: string
    startTime: number
    endTime: number
    text: string
    speaker?: string | null
    confidence?: number | null
    keywords?: AudioSegmentCreatekeywordsInput | string[]
    sentiment?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    audioHistory: AudioHistoryCreateNestedOneWithoutSegmentsInput
    user: UserCreateNestedOneWithoutAudioSegmentsInput
  }

  export type AudioSegmentUncheckedCreateInput = {
    id?: string
    audioHistoryId: string
    userId: string
    startTime: number
    endTime: number
    text: string
    speaker?: string | null
    confidence?: number | null
    keywords?: AudioSegmentCreatekeywordsInput | string[]
    sentiment?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AudioSegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: AudioSegmentUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioHistory?: AudioHistoryUpdateOneRequiredWithoutSegmentsNestedInput
    user?: UserUpdateOneRequiredWithoutAudioSegmentsNestedInput
  }

  export type AudioSegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: AudioSegmentUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioSegmentCreateManyInput = {
    id?: string
    audioHistoryId: string
    userId: string
    startTime: number
    endTime: number
    text: string
    speaker?: string | null
    confidence?: number | null
    keywords?: AudioSegmentCreatekeywordsInput | string[]
    sentiment?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AudioSegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: AudioSegmentUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioSegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: AudioSegmentUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioChunkCreateInput = {
    id?: string
    chunkIndex: number
    startByte: bigint | number
    endByte: bigint | number
    size: bigint | number
    storageKey: string
    checksum: string
    uploadedAt?: Date | string | null
    createdAt?: Date | string
    upload: AudioUploadCreateNestedOneWithoutAudioChunksInput
  }

  export type AudioChunkUncheckedCreateInput = {
    id?: string
    uploadId: string
    chunkIndex: number
    startByte: bigint | number
    endByte: bigint | number
    size: bigint | number
    storageKey: string
    checksum: string
    uploadedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AudioChunkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startByte?: BigIntFieldUpdateOperationsInput | bigint | number
    endByte?: BigIntFieldUpdateOperationsInput | bigint | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    storageKey?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upload?: AudioUploadUpdateOneRequiredWithoutAudioChunksNestedInput
  }

  export type AudioChunkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startByte?: BigIntFieldUpdateOperationsInput | bigint | number
    endByte?: BigIntFieldUpdateOperationsInput | bigint | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    storageKey?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioChunkCreateManyInput = {
    id?: string
    uploadId: string
    chunkIndex: number
    startByte: bigint | number
    endByte: bigint | number
    size: bigint | number
    storageKey: string
    checksum: string
    uploadedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AudioChunkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startByte?: BigIntFieldUpdateOperationsInput | bigint | number
    endByte?: BigIntFieldUpdateOperationsInput | bigint | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    storageKey?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioChunkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startByte?: BigIntFieldUpdateOperationsInput | bigint | number
    endByte?: BigIntFieldUpdateOperationsInput | bigint | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    storageKey?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageProviderCreateInput = {
    id?: string
    name: string
    type: string
    endpoint?: string | null
    region?: string | null
    bucket?: string | null
    cdnEndpoint?: string | null
    isActive?: boolean
    isDefault?: boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileStorageCreateNestedManyWithoutProviderInput
  }

  export type StorageProviderUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    endpoint?: string | null
    region?: string | null
    bucket?: string | null
    cdnEndpoint?: string | null
    isActive?: boolean
    isDefault?: boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileStorageUncheckedCreateNestedManyWithoutProviderInput
  }

  export type StorageProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    cdnEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileStorageUpdateManyWithoutProviderNestedInput
  }

  export type StorageProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    cdnEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileStorageUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type StorageProviderCreateManyInput = {
    id?: string
    name: string
    type: string
    endpoint?: string | null
    region?: string | null
    bucket?: string | null
    cdnEndpoint?: string | null
    isActive?: boolean
    isDefault?: boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    cdnEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    cdnEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileStorageCreateInput = {
    id?: string
    storageKey: string
    fileName: string
    fileSize: bigint | number
    mimeType: string
    checksum: string
    publicUrl?: string | null
    cdnUrl?: string | null
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastAccessedAt?: Date | string | null
    provider: StorageProviderCreateNestedOneWithoutFilesInput
    upload: AudioUploadCreateNestedOneWithoutFileStorageInput
  }

  export type FileStorageUncheckedCreateInput = {
    id?: string
    uploadId: string
    providerId: string
    storageKey: string
    fileName: string
    fileSize: bigint | number
    mimeType: string
    checksum: string
    publicUrl?: string | null
    cdnUrl?: string | null
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastAccessedAt?: Date | string | null
  }

  export type FileStorageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: StorageProviderUpdateOneRequiredWithoutFilesNestedInput
    upload?: AudioUploadUpdateOneRequiredWithoutFileStorageNestedInput
  }

  export type FileStorageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileStorageCreateManyInput = {
    id?: string
    uploadId: string
    providerId: string
    storageKey: string
    fileName: string
    fileSize: bigint | number
    mimeType: string
    checksum: string
    publicUrl?: string | null
    cdnUrl?: string | null
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastAccessedAt?: Date | string | null
  }

  export type FileStorageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileStorageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionPlanCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    tier: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingPeriod: string
    features: JsonNullValueInput | InputJsonValue
    quotas: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublic?: boolean
    trialDays?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutPlanInput
    planPricing?: PlanPricingCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    tier: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingPeriod: string
    features: JsonNullValueInput | InputJsonValue
    quotas: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublic?: boolean
    trialDays?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutPlanInput
    planPricing?: PlanPricingUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    quotas?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    trialDays?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutPlanNestedInput
    planPricing?: PlanPricingUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    quotas?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    trialDays?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    planPricing?: PlanPricingUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    tier: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingPeriod: string
    features: JsonNullValueInput | InputJsonValue
    quotas: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublic?: boolean
    trialDays?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    quotas?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    trialDays?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    quotas?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    trialDays?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceSubscriptionCreateInput = {
    id?: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    billingRecords?: BillingRecordCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionUncheckedCreateInput = {
    id?: string
    workspaceId: string
    planId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    billingRecords?: BillingRecordUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    billingRecords?: BillingRecordUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingRecords?: BillingRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionCreateManyInput = {
    id?: string
    workspaceId: string
    planId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRecordCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: string
    invoiceNumber?: string | null
    invoiceUrl?: string | null
    paymentMethod?: string | null
    paymentIntentId?: string | null
    failureReason?: string | null
    paidAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    subscription: WorkspaceSubscriptionCreateNestedOneWithoutBillingRecordsInput
  }

  export type BillingRecordUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: string
    invoiceNumber?: string | null
    invoiceUrl?: string | null
    paymentMethod?: string | null
    paymentIntentId?: string | null
    failureReason?: string | null
    paidAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: WorkspaceSubscriptionUpdateOneRequiredWithoutBillingRecordsNestedInput
  }

  export type BillingRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRecordCreateManyInput = {
    id?: string
    subscriptionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: string
    invoiceNumber?: string | null
    invoiceUrl?: string | null
    paymentMethod?: string | null
    paymentIntentId?: string | null
    failureReason?: string | null
    paidAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    workspaceId: string
    type: string
    provider: string
    isDefault?: boolean
    lastFour?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    workspaceId: string
    type: string
    provider: string
    isDefault?: boolean
    lastFour?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastFour?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastFour?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    workspaceId: string
    type: string
    provider: string
    isDefault?: boolean
    lastFour?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastFour?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastFour?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyManagementCreateInput = {
    id?: string
    provider: string
    keyHash: string
    keyPrefix: string
    encryptedKey: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    usageCount?: number
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutApiKeysInput
    usageLogs?: ApiKeyUsageLogCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyManagementUncheckedCreateInput = {
    id?: string
    userId: string
    provider: string
    keyHash: string
    keyPrefix: string
    encryptedKey: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    usageCount?: number
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: ApiKeyUsageLogUncheckedCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyManagementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
    usageLogs?: ApiKeyUsageLogUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyManagementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: ApiKeyUsageLogUncheckedUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyManagementCreateManyInput = {
    id?: string
    userId: string
    provider: string
    keyHash: string
    keyPrefix: string
    encryptedKey: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    usageCount?: number
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyManagementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyManagementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUsageLogCreateInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    apiKey: ApiKeyManagementCreateNestedOneWithoutUsageLogsInput
  }

  export type ApiKeyUsageLogUncheckedCreateInput = {
    id?: string
    apiKeyId: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ApiKeyUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKey?: ApiKeyManagementUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type ApiKeyUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiKeyId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUsageLogCreateManyInput = {
    id?: string
    apiKeyId: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ApiKeyUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiKeyId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    openaiApiKeyEncrypted?: string | null
    elevenlabsApiKeyEncrypted?: string | null
    preferredLanguage?: string
    summaryQuality?: string
    theme?: string
    notifications?: JsonNullValueInput | InputJsonValue
    privacy?: JsonNullValueInput | InputJsonValue
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    userId: string
    openaiApiKeyEncrypted?: string | null
    elevenlabsApiKeyEncrypted?: string | null
    preferredLanguage?: string
    summaryQuality?: string
    theme?: string
    notifications?: JsonNullValueInput | InputJsonValue
    privacy?: JsonNullValueInput | InputJsonValue
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    openaiApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    elevenlabsApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    summaryQuality?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: JsonNullValueInput | InputJsonValue
    privacy?: JsonNullValueInput | InputJsonValue
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    openaiApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    elevenlabsApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    summaryQuality?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: JsonNullValueInput | InputJsonValue
    privacy?: JsonNullValueInput | InputJsonValue
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    userId: string
    openaiApiKeyEncrypted?: string | null
    elevenlabsApiKeyEncrypted?: string | null
    preferredLanguage?: string
    summaryQuality?: string
    theme?: string
    notifications?: JsonNullValueInput | InputJsonValue
    privacy?: JsonNullValueInput | InputJsonValue
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    openaiApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    elevenlabsApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    summaryQuality?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: JsonNullValueInput | InputJsonValue
    privacy?: JsonNullValueInput | InputJsonValue
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    openaiApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    elevenlabsApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    summaryQuality?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: JsonNullValueInput | InputJsonValue
    privacy?: JsonNullValueInput | InputJsonValue
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricCreateInput = {
    id?: string
    workspaceId: string
    metricType: string
    value: bigint | number
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageMetricUncheckedCreateInput = {
    id?: string
    workspaceId: string
    metricType: string
    value: bigint | number
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricCreateManyInput = {
    id?: string
    workspaceId: string
    metricType: string
    value: bigint | number
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuotaCreateInput = {
    id?: string
    workspaceId: string
    quotaType: string
    used?: bigint | number
    limit: bigint | number
    resetPeriod: string
    nextResetAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutQuotaUsageInput
  }

  export type UserQuotaUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId: string
    quotaType: string
    used?: bigint | number
    limit: bigint | number
    resetPeriod: string
    nextResetAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQuotaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    quotaType?: StringFieldUpdateOperationsInput | string
    used?: BigIntFieldUpdateOperationsInput | bigint | number
    limit?: BigIntFieldUpdateOperationsInput | bigint | number
    resetPeriod?: StringFieldUpdateOperationsInput | string
    nextResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutQuotaUsageNestedInput
  }

  export type UserQuotaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    quotaType?: StringFieldUpdateOperationsInput | string
    used?: BigIntFieldUpdateOperationsInput | bigint | number
    limit?: BigIntFieldUpdateOperationsInput | bigint | number
    resetPeriod?: StringFieldUpdateOperationsInput | string
    nextResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuotaCreateManyInput = {
    id?: string
    userId: string
    workspaceId: string
    quotaType: string
    used?: bigint | number
    limit: bigint | number
    resetPeriod: string
    nextResetAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQuotaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    quotaType?: StringFieldUpdateOperationsInput | string
    used?: BigIntFieldUpdateOperationsInput | bigint | number
    limit?: BigIntFieldUpdateOperationsInput | bigint | number
    resetPeriod?: StringFieldUpdateOperationsInput | string
    nextResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuotaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    quotaType?: StringFieldUpdateOperationsInput | string
    used?: BigIntFieldUpdateOperationsInput | bigint | number
    limit?: BigIntFieldUpdateOperationsInput | bigint | number
    resetPeriod?: StringFieldUpdateOperationsInput | string
    nextResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaCreateInput = {
    id?: string
    totalBytes: bigint | number
    usedBytes: bigint | number
    fileCount: number
    lastCalculated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutStorageQuotasInput
  }

  export type StorageQuotaUncheckedCreateInput = {
    id?: string
    workspaceId: string
    totalBytes: bigint | number
    usedBytes: bigint | number
    fileCount: number
    lastCalculated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageQuotaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutStorageQuotasNestedInput
  }

  export type StorageQuotaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    totalBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaCreateManyInput = {
    id?: string
    workspaceId: string
    totalBytes: bigint | number
    usedBytes: bigint | number
    fileCount: number
    lastCalculated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageQuotaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    totalBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordCreateInput = {
    id?: string
    recordType: string
    quantity: bigint | number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    subscription: WorkspaceSubscriptionCreateNestedOneWithoutUsageRecordsInput
  }

  export type UsageRecordUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    recordType: string
    quantity: bigint | number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: WorkspaceSubscriptionUpdateOneRequiredWithoutUsageRecordsNestedInput
  }

  export type UsageRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordCreateManyInput = {
    id?: string
    subscriptionId: string
    recordType: string
    quantity: bigint | number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    workspaceId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    workspaceId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    workspaceId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventCreateInput = {
    id?: string
    eventType: string
    severity: string
    description: string
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutSecurityEventsInput
  }

  export type SecurityEventUncheckedCreateInput = {
    id?: string
    userId?: string | null
    eventType: string
    severity: string
    description: string
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type SecurityEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSecurityEventsNestedInput
  }

  export type SecurityEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventCreateManyInput = {
    id?: string
    userId?: string | null
    eventType: string
    severity: string
    description: string
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type SecurityEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    actionUrl?: string | null
    read?: boolean
    readAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    actionUrl?: string | null
    read?: boolean
    readAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    actionUrl?: string | null
    read?: boolean
    readAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateInput = {
    id?: string
    name: string
    subject: string
    htmlContent: string
    textContent: string
    variables: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emailLogs?: EmailLogCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    htmlContent: string
    textContent: string
    variables: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    textContent?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailLogs?: EmailLogUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    textContent?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailLogs?: EmailLogUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    name: string
    subject: string
    htmlContent: string
    textContent: string
    variables: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    textContent?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    textContent?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateInput = {
    id?: string
    recipientEmail: string
    subject: string
    status: string
    provider: string
    providerMessageId?: string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    template?: EmailTemplateCreateNestedOneWithoutEmailLogsInput
  }

  export type EmailLogUncheckedCreateInput = {
    id?: string
    templateId?: string | null
    recipientEmail: string
    subject: string
    status: string
    provider: string
    providerMessageId?: string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: EmailTemplateUpdateOneWithoutEmailLogsNestedInput
  }

  export type EmailLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateManyInput = {
    id?: string
    templateId?: string | null
    recipientEmail: string
    subject: string
    status: string
    provider: string
    providerMessageId?: string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailPreferenceCreateInput = {
    marketing?: boolean
    transactional?: boolean
    security?: boolean
    newsletter?: boolean
    productUpdates?: boolean
    unsubscribeToken: string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmailPreferencesInput
  }

  export type EmailPreferenceUncheckedCreateInput = {
    userId: string
    marketing?: boolean
    transactional?: boolean
    security?: boolean
    newsletter?: boolean
    productUpdates?: boolean
    unsubscribeToken: string
    updatedAt?: Date | string
  }

  export type EmailPreferenceUpdateInput = {
    marketing?: BoolFieldUpdateOperationsInput | boolean
    transactional?: BoolFieldUpdateOperationsInput | boolean
    security?: BoolFieldUpdateOperationsInput | boolean
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    productUpdates?: BoolFieldUpdateOperationsInput | boolean
    unsubscribeToken?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailPreferencesNestedInput
  }

  export type EmailPreferenceUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    marketing?: BoolFieldUpdateOperationsInput | boolean
    transactional?: BoolFieldUpdateOperationsInput | boolean
    security?: BoolFieldUpdateOperationsInput | boolean
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    productUpdates?: BoolFieldUpdateOperationsInput | boolean
    unsubscribeToken?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailPreferenceCreateManyInput = {
    userId: string
    marketing?: boolean
    transactional?: boolean
    security?: boolean
    newsletter?: boolean
    productUpdates?: boolean
    unsubscribeToken: string
    updatedAt?: Date | string
  }

  export type EmailPreferenceUpdateManyMutationInput = {
    marketing?: BoolFieldUpdateOperationsInput | boolean
    transactional?: BoolFieldUpdateOperationsInput | boolean
    security?: BoolFieldUpdateOperationsInput | boolean
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    productUpdates?: BoolFieldUpdateOperationsInput | boolean
    unsubscribeToken?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailPreferenceUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    marketing?: BoolFieldUpdateOperationsInput | boolean
    transactional?: BoolFieldUpdateOperationsInput | boolean
    security?: BoolFieldUpdateOperationsInput | boolean
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    productUpdates?: BoolFieldUpdateOperationsInput | boolean
    unsubscribeToken?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateInput = {
    id?: string
    type: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutIntegrationsInput
  }

  export type IntegrationUncheckedCreateInput = {
    id?: string
    workspaceId: string
    type: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type IntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateManyInput = {
    id?: string
    workspaceId: string
    type: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceAutomationCreateInput = {
    id?: string
    name: string
    description?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutAutomationsInput
  }

  export type WorkspaceAutomationUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceAutomationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAutomationsNestedInput
  }

  export type WorkspaceAutomationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceAutomationCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceAutomationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceAutomationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateInput = {
    id?: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    lastTriggeredAt?: Date | string | null
    failureCount?: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutWebhooksInput
  }

  export type WebhookUncheckedCreateInput = {
    id?: string
    workspaceId: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    lastTriggeredAt?: Date | string | null
    failureCount?: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutWebhooksNestedInput
  }

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateManyInput = {
    id?: string
    workspaceId: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    lastTriggeredAt?: Date | string | null
    failureCount?: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldCreateInput = {
    id?: string
    name: string
    fieldType: string
    isRequired?: boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCustomFieldsInput
  }

  export type CustomFieldUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    fieldType: string
    isRequired?: boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCustomFieldsNestedInput
  }

  export type CustomFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    fieldType: string
    isRequired?: boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    color: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    color: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    color: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAgentCreateInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    model?: string
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutAiAgentsInput
    conversations?: AiConversationCreateNestedManyWithoutAgentInput
  }

  export type AiAgentUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    systemPrompt: string
    model?: string
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: AiConversationUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AiAgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAiAgentsNestedInput
    conversations?: AiConversationUpdateManyWithoutAgentNestedInput
  }

  export type AiAgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: AiConversationUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AiAgentCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    systemPrompt: string
    model?: string
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiAgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiConversationCreateInput = {
    id?: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AiAgentCreateNestedOneWithoutConversationsInput
    messages?: AiMessageCreateNestedManyWithoutConversationInput
  }

  export type AiConversationUncheckedCreateInput = {
    id?: string
    agentId: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: AiMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type AiConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AiAgentUpdateOneRequiredWithoutConversationsNestedInput
    messages?: AiMessageUpdateManyWithoutConversationNestedInput
  }

  export type AiConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AiMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AiConversationCreateManyInput = {
    id?: string
    agentId: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageCreateInput = {
    id?: string
    role: string
    content: string
    tokensUsed?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    conversation: AiConversationCreateNestedOneWithoutMessagesInput
  }

  export type AiMessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    tokensUsed?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: AiConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type AiMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageCreateManyInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    tokensUsed?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiTokenUsageCreateInput = {
    id?: string
    workspaceId: string
    provider: string
    model: string
    tokensUsed: number
    cost: Decimal | DecimalJsLike | number | string
    purpose: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAiTokenUsageInput
  }

  export type AiTokenUsageUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId: string
    provider: string
    model: string
    tokensUsed: number
    cost: Decimal | DecimalJsLike | number | string
    purpose: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiTokenUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiTokenUsageNestedInput
  }

  export type AiTokenUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiTokenUsageCreateManyInput = {
    id?: string
    userId: string
    workspaceId: string
    provider: string
    model: string
    tokensUsed: number
    cost: Decimal | DecimalJsLike | number | string
    purpose: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiTokenUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiTokenUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    name: string
    description?: string | null
    resource: string
    action: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    resource: string
    action: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    resource: string
    action: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingCreateInput = {
    id?: string
    userId: string
    workspaceId: string
    resourceType: string
    resourceId: string
    action: string
    quantity?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UsageTrackingUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId: string
    resourceType: string
    resourceId: string
    action: string
    quantity?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UsageTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingCreateManyInput = {
    id?: string
    userId: string
    workspaceId: string
    resourceType: string
    resourceId: string
    action: string
    quantity?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UsageTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageReportCreateInput = {
    id?: string
    workspaceId: string
    reportType: string
    periodStart: Date | string
    periodEnd: Date | string
    totalUploads?: number
    totalMinutes?: number
    totalStorage?: bigint | number
    reportData: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type UsageReportUncheckedCreateInput = {
    id?: string
    workspaceId: string
    reportType: string
    periodStart: Date | string
    periodEnd: Date | string
    totalUploads?: number
    totalMinutes?: number
    totalStorage?: bigint | number
    reportData: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type UsageReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalUploads?: IntFieldUpdateOperationsInput | number
    totalMinutes?: IntFieldUpdateOperationsInput | number
    totalStorage?: BigIntFieldUpdateOperationsInput | bigint | number
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalUploads?: IntFieldUpdateOperationsInput | number
    totalMinutes?: IntFieldUpdateOperationsInput | number
    totalStorage?: BigIntFieldUpdateOperationsInput | bigint | number
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageReportCreateManyInput = {
    id?: string
    workspaceId: string
    reportType: string
    periodStart: Date | string
    periodEnd: Date | string
    totalUploads?: number
    totalMinutes?: number
    totalStorage?: bigint | number
    reportData: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type UsageReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalUploads?: IntFieldUpdateOperationsInput | number
    totalMinutes?: IntFieldUpdateOperationsInput | number
    totalStorage?: BigIntFieldUpdateOperationsInput | bigint | number
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalUploads?: IntFieldUpdateOperationsInput | number
    totalMinutes?: IntFieldUpdateOperationsInput | number
    totalStorage?: BigIntFieldUpdateOperationsInput | bigint | number
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentGatewayConfigCreateInput = {
    id?: string
    provider: string
    environment: string
    isActive?: boolean
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentGatewayConfigUncheckedCreateInput = {
    id?: string
    provider: string
    environment: string
    isActive?: boolean
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentGatewayConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentGatewayConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentGatewayConfigCreateManyInput = {
    id?: string
    provider: string
    environment: string
    isActive?: boolean
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentGatewayConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentGatewayConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPricingCreateInput = {
    id?: string
    currency?: string
    price: Decimal | DecimalJsLike | number | string
    interval: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutPlanPricingInput
  }

  export type PlanPricingUncheckedCreateInput = {
    id?: string
    planId: string
    currency?: string
    price: Decimal | DecimalJsLike | number | string
    interval: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPricingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutPlanPricingNestedInput
  }

  export type PlanPricingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPricingCreateManyInput = {
    id?: string
    planId: string
    currency?: string
    price: Decimal | DecimalJsLike | number | string
    interval: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPricingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPricingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayTransactionCreateInput = {
    id?: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    transactionStatus?: string
    responseCode?: string | null
    responseMessage?: string | null
    authCode?: string | null
    beagleScore?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ewayCustomer?: EwayCustomerCreateNestedOneWithoutTransactionsInput
  }

  export type EwayTransactionUncheckedCreateInput = {
    id?: string
    transactionId: string
    customerToken?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    transactionStatus?: string
    responseCode?: string | null
    responseMessage?: string | null
    authCode?: string | null
    beagleScore?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayCustomer?: EwayCustomerUpdateOneWithoutTransactionsNestedInput
  }

  export type EwayTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    customerToken?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayTransactionCreateManyInput = {
    id?: string
    transactionId: string
    customerToken?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    transactionStatus?: string
    responseCode?: string | null
    responseMessage?: string | null
    authCode?: string | null
    beagleScore?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    customerToken?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayCustomerCreateInput = {
    id?: string
    customerToken: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: string | null
    cardName?: string | null
    cardExpiryMonth?: string | null
    cardExpiryYear?: string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: EwayTransactionCreateNestedManyWithoutEwayCustomerInput
    recurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerUncheckedCreateInput = {
    id?: string
    customerToken: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: string | null
    cardName?: string | null
    cardExpiryMonth?: string | null
    cardExpiryYear?: string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: EwayTransactionUncheckedCreateNestedManyWithoutEwayCustomerInput
    recurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerToken?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: EwayTransactionUpdateManyWithoutEwayCustomerNestedInput
    recurringSchedules?: EwayRecurringScheduleUpdateManyWithoutEwayCustomerNestedInput
  }

  export type EwayCustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerToken?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: EwayTransactionUncheckedUpdateManyWithoutEwayCustomerNestedInput
    recurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutEwayCustomerNestedInput
  }

  export type EwayCustomerCreateManyInput = {
    id?: string
    customerToken: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: string | null
    cardName?: string | null
    cardExpiryMonth?: string | null
    cardExpiryYear?: string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayCustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerToken?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayCustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerToken?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayRecurringScheduleCreateInput = {
    id?: string
    interval: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    nextPayment: Date | string
    lastPayment?: Date | string | null
    paymentCount?: number
    maxPayments?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ewayCustomer: EwayCustomerCreateNestedOneWithoutRecurringSchedulesInput
  }

  export type EwayRecurringScheduleUncheckedCreateInput = {
    id?: string
    customerToken: string
    interval: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    nextPayment: Date | string
    lastPayment?: Date | string | null
    paymentCount?: number
    maxPayments?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayRecurringScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextPayment?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentCount?: IntFieldUpdateOperationsInput | number
    maxPayments?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ewayCustomer?: EwayCustomerUpdateOneRequiredWithoutRecurringSchedulesNestedInput
  }

  export type EwayRecurringScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerToken?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextPayment?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentCount?: IntFieldUpdateOperationsInput | number
    maxPayments?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayRecurringScheduleCreateManyInput = {
    id?: string
    customerToken: string
    interval: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    nextPayment: Date | string
    lastPayment?: Date | string | null
    paymentCount?: number
    maxPayments?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayRecurringScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextPayment?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentCount?: IntFieldUpdateOperationsInput | number
    maxPayments?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayRecurringScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerToken?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextPayment?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentCount?: IntFieldUpdateOperationsInput | number
    maxPayments?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayWebhookEventCreateInput = {
    id?: string
    eventType: string
    transactionId?: string | null
    customerToken?: string | null
    payload: JsonNullValueInput | InputJsonValue
    processed?: boolean
    processedAt?: Date | string | null
    error?: string | null
    retryCount?: number
    createdAt?: Date | string
  }

  export type EwayWebhookEventUncheckedCreateInput = {
    id?: string
    eventType: string
    transactionId?: string | null
    customerToken?: string | null
    payload: JsonNullValueInput | InputJsonValue
    processed?: boolean
    processedAt?: Date | string | null
    error?: string | null
    retryCount?: number
    createdAt?: Date | string
  }

  export type EwayWebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerToken?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayWebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerToken?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayWebhookEventCreateManyInput = {
    id?: string
    eventType: string
    transactionId?: string | null
    customerToken?: string | null
    payload: JsonNullValueInput | InputJsonValue
    processed?: boolean
    processedAt?: Date | string | null
    error?: string | null
    retryCount?: number
    createdAt?: Date | string
  }

  export type EwayWebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerToken?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayWebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerToken?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthCheckCreateInput = {
    id?: string
    service: string
    status: string
    responseTime: number
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: Date | string
  }

  export type HealthCheckUncheckedCreateInput = {
    id?: string
    service: string
    status: string
    responseTime: number
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: Date | string
  }

  export type HealthCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responseTime?: IntFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responseTime?: IntFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthCheckCreateManyInput = {
    id?: string
    service: string
    status: string
    responseTime: number
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: Date | string
  }

  export type HealthCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responseTime?: IntFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responseTime?: IntFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type WorkspaceUserListRelationFilter = {
    every?: WorkspaceUserWhereInput
    some?: WorkspaceUserWhereInput
    none?: WorkspaceUserWhereInput
  }

  export type AudioHistoryListRelationFilter = {
    every?: AudioHistoryWhereInput
    some?: AudioHistoryWhereInput
    none?: AudioHistoryWhereInput
  }

  export type AudioUploadListRelationFilter = {
    every?: AudioUploadWhereInput
    some?: AudioUploadWhereInput
    none?: AudioUploadWhereInput
  }

  export type ApiKeyManagementListRelationFilter = {
    every?: ApiKeyManagementWhereInput
    some?: ApiKeyManagementWhereInput
    none?: ApiKeyManagementWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type UserSettingsNullableRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SecurityEventListRelationFilter = {
    every?: SecurityEventWhereInput
    some?: SecurityEventWhereInput
    none?: SecurityEventWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AudioSegmentListRelationFilter = {
    every?: AudioSegmentWhereInput
    some?: AudioSegmentWhereInput
    none?: AudioSegmentWhereInput
  }

  export type EmailPreferenceNullableRelationFilter = {
    is?: EmailPreferenceWhereInput | null
    isNot?: EmailPreferenceWhereInput | null
  }

  export type UserQuotaListRelationFilter = {
    every?: UserQuotaWhereInput
    some?: UserQuotaWhereInput
    none?: UserQuotaWhereInput
  }

  export type AiTokenUsageListRelationFilter = {
    every?: AiTokenUsageWhereInput
    some?: AiTokenUsageWhereInput
    none?: AiTokenUsageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type WorkspaceUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioUploadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyManagementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioSegmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserQuotaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiTokenUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    phoneNumber?: SortOrder
    timezone?: SortOrder
    lastLoginAt?: SortOrder
    emailVerified?: SortOrder
    emailVerifiedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    phoneNumber?: SortOrder
    timezone?: SortOrder
    lastLoginAt?: SortOrder
    emailVerified?: SortOrder
    emailVerifiedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    phoneNumber?: SortOrder
    timezone?: SortOrder
    lastLoginAt?: SortOrder
    emailVerified?: SortOrder
    emailVerifiedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WorkspaceInvitationListRelationFilter = {
    every?: WorkspaceInvitationWhereInput
    some?: WorkspaceInvitationWhereInput
    none?: WorkspaceInvitationWhereInput
  }

  export type WorkspaceSubscriptionListRelationFilter = {
    every?: WorkspaceSubscriptionWhereInput
    some?: WorkspaceSubscriptionWhereInput
    none?: WorkspaceSubscriptionWhereInput
  }

  export type StorageQuotaListRelationFilter = {
    every?: StorageQuotaWhereInput
    some?: StorageQuotaWhereInput
    none?: StorageQuotaWhereInput
  }

  export type IntegrationListRelationFilter = {
    every?: IntegrationWhereInput
    some?: IntegrationWhereInput
    none?: IntegrationWhereInput
  }

  export type WorkspaceAutomationListRelationFilter = {
    every?: WorkspaceAutomationWhereInput
    some?: WorkspaceAutomationWhereInput
    none?: WorkspaceAutomationWhereInput
  }

  export type WebhookListRelationFilter = {
    every?: WebhookWhereInput
    some?: WebhookWhereInput
    none?: WebhookWhereInput
  }

  export type CustomFieldListRelationFilter = {
    every?: CustomFieldWhereInput
    some?: CustomFieldWhereInput
    none?: CustomFieldWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type AiAgentListRelationFilter = {
    every?: AiAgentWhereInput
    some?: AiAgentWhereInput
    none?: AiAgentWhereInput
  }

  export type WorkspaceInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageQuotaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceAutomationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiAgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    website?: SortOrder
    industry?: SortOrder
    size?: SortOrder
    isActive?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    website?: SortOrder
    industry?: SortOrder
    size?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    website?: SortOrder
    industry?: SortOrder
    size?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type WorkspaceRelationFilter = {
    is?: WorkspaceWhereInput
    isNot?: WorkspaceWhereInput
  }

  export type WorkspaceUserWorkspaceIdUserIdCompoundUniqueInput = {
    workspaceId: string
    userId: string
  }

  export type WorkspaceUserCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type WorkspaceUserMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type WorkspaceUserMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type WorkspaceInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type WorkspaceInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type WorkspaceInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ProcessingJobListRelationFilter = {
    every?: ProcessingJobWhereInput
    some?: ProcessingJobWhereInput
    none?: ProcessingJobWhereInput
  }

  export type AudioChunkListRelationFilter = {
    every?: AudioChunkWhereInput
    some?: AudioChunkWhereInput
    none?: AudioChunkWhereInput
  }

  export type FileStorageNullableRelationFilter = {
    is?: FileStorageWhereInput | null
    isNot?: FileStorageWhereInput | null
  }

  export type ProcessingJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioChunkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioUploadCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    originalFileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadStatus?: SortOrder
    uploadProgress?: SortOrder
    storageProvider?: SortOrder
    storagePath?: SortOrder
    storageUrl?: SortOrder
    cdnUrl?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AudioUploadAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    uploadProgress?: SortOrder
  }

  export type AudioUploadMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    originalFileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadStatus?: SortOrder
    uploadProgress?: SortOrder
    storageProvider?: SortOrder
    storagePath?: SortOrder
    storageUrl?: SortOrder
    cdnUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AudioUploadMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    originalFileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadStatus?: SortOrder
    uploadProgress?: SortOrder
    storageProvider?: SortOrder
    storagePath?: SortOrder
    storageUrl?: SortOrder
    cdnUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AudioUploadSumOrderByAggregateInput = {
    fileSize?: SortOrder
    uploadProgress?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AudioUploadRelationFilter = {
    is?: AudioUploadWhereInput
    isNot?: AudioUploadWhereInput
  }

  export type AudioHistoryNullableRelationFilter = {
    is?: AudioHistoryWhereInput | null
    isNot?: AudioHistoryWhereInput | null
  }

  export type ProcessingJobCountOrderByAggregateInput = {
    id?: SortOrder
    uploadId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
    result?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessingJobAvgOrderByAggregateInput = {
    priority?: SortOrder
    progress?: SortOrder
  }

  export type ProcessingJobMaxOrderByAggregateInput = {
    id?: SortOrder
    uploadId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessingJobMinOrderByAggregateInput = {
    id?: SortOrder
    uploadId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessingJobSumOrderByAggregateInput = {
    priority?: SortOrder
    progress?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type WorkspaceNullableRelationFilter = {
    is?: WorkspaceWhereInput | null
    isNot?: WorkspaceWhereInput | null
  }

  export type ProcessingJobNullableRelationFilter = {
    is?: ProcessingJobWhereInput | null
    isNot?: ProcessingJobWhereInput | null
  }

  export type AudioHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    processingJobId?: SortOrder
    title?: SortOrder
    audioUrl?: SortOrder
    fileSizeBytes?: SortOrder
    durationSeconds?: SortOrder
    transcript?: SortOrder
    summary?: SortOrder
    keyMoments?: SortOrder
    processingOptions?: SortOrder
    language?: SortOrder
    confidence?: SortOrder
    speakers?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioHistoryAvgOrderByAggregateInput = {
    fileSizeBytes?: SortOrder
    durationSeconds?: SortOrder
    confidence?: SortOrder
    speakers?: SortOrder
  }

  export type AudioHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    processingJobId?: SortOrder
    title?: SortOrder
    audioUrl?: SortOrder
    fileSizeBytes?: SortOrder
    durationSeconds?: SortOrder
    transcript?: SortOrder
    summary?: SortOrder
    language?: SortOrder
    confidence?: SortOrder
    speakers?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    processingJobId?: SortOrder
    title?: SortOrder
    audioUrl?: SortOrder
    fileSizeBytes?: SortOrder
    durationSeconds?: SortOrder
    transcript?: SortOrder
    summary?: SortOrder
    language?: SortOrder
    confidence?: SortOrder
    speakers?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioHistorySumOrderByAggregateInput = {
    fileSizeBytes?: SortOrder
    durationSeconds?: SortOrder
    confidence?: SortOrder
    speakers?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AudioHistoryRelationFilter = {
    is?: AudioHistoryWhereInput
    isNot?: AudioHistoryWhereInput
  }

  export type AudioSegmentCountOrderByAggregateInput = {
    id?: SortOrder
    audioHistoryId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    text?: SortOrder
    speaker?: SortOrder
    confidence?: SortOrder
    keywords?: SortOrder
    sentiment?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioSegmentAvgOrderByAggregateInput = {
    startTime?: SortOrder
    endTime?: SortOrder
    confidence?: SortOrder
  }

  export type AudioSegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    audioHistoryId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    text?: SortOrder
    speaker?: SortOrder
    confidence?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioSegmentMinOrderByAggregateInput = {
    id?: SortOrder
    audioHistoryId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    text?: SortOrder
    speaker?: SortOrder
    confidence?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioSegmentSumOrderByAggregateInput = {
    startTime?: SortOrder
    endTime?: SortOrder
    confidence?: SortOrder
  }

  export type AudioChunkUploadIdChunkIndexCompoundUniqueInput = {
    uploadId: string
    chunkIndex: number
  }

  export type AudioChunkCountOrderByAggregateInput = {
    id?: SortOrder
    uploadId?: SortOrder
    chunkIndex?: SortOrder
    startByte?: SortOrder
    endByte?: SortOrder
    size?: SortOrder
    storageKey?: SortOrder
    checksum?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioChunkAvgOrderByAggregateInput = {
    chunkIndex?: SortOrder
    startByte?: SortOrder
    endByte?: SortOrder
    size?: SortOrder
  }

  export type AudioChunkMaxOrderByAggregateInput = {
    id?: SortOrder
    uploadId?: SortOrder
    chunkIndex?: SortOrder
    startByte?: SortOrder
    endByte?: SortOrder
    size?: SortOrder
    storageKey?: SortOrder
    checksum?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioChunkMinOrderByAggregateInput = {
    id?: SortOrder
    uploadId?: SortOrder
    chunkIndex?: SortOrder
    startByte?: SortOrder
    endByte?: SortOrder
    size?: SortOrder
    storageKey?: SortOrder
    checksum?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioChunkSumOrderByAggregateInput = {
    chunkIndex?: SortOrder
    startByte?: SortOrder
    endByte?: SortOrder
    size?: SortOrder
  }

  export type FileStorageListRelationFilter = {
    every?: FileStorageWhereInput
    some?: FileStorageWhereInput
    none?: FileStorageWhereInput
  }

  export type FileStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageProviderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    endpoint?: SortOrder
    region?: SortOrder
    bucket?: SortOrder
    cdnEndpoint?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    endpoint?: SortOrder
    region?: SortOrder
    bucket?: SortOrder
    cdnEndpoint?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageProviderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    endpoint?: SortOrder
    region?: SortOrder
    bucket?: SortOrder
    cdnEndpoint?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageProviderRelationFilter = {
    is?: StorageProviderWhereInput
    isNot?: StorageProviderWhereInput
  }

  export type FileStorageCountOrderByAggregateInput = {
    id?: SortOrder
    uploadId?: SortOrder
    providerId?: SortOrder
    storageKey?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    checksum?: SortOrder
    publicUrl?: SortOrder
    cdnUrl?: SortOrder
    expiresAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    lastAccessedAt?: SortOrder
  }

  export type FileStorageAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type FileStorageMaxOrderByAggregateInput = {
    id?: SortOrder
    uploadId?: SortOrder
    providerId?: SortOrder
    storageKey?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    checksum?: SortOrder
    publicUrl?: SortOrder
    cdnUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastAccessedAt?: SortOrder
  }

  export type FileStorageMinOrderByAggregateInput = {
    id?: SortOrder
    uploadId?: SortOrder
    providerId?: SortOrder
    storageKey?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    checksum?: SortOrder
    publicUrl?: SortOrder
    cdnUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastAccessedAt?: SortOrder
  }

  export type FileStorageSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PlanPricingListRelationFilter = {
    every?: PlanPricingWhereInput
    some?: PlanPricingWhereInput
    none?: PlanPricingWhereInput
  }

  export type PlanPricingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    tier?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingPeriod?: SortOrder
    features?: SortOrder
    quotas?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    trialDays?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    price?: SortOrder
    trialDays?: SortOrder
    sortOrder?: SortOrder
  }

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    tier?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingPeriod?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    trialDays?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    tier?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingPeriod?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    trialDays?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanSumOrderByAggregateInput = {
    price?: SortOrder
    trialDays?: SortOrder
    sortOrder?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type SubscriptionPlanRelationFilter = {
    is?: SubscriptionPlanWhereInput
    isNot?: SubscriptionPlanWhereInput
  }

  export type BillingRecordListRelationFilter = {
    every?: BillingRecordWhereInput
    some?: BillingRecordWhereInput
    none?: BillingRecordWhereInput
  }

  export type UsageRecordListRelationFilter = {
    every?: UsageRecordWhereInput
    some?: UsageRecordWhereInput
    none?: UsageRecordWhereInput
  }

  export type BillingRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    trialEnd?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    trialEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    trialEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceSubscriptionRelationFilter = {
    is?: WorkspaceSubscriptionWhereInput
    isNot?: WorkspaceSubscriptionWhereInput
  }

  export type BillingRecordCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoiceNumber?: SortOrder
    invoiceUrl?: SortOrder
    paymentMethod?: SortOrder
    paymentIntentId?: SortOrder
    failureReason?: SortOrder
    paidAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type BillingRecordAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoiceNumber?: SortOrder
    invoiceUrl?: SortOrder
    paymentMethod?: SortOrder
    paymentIntentId?: SortOrder
    failureReason?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BillingRecordMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoiceNumber?: SortOrder
    invoiceUrl?: SortOrder
    paymentMethod?: SortOrder
    paymentIntentId?: SortOrder
    failureReason?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BillingRecordSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    lastFour?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    lastFour?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    lastFour?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
  }

  export type ApiKeyUsageLogListRelationFilter = {
    every?: ApiKeyUsageLogWhereInput
    some?: ApiKeyUsageLogWhereInput
    none?: ApiKeyUsageLogWhereInput
  }

  export type ApiKeyUsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyManagementUserIdProviderCompoundUniqueInput = {
    userId: string
    provider: string
  }

  export type ApiKeyManagementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    encryptedKey?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    usageCount?: SortOrder
    expiresAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyManagementAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type ApiKeyManagementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    encryptedKey?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    usageCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyManagementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    encryptedKey?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    usageCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyManagementSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ApiKeyManagementRelationFilter = {
    is?: ApiKeyManagementWhereInput
    isNot?: ApiKeyManagementWhereInput
  }

  export type ApiKeyUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyUsageLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    responseTime?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
  }

  export type ApiKeyUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyUsageLogSumOrderByAggregateInput = {
    statusCode?: SortOrder
    responseTime?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type UserSettingsCountOrderByAggregateInput = {
    userId?: SortOrder
    openaiApiKeyEncrypted?: SortOrder
    elevenlabsApiKeyEncrypted?: SortOrder
    preferredLanguage?: SortOrder
    summaryQuality?: SortOrder
    theme?: SortOrder
    notifications?: SortOrder
    privacy?: SortOrder
    settingsJson?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    userId?: SortOrder
    openaiApiKeyEncrypted?: SortOrder
    elevenlabsApiKeyEncrypted?: SortOrder
    preferredLanguage?: SortOrder
    summaryQuality?: SortOrder
    theme?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    userId?: SortOrder
    openaiApiKeyEncrypted?: SortOrder
    elevenlabsApiKeyEncrypted?: SortOrder
    preferredLanguage?: SortOrder
    summaryQuality?: SortOrder
    theme?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageMetricWorkspaceIdMetricTypePeriodStartCompoundUniqueInput = {
    workspaceId: string
    metricType: string
    periodStart: Date | string
  }

  export type UsageMetricCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageMetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type UsageMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageMetricMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageMetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type UserQuotaUserIdWorkspaceIdQuotaTypeCompoundUniqueInput = {
    userId: string
    workspaceId: string
    quotaType: string
  }

  export type UserQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    quotaType?: SortOrder
    used?: SortOrder
    limit?: SortOrder
    resetPeriod?: SortOrder
    nextResetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQuotaAvgOrderByAggregateInput = {
    used?: SortOrder
    limit?: SortOrder
  }

  export type UserQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    quotaType?: SortOrder
    used?: SortOrder
    limit?: SortOrder
    resetPeriod?: SortOrder
    nextResetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    quotaType?: SortOrder
    used?: SortOrder
    limit?: SortOrder
    resetPeriod?: SortOrder
    nextResetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQuotaSumOrderByAggregateInput = {
    used?: SortOrder
    limit?: SortOrder
  }

  export type StorageQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    totalBytes?: SortOrder
    usedBytes?: SortOrder
    fileCount?: SortOrder
    lastCalculated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageQuotaAvgOrderByAggregateInput = {
    totalBytes?: SortOrder
    usedBytes?: SortOrder
    fileCount?: SortOrder
  }

  export type StorageQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    totalBytes?: SortOrder
    usedBytes?: SortOrder
    fileCount?: SortOrder
    lastCalculated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    totalBytes?: SortOrder
    usedBytes?: SortOrder
    fileCount?: SortOrder
    lastCalculated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageQuotaSumOrderByAggregateInput = {
    totalBytes?: SortOrder
    usedBytes?: SortOrder
    fileCount?: SortOrder
  }

  export type UsageRecordCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    recordType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageRecordAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
  }

  export type UsageRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    recordType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageRecordMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    recordType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageRecordSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailLogListRelationFilter = {
    every?: EmailLogWhereInput
    some?: EmailLogWhereInput
    none?: EmailLogWhereInput
  }

  export type EmailLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    variables?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateNullableRelationFilter = {
    is?: EmailTemplateWhereInput | null
    isNot?: EmailTemplateWhereInput | null
  }

  export type EmailLogCountOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    recipientEmail?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    providerMessageId?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailLogMaxOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    recipientEmail?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    providerMessageId?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailLogMinOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    recipientEmail?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    providerMessageId?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailPreferenceCountOrderByAggregateInput = {
    userId?: SortOrder
    marketing?: SortOrder
    transactional?: SortOrder
    security?: SortOrder
    newsletter?: SortOrder
    productUpdates?: SortOrder
    unsubscribeToken?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailPreferenceMaxOrderByAggregateInput = {
    userId?: SortOrder
    marketing?: SortOrder
    transactional?: SortOrder
    security?: SortOrder
    newsletter?: SortOrder
    productUpdates?: SortOrder
    unsubscribeToken?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailPreferenceMinOrderByAggregateInput = {
    userId?: SortOrder
    marketing?: SortOrder
    transactional?: SortOrder
    security?: SortOrder
    newsletter?: SortOrder
    productUpdates?: SortOrder
    unsubscribeToken?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationWorkspaceIdTypeCompoundUniqueInput = {
    workspaceId: string
    type: string
  }

  export type IntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceAutomationCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    trigger?: SortOrder
    actions?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceAutomationAvgOrderByAggregateInput = {
    runCount?: SortOrder
  }

  export type WorkspaceAutomationMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceAutomationMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceAutomationSumOrderByAggregateInput = {
    runCount?: SortOrder
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    lastTriggeredAt?: SortOrder
    failureCount?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookAvgOrderByAggregateInput = {
    failureCount?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    lastTriggeredAt?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    lastTriggeredAt?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookSumOrderByAggregateInput = {
    failureCount?: SortOrder
  }

  export type CustomFieldWorkspaceIdNameCompoundUniqueInput = {
    workspaceId: string
    name: string
  }

  export type CustomFieldCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    fieldType?: SortOrder
    isRequired?: SortOrder
    options?: SortOrder
    defaultValue?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomFieldAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CustomFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    fieldType?: SortOrder
    isRequired?: SortOrder
    defaultValue?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomFieldMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    fieldType?: SortOrder
    isRequired?: SortOrder
    defaultValue?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomFieldSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type TagWorkspaceIdNameCompoundUniqueInput = {
    workspaceId: string
    name: string
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiConversationListRelationFilter = {
    every?: AiConversationWhereInput
    some?: AiConversationWhereInput
    none?: AiConversationWhereInput
  }

  export type AiConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiAgentCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    model?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiAgentAvgOrderByAggregateInput = {
    temperature?: SortOrder
    maxTokens?: SortOrder
  }

  export type AiAgentMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    model?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiAgentMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    model?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiAgentSumOrderByAggregateInput = {
    temperature?: SortOrder
    maxTokens?: SortOrder
  }

  export type AiAgentRelationFilter = {
    is?: AiAgentWhereInput
    isNot?: AiAgentWhereInput
  }

  export type AiMessageListRelationFilter = {
    every?: AiMessageWhereInput
    some?: AiMessageWhereInput
    none?: AiMessageWhereInput
  }

  export type AiMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiConversationCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    context?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiConversationMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiConversationRelationFilter = {
    is?: AiConversationWhereInput
    isNot?: AiConversationWhereInput
  }

  export type AiMessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    tokensUsed?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AiMessageAvgOrderByAggregateInput = {
    tokensUsed?: SortOrder
  }

  export type AiMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    tokensUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type AiMessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    tokensUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type AiMessageSumOrderByAggregateInput = {
    tokensUsed?: SortOrder
  }

  export type AiTokenUsageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    purpose?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AiTokenUsageAvgOrderByAggregateInput = {
    tokensUsed?: SortOrder
    cost?: SortOrder
  }

  export type AiTokenUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    purpose?: SortOrder
    createdAt?: SortOrder
  }

  export type AiTokenUsageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    purpose?: SortOrder
    createdAt?: SortOrder
  }

  export type AiTokenUsageSumOrderByAggregateInput = {
    tokensUsed?: SortOrder
    cost?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type UsageTrackingAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UsageTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    timestamp?: SortOrder
  }

  export type UsageTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    timestamp?: SortOrder
  }

  export type UsageTrackingSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UsageReportWorkspaceIdReportTypePeriodStartCompoundUniqueInput = {
    workspaceId: string
    reportType: string
    periodStart: Date | string
  }

  export type UsageReportCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    reportType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalUploads?: SortOrder
    totalMinutes?: SortOrder
    totalStorage?: SortOrder
    reportData?: SortOrder
    generatedAt?: SortOrder
  }

  export type UsageReportAvgOrderByAggregateInput = {
    totalUploads?: SortOrder
    totalMinutes?: SortOrder
    totalStorage?: SortOrder
  }

  export type UsageReportMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    reportType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalUploads?: SortOrder
    totalMinutes?: SortOrder
    totalStorage?: SortOrder
    generatedAt?: SortOrder
  }

  export type UsageReportMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    reportType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalUploads?: SortOrder
    totalMinutes?: SortOrder
    totalStorage?: SortOrder
    generatedAt?: SortOrder
  }

  export type UsageReportSumOrderByAggregateInput = {
    totalUploads?: SortOrder
    totalMinutes?: SortOrder
    totalStorage?: SortOrder
  }

  export type PaymentGatewayConfigProviderEnvironmentCompoundUniqueInput = {
    provider: string
    environment: string
  }

  export type PaymentGatewayConfigCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentGatewayConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentGatewayConfigMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPricingPlanIdCurrencyIntervalCompoundUniqueInput = {
    planId: string
    currency: string
    interval: string
  }

  export type PlanPricingCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    price?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPricingAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PlanPricingMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    price?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPricingMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    price?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPricingSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EwayCustomerNullableRelationFilter = {
    is?: EwayCustomerWhereInput | null
    isNot?: EwayCustomerWhereInput | null
  }

  export type EwayTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerToken?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    transactionStatus?: SortOrder
    responseCode?: SortOrder
    responseMessage?: SortOrder
    authCode?: SortOrder
    beagleScore?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    beagleScore?: SortOrder
  }

  export type EwayTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerToken?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    transactionStatus?: SortOrder
    responseCode?: SortOrder
    responseMessage?: SortOrder
    authCode?: SortOrder
    beagleScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerToken?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    transactionStatus?: SortOrder
    responseCode?: SortOrder
    responseMessage?: SortOrder
    authCode?: SortOrder
    beagleScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    beagleScore?: SortOrder
  }

  export type EwayTransactionListRelationFilter = {
    every?: EwayTransactionWhereInput
    some?: EwayTransactionWhereInput
    none?: EwayTransactionWhereInput
  }

  export type EwayRecurringScheduleListRelationFilter = {
    every?: EwayRecurringScheduleWhereInput
    some?: EwayRecurringScheduleWhereInput
    none?: EwayRecurringScheduleWhereInput
  }

  export type EwayTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EwayRecurringScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EwayCustomerCountOrderByAggregateInput = {
    id?: SortOrder
    customerToken?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    cardNumber?: SortOrder
    cardName?: SortOrder
    cardExpiryMonth?: SortOrder
    cardExpiryYear?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayCustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    customerToken?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cardNumber?: SortOrder
    cardName?: SortOrder
    cardExpiryMonth?: SortOrder
    cardExpiryYear?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayCustomerMinOrderByAggregateInput = {
    id?: SortOrder
    customerToken?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cardNumber?: SortOrder
    cardName?: SortOrder
    cardExpiryMonth?: SortOrder
    cardExpiryYear?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayCustomerRelationFilter = {
    is?: EwayCustomerWhereInput
    isNot?: EwayCustomerWhereInput
  }

  export type EwayRecurringScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    customerToken?: SortOrder
    interval?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    nextPayment?: SortOrder
    lastPayment?: SortOrder
    paymentCount?: SortOrder
    maxPayments?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayRecurringScheduleAvgOrderByAggregateInput = {
    amount?: SortOrder
    paymentCount?: SortOrder
    maxPayments?: SortOrder
  }

  export type EwayRecurringScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    customerToken?: SortOrder
    interval?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    nextPayment?: SortOrder
    lastPayment?: SortOrder
    paymentCount?: SortOrder
    maxPayments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayRecurringScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    customerToken?: SortOrder
    interval?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    nextPayment?: SortOrder
    lastPayment?: SortOrder
    paymentCount?: SortOrder
    maxPayments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EwayRecurringScheduleSumOrderByAggregateInput = {
    amount?: SortOrder
    paymentCount?: SortOrder
    maxPayments?: SortOrder
  }

  export type EwayWebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    transactionId?: SortOrder
    customerToken?: SortOrder
    payload?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    error?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
  }

  export type EwayWebhookEventAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type EwayWebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    transactionId?: SortOrder
    customerToken?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    error?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
  }

  export type EwayWebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    transactionId?: SortOrder
    customerToken?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    error?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
  }

  export type EwayWebhookEventSumOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type SystemConfigCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    key?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    key?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthCheckCountOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    details?: SortOrder
    checkedAt?: SortOrder
  }

  export type HealthCheckAvgOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type HealthCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    checkedAt?: SortOrder
  }

  export type HealthCheckMinOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    checkedAt?: SortOrder
  }

  export type HealthCheckSumOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type WorkspaceUserCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type AudioHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioHistoryCreateWithoutUserInput, AudioHistoryUncheckedCreateWithoutUserInput> | AudioHistoryCreateWithoutUserInput[] | AudioHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutUserInput | AudioHistoryCreateOrConnectWithoutUserInput[]
    createMany?: AudioHistoryCreateManyUserInputEnvelope
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
  }

  export type AudioUploadCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioUploadCreateWithoutUserInput, AudioUploadUncheckedCreateWithoutUserInput> | AudioUploadCreateWithoutUserInput[] | AudioUploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutUserInput | AudioUploadCreateOrConnectWithoutUserInput[]
    createMany?: AudioUploadCreateManyUserInputEnvelope
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
  }

  export type ApiKeyManagementCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyManagementCreateWithoutUserInput, ApiKeyManagementUncheckedCreateWithoutUserInput> | ApiKeyManagementCreateWithoutUserInput[] | ApiKeyManagementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyManagementCreateOrConnectWithoutUserInput | ApiKeyManagementCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyManagementCreateManyUserInputEnvelope
    connect?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SecurityEventCreateNestedManyWithoutUserInput = {
    create?: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput> | SecurityEventCreateWithoutUserInput[] | SecurityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityEventCreateOrConnectWithoutUserInput | SecurityEventCreateOrConnectWithoutUserInput[]
    createMany?: SecurityEventCreateManyUserInputEnvelope
    connect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AudioSegmentCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioSegmentCreateWithoutUserInput, AudioSegmentUncheckedCreateWithoutUserInput> | AudioSegmentCreateWithoutUserInput[] | AudioSegmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioSegmentCreateOrConnectWithoutUserInput | AudioSegmentCreateOrConnectWithoutUserInput[]
    createMany?: AudioSegmentCreateManyUserInputEnvelope
    connect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
  }

  export type EmailPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<EmailPreferenceCreateWithoutUserInput, EmailPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailPreferenceCreateOrConnectWithoutUserInput
    connect?: EmailPreferenceWhereUniqueInput
  }

  export type UserQuotaCreateNestedManyWithoutUserInput = {
    create?: XOR<UserQuotaCreateWithoutUserInput, UserQuotaUncheckedCreateWithoutUserInput> | UserQuotaCreateWithoutUserInput[] | UserQuotaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQuotaCreateOrConnectWithoutUserInput | UserQuotaCreateOrConnectWithoutUserInput[]
    createMany?: UserQuotaCreateManyUserInputEnvelope
    connect?: UserQuotaWhereUniqueInput | UserQuotaWhereUniqueInput[]
  }

  export type AiTokenUsageCreateNestedManyWithoutUserInput = {
    create?: XOR<AiTokenUsageCreateWithoutUserInput, AiTokenUsageUncheckedCreateWithoutUserInput> | AiTokenUsageCreateWithoutUserInput[] | AiTokenUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiTokenUsageCreateOrConnectWithoutUserInput | AiTokenUsageCreateOrConnectWithoutUserInput[]
    createMany?: AiTokenUsageCreateManyUserInputEnvelope
    connect?: AiTokenUsageWhereUniqueInput | AiTokenUsageWhereUniqueInput[]
  }

  export type WorkspaceUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type AudioHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioHistoryCreateWithoutUserInput, AudioHistoryUncheckedCreateWithoutUserInput> | AudioHistoryCreateWithoutUserInput[] | AudioHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutUserInput | AudioHistoryCreateOrConnectWithoutUserInput[]
    createMany?: AudioHistoryCreateManyUserInputEnvelope
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
  }

  export type AudioUploadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioUploadCreateWithoutUserInput, AudioUploadUncheckedCreateWithoutUserInput> | AudioUploadCreateWithoutUserInput[] | AudioUploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutUserInput | AudioUploadCreateOrConnectWithoutUserInput[]
    createMany?: AudioUploadCreateManyUserInputEnvelope
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
  }

  export type ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyManagementCreateWithoutUserInput, ApiKeyManagementUncheckedCreateWithoutUserInput> | ApiKeyManagementCreateWithoutUserInput[] | ApiKeyManagementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyManagementCreateOrConnectWithoutUserInput | ApiKeyManagementCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyManagementCreateManyUserInputEnvelope
    connect?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SecurityEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput> | SecurityEventCreateWithoutUserInput[] | SecurityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityEventCreateOrConnectWithoutUserInput | SecurityEventCreateOrConnectWithoutUserInput[]
    createMany?: SecurityEventCreateManyUserInputEnvelope
    connect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AudioSegmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioSegmentCreateWithoutUserInput, AudioSegmentUncheckedCreateWithoutUserInput> | AudioSegmentCreateWithoutUserInput[] | AudioSegmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioSegmentCreateOrConnectWithoutUserInput | AudioSegmentCreateOrConnectWithoutUserInput[]
    createMany?: AudioSegmentCreateManyUserInputEnvelope
    connect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
  }

  export type EmailPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmailPreferenceCreateWithoutUserInput, EmailPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailPreferenceCreateOrConnectWithoutUserInput
    connect?: EmailPreferenceWhereUniqueInput
  }

  export type UserQuotaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserQuotaCreateWithoutUserInput, UserQuotaUncheckedCreateWithoutUserInput> | UserQuotaCreateWithoutUserInput[] | UserQuotaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQuotaCreateOrConnectWithoutUserInput | UserQuotaCreateOrConnectWithoutUserInput[]
    createMany?: UserQuotaCreateManyUserInputEnvelope
    connect?: UserQuotaWhereUniqueInput | UserQuotaWhereUniqueInput[]
  }

  export type AiTokenUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AiTokenUsageCreateWithoutUserInput, AiTokenUsageUncheckedCreateWithoutUserInput> | AiTokenUsageCreateWithoutUserInput[] | AiTokenUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiTokenUsageCreateOrConnectWithoutUserInput | AiTokenUsageCreateOrConnectWithoutUserInput[]
    createMany?: AiTokenUsageCreateManyUserInputEnvelope
    connect?: AiTokenUsageWhereUniqueInput | AiTokenUsageWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type WorkspaceUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutUserInput | WorkspaceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutUserInput | WorkspaceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutUserInput | WorkspaceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type AudioHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutUserInput, AudioHistoryUncheckedCreateWithoutUserInput> | AudioHistoryCreateWithoutUserInput[] | AudioHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutUserInput | AudioHistoryCreateOrConnectWithoutUserInput[]
    upsert?: AudioHistoryUpsertWithWhereUniqueWithoutUserInput | AudioHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioHistoryCreateManyUserInputEnvelope
    set?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    disconnect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    delete?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    update?: AudioHistoryUpdateWithWhereUniqueWithoutUserInput | AudioHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioHistoryUpdateManyWithWhereWithoutUserInput | AudioHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
  }

  export type AudioUploadUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioUploadCreateWithoutUserInput, AudioUploadUncheckedCreateWithoutUserInput> | AudioUploadCreateWithoutUserInput[] | AudioUploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutUserInput | AudioUploadCreateOrConnectWithoutUserInput[]
    upsert?: AudioUploadUpsertWithWhereUniqueWithoutUserInput | AudioUploadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioUploadCreateManyUserInputEnvelope
    set?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    disconnect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    delete?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    update?: AudioUploadUpdateWithWhereUniqueWithoutUserInput | AudioUploadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioUploadUpdateManyWithWhereWithoutUserInput | AudioUploadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioUploadScalarWhereInput | AudioUploadScalarWhereInput[]
  }

  export type ApiKeyManagementUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyManagementCreateWithoutUserInput, ApiKeyManagementUncheckedCreateWithoutUserInput> | ApiKeyManagementCreateWithoutUserInput[] | ApiKeyManagementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyManagementCreateOrConnectWithoutUserInput | ApiKeyManagementCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyManagementUpsertWithWhereUniqueWithoutUserInput | ApiKeyManagementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyManagementCreateManyUserInputEnvelope
    set?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    disconnect?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    delete?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    connect?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    update?: ApiKeyManagementUpdateWithWhereUniqueWithoutUserInput | ApiKeyManagementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyManagementUpdateManyWithWhereWithoutUserInput | ApiKeyManagementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyManagementScalarWhereInput | ApiKeyManagementScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SecurityEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput> | SecurityEventCreateWithoutUserInput[] | SecurityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityEventCreateOrConnectWithoutUserInput | SecurityEventCreateOrConnectWithoutUserInput[]
    upsert?: SecurityEventUpsertWithWhereUniqueWithoutUserInput | SecurityEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SecurityEventCreateManyUserInputEnvelope
    set?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    disconnect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    delete?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    connect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    update?: SecurityEventUpdateWithWhereUniqueWithoutUserInput | SecurityEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SecurityEventUpdateManyWithWhereWithoutUserInput | SecurityEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SecurityEventScalarWhereInput | SecurityEventScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AudioSegmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioSegmentCreateWithoutUserInput, AudioSegmentUncheckedCreateWithoutUserInput> | AudioSegmentCreateWithoutUserInput[] | AudioSegmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioSegmentCreateOrConnectWithoutUserInput | AudioSegmentCreateOrConnectWithoutUserInput[]
    upsert?: AudioSegmentUpsertWithWhereUniqueWithoutUserInput | AudioSegmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioSegmentCreateManyUserInputEnvelope
    set?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    disconnect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    delete?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    connect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    update?: AudioSegmentUpdateWithWhereUniqueWithoutUserInput | AudioSegmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioSegmentUpdateManyWithWhereWithoutUserInput | AudioSegmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioSegmentScalarWhereInput | AudioSegmentScalarWhereInput[]
  }

  export type EmailPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmailPreferenceCreateWithoutUserInput, EmailPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailPreferenceCreateOrConnectWithoutUserInput
    upsert?: EmailPreferenceUpsertWithoutUserInput
    disconnect?: EmailPreferenceWhereInput | boolean
    delete?: EmailPreferenceWhereInput | boolean
    connect?: EmailPreferenceWhereUniqueInput
    update?: XOR<XOR<EmailPreferenceUpdateToOneWithWhereWithoutUserInput, EmailPreferenceUpdateWithoutUserInput>, EmailPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type UserQuotaUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserQuotaCreateWithoutUserInput, UserQuotaUncheckedCreateWithoutUserInput> | UserQuotaCreateWithoutUserInput[] | UserQuotaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQuotaCreateOrConnectWithoutUserInput | UserQuotaCreateOrConnectWithoutUserInput[]
    upsert?: UserQuotaUpsertWithWhereUniqueWithoutUserInput | UserQuotaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserQuotaCreateManyUserInputEnvelope
    set?: UserQuotaWhereUniqueInput | UserQuotaWhereUniqueInput[]
    disconnect?: UserQuotaWhereUniqueInput | UserQuotaWhereUniqueInput[]
    delete?: UserQuotaWhereUniqueInput | UserQuotaWhereUniqueInput[]
    connect?: UserQuotaWhereUniqueInput | UserQuotaWhereUniqueInput[]
    update?: UserQuotaUpdateWithWhereUniqueWithoutUserInput | UserQuotaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserQuotaUpdateManyWithWhereWithoutUserInput | UserQuotaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserQuotaScalarWhereInput | UserQuotaScalarWhereInput[]
  }

  export type AiTokenUsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<AiTokenUsageCreateWithoutUserInput, AiTokenUsageUncheckedCreateWithoutUserInput> | AiTokenUsageCreateWithoutUserInput[] | AiTokenUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiTokenUsageCreateOrConnectWithoutUserInput | AiTokenUsageCreateOrConnectWithoutUserInput[]
    upsert?: AiTokenUsageUpsertWithWhereUniqueWithoutUserInput | AiTokenUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AiTokenUsageCreateManyUserInputEnvelope
    set?: AiTokenUsageWhereUniqueInput | AiTokenUsageWhereUniqueInput[]
    disconnect?: AiTokenUsageWhereUniqueInput | AiTokenUsageWhereUniqueInput[]
    delete?: AiTokenUsageWhereUniqueInput | AiTokenUsageWhereUniqueInput[]
    connect?: AiTokenUsageWhereUniqueInput | AiTokenUsageWhereUniqueInput[]
    update?: AiTokenUsageUpdateWithWhereUniqueWithoutUserInput | AiTokenUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AiTokenUsageUpdateManyWithWhereWithoutUserInput | AiTokenUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AiTokenUsageScalarWhereInput | AiTokenUsageScalarWhereInput[]
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutUserInput | WorkspaceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutUserInput | WorkspaceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutUserInput | WorkspaceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type AudioHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutUserInput, AudioHistoryUncheckedCreateWithoutUserInput> | AudioHistoryCreateWithoutUserInput[] | AudioHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutUserInput | AudioHistoryCreateOrConnectWithoutUserInput[]
    upsert?: AudioHistoryUpsertWithWhereUniqueWithoutUserInput | AudioHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioHistoryCreateManyUserInputEnvelope
    set?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    disconnect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    delete?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    update?: AudioHistoryUpdateWithWhereUniqueWithoutUserInput | AudioHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioHistoryUpdateManyWithWhereWithoutUserInput | AudioHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
  }

  export type AudioUploadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioUploadCreateWithoutUserInput, AudioUploadUncheckedCreateWithoutUserInput> | AudioUploadCreateWithoutUserInput[] | AudioUploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutUserInput | AudioUploadCreateOrConnectWithoutUserInput[]
    upsert?: AudioUploadUpsertWithWhereUniqueWithoutUserInput | AudioUploadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioUploadCreateManyUserInputEnvelope
    set?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    disconnect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    delete?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    update?: AudioUploadUpdateWithWhereUniqueWithoutUserInput | AudioUploadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioUploadUpdateManyWithWhereWithoutUserInput | AudioUploadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioUploadScalarWhereInput | AudioUploadScalarWhereInput[]
  }

  export type ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyManagementCreateWithoutUserInput, ApiKeyManagementUncheckedCreateWithoutUserInput> | ApiKeyManagementCreateWithoutUserInput[] | ApiKeyManagementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyManagementCreateOrConnectWithoutUserInput | ApiKeyManagementCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyManagementUpsertWithWhereUniqueWithoutUserInput | ApiKeyManagementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyManagementCreateManyUserInputEnvelope
    set?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    disconnect?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    delete?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    connect?: ApiKeyManagementWhereUniqueInput | ApiKeyManagementWhereUniqueInput[]
    update?: ApiKeyManagementUpdateWithWhereUniqueWithoutUserInput | ApiKeyManagementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyManagementUpdateManyWithWhereWithoutUserInput | ApiKeyManagementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyManagementScalarWhereInput | ApiKeyManagementScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SecurityEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput> | SecurityEventCreateWithoutUserInput[] | SecurityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityEventCreateOrConnectWithoutUserInput | SecurityEventCreateOrConnectWithoutUserInput[]
    upsert?: SecurityEventUpsertWithWhereUniqueWithoutUserInput | SecurityEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SecurityEventCreateManyUserInputEnvelope
    set?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    disconnect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    delete?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    connect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    update?: SecurityEventUpdateWithWhereUniqueWithoutUserInput | SecurityEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SecurityEventUpdateManyWithWhereWithoutUserInput | SecurityEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SecurityEventScalarWhereInput | SecurityEventScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AudioSegmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioSegmentCreateWithoutUserInput, AudioSegmentUncheckedCreateWithoutUserInput> | AudioSegmentCreateWithoutUserInput[] | AudioSegmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioSegmentCreateOrConnectWithoutUserInput | AudioSegmentCreateOrConnectWithoutUserInput[]
    upsert?: AudioSegmentUpsertWithWhereUniqueWithoutUserInput | AudioSegmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioSegmentCreateManyUserInputEnvelope
    set?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    disconnect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    delete?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    connect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    update?: AudioSegmentUpdateWithWhereUniqueWithoutUserInput | AudioSegmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioSegmentUpdateManyWithWhereWithoutUserInput | AudioSegmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioSegmentScalarWhereInput | AudioSegmentScalarWhereInput[]
  }

  export type EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmailPreferenceCreateWithoutUserInput, EmailPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailPreferenceCreateOrConnectWithoutUserInput
    upsert?: EmailPreferenceUpsertWithoutUserInput
    disconnect?: EmailPreferenceWhereInput | boolean
    delete?: EmailPreferenceWhereInput | boolean
    connect?: EmailPreferenceWhereUniqueInput
    update?: XOR<XOR<EmailPreferenceUpdateToOneWithWhereWithoutUserInput, EmailPreferenceUpdateWithoutUserInput>, EmailPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type UserQuotaUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserQuotaCreateWithoutUserInput, UserQuotaUncheckedCreateWithoutUserInput> | UserQuotaCreateWithoutUserInput[] | UserQuotaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQuotaCreateOrConnectWithoutUserInput | UserQuotaCreateOrConnectWithoutUserInput[]
    upsert?: UserQuotaUpsertWithWhereUniqueWithoutUserInput | UserQuotaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserQuotaCreateManyUserInputEnvelope
    set?: UserQuotaWhereUniqueInput | UserQuotaWhereUniqueInput[]
    disconnect?: UserQuotaWhereUniqueInput | UserQuotaWhereUniqueInput[]
    delete?: UserQuotaWhereUniqueInput | UserQuotaWhereUniqueInput[]
    connect?: UserQuotaWhereUniqueInput | UserQuotaWhereUniqueInput[]
    update?: UserQuotaUpdateWithWhereUniqueWithoutUserInput | UserQuotaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserQuotaUpdateManyWithWhereWithoutUserInput | UserQuotaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserQuotaScalarWhereInput | UserQuotaScalarWhereInput[]
  }

  export type AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AiTokenUsageCreateWithoutUserInput, AiTokenUsageUncheckedCreateWithoutUserInput> | AiTokenUsageCreateWithoutUserInput[] | AiTokenUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiTokenUsageCreateOrConnectWithoutUserInput | AiTokenUsageCreateOrConnectWithoutUserInput[]
    upsert?: AiTokenUsageUpsertWithWhereUniqueWithoutUserInput | AiTokenUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AiTokenUsageCreateManyUserInputEnvelope
    set?: AiTokenUsageWhereUniqueInput | AiTokenUsageWhereUniqueInput[]
    disconnect?: AiTokenUsageWhereUniqueInput | AiTokenUsageWhereUniqueInput[]
    delete?: AiTokenUsageWhereUniqueInput | AiTokenUsageWhereUniqueInput[]
    connect?: AiTokenUsageWhereUniqueInput | AiTokenUsageWhereUniqueInput[]
    update?: AiTokenUsageUpdateWithWhereUniqueWithoutUserInput | AiTokenUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AiTokenUsageUpdateManyWithWhereWithoutUserInput | AiTokenUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AiTokenUsageScalarWhereInput | AiTokenUsageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type WorkspaceUserCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type AudioHistoryCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AudioHistoryCreateWithoutWorkspaceInput, AudioHistoryUncheckedCreateWithoutWorkspaceInput> | AudioHistoryCreateWithoutWorkspaceInput[] | AudioHistoryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutWorkspaceInput | AudioHistoryCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AudioHistoryCreateManyWorkspaceInputEnvelope
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
  }

  export type AudioUploadCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AudioUploadCreateWithoutWorkspaceInput, AudioUploadUncheckedCreateWithoutWorkspaceInput> | AudioUploadCreateWithoutWorkspaceInput[] | AudioUploadUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutWorkspaceInput | AudioUploadCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AudioUploadCreateManyWorkspaceInputEnvelope
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
  }

  export type WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput> | WorkspaceSubscriptionCreateWithoutWorkspaceInput[] | WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput | WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceSubscriptionCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
  }

  export type StorageQuotaCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<StorageQuotaCreateWithoutWorkspaceInput, StorageQuotaUncheckedCreateWithoutWorkspaceInput> | StorageQuotaCreateWithoutWorkspaceInput[] | StorageQuotaUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: StorageQuotaCreateOrConnectWithoutWorkspaceInput | StorageQuotaCreateOrConnectWithoutWorkspaceInput[]
    createMany?: StorageQuotaCreateManyWorkspaceInputEnvelope
    connect?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
  }

  export type IntegrationCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<IntegrationCreateWithoutWorkspaceInput, IntegrationUncheckedCreateWithoutWorkspaceInput> | IntegrationCreateWithoutWorkspaceInput[] | IntegrationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutWorkspaceInput | IntegrationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: IntegrationCreateManyWorkspaceInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceAutomationCreateWithoutWorkspaceInput, WorkspaceAutomationUncheckedCreateWithoutWorkspaceInput> | WorkspaceAutomationCreateWithoutWorkspaceInput[] | WorkspaceAutomationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceAutomationCreateOrConnectWithoutWorkspaceInput | WorkspaceAutomationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceAutomationCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceAutomationWhereUniqueInput | WorkspaceAutomationWhereUniqueInput[]
  }

  export type WebhookCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WebhookCreateWithoutWorkspaceInput, WebhookUncheckedCreateWithoutWorkspaceInput> | WebhookCreateWithoutWorkspaceInput[] | WebhookUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutWorkspaceInput | WebhookCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WebhookCreateManyWorkspaceInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type CustomFieldCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<CustomFieldCreateWithoutWorkspaceInput, CustomFieldUncheckedCreateWithoutWorkspaceInput> | CustomFieldCreateWithoutWorkspaceInput[] | CustomFieldUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutWorkspaceInput | CustomFieldCreateOrConnectWithoutWorkspaceInput[]
    createMany?: CustomFieldCreateManyWorkspaceInputEnvelope
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<TagCreateWithoutWorkspaceInput, TagUncheckedCreateWithoutWorkspaceInput> | TagCreateWithoutWorkspaceInput[] | TagUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: TagCreateOrConnectWithoutWorkspaceInput | TagCreateOrConnectWithoutWorkspaceInput[]
    createMany?: TagCreateManyWorkspaceInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type AiAgentCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AiAgentCreateWithoutWorkspaceInput, AiAgentUncheckedCreateWithoutWorkspaceInput> | AiAgentCreateWithoutWorkspaceInput[] | AiAgentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AiAgentCreateOrConnectWithoutWorkspaceInput | AiAgentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AiAgentCreateManyWorkspaceInputEnvelope
    connect?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
  }

  export type WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AudioHistoryCreateWithoutWorkspaceInput, AudioHistoryUncheckedCreateWithoutWorkspaceInput> | AudioHistoryCreateWithoutWorkspaceInput[] | AudioHistoryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutWorkspaceInput | AudioHistoryCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AudioHistoryCreateManyWorkspaceInputEnvelope
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
  }

  export type AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AudioUploadCreateWithoutWorkspaceInput, AudioUploadUncheckedCreateWithoutWorkspaceInput> | AudioUploadCreateWithoutWorkspaceInput[] | AudioUploadUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutWorkspaceInput | AudioUploadCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AudioUploadCreateManyWorkspaceInputEnvelope
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
  }

  export type WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput> | WorkspaceSubscriptionCreateWithoutWorkspaceInput[] | WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput | WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceSubscriptionCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
  }

  export type StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<StorageQuotaCreateWithoutWorkspaceInput, StorageQuotaUncheckedCreateWithoutWorkspaceInput> | StorageQuotaCreateWithoutWorkspaceInput[] | StorageQuotaUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: StorageQuotaCreateOrConnectWithoutWorkspaceInput | StorageQuotaCreateOrConnectWithoutWorkspaceInput[]
    createMany?: StorageQuotaCreateManyWorkspaceInputEnvelope
    connect?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
  }

  export type IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<IntegrationCreateWithoutWorkspaceInput, IntegrationUncheckedCreateWithoutWorkspaceInput> | IntegrationCreateWithoutWorkspaceInput[] | IntegrationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutWorkspaceInput | IntegrationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: IntegrationCreateManyWorkspaceInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceAutomationCreateWithoutWorkspaceInput, WorkspaceAutomationUncheckedCreateWithoutWorkspaceInput> | WorkspaceAutomationCreateWithoutWorkspaceInput[] | WorkspaceAutomationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceAutomationCreateOrConnectWithoutWorkspaceInput | WorkspaceAutomationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceAutomationCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceAutomationWhereUniqueInput | WorkspaceAutomationWhereUniqueInput[]
  }

  export type WebhookUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WebhookCreateWithoutWorkspaceInput, WebhookUncheckedCreateWithoutWorkspaceInput> | WebhookCreateWithoutWorkspaceInput[] | WebhookUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutWorkspaceInput | WebhookCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WebhookCreateManyWorkspaceInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<CustomFieldCreateWithoutWorkspaceInput, CustomFieldUncheckedCreateWithoutWorkspaceInput> | CustomFieldCreateWithoutWorkspaceInput[] | CustomFieldUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutWorkspaceInput | CustomFieldCreateOrConnectWithoutWorkspaceInput[]
    createMany?: CustomFieldCreateManyWorkspaceInputEnvelope
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<TagCreateWithoutWorkspaceInput, TagUncheckedCreateWithoutWorkspaceInput> | TagCreateWithoutWorkspaceInput[] | TagUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: TagCreateOrConnectWithoutWorkspaceInput | TagCreateOrConnectWithoutWorkspaceInput[]
    createMany?: TagCreateManyWorkspaceInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AiAgentCreateWithoutWorkspaceInput, AiAgentUncheckedCreateWithoutWorkspaceInput> | AiAgentCreateWithoutWorkspaceInput[] | AiAgentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AiAgentCreateOrConnectWithoutWorkspaceInput | AiAgentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AiAgentCreateManyWorkspaceInputEnvelope
    connect?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
  }

  export type WorkspaceUserUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type AudioHistoryUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutWorkspaceInput, AudioHistoryUncheckedCreateWithoutWorkspaceInput> | AudioHistoryCreateWithoutWorkspaceInput[] | AudioHistoryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutWorkspaceInput | AudioHistoryCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AudioHistoryUpsertWithWhereUniqueWithoutWorkspaceInput | AudioHistoryUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AudioHistoryCreateManyWorkspaceInputEnvelope
    set?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    disconnect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    delete?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    update?: AudioHistoryUpdateWithWhereUniqueWithoutWorkspaceInput | AudioHistoryUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AudioHistoryUpdateManyWithWhereWithoutWorkspaceInput | AudioHistoryUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
  }

  export type AudioUploadUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AudioUploadCreateWithoutWorkspaceInput, AudioUploadUncheckedCreateWithoutWorkspaceInput> | AudioUploadCreateWithoutWorkspaceInput[] | AudioUploadUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutWorkspaceInput | AudioUploadCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AudioUploadUpsertWithWhereUniqueWithoutWorkspaceInput | AudioUploadUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AudioUploadCreateManyWorkspaceInputEnvelope
    set?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    disconnect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    delete?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    update?: AudioUploadUpdateWithWhereUniqueWithoutWorkspaceInput | AudioUploadUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AudioUploadUpdateManyWithWhereWithoutWorkspaceInput | AudioUploadUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AudioUploadScalarWhereInput | AudioUploadScalarWhereInput[]
  }

  export type WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput> | WorkspaceSubscriptionCreateWithoutWorkspaceInput[] | WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput | WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceSubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceSubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceSubscriptionCreateManyWorkspaceInputEnvelope
    set?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    disconnect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    delete?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    update?: WorkspaceSubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceSubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceSubscriptionUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceSubscriptionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceSubscriptionScalarWhereInput | WorkspaceSubscriptionScalarWhereInput[]
  }

  export type StorageQuotaUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<StorageQuotaCreateWithoutWorkspaceInput, StorageQuotaUncheckedCreateWithoutWorkspaceInput> | StorageQuotaCreateWithoutWorkspaceInput[] | StorageQuotaUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: StorageQuotaCreateOrConnectWithoutWorkspaceInput | StorageQuotaCreateOrConnectWithoutWorkspaceInput[]
    upsert?: StorageQuotaUpsertWithWhereUniqueWithoutWorkspaceInput | StorageQuotaUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: StorageQuotaCreateManyWorkspaceInputEnvelope
    set?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    disconnect?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    delete?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    connect?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    update?: StorageQuotaUpdateWithWhereUniqueWithoutWorkspaceInput | StorageQuotaUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: StorageQuotaUpdateManyWithWhereWithoutWorkspaceInput | StorageQuotaUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: StorageQuotaScalarWhereInput | StorageQuotaScalarWhereInput[]
  }

  export type IntegrationUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<IntegrationCreateWithoutWorkspaceInput, IntegrationUncheckedCreateWithoutWorkspaceInput> | IntegrationCreateWithoutWorkspaceInput[] | IntegrationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutWorkspaceInput | IntegrationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutWorkspaceInput | IntegrationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: IntegrationCreateManyWorkspaceInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutWorkspaceInput | IntegrationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutWorkspaceInput | IntegrationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceAutomationCreateWithoutWorkspaceInput, WorkspaceAutomationUncheckedCreateWithoutWorkspaceInput> | WorkspaceAutomationCreateWithoutWorkspaceInput[] | WorkspaceAutomationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceAutomationCreateOrConnectWithoutWorkspaceInput | WorkspaceAutomationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceAutomationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceAutomationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceAutomationCreateManyWorkspaceInputEnvelope
    set?: WorkspaceAutomationWhereUniqueInput | WorkspaceAutomationWhereUniqueInput[]
    disconnect?: WorkspaceAutomationWhereUniqueInput | WorkspaceAutomationWhereUniqueInput[]
    delete?: WorkspaceAutomationWhereUniqueInput | WorkspaceAutomationWhereUniqueInput[]
    connect?: WorkspaceAutomationWhereUniqueInput | WorkspaceAutomationWhereUniqueInput[]
    update?: WorkspaceAutomationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceAutomationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceAutomationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceAutomationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceAutomationScalarWhereInput | WorkspaceAutomationScalarWhereInput[]
  }

  export type WebhookUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WebhookCreateWithoutWorkspaceInput, WebhookUncheckedCreateWithoutWorkspaceInput> | WebhookCreateWithoutWorkspaceInput[] | WebhookUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutWorkspaceInput | WebhookCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutWorkspaceInput | WebhookUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WebhookCreateManyWorkspaceInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutWorkspaceInput | WebhookUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutWorkspaceInput | WebhookUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type CustomFieldUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<CustomFieldCreateWithoutWorkspaceInput, CustomFieldUncheckedCreateWithoutWorkspaceInput> | CustomFieldCreateWithoutWorkspaceInput[] | CustomFieldUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutWorkspaceInput | CustomFieldCreateOrConnectWithoutWorkspaceInput[]
    upsert?: CustomFieldUpsertWithWhereUniqueWithoutWorkspaceInput | CustomFieldUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: CustomFieldCreateManyWorkspaceInputEnvelope
    set?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    disconnect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    delete?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    update?: CustomFieldUpdateWithWhereUniqueWithoutWorkspaceInput | CustomFieldUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: CustomFieldUpdateManyWithWhereWithoutWorkspaceInput | CustomFieldUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
  }

  export type TagUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<TagCreateWithoutWorkspaceInput, TagUncheckedCreateWithoutWorkspaceInput> | TagCreateWithoutWorkspaceInput[] | TagUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: TagCreateOrConnectWithoutWorkspaceInput | TagCreateOrConnectWithoutWorkspaceInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutWorkspaceInput | TagUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: TagCreateManyWorkspaceInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutWorkspaceInput | TagUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: TagUpdateManyWithWhereWithoutWorkspaceInput | TagUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type AiAgentUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AiAgentCreateWithoutWorkspaceInput, AiAgentUncheckedCreateWithoutWorkspaceInput> | AiAgentCreateWithoutWorkspaceInput[] | AiAgentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AiAgentCreateOrConnectWithoutWorkspaceInput | AiAgentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AiAgentUpsertWithWhereUniqueWithoutWorkspaceInput | AiAgentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AiAgentCreateManyWorkspaceInputEnvelope
    set?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    disconnect?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    delete?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    connect?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    update?: AiAgentUpdateWithWhereUniqueWithoutWorkspaceInput | AiAgentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AiAgentUpdateManyWithWhereWithoutWorkspaceInput | AiAgentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AiAgentScalarWhereInput | AiAgentScalarWhereInput[]
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutWorkspaceInput, AudioHistoryUncheckedCreateWithoutWorkspaceInput> | AudioHistoryCreateWithoutWorkspaceInput[] | AudioHistoryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutWorkspaceInput | AudioHistoryCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AudioHistoryUpsertWithWhereUniqueWithoutWorkspaceInput | AudioHistoryUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AudioHistoryCreateManyWorkspaceInputEnvelope
    set?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    disconnect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    delete?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    connect?: AudioHistoryWhereUniqueInput | AudioHistoryWhereUniqueInput[]
    update?: AudioHistoryUpdateWithWhereUniqueWithoutWorkspaceInput | AudioHistoryUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AudioHistoryUpdateManyWithWhereWithoutWorkspaceInput | AudioHistoryUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
  }

  export type AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AudioUploadCreateWithoutWorkspaceInput, AudioUploadUncheckedCreateWithoutWorkspaceInput> | AudioUploadCreateWithoutWorkspaceInput[] | AudioUploadUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AudioUploadCreateOrConnectWithoutWorkspaceInput | AudioUploadCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AudioUploadUpsertWithWhereUniqueWithoutWorkspaceInput | AudioUploadUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AudioUploadCreateManyWorkspaceInputEnvelope
    set?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    disconnect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    delete?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    connect?: AudioUploadWhereUniqueInput | AudioUploadWhereUniqueInput[]
    update?: AudioUploadUpdateWithWhereUniqueWithoutWorkspaceInput | AudioUploadUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AudioUploadUpdateManyWithWhereWithoutWorkspaceInput | AudioUploadUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AudioUploadScalarWhereInput | AudioUploadScalarWhereInput[]
  }

  export type WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput> | WorkspaceSubscriptionCreateWithoutWorkspaceInput[] | WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput | WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceSubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceSubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceSubscriptionCreateManyWorkspaceInputEnvelope
    set?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    disconnect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    delete?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    update?: WorkspaceSubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceSubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceSubscriptionUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceSubscriptionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceSubscriptionScalarWhereInput | WorkspaceSubscriptionScalarWhereInput[]
  }

  export type StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<StorageQuotaCreateWithoutWorkspaceInput, StorageQuotaUncheckedCreateWithoutWorkspaceInput> | StorageQuotaCreateWithoutWorkspaceInput[] | StorageQuotaUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: StorageQuotaCreateOrConnectWithoutWorkspaceInput | StorageQuotaCreateOrConnectWithoutWorkspaceInput[]
    upsert?: StorageQuotaUpsertWithWhereUniqueWithoutWorkspaceInput | StorageQuotaUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: StorageQuotaCreateManyWorkspaceInputEnvelope
    set?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    disconnect?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    delete?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    connect?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    update?: StorageQuotaUpdateWithWhereUniqueWithoutWorkspaceInput | StorageQuotaUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: StorageQuotaUpdateManyWithWhereWithoutWorkspaceInput | StorageQuotaUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: StorageQuotaScalarWhereInput | StorageQuotaScalarWhereInput[]
  }

  export type IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<IntegrationCreateWithoutWorkspaceInput, IntegrationUncheckedCreateWithoutWorkspaceInput> | IntegrationCreateWithoutWorkspaceInput[] | IntegrationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutWorkspaceInput | IntegrationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutWorkspaceInput | IntegrationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: IntegrationCreateManyWorkspaceInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutWorkspaceInput | IntegrationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutWorkspaceInput | IntegrationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceAutomationCreateWithoutWorkspaceInput, WorkspaceAutomationUncheckedCreateWithoutWorkspaceInput> | WorkspaceAutomationCreateWithoutWorkspaceInput[] | WorkspaceAutomationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceAutomationCreateOrConnectWithoutWorkspaceInput | WorkspaceAutomationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceAutomationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceAutomationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceAutomationCreateManyWorkspaceInputEnvelope
    set?: WorkspaceAutomationWhereUniqueInput | WorkspaceAutomationWhereUniqueInput[]
    disconnect?: WorkspaceAutomationWhereUniqueInput | WorkspaceAutomationWhereUniqueInput[]
    delete?: WorkspaceAutomationWhereUniqueInput | WorkspaceAutomationWhereUniqueInput[]
    connect?: WorkspaceAutomationWhereUniqueInput | WorkspaceAutomationWhereUniqueInput[]
    update?: WorkspaceAutomationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceAutomationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceAutomationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceAutomationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceAutomationScalarWhereInput | WorkspaceAutomationScalarWhereInput[]
  }

  export type WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WebhookCreateWithoutWorkspaceInput, WebhookUncheckedCreateWithoutWorkspaceInput> | WebhookCreateWithoutWorkspaceInput[] | WebhookUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutWorkspaceInput | WebhookCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutWorkspaceInput | WebhookUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WebhookCreateManyWorkspaceInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutWorkspaceInput | WebhookUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutWorkspaceInput | WebhookUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<CustomFieldCreateWithoutWorkspaceInput, CustomFieldUncheckedCreateWithoutWorkspaceInput> | CustomFieldCreateWithoutWorkspaceInput[] | CustomFieldUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutWorkspaceInput | CustomFieldCreateOrConnectWithoutWorkspaceInput[]
    upsert?: CustomFieldUpsertWithWhereUniqueWithoutWorkspaceInput | CustomFieldUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: CustomFieldCreateManyWorkspaceInputEnvelope
    set?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    disconnect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    delete?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    update?: CustomFieldUpdateWithWhereUniqueWithoutWorkspaceInput | CustomFieldUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: CustomFieldUpdateManyWithWhereWithoutWorkspaceInput | CustomFieldUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<TagCreateWithoutWorkspaceInput, TagUncheckedCreateWithoutWorkspaceInput> | TagCreateWithoutWorkspaceInput[] | TagUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: TagCreateOrConnectWithoutWorkspaceInput | TagCreateOrConnectWithoutWorkspaceInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutWorkspaceInput | TagUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: TagCreateManyWorkspaceInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutWorkspaceInput | TagUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: TagUpdateManyWithWhereWithoutWorkspaceInput | TagUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AiAgentCreateWithoutWorkspaceInput, AiAgentUncheckedCreateWithoutWorkspaceInput> | AiAgentCreateWithoutWorkspaceInput[] | AiAgentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AiAgentCreateOrConnectWithoutWorkspaceInput | AiAgentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AiAgentUpsertWithWhereUniqueWithoutWorkspaceInput | AiAgentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AiAgentCreateManyWorkspaceInputEnvelope
    set?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    disconnect?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    delete?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    connect?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    update?: AiAgentUpdateWithWhereUniqueWithoutWorkspaceInput | AiAgentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AiAgentUpdateManyWithWhereWithoutWorkspaceInput | AiAgentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AiAgentScalarWhereInput | AiAgentScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutUsersInput = {
    create?: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUsersInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkspacesInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUsersInput
    upsert?: WorkspaceUpsertWithoutUsersInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutUsersInput, WorkspaceUpdateWithoutUsersInput>, WorkspaceUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutWorkspacesNestedInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    upsert?: UserUpsertWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspacesInput, UserUpdateWithoutWorkspacesInput>, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type WorkspaceCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
    upsert?: WorkspaceUpsertWithoutInvitationsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutInvitationsInput, WorkspaceUpdateWithoutInvitationsInput>, WorkspaceUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserCreateNestedOneWithoutAudioUploadsInput = {
    create?: XOR<UserCreateWithoutAudioUploadsInput, UserUncheckedCreateWithoutAudioUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudioUploadsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutAudioUploadsInput = {
    create?: XOR<WorkspaceCreateWithoutAudioUploadsInput, WorkspaceUncheckedCreateWithoutAudioUploadsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAudioUploadsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ProcessingJobCreateNestedManyWithoutUploadInput = {
    create?: XOR<ProcessingJobCreateWithoutUploadInput, ProcessingJobUncheckedCreateWithoutUploadInput> | ProcessingJobCreateWithoutUploadInput[] | ProcessingJobUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutUploadInput | ProcessingJobCreateOrConnectWithoutUploadInput[]
    createMany?: ProcessingJobCreateManyUploadInputEnvelope
    connect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
  }

  export type AudioChunkCreateNestedManyWithoutUploadInput = {
    create?: XOR<AudioChunkCreateWithoutUploadInput, AudioChunkUncheckedCreateWithoutUploadInput> | AudioChunkCreateWithoutUploadInput[] | AudioChunkUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: AudioChunkCreateOrConnectWithoutUploadInput | AudioChunkCreateOrConnectWithoutUploadInput[]
    createMany?: AudioChunkCreateManyUploadInputEnvelope
    connect?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
  }

  export type FileStorageCreateNestedOneWithoutUploadInput = {
    create?: XOR<FileStorageCreateWithoutUploadInput, FileStorageUncheckedCreateWithoutUploadInput>
    connectOrCreate?: FileStorageCreateOrConnectWithoutUploadInput
    connect?: FileStorageWhereUniqueInput
  }

  export type ProcessingJobUncheckedCreateNestedManyWithoutUploadInput = {
    create?: XOR<ProcessingJobCreateWithoutUploadInput, ProcessingJobUncheckedCreateWithoutUploadInput> | ProcessingJobCreateWithoutUploadInput[] | ProcessingJobUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutUploadInput | ProcessingJobCreateOrConnectWithoutUploadInput[]
    createMany?: ProcessingJobCreateManyUploadInputEnvelope
    connect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
  }

  export type AudioChunkUncheckedCreateNestedManyWithoutUploadInput = {
    create?: XOR<AudioChunkCreateWithoutUploadInput, AudioChunkUncheckedCreateWithoutUploadInput> | AudioChunkCreateWithoutUploadInput[] | AudioChunkUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: AudioChunkCreateOrConnectWithoutUploadInput | AudioChunkCreateOrConnectWithoutUploadInput[]
    createMany?: AudioChunkCreateManyUploadInputEnvelope
    connect?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
  }

  export type FileStorageUncheckedCreateNestedOneWithoutUploadInput = {
    create?: XOR<FileStorageCreateWithoutUploadInput, FileStorageUncheckedCreateWithoutUploadInput>
    connectOrCreate?: FileStorageCreateOrConnectWithoutUploadInput
    connect?: FileStorageWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAudioUploadsNestedInput = {
    create?: XOR<UserCreateWithoutAudioUploadsInput, UserUncheckedCreateWithoutAudioUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudioUploadsInput
    upsert?: UserUpsertWithoutAudioUploadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAudioUploadsInput, UserUpdateWithoutAudioUploadsInput>, UserUncheckedUpdateWithoutAudioUploadsInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutAudioUploadsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAudioUploadsInput, WorkspaceUncheckedCreateWithoutAudioUploadsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAudioUploadsInput
    upsert?: WorkspaceUpsertWithoutAudioUploadsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAudioUploadsInput, WorkspaceUpdateWithoutAudioUploadsInput>, WorkspaceUncheckedUpdateWithoutAudioUploadsInput>
  }

  export type ProcessingJobUpdateManyWithoutUploadNestedInput = {
    create?: XOR<ProcessingJobCreateWithoutUploadInput, ProcessingJobUncheckedCreateWithoutUploadInput> | ProcessingJobCreateWithoutUploadInput[] | ProcessingJobUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutUploadInput | ProcessingJobCreateOrConnectWithoutUploadInput[]
    upsert?: ProcessingJobUpsertWithWhereUniqueWithoutUploadInput | ProcessingJobUpsertWithWhereUniqueWithoutUploadInput[]
    createMany?: ProcessingJobCreateManyUploadInputEnvelope
    set?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    disconnect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    delete?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    connect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    update?: ProcessingJobUpdateWithWhereUniqueWithoutUploadInput | ProcessingJobUpdateWithWhereUniqueWithoutUploadInput[]
    updateMany?: ProcessingJobUpdateManyWithWhereWithoutUploadInput | ProcessingJobUpdateManyWithWhereWithoutUploadInput[]
    deleteMany?: ProcessingJobScalarWhereInput | ProcessingJobScalarWhereInput[]
  }

  export type AudioChunkUpdateManyWithoutUploadNestedInput = {
    create?: XOR<AudioChunkCreateWithoutUploadInput, AudioChunkUncheckedCreateWithoutUploadInput> | AudioChunkCreateWithoutUploadInput[] | AudioChunkUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: AudioChunkCreateOrConnectWithoutUploadInput | AudioChunkCreateOrConnectWithoutUploadInput[]
    upsert?: AudioChunkUpsertWithWhereUniqueWithoutUploadInput | AudioChunkUpsertWithWhereUniqueWithoutUploadInput[]
    createMany?: AudioChunkCreateManyUploadInputEnvelope
    set?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    disconnect?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    delete?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    connect?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    update?: AudioChunkUpdateWithWhereUniqueWithoutUploadInput | AudioChunkUpdateWithWhereUniqueWithoutUploadInput[]
    updateMany?: AudioChunkUpdateManyWithWhereWithoutUploadInput | AudioChunkUpdateManyWithWhereWithoutUploadInput[]
    deleteMany?: AudioChunkScalarWhereInput | AudioChunkScalarWhereInput[]
  }

  export type FileStorageUpdateOneWithoutUploadNestedInput = {
    create?: XOR<FileStorageCreateWithoutUploadInput, FileStorageUncheckedCreateWithoutUploadInput>
    connectOrCreate?: FileStorageCreateOrConnectWithoutUploadInput
    upsert?: FileStorageUpsertWithoutUploadInput
    disconnect?: FileStorageWhereInput | boolean
    delete?: FileStorageWhereInput | boolean
    connect?: FileStorageWhereUniqueInput
    update?: XOR<XOR<FileStorageUpdateToOneWithWhereWithoutUploadInput, FileStorageUpdateWithoutUploadInput>, FileStorageUncheckedUpdateWithoutUploadInput>
  }

  export type ProcessingJobUncheckedUpdateManyWithoutUploadNestedInput = {
    create?: XOR<ProcessingJobCreateWithoutUploadInput, ProcessingJobUncheckedCreateWithoutUploadInput> | ProcessingJobCreateWithoutUploadInput[] | ProcessingJobUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutUploadInput | ProcessingJobCreateOrConnectWithoutUploadInput[]
    upsert?: ProcessingJobUpsertWithWhereUniqueWithoutUploadInput | ProcessingJobUpsertWithWhereUniqueWithoutUploadInput[]
    createMany?: ProcessingJobCreateManyUploadInputEnvelope
    set?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    disconnect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    delete?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    connect?: ProcessingJobWhereUniqueInput | ProcessingJobWhereUniqueInput[]
    update?: ProcessingJobUpdateWithWhereUniqueWithoutUploadInput | ProcessingJobUpdateWithWhereUniqueWithoutUploadInput[]
    updateMany?: ProcessingJobUpdateManyWithWhereWithoutUploadInput | ProcessingJobUpdateManyWithWhereWithoutUploadInput[]
    deleteMany?: ProcessingJobScalarWhereInput | ProcessingJobScalarWhereInput[]
  }

  export type AudioChunkUncheckedUpdateManyWithoutUploadNestedInput = {
    create?: XOR<AudioChunkCreateWithoutUploadInput, AudioChunkUncheckedCreateWithoutUploadInput> | AudioChunkCreateWithoutUploadInput[] | AudioChunkUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: AudioChunkCreateOrConnectWithoutUploadInput | AudioChunkCreateOrConnectWithoutUploadInput[]
    upsert?: AudioChunkUpsertWithWhereUniqueWithoutUploadInput | AudioChunkUpsertWithWhereUniqueWithoutUploadInput[]
    createMany?: AudioChunkCreateManyUploadInputEnvelope
    set?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    disconnect?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    delete?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    connect?: AudioChunkWhereUniqueInput | AudioChunkWhereUniqueInput[]
    update?: AudioChunkUpdateWithWhereUniqueWithoutUploadInput | AudioChunkUpdateWithWhereUniqueWithoutUploadInput[]
    updateMany?: AudioChunkUpdateManyWithWhereWithoutUploadInput | AudioChunkUpdateManyWithWhereWithoutUploadInput[]
    deleteMany?: AudioChunkScalarWhereInput | AudioChunkScalarWhereInput[]
  }

  export type FileStorageUncheckedUpdateOneWithoutUploadNestedInput = {
    create?: XOR<FileStorageCreateWithoutUploadInput, FileStorageUncheckedCreateWithoutUploadInput>
    connectOrCreate?: FileStorageCreateOrConnectWithoutUploadInput
    upsert?: FileStorageUpsertWithoutUploadInput
    disconnect?: FileStorageWhereInput | boolean
    delete?: FileStorageWhereInput | boolean
    connect?: FileStorageWhereUniqueInput
    update?: XOR<XOR<FileStorageUpdateToOneWithWhereWithoutUploadInput, FileStorageUpdateWithoutUploadInput>, FileStorageUncheckedUpdateWithoutUploadInput>
  }

  export type AudioUploadCreateNestedOneWithoutProcessingJobsInput = {
    create?: XOR<AudioUploadCreateWithoutProcessingJobsInput, AudioUploadUncheckedCreateWithoutProcessingJobsInput>
    connectOrCreate?: AudioUploadCreateOrConnectWithoutProcessingJobsInput
    connect?: AudioUploadWhereUniqueInput
  }

  export type AudioHistoryCreateNestedOneWithoutProcessingJobInput = {
    create?: XOR<AudioHistoryCreateWithoutProcessingJobInput, AudioHistoryUncheckedCreateWithoutProcessingJobInput>
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutProcessingJobInput
    connect?: AudioHistoryWhereUniqueInput
  }

  export type AudioHistoryUncheckedCreateNestedOneWithoutProcessingJobInput = {
    create?: XOR<AudioHistoryCreateWithoutProcessingJobInput, AudioHistoryUncheckedCreateWithoutProcessingJobInput>
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutProcessingJobInput
    connect?: AudioHistoryWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AudioUploadUpdateOneRequiredWithoutProcessingJobsNestedInput = {
    create?: XOR<AudioUploadCreateWithoutProcessingJobsInput, AudioUploadUncheckedCreateWithoutProcessingJobsInput>
    connectOrCreate?: AudioUploadCreateOrConnectWithoutProcessingJobsInput
    upsert?: AudioUploadUpsertWithoutProcessingJobsInput
    connect?: AudioUploadWhereUniqueInput
    update?: XOR<XOR<AudioUploadUpdateToOneWithWhereWithoutProcessingJobsInput, AudioUploadUpdateWithoutProcessingJobsInput>, AudioUploadUncheckedUpdateWithoutProcessingJobsInput>
  }

  export type AudioHistoryUpdateOneWithoutProcessingJobNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutProcessingJobInput, AudioHistoryUncheckedCreateWithoutProcessingJobInput>
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutProcessingJobInput
    upsert?: AudioHistoryUpsertWithoutProcessingJobInput
    disconnect?: AudioHistoryWhereInput | boolean
    delete?: AudioHistoryWhereInput | boolean
    connect?: AudioHistoryWhereUniqueInput
    update?: XOR<XOR<AudioHistoryUpdateToOneWithWhereWithoutProcessingJobInput, AudioHistoryUpdateWithoutProcessingJobInput>, AudioHistoryUncheckedUpdateWithoutProcessingJobInput>
  }

  export type AudioHistoryUncheckedUpdateOneWithoutProcessingJobNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutProcessingJobInput, AudioHistoryUncheckedCreateWithoutProcessingJobInput>
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutProcessingJobInput
    upsert?: AudioHistoryUpsertWithoutProcessingJobInput
    disconnect?: AudioHistoryWhereInput | boolean
    delete?: AudioHistoryWhereInput | boolean
    connect?: AudioHistoryWhereUniqueInput
    update?: XOR<XOR<AudioHistoryUpdateToOneWithWhereWithoutProcessingJobInput, AudioHistoryUpdateWithoutProcessingJobInput>, AudioHistoryUncheckedUpdateWithoutProcessingJobInput>
  }

  export type AudioHistoryCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAudioHistoryInput = {
    create?: XOR<UserCreateWithoutAudioHistoryInput, UserUncheckedCreateWithoutAudioHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudioHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutAudioHistoryInput = {
    create?: XOR<WorkspaceCreateWithoutAudioHistoryInput, WorkspaceUncheckedCreateWithoutAudioHistoryInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAudioHistoryInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ProcessingJobCreateNestedOneWithoutAudioHistoryInput = {
    create?: XOR<ProcessingJobCreateWithoutAudioHistoryInput, ProcessingJobUncheckedCreateWithoutAudioHistoryInput>
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutAudioHistoryInput
    connect?: ProcessingJobWhereUniqueInput
  }

  export type AudioSegmentCreateNestedManyWithoutAudioHistoryInput = {
    create?: XOR<AudioSegmentCreateWithoutAudioHistoryInput, AudioSegmentUncheckedCreateWithoutAudioHistoryInput> | AudioSegmentCreateWithoutAudioHistoryInput[] | AudioSegmentUncheckedCreateWithoutAudioHistoryInput[]
    connectOrCreate?: AudioSegmentCreateOrConnectWithoutAudioHistoryInput | AudioSegmentCreateOrConnectWithoutAudioHistoryInput[]
    createMany?: AudioSegmentCreateManyAudioHistoryInputEnvelope
    connect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
  }

  export type AudioSegmentUncheckedCreateNestedManyWithoutAudioHistoryInput = {
    create?: XOR<AudioSegmentCreateWithoutAudioHistoryInput, AudioSegmentUncheckedCreateWithoutAudioHistoryInput> | AudioSegmentCreateWithoutAudioHistoryInput[] | AudioSegmentUncheckedCreateWithoutAudioHistoryInput[]
    connectOrCreate?: AudioSegmentCreateOrConnectWithoutAudioHistoryInput | AudioSegmentCreateOrConnectWithoutAudioHistoryInput[]
    createMany?: AudioSegmentCreateManyAudioHistoryInputEnvelope
    connect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AudioHistoryUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAudioHistoryNestedInput = {
    create?: XOR<UserCreateWithoutAudioHistoryInput, UserUncheckedCreateWithoutAudioHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudioHistoryInput
    upsert?: UserUpsertWithoutAudioHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAudioHistoryInput, UserUpdateWithoutAudioHistoryInput>, UserUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type WorkspaceUpdateOneWithoutAudioHistoryNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAudioHistoryInput, WorkspaceUncheckedCreateWithoutAudioHistoryInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAudioHistoryInput
    upsert?: WorkspaceUpsertWithoutAudioHistoryInput
    disconnect?: WorkspaceWhereInput | boolean
    delete?: WorkspaceWhereInput | boolean
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAudioHistoryInput, WorkspaceUpdateWithoutAudioHistoryInput>, WorkspaceUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type ProcessingJobUpdateOneWithoutAudioHistoryNestedInput = {
    create?: XOR<ProcessingJobCreateWithoutAudioHistoryInput, ProcessingJobUncheckedCreateWithoutAudioHistoryInput>
    connectOrCreate?: ProcessingJobCreateOrConnectWithoutAudioHistoryInput
    upsert?: ProcessingJobUpsertWithoutAudioHistoryInput
    disconnect?: ProcessingJobWhereInput | boolean
    delete?: ProcessingJobWhereInput | boolean
    connect?: ProcessingJobWhereUniqueInput
    update?: XOR<XOR<ProcessingJobUpdateToOneWithWhereWithoutAudioHistoryInput, ProcessingJobUpdateWithoutAudioHistoryInput>, ProcessingJobUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type AudioSegmentUpdateManyWithoutAudioHistoryNestedInput = {
    create?: XOR<AudioSegmentCreateWithoutAudioHistoryInput, AudioSegmentUncheckedCreateWithoutAudioHistoryInput> | AudioSegmentCreateWithoutAudioHistoryInput[] | AudioSegmentUncheckedCreateWithoutAudioHistoryInput[]
    connectOrCreate?: AudioSegmentCreateOrConnectWithoutAudioHistoryInput | AudioSegmentCreateOrConnectWithoutAudioHistoryInput[]
    upsert?: AudioSegmentUpsertWithWhereUniqueWithoutAudioHistoryInput | AudioSegmentUpsertWithWhereUniqueWithoutAudioHistoryInput[]
    createMany?: AudioSegmentCreateManyAudioHistoryInputEnvelope
    set?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    disconnect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    delete?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    connect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    update?: AudioSegmentUpdateWithWhereUniqueWithoutAudioHistoryInput | AudioSegmentUpdateWithWhereUniqueWithoutAudioHistoryInput[]
    updateMany?: AudioSegmentUpdateManyWithWhereWithoutAudioHistoryInput | AudioSegmentUpdateManyWithWhereWithoutAudioHistoryInput[]
    deleteMany?: AudioSegmentScalarWhereInput | AudioSegmentScalarWhereInput[]
  }

  export type AudioSegmentUncheckedUpdateManyWithoutAudioHistoryNestedInput = {
    create?: XOR<AudioSegmentCreateWithoutAudioHistoryInput, AudioSegmentUncheckedCreateWithoutAudioHistoryInput> | AudioSegmentCreateWithoutAudioHistoryInput[] | AudioSegmentUncheckedCreateWithoutAudioHistoryInput[]
    connectOrCreate?: AudioSegmentCreateOrConnectWithoutAudioHistoryInput | AudioSegmentCreateOrConnectWithoutAudioHistoryInput[]
    upsert?: AudioSegmentUpsertWithWhereUniqueWithoutAudioHistoryInput | AudioSegmentUpsertWithWhereUniqueWithoutAudioHistoryInput[]
    createMany?: AudioSegmentCreateManyAudioHistoryInputEnvelope
    set?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    disconnect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    delete?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    connect?: AudioSegmentWhereUniqueInput | AudioSegmentWhereUniqueInput[]
    update?: AudioSegmentUpdateWithWhereUniqueWithoutAudioHistoryInput | AudioSegmentUpdateWithWhereUniqueWithoutAudioHistoryInput[]
    updateMany?: AudioSegmentUpdateManyWithWhereWithoutAudioHistoryInput | AudioSegmentUpdateManyWithWhereWithoutAudioHistoryInput[]
    deleteMany?: AudioSegmentScalarWhereInput | AudioSegmentScalarWhereInput[]
  }

  export type AudioSegmentCreatekeywordsInput = {
    set: string[]
  }

  export type AudioHistoryCreateNestedOneWithoutSegmentsInput = {
    create?: XOR<AudioHistoryCreateWithoutSegmentsInput, AudioHistoryUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutSegmentsInput
    connect?: AudioHistoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAudioSegmentsInput = {
    create?: XOR<UserCreateWithoutAudioSegmentsInput, UserUncheckedCreateWithoutAudioSegmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudioSegmentsInput
    connect?: UserWhereUniqueInput
  }

  export type AudioSegmentUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AudioHistoryUpdateOneRequiredWithoutSegmentsNestedInput = {
    create?: XOR<AudioHistoryCreateWithoutSegmentsInput, AudioHistoryUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: AudioHistoryCreateOrConnectWithoutSegmentsInput
    upsert?: AudioHistoryUpsertWithoutSegmentsInput
    connect?: AudioHistoryWhereUniqueInput
    update?: XOR<XOR<AudioHistoryUpdateToOneWithWhereWithoutSegmentsInput, AudioHistoryUpdateWithoutSegmentsInput>, AudioHistoryUncheckedUpdateWithoutSegmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAudioSegmentsNestedInput = {
    create?: XOR<UserCreateWithoutAudioSegmentsInput, UserUncheckedCreateWithoutAudioSegmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudioSegmentsInput
    upsert?: UserUpsertWithoutAudioSegmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAudioSegmentsInput, UserUpdateWithoutAudioSegmentsInput>, UserUncheckedUpdateWithoutAudioSegmentsInput>
  }

  export type AudioUploadCreateNestedOneWithoutAudioChunksInput = {
    create?: XOR<AudioUploadCreateWithoutAudioChunksInput, AudioUploadUncheckedCreateWithoutAudioChunksInput>
    connectOrCreate?: AudioUploadCreateOrConnectWithoutAudioChunksInput
    connect?: AudioUploadWhereUniqueInput
  }

  export type AudioUploadUpdateOneRequiredWithoutAudioChunksNestedInput = {
    create?: XOR<AudioUploadCreateWithoutAudioChunksInput, AudioUploadUncheckedCreateWithoutAudioChunksInput>
    connectOrCreate?: AudioUploadCreateOrConnectWithoutAudioChunksInput
    upsert?: AudioUploadUpsertWithoutAudioChunksInput
    connect?: AudioUploadWhereUniqueInput
    update?: XOR<XOR<AudioUploadUpdateToOneWithWhereWithoutAudioChunksInput, AudioUploadUpdateWithoutAudioChunksInput>, AudioUploadUncheckedUpdateWithoutAudioChunksInput>
  }

  export type FileStorageCreateNestedManyWithoutProviderInput = {
    create?: XOR<FileStorageCreateWithoutProviderInput, FileStorageUncheckedCreateWithoutProviderInput> | FileStorageCreateWithoutProviderInput[] | FileStorageUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutProviderInput | FileStorageCreateOrConnectWithoutProviderInput[]
    createMany?: FileStorageCreateManyProviderInputEnvelope
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
  }

  export type FileStorageUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<FileStorageCreateWithoutProviderInput, FileStorageUncheckedCreateWithoutProviderInput> | FileStorageCreateWithoutProviderInput[] | FileStorageUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutProviderInput | FileStorageCreateOrConnectWithoutProviderInput[]
    createMany?: FileStorageCreateManyProviderInputEnvelope
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
  }

  export type FileStorageUpdateManyWithoutProviderNestedInput = {
    create?: XOR<FileStorageCreateWithoutProviderInput, FileStorageUncheckedCreateWithoutProviderInput> | FileStorageCreateWithoutProviderInput[] | FileStorageUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutProviderInput | FileStorageCreateOrConnectWithoutProviderInput[]
    upsert?: FileStorageUpsertWithWhereUniqueWithoutProviderInput | FileStorageUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: FileStorageCreateManyProviderInputEnvelope
    set?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    disconnect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    delete?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    update?: FileStorageUpdateWithWhereUniqueWithoutProviderInput | FileStorageUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: FileStorageUpdateManyWithWhereWithoutProviderInput | FileStorageUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: FileStorageScalarWhereInput | FileStorageScalarWhereInput[]
  }

  export type FileStorageUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<FileStorageCreateWithoutProviderInput, FileStorageUncheckedCreateWithoutProviderInput> | FileStorageCreateWithoutProviderInput[] | FileStorageUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutProviderInput | FileStorageCreateOrConnectWithoutProviderInput[]
    upsert?: FileStorageUpsertWithWhereUniqueWithoutProviderInput | FileStorageUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: FileStorageCreateManyProviderInputEnvelope
    set?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    disconnect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    delete?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    update?: FileStorageUpdateWithWhereUniqueWithoutProviderInput | FileStorageUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: FileStorageUpdateManyWithWhereWithoutProviderInput | FileStorageUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: FileStorageScalarWhereInput | FileStorageScalarWhereInput[]
  }

  export type StorageProviderCreateNestedOneWithoutFilesInput = {
    create?: XOR<StorageProviderCreateWithoutFilesInput, StorageProviderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: StorageProviderCreateOrConnectWithoutFilesInput
    connect?: StorageProviderWhereUniqueInput
  }

  export type AudioUploadCreateNestedOneWithoutFileStorageInput = {
    create?: XOR<AudioUploadCreateWithoutFileStorageInput, AudioUploadUncheckedCreateWithoutFileStorageInput>
    connectOrCreate?: AudioUploadCreateOrConnectWithoutFileStorageInput
    connect?: AudioUploadWhereUniqueInput
  }

  export type StorageProviderUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<StorageProviderCreateWithoutFilesInput, StorageProviderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: StorageProviderCreateOrConnectWithoutFilesInput
    upsert?: StorageProviderUpsertWithoutFilesInput
    connect?: StorageProviderWhereUniqueInput
    update?: XOR<XOR<StorageProviderUpdateToOneWithWhereWithoutFilesInput, StorageProviderUpdateWithoutFilesInput>, StorageProviderUncheckedUpdateWithoutFilesInput>
  }

  export type AudioUploadUpdateOneRequiredWithoutFileStorageNestedInput = {
    create?: XOR<AudioUploadCreateWithoutFileStorageInput, AudioUploadUncheckedCreateWithoutFileStorageInput>
    connectOrCreate?: AudioUploadCreateOrConnectWithoutFileStorageInput
    upsert?: AudioUploadUpsertWithoutFileStorageInput
    connect?: AudioUploadWhereUniqueInput
    update?: XOR<XOR<AudioUploadUpdateToOneWithWhereWithoutFileStorageInput, AudioUploadUpdateWithoutFileStorageInput>, AudioUploadUncheckedUpdateWithoutFileStorageInput>
  }

  export type WorkspaceSubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutPlanInput, WorkspaceSubscriptionUncheckedCreateWithoutPlanInput> | WorkspaceSubscriptionCreateWithoutPlanInput[] | WorkspaceSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutPlanInput | WorkspaceSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: WorkspaceSubscriptionCreateManyPlanInputEnvelope
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
  }

  export type PlanPricingCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanPricingCreateWithoutPlanInput, PlanPricingUncheckedCreateWithoutPlanInput> | PlanPricingCreateWithoutPlanInput[] | PlanPricingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPricingCreateOrConnectWithoutPlanInput | PlanPricingCreateOrConnectWithoutPlanInput[]
    createMany?: PlanPricingCreateManyPlanInputEnvelope
    connect?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
  }

  export type WorkspaceSubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutPlanInput, WorkspaceSubscriptionUncheckedCreateWithoutPlanInput> | WorkspaceSubscriptionCreateWithoutPlanInput[] | WorkspaceSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutPlanInput | WorkspaceSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: WorkspaceSubscriptionCreateManyPlanInputEnvelope
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
  }

  export type PlanPricingUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanPricingCreateWithoutPlanInput, PlanPricingUncheckedCreateWithoutPlanInput> | PlanPricingCreateWithoutPlanInput[] | PlanPricingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPricingCreateOrConnectWithoutPlanInput | PlanPricingCreateOrConnectWithoutPlanInput[]
    createMany?: PlanPricingCreateManyPlanInputEnvelope
    connect?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type WorkspaceSubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutPlanInput, WorkspaceSubscriptionUncheckedCreateWithoutPlanInput> | WorkspaceSubscriptionCreateWithoutPlanInput[] | WorkspaceSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutPlanInput | WorkspaceSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: WorkspaceSubscriptionUpsertWithWhereUniqueWithoutPlanInput | WorkspaceSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: WorkspaceSubscriptionCreateManyPlanInputEnvelope
    set?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    disconnect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    delete?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    update?: WorkspaceSubscriptionUpdateWithWhereUniqueWithoutPlanInput | WorkspaceSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: WorkspaceSubscriptionUpdateManyWithWhereWithoutPlanInput | WorkspaceSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: WorkspaceSubscriptionScalarWhereInput | WorkspaceSubscriptionScalarWhereInput[]
  }

  export type PlanPricingUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanPricingCreateWithoutPlanInput, PlanPricingUncheckedCreateWithoutPlanInput> | PlanPricingCreateWithoutPlanInput[] | PlanPricingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPricingCreateOrConnectWithoutPlanInput | PlanPricingCreateOrConnectWithoutPlanInput[]
    upsert?: PlanPricingUpsertWithWhereUniqueWithoutPlanInput | PlanPricingUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanPricingCreateManyPlanInputEnvelope
    set?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    disconnect?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    delete?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    connect?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    update?: PlanPricingUpdateWithWhereUniqueWithoutPlanInput | PlanPricingUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanPricingUpdateManyWithWhereWithoutPlanInput | PlanPricingUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanPricingScalarWhereInput | PlanPricingScalarWhereInput[]
  }

  export type WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutPlanInput, WorkspaceSubscriptionUncheckedCreateWithoutPlanInput> | WorkspaceSubscriptionCreateWithoutPlanInput[] | WorkspaceSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutPlanInput | WorkspaceSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: WorkspaceSubscriptionUpsertWithWhereUniqueWithoutPlanInput | WorkspaceSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: WorkspaceSubscriptionCreateManyPlanInputEnvelope
    set?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    disconnect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    delete?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    connect?: WorkspaceSubscriptionWhereUniqueInput | WorkspaceSubscriptionWhereUniqueInput[]
    update?: WorkspaceSubscriptionUpdateWithWhereUniqueWithoutPlanInput | WorkspaceSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: WorkspaceSubscriptionUpdateManyWithWhereWithoutPlanInput | WorkspaceSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: WorkspaceSubscriptionScalarWhereInput | WorkspaceSubscriptionScalarWhereInput[]
  }

  export type PlanPricingUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanPricingCreateWithoutPlanInput, PlanPricingUncheckedCreateWithoutPlanInput> | PlanPricingCreateWithoutPlanInput[] | PlanPricingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPricingCreateOrConnectWithoutPlanInput | PlanPricingCreateOrConnectWithoutPlanInput[]
    upsert?: PlanPricingUpsertWithWhereUniqueWithoutPlanInput | PlanPricingUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanPricingCreateManyPlanInputEnvelope
    set?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    disconnect?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    delete?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    connect?: PlanPricingWhereUniqueInput | PlanPricingWhereUniqueInput[]
    update?: PlanPricingUpdateWithWhereUniqueWithoutPlanInput | PlanPricingUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanPricingUpdateManyWithWhereWithoutPlanInput | PlanPricingUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanPricingScalarWhereInput | PlanPricingScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<WorkspaceCreateWithoutSubscriptionsInput, WorkspaceUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSubscriptionsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type BillingRecordCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<BillingRecordCreateWithoutSubscriptionInput, BillingRecordUncheckedCreateWithoutSubscriptionInput> | BillingRecordCreateWithoutSubscriptionInput[] | BillingRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BillingRecordCreateOrConnectWithoutSubscriptionInput | BillingRecordCreateOrConnectWithoutSubscriptionInput[]
    createMany?: BillingRecordCreateManySubscriptionInputEnvelope
    connect?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
  }

  export type UsageRecordCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
  }

  export type BillingRecordUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<BillingRecordCreateWithoutSubscriptionInput, BillingRecordUncheckedCreateWithoutSubscriptionInput> | BillingRecordCreateWithoutSubscriptionInput[] | BillingRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BillingRecordCreateOrConnectWithoutSubscriptionInput | BillingRecordCreateOrConnectWithoutSubscriptionInput[]
    createMany?: BillingRecordCreateManySubscriptionInputEnvelope
    connect?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
  }

  export type UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutSubscriptionsInput, WorkspaceUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSubscriptionsInput
    upsert?: WorkspaceUpsertWithoutSubscriptionsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutSubscriptionsInput, WorkspaceUpdateWithoutSubscriptionsInput>, WorkspaceUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: SubscriptionPlanUpsertWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput, SubscriptionPlanUpdateWithoutSubscriptionsInput>, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type BillingRecordUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<BillingRecordCreateWithoutSubscriptionInput, BillingRecordUncheckedCreateWithoutSubscriptionInput> | BillingRecordCreateWithoutSubscriptionInput[] | BillingRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BillingRecordCreateOrConnectWithoutSubscriptionInput | BillingRecordCreateOrConnectWithoutSubscriptionInput[]
    upsert?: BillingRecordUpsertWithWhereUniqueWithoutSubscriptionInput | BillingRecordUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: BillingRecordCreateManySubscriptionInputEnvelope
    set?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    disconnect?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    delete?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    connect?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    update?: BillingRecordUpdateWithWhereUniqueWithoutSubscriptionInput | BillingRecordUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: BillingRecordUpdateManyWithWhereWithoutSubscriptionInput | BillingRecordUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: BillingRecordScalarWhereInput | BillingRecordScalarWhereInput[]
  }

  export type UsageRecordUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    set?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    disconnect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    delete?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    update?: UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UsageRecordUpdateManyWithWhereWithoutSubscriptionInput | UsageRecordUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
  }

  export type BillingRecordUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<BillingRecordCreateWithoutSubscriptionInput, BillingRecordUncheckedCreateWithoutSubscriptionInput> | BillingRecordCreateWithoutSubscriptionInput[] | BillingRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: BillingRecordCreateOrConnectWithoutSubscriptionInput | BillingRecordCreateOrConnectWithoutSubscriptionInput[]
    upsert?: BillingRecordUpsertWithWhereUniqueWithoutSubscriptionInput | BillingRecordUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: BillingRecordCreateManySubscriptionInputEnvelope
    set?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    disconnect?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    delete?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    connect?: BillingRecordWhereUniqueInput | BillingRecordWhereUniqueInput[]
    update?: BillingRecordUpdateWithWhereUniqueWithoutSubscriptionInput | BillingRecordUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: BillingRecordUpdateManyWithWhereWithoutSubscriptionInput | BillingRecordUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: BillingRecordScalarWhereInput | BillingRecordScalarWhereInput[]
  }

  export type UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    set?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    disconnect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    delete?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    update?: UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UsageRecordUpdateManyWithWhereWithoutSubscriptionInput | UsageRecordUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
  }

  export type WorkspaceSubscriptionCreateNestedOneWithoutBillingRecordsInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutBillingRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutBillingRecordsInput>
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutBillingRecordsInput
    connect?: WorkspaceSubscriptionWhereUniqueInput
  }

  export type WorkspaceSubscriptionUpdateOneRequiredWithoutBillingRecordsNestedInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutBillingRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutBillingRecordsInput>
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutBillingRecordsInput
    upsert?: WorkspaceSubscriptionUpsertWithoutBillingRecordsInput
    connect?: WorkspaceSubscriptionWhereUniqueInput
    update?: XOR<XOR<WorkspaceSubscriptionUpdateToOneWithWhereWithoutBillingRecordsInput, WorkspaceSubscriptionUpdateWithoutBillingRecordsInput>, WorkspaceSubscriptionUncheckedUpdateWithoutBillingRecordsInput>
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type ApiKeyUsageLogCreateNestedManyWithoutApiKeyInput = {
    create?: XOR<ApiKeyUsageLogCreateWithoutApiKeyInput, ApiKeyUsageLogUncheckedCreateWithoutApiKeyInput> | ApiKeyUsageLogCreateWithoutApiKeyInput[] | ApiKeyUsageLogUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: ApiKeyUsageLogCreateOrConnectWithoutApiKeyInput | ApiKeyUsageLogCreateOrConnectWithoutApiKeyInput[]
    createMany?: ApiKeyUsageLogCreateManyApiKeyInputEnvelope
    connect?: ApiKeyUsageLogWhereUniqueInput | ApiKeyUsageLogWhereUniqueInput[]
  }

  export type ApiKeyUsageLogUncheckedCreateNestedManyWithoutApiKeyInput = {
    create?: XOR<ApiKeyUsageLogCreateWithoutApiKeyInput, ApiKeyUsageLogUncheckedCreateWithoutApiKeyInput> | ApiKeyUsageLogCreateWithoutApiKeyInput[] | ApiKeyUsageLogUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: ApiKeyUsageLogCreateOrConnectWithoutApiKeyInput | ApiKeyUsageLogCreateOrConnectWithoutApiKeyInput[]
    createMany?: ApiKeyUsageLogCreateManyApiKeyInputEnvelope
    connect?: ApiKeyUsageLogWhereUniqueInput | ApiKeyUsageLogWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type ApiKeyUsageLogUpdateManyWithoutApiKeyNestedInput = {
    create?: XOR<ApiKeyUsageLogCreateWithoutApiKeyInput, ApiKeyUsageLogUncheckedCreateWithoutApiKeyInput> | ApiKeyUsageLogCreateWithoutApiKeyInput[] | ApiKeyUsageLogUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: ApiKeyUsageLogCreateOrConnectWithoutApiKeyInput | ApiKeyUsageLogCreateOrConnectWithoutApiKeyInput[]
    upsert?: ApiKeyUsageLogUpsertWithWhereUniqueWithoutApiKeyInput | ApiKeyUsageLogUpsertWithWhereUniqueWithoutApiKeyInput[]
    createMany?: ApiKeyUsageLogCreateManyApiKeyInputEnvelope
    set?: ApiKeyUsageLogWhereUniqueInput | ApiKeyUsageLogWhereUniqueInput[]
    disconnect?: ApiKeyUsageLogWhereUniqueInput | ApiKeyUsageLogWhereUniqueInput[]
    delete?: ApiKeyUsageLogWhereUniqueInput | ApiKeyUsageLogWhereUniqueInput[]
    connect?: ApiKeyUsageLogWhereUniqueInput | ApiKeyUsageLogWhereUniqueInput[]
    update?: ApiKeyUsageLogUpdateWithWhereUniqueWithoutApiKeyInput | ApiKeyUsageLogUpdateWithWhereUniqueWithoutApiKeyInput[]
    updateMany?: ApiKeyUsageLogUpdateManyWithWhereWithoutApiKeyInput | ApiKeyUsageLogUpdateManyWithWhereWithoutApiKeyInput[]
    deleteMany?: ApiKeyUsageLogScalarWhereInput | ApiKeyUsageLogScalarWhereInput[]
  }

  export type ApiKeyUsageLogUncheckedUpdateManyWithoutApiKeyNestedInput = {
    create?: XOR<ApiKeyUsageLogCreateWithoutApiKeyInput, ApiKeyUsageLogUncheckedCreateWithoutApiKeyInput> | ApiKeyUsageLogCreateWithoutApiKeyInput[] | ApiKeyUsageLogUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: ApiKeyUsageLogCreateOrConnectWithoutApiKeyInput | ApiKeyUsageLogCreateOrConnectWithoutApiKeyInput[]
    upsert?: ApiKeyUsageLogUpsertWithWhereUniqueWithoutApiKeyInput | ApiKeyUsageLogUpsertWithWhereUniqueWithoutApiKeyInput[]
    createMany?: ApiKeyUsageLogCreateManyApiKeyInputEnvelope
    set?: ApiKeyUsageLogWhereUniqueInput | ApiKeyUsageLogWhereUniqueInput[]
    disconnect?: ApiKeyUsageLogWhereUniqueInput | ApiKeyUsageLogWhereUniqueInput[]
    delete?: ApiKeyUsageLogWhereUniqueInput | ApiKeyUsageLogWhereUniqueInput[]
    connect?: ApiKeyUsageLogWhereUniqueInput | ApiKeyUsageLogWhereUniqueInput[]
    update?: ApiKeyUsageLogUpdateWithWhereUniqueWithoutApiKeyInput | ApiKeyUsageLogUpdateWithWhereUniqueWithoutApiKeyInput[]
    updateMany?: ApiKeyUsageLogUpdateManyWithWhereWithoutApiKeyInput | ApiKeyUsageLogUpdateManyWithWhereWithoutApiKeyInput[]
    deleteMany?: ApiKeyUsageLogScalarWhereInput | ApiKeyUsageLogScalarWhereInput[]
  }

  export type ApiKeyManagementCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<ApiKeyManagementCreateWithoutUsageLogsInput, ApiKeyManagementUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ApiKeyManagementCreateOrConnectWithoutUsageLogsInput
    connect?: ApiKeyManagementWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ApiKeyManagementUpdateOneRequiredWithoutUsageLogsNestedInput = {
    create?: XOR<ApiKeyManagementCreateWithoutUsageLogsInput, ApiKeyManagementUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ApiKeyManagementCreateOrConnectWithoutUsageLogsInput
    upsert?: ApiKeyManagementUpsertWithoutUsageLogsInput
    connect?: ApiKeyManagementWhereUniqueInput
    update?: XOR<XOR<ApiKeyManagementUpdateToOneWithWhereWithoutUsageLogsInput, ApiKeyManagementUpdateWithoutUsageLogsInput>, ApiKeyManagementUncheckedUpdateWithoutUsageLogsInput>
  }

  export type UserCreateNestedOneWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    upsert?: UserUpsertWithoutSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsInput, UserUpdateWithoutSettingsInput>, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutQuotaUsageInput = {
    create?: XOR<UserCreateWithoutQuotaUsageInput, UserUncheckedCreateWithoutQuotaUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuotaUsageInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutQuotaUsageNestedInput = {
    create?: XOR<UserCreateWithoutQuotaUsageInput, UserUncheckedCreateWithoutQuotaUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuotaUsageInput
    upsert?: UserUpsertWithoutQuotaUsageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuotaUsageInput, UserUpdateWithoutQuotaUsageInput>, UserUncheckedUpdateWithoutQuotaUsageInput>
  }

  export type WorkspaceCreateNestedOneWithoutStorageQuotasInput = {
    create?: XOR<WorkspaceCreateWithoutStorageQuotasInput, WorkspaceUncheckedCreateWithoutStorageQuotasInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutStorageQuotasInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutStorageQuotasNestedInput = {
    create?: XOR<WorkspaceCreateWithoutStorageQuotasInput, WorkspaceUncheckedCreateWithoutStorageQuotasInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutStorageQuotasInput
    upsert?: WorkspaceUpsertWithoutStorageQuotasInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutStorageQuotasInput, WorkspaceUpdateWithoutStorageQuotasInput>, WorkspaceUncheckedUpdateWithoutStorageQuotasInput>
  }

  export type WorkspaceSubscriptionCreateNestedOneWithoutUsageRecordsInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutUsageRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutUsageRecordsInput
    connect?: WorkspaceSubscriptionWhereUniqueInput
  }

  export type WorkspaceSubscriptionUpdateOneRequiredWithoutUsageRecordsNestedInput = {
    create?: XOR<WorkspaceSubscriptionCreateWithoutUsageRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: WorkspaceSubscriptionCreateOrConnectWithoutUsageRecordsInput
    upsert?: WorkspaceSubscriptionUpsertWithoutUsageRecordsInput
    connect?: WorkspaceSubscriptionWhereUniqueInput
    update?: XOR<XOR<WorkspaceSubscriptionUpdateToOneWithWhereWithoutUsageRecordsInput, WorkspaceSubscriptionUpdateWithoutUsageRecordsInput>, WorkspaceSubscriptionUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutSecurityEventsInput = {
    create?: XOR<UserCreateWithoutSecurityEventsInput, UserUncheckedCreateWithoutSecurityEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutSecurityEventsNestedInput = {
    create?: XOR<UserCreateWithoutSecurityEventsInput, UserUncheckedCreateWithoutSecurityEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityEventsInput
    upsert?: UserUpsertWithoutSecurityEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSecurityEventsInput, UserUpdateWithoutSecurityEventsInput>, UserUncheckedUpdateWithoutSecurityEventsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type EmailLogCreateNestedManyWithoutTemplateInput = {
    create?: XOR<EmailLogCreateWithoutTemplateInput, EmailLogUncheckedCreateWithoutTemplateInput> | EmailLogCreateWithoutTemplateInput[] | EmailLogUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutTemplateInput | EmailLogCreateOrConnectWithoutTemplateInput[]
    createMany?: EmailLogCreateManyTemplateInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type EmailLogUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<EmailLogCreateWithoutTemplateInput, EmailLogUncheckedCreateWithoutTemplateInput> | EmailLogCreateWithoutTemplateInput[] | EmailLogUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutTemplateInput | EmailLogCreateOrConnectWithoutTemplateInput[]
    createMany?: EmailLogCreateManyTemplateInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type EmailLogUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<EmailLogCreateWithoutTemplateInput, EmailLogUncheckedCreateWithoutTemplateInput> | EmailLogCreateWithoutTemplateInput[] | EmailLogUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutTemplateInput | EmailLogCreateOrConnectWithoutTemplateInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutTemplateInput | EmailLogUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: EmailLogCreateManyTemplateInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutTemplateInput | EmailLogUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutTemplateInput | EmailLogUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type EmailLogUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<EmailLogCreateWithoutTemplateInput, EmailLogUncheckedCreateWithoutTemplateInput> | EmailLogCreateWithoutTemplateInput[] | EmailLogUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutTemplateInput | EmailLogCreateOrConnectWithoutTemplateInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutTemplateInput | EmailLogUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: EmailLogCreateManyTemplateInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutTemplateInput | EmailLogUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutTemplateInput | EmailLogUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type EmailTemplateCreateNestedOneWithoutEmailLogsInput = {
    create?: XOR<EmailTemplateCreateWithoutEmailLogsInput, EmailTemplateUncheckedCreateWithoutEmailLogsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutEmailLogsInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type EmailTemplateUpdateOneWithoutEmailLogsNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutEmailLogsInput, EmailTemplateUncheckedCreateWithoutEmailLogsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutEmailLogsInput
    upsert?: EmailTemplateUpsertWithoutEmailLogsInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutEmailLogsInput, EmailTemplateUpdateWithoutEmailLogsInput>, EmailTemplateUncheckedUpdateWithoutEmailLogsInput>
  }

  export type UserCreateNestedOneWithoutEmailPreferencesInput = {
    create?: XOR<UserCreateWithoutEmailPreferencesInput, UserUncheckedCreateWithoutEmailPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutEmailPreferencesInput, UserUncheckedCreateWithoutEmailPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailPreferencesInput
    upsert?: UserUpsertWithoutEmailPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailPreferencesInput, UserUpdateWithoutEmailPreferencesInput>, UserUncheckedUpdateWithoutEmailPreferencesInput>
  }

  export type WorkspaceCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<WorkspaceCreateWithoutIntegrationsInput, WorkspaceUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutIntegrationsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutIntegrationsInput, WorkspaceUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutIntegrationsInput
    upsert?: WorkspaceUpsertWithoutIntegrationsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutIntegrationsInput, WorkspaceUpdateWithoutIntegrationsInput>, WorkspaceUncheckedUpdateWithoutIntegrationsInput>
  }

  export type WorkspaceCreateNestedOneWithoutAutomationsInput = {
    create?: XOR<WorkspaceCreateWithoutAutomationsInput, WorkspaceUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAutomationsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutAutomationsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAutomationsInput, WorkspaceUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAutomationsInput
    upsert?: WorkspaceUpsertWithoutAutomationsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAutomationsInput, WorkspaceUpdateWithoutAutomationsInput>, WorkspaceUncheckedUpdateWithoutAutomationsInput>
  }

  export type WebhookCreateeventsInput = {
    set: string[]
  }

  export type WorkspaceCreateNestedOneWithoutWebhooksInput = {
    create?: XOR<WorkspaceCreateWithoutWebhooksInput, WorkspaceUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutWebhooksInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WebhookUpdateeventsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WorkspaceUpdateOneRequiredWithoutWebhooksNestedInput = {
    create?: XOR<WorkspaceCreateWithoutWebhooksInput, WorkspaceUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutWebhooksInput
    upsert?: WorkspaceUpsertWithoutWebhooksInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutWebhooksInput, WorkspaceUpdateWithoutWebhooksInput>, WorkspaceUncheckedUpdateWithoutWebhooksInput>
  }

  export type WorkspaceCreateNestedOneWithoutCustomFieldsInput = {
    create?: XOR<WorkspaceCreateWithoutCustomFieldsInput, WorkspaceUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCustomFieldsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutCustomFieldsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutCustomFieldsInput, WorkspaceUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCustomFieldsInput
    upsert?: WorkspaceUpsertWithoutCustomFieldsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutCustomFieldsInput, WorkspaceUpdateWithoutCustomFieldsInput>, WorkspaceUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type WorkspaceCreateNestedOneWithoutTagsInput = {
    create?: XOR<WorkspaceCreateWithoutTagsInput, WorkspaceUncheckedCreateWithoutTagsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutTagsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutTagsInput, WorkspaceUncheckedCreateWithoutTagsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutTagsInput
    upsert?: WorkspaceUpsertWithoutTagsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutTagsInput, WorkspaceUpdateWithoutTagsInput>, WorkspaceUncheckedUpdateWithoutTagsInput>
  }

  export type WorkspaceCreateNestedOneWithoutAiAgentsInput = {
    create?: XOR<WorkspaceCreateWithoutAiAgentsInput, WorkspaceUncheckedCreateWithoutAiAgentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAiAgentsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type AiConversationCreateNestedManyWithoutAgentInput = {
    create?: XOR<AiConversationCreateWithoutAgentInput, AiConversationUncheckedCreateWithoutAgentInput> | AiConversationCreateWithoutAgentInput[] | AiConversationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AiConversationCreateOrConnectWithoutAgentInput | AiConversationCreateOrConnectWithoutAgentInput[]
    createMany?: AiConversationCreateManyAgentInputEnvelope
    connect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
  }

  export type AiConversationUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AiConversationCreateWithoutAgentInput, AiConversationUncheckedCreateWithoutAgentInput> | AiConversationCreateWithoutAgentInput[] | AiConversationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AiConversationCreateOrConnectWithoutAgentInput | AiConversationCreateOrConnectWithoutAgentInput[]
    createMany?: AiConversationCreateManyAgentInputEnvelope
    connect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutAiAgentsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAiAgentsInput, WorkspaceUncheckedCreateWithoutAiAgentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAiAgentsInput
    upsert?: WorkspaceUpsertWithoutAiAgentsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAiAgentsInput, WorkspaceUpdateWithoutAiAgentsInput>, WorkspaceUncheckedUpdateWithoutAiAgentsInput>
  }

  export type AiConversationUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AiConversationCreateWithoutAgentInput, AiConversationUncheckedCreateWithoutAgentInput> | AiConversationCreateWithoutAgentInput[] | AiConversationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AiConversationCreateOrConnectWithoutAgentInput | AiConversationCreateOrConnectWithoutAgentInput[]
    upsert?: AiConversationUpsertWithWhereUniqueWithoutAgentInput | AiConversationUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AiConversationCreateManyAgentInputEnvelope
    set?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    disconnect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    delete?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    connect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    update?: AiConversationUpdateWithWhereUniqueWithoutAgentInput | AiConversationUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AiConversationUpdateManyWithWhereWithoutAgentInput | AiConversationUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AiConversationScalarWhereInput | AiConversationScalarWhereInput[]
  }

  export type AiConversationUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AiConversationCreateWithoutAgentInput, AiConversationUncheckedCreateWithoutAgentInput> | AiConversationCreateWithoutAgentInput[] | AiConversationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AiConversationCreateOrConnectWithoutAgentInput | AiConversationCreateOrConnectWithoutAgentInput[]
    upsert?: AiConversationUpsertWithWhereUniqueWithoutAgentInput | AiConversationUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AiConversationCreateManyAgentInputEnvelope
    set?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    disconnect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    delete?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    connect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    update?: AiConversationUpdateWithWhereUniqueWithoutAgentInput | AiConversationUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AiConversationUpdateManyWithWhereWithoutAgentInput | AiConversationUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AiConversationScalarWhereInput | AiConversationScalarWhereInput[]
  }

  export type AiAgentCreateNestedOneWithoutConversationsInput = {
    create?: XOR<AiAgentCreateWithoutConversationsInput, AiAgentUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: AiAgentCreateOrConnectWithoutConversationsInput
    connect?: AiAgentWhereUniqueInput
  }

  export type AiMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput> | AiMessageCreateWithoutConversationInput[] | AiMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AiMessageCreateOrConnectWithoutConversationInput | AiMessageCreateOrConnectWithoutConversationInput[]
    createMany?: AiMessageCreateManyConversationInputEnvelope
    connect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
  }

  export type AiMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput> | AiMessageCreateWithoutConversationInput[] | AiMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AiMessageCreateOrConnectWithoutConversationInput | AiMessageCreateOrConnectWithoutConversationInput[]
    createMany?: AiMessageCreateManyConversationInputEnvelope
    connect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
  }

  export type AiAgentUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<AiAgentCreateWithoutConversationsInput, AiAgentUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: AiAgentCreateOrConnectWithoutConversationsInput
    upsert?: AiAgentUpsertWithoutConversationsInput
    connect?: AiAgentWhereUniqueInput
    update?: XOR<XOR<AiAgentUpdateToOneWithWhereWithoutConversationsInput, AiAgentUpdateWithoutConversationsInput>, AiAgentUncheckedUpdateWithoutConversationsInput>
  }

  export type AiMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput> | AiMessageCreateWithoutConversationInput[] | AiMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AiMessageCreateOrConnectWithoutConversationInput | AiMessageCreateOrConnectWithoutConversationInput[]
    upsert?: AiMessageUpsertWithWhereUniqueWithoutConversationInput | AiMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: AiMessageCreateManyConversationInputEnvelope
    set?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    disconnect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    delete?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    connect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    update?: AiMessageUpdateWithWhereUniqueWithoutConversationInput | AiMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: AiMessageUpdateManyWithWhereWithoutConversationInput | AiMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: AiMessageScalarWhereInput | AiMessageScalarWhereInput[]
  }

  export type AiMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput> | AiMessageCreateWithoutConversationInput[] | AiMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AiMessageCreateOrConnectWithoutConversationInput | AiMessageCreateOrConnectWithoutConversationInput[]
    upsert?: AiMessageUpsertWithWhereUniqueWithoutConversationInput | AiMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: AiMessageCreateManyConversationInputEnvelope
    set?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    disconnect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    delete?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    connect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    update?: AiMessageUpdateWithWhereUniqueWithoutConversationInput | AiMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: AiMessageUpdateManyWithWhereWithoutConversationInput | AiMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: AiMessageScalarWhereInput | AiMessageScalarWhereInput[]
  }

  export type AiConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<AiConversationCreateWithoutMessagesInput, AiConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AiConversationCreateOrConnectWithoutMessagesInput
    connect?: AiConversationWhereUniqueInput
  }

  export type AiConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<AiConversationCreateWithoutMessagesInput, AiConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AiConversationCreateOrConnectWithoutMessagesInput
    upsert?: AiConversationUpsertWithoutMessagesInput
    connect?: AiConversationWhereUniqueInput
    update?: XOR<XOR<AiConversationUpdateToOneWithWhereWithoutMessagesInput, AiConversationUpdateWithoutMessagesInput>, AiConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutAiTokenUsageInput = {
    create?: XOR<UserCreateWithoutAiTokenUsageInput, UserUncheckedCreateWithoutAiTokenUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiTokenUsageInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAiTokenUsageNestedInput = {
    create?: XOR<UserCreateWithoutAiTokenUsageInput, UserUncheckedCreateWithoutAiTokenUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiTokenUsageInput
    upsert?: UserUpsertWithoutAiTokenUsageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiTokenUsageInput, UserUpdateWithoutAiTokenUsageInput>, UserUncheckedUpdateWithoutAiTokenUsageInput>
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type SubscriptionPlanCreateNestedOneWithoutPlanPricingInput = {
    create?: XOR<SubscriptionPlanCreateWithoutPlanPricingInput, SubscriptionPlanUncheckedCreateWithoutPlanPricingInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutPlanPricingInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutPlanPricingNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutPlanPricingInput, SubscriptionPlanUncheckedCreateWithoutPlanPricingInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutPlanPricingInput
    upsert?: SubscriptionPlanUpsertWithoutPlanPricingInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutPlanPricingInput, SubscriptionPlanUpdateWithoutPlanPricingInput>, SubscriptionPlanUncheckedUpdateWithoutPlanPricingInput>
  }

  export type EwayCustomerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<EwayCustomerCreateWithoutTransactionsInput, EwayCustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: EwayCustomerCreateOrConnectWithoutTransactionsInput
    connect?: EwayCustomerWhereUniqueInput
  }

  export type EwayCustomerUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<EwayCustomerCreateWithoutTransactionsInput, EwayCustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: EwayCustomerCreateOrConnectWithoutTransactionsInput
    upsert?: EwayCustomerUpsertWithoutTransactionsInput
    disconnect?: EwayCustomerWhereInput | boolean
    delete?: EwayCustomerWhereInput | boolean
    connect?: EwayCustomerWhereUniqueInput
    update?: XOR<XOR<EwayCustomerUpdateToOneWithWhereWithoutTransactionsInput, EwayCustomerUpdateWithoutTransactionsInput>, EwayCustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type EwayTransactionCreateNestedManyWithoutEwayCustomerInput = {
    create?: XOR<EwayTransactionCreateWithoutEwayCustomerInput, EwayTransactionUncheckedCreateWithoutEwayCustomerInput> | EwayTransactionCreateWithoutEwayCustomerInput[] | EwayTransactionUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayTransactionCreateOrConnectWithoutEwayCustomerInput | EwayTransactionCreateOrConnectWithoutEwayCustomerInput[]
    createMany?: EwayTransactionCreateManyEwayCustomerInputEnvelope
    connect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
  }

  export type EwayRecurringScheduleCreateNestedManyWithoutEwayCustomerInput = {
    create?: XOR<EwayRecurringScheduleCreateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput> | EwayRecurringScheduleCreateWithoutEwayCustomerInput[] | EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput | EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput[]
    createMany?: EwayRecurringScheduleCreateManyEwayCustomerInputEnvelope
    connect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
  }

  export type EwayTransactionUncheckedCreateNestedManyWithoutEwayCustomerInput = {
    create?: XOR<EwayTransactionCreateWithoutEwayCustomerInput, EwayTransactionUncheckedCreateWithoutEwayCustomerInput> | EwayTransactionCreateWithoutEwayCustomerInput[] | EwayTransactionUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayTransactionCreateOrConnectWithoutEwayCustomerInput | EwayTransactionCreateOrConnectWithoutEwayCustomerInput[]
    createMany?: EwayTransactionCreateManyEwayCustomerInputEnvelope
    connect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
  }

  export type EwayRecurringScheduleUncheckedCreateNestedManyWithoutEwayCustomerInput = {
    create?: XOR<EwayRecurringScheduleCreateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput> | EwayRecurringScheduleCreateWithoutEwayCustomerInput[] | EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput | EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput[]
    createMany?: EwayRecurringScheduleCreateManyEwayCustomerInputEnvelope
    connect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
  }

  export type EwayTransactionUpdateManyWithoutEwayCustomerNestedInput = {
    create?: XOR<EwayTransactionCreateWithoutEwayCustomerInput, EwayTransactionUncheckedCreateWithoutEwayCustomerInput> | EwayTransactionCreateWithoutEwayCustomerInput[] | EwayTransactionUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayTransactionCreateOrConnectWithoutEwayCustomerInput | EwayTransactionCreateOrConnectWithoutEwayCustomerInput[]
    upsert?: EwayTransactionUpsertWithWhereUniqueWithoutEwayCustomerInput | EwayTransactionUpsertWithWhereUniqueWithoutEwayCustomerInput[]
    createMany?: EwayTransactionCreateManyEwayCustomerInputEnvelope
    set?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    disconnect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    delete?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    connect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    update?: EwayTransactionUpdateWithWhereUniqueWithoutEwayCustomerInput | EwayTransactionUpdateWithWhereUniqueWithoutEwayCustomerInput[]
    updateMany?: EwayTransactionUpdateManyWithWhereWithoutEwayCustomerInput | EwayTransactionUpdateManyWithWhereWithoutEwayCustomerInput[]
    deleteMany?: EwayTransactionScalarWhereInput | EwayTransactionScalarWhereInput[]
  }

  export type EwayRecurringScheduleUpdateManyWithoutEwayCustomerNestedInput = {
    create?: XOR<EwayRecurringScheduleCreateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput> | EwayRecurringScheduleCreateWithoutEwayCustomerInput[] | EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput | EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput[]
    upsert?: EwayRecurringScheduleUpsertWithWhereUniqueWithoutEwayCustomerInput | EwayRecurringScheduleUpsertWithWhereUniqueWithoutEwayCustomerInput[]
    createMany?: EwayRecurringScheduleCreateManyEwayCustomerInputEnvelope
    set?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    disconnect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    delete?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    connect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    update?: EwayRecurringScheduleUpdateWithWhereUniqueWithoutEwayCustomerInput | EwayRecurringScheduleUpdateWithWhereUniqueWithoutEwayCustomerInput[]
    updateMany?: EwayRecurringScheduleUpdateManyWithWhereWithoutEwayCustomerInput | EwayRecurringScheduleUpdateManyWithWhereWithoutEwayCustomerInput[]
    deleteMany?: EwayRecurringScheduleScalarWhereInput | EwayRecurringScheduleScalarWhereInput[]
  }

  export type EwayTransactionUncheckedUpdateManyWithoutEwayCustomerNestedInput = {
    create?: XOR<EwayTransactionCreateWithoutEwayCustomerInput, EwayTransactionUncheckedCreateWithoutEwayCustomerInput> | EwayTransactionCreateWithoutEwayCustomerInput[] | EwayTransactionUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayTransactionCreateOrConnectWithoutEwayCustomerInput | EwayTransactionCreateOrConnectWithoutEwayCustomerInput[]
    upsert?: EwayTransactionUpsertWithWhereUniqueWithoutEwayCustomerInput | EwayTransactionUpsertWithWhereUniqueWithoutEwayCustomerInput[]
    createMany?: EwayTransactionCreateManyEwayCustomerInputEnvelope
    set?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    disconnect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    delete?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    connect?: EwayTransactionWhereUniqueInput | EwayTransactionWhereUniqueInput[]
    update?: EwayTransactionUpdateWithWhereUniqueWithoutEwayCustomerInput | EwayTransactionUpdateWithWhereUniqueWithoutEwayCustomerInput[]
    updateMany?: EwayTransactionUpdateManyWithWhereWithoutEwayCustomerInput | EwayTransactionUpdateManyWithWhereWithoutEwayCustomerInput[]
    deleteMany?: EwayTransactionScalarWhereInput | EwayTransactionScalarWhereInput[]
  }

  export type EwayRecurringScheduleUncheckedUpdateManyWithoutEwayCustomerNestedInput = {
    create?: XOR<EwayRecurringScheduleCreateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput> | EwayRecurringScheduleCreateWithoutEwayCustomerInput[] | EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput[]
    connectOrCreate?: EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput | EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput[]
    upsert?: EwayRecurringScheduleUpsertWithWhereUniqueWithoutEwayCustomerInput | EwayRecurringScheduleUpsertWithWhereUniqueWithoutEwayCustomerInput[]
    createMany?: EwayRecurringScheduleCreateManyEwayCustomerInputEnvelope
    set?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    disconnect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    delete?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    connect?: EwayRecurringScheduleWhereUniqueInput | EwayRecurringScheduleWhereUniqueInput[]
    update?: EwayRecurringScheduleUpdateWithWhereUniqueWithoutEwayCustomerInput | EwayRecurringScheduleUpdateWithWhereUniqueWithoutEwayCustomerInput[]
    updateMany?: EwayRecurringScheduleUpdateManyWithWhereWithoutEwayCustomerInput | EwayRecurringScheduleUpdateManyWithWhereWithoutEwayCustomerInput[]
    deleteMany?: EwayRecurringScheduleScalarWhereInput | EwayRecurringScheduleScalarWhereInput[]
  }

  export type EwayCustomerCreateNestedOneWithoutRecurringSchedulesInput = {
    create?: XOR<EwayCustomerCreateWithoutRecurringSchedulesInput, EwayCustomerUncheckedCreateWithoutRecurringSchedulesInput>
    connectOrCreate?: EwayCustomerCreateOrConnectWithoutRecurringSchedulesInput
    connect?: EwayCustomerWhereUniqueInput
  }

  export type EwayCustomerUpdateOneRequiredWithoutRecurringSchedulesNestedInput = {
    create?: XOR<EwayCustomerCreateWithoutRecurringSchedulesInput, EwayCustomerUncheckedCreateWithoutRecurringSchedulesInput>
    connectOrCreate?: EwayCustomerCreateOrConnectWithoutRecurringSchedulesInput
    upsert?: EwayCustomerUpsertWithoutRecurringSchedulesInput
    connect?: EwayCustomerWhereUniqueInput
    update?: XOR<XOR<EwayCustomerUpdateToOneWithWhereWithoutRecurringSchedulesInput, EwayCustomerUpdateWithoutRecurringSchedulesInput>, EwayCustomerUncheckedUpdateWithoutRecurringSchedulesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type WorkspaceUserCreateWithoutUserInput = {
    id?: string
    role?: string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutUsersInput
  }

  export type WorkspaceUserUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    role?: string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string | null
  }

  export type WorkspaceUserCreateOrConnectWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    create: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserCreateManyUserInputEnvelope = {
    data: WorkspaceUserCreateManyUserInput | WorkspaceUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AudioHistoryCreateWithoutUserInput = {
    id?: string
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
    workspace?: WorkspaceCreateNestedOneWithoutAudioHistoryInput
    processingJob?: ProcessingJobCreateNestedOneWithoutAudioHistoryInput
    segments?: AudioSegmentCreateNestedManyWithoutAudioHistoryInput
  }

  export type AudioHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    processingJobId?: string | null
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
    segments?: AudioSegmentUncheckedCreateNestedManyWithoutAudioHistoryInput
  }

  export type AudioHistoryCreateOrConnectWithoutUserInput = {
    where: AudioHistoryWhereUniqueInput
    create: XOR<AudioHistoryCreateWithoutUserInput, AudioHistoryUncheckedCreateWithoutUserInput>
  }

  export type AudioHistoryCreateManyUserInputEnvelope = {
    data: AudioHistoryCreateManyUserInput | AudioHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AudioUploadCreateWithoutUserInput = {
    id?: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutAudioUploadsInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkCreateNestedManyWithoutUploadInput
    fileStorage?: FileStorageCreateNestedOneWithoutUploadInput
  }

  export type AudioUploadUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkUncheckedCreateNestedManyWithoutUploadInput
    fileStorage?: FileStorageUncheckedCreateNestedOneWithoutUploadInput
  }

  export type AudioUploadCreateOrConnectWithoutUserInput = {
    where: AudioUploadWhereUniqueInput
    create: XOR<AudioUploadCreateWithoutUserInput, AudioUploadUncheckedCreateWithoutUserInput>
  }

  export type AudioUploadCreateManyUserInputEnvelope = {
    data: AudioUploadCreateManyUserInput | AudioUploadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyManagementCreateWithoutUserInput = {
    id?: string
    provider: string
    keyHash: string
    keyPrefix: string
    encryptedKey: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    usageCount?: number
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: ApiKeyUsageLogCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyManagementUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    keyHash: string
    keyPrefix: string
    encryptedKey: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    usageCount?: number
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    usageLogs?: ApiKeyUsageLogUncheckedCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyManagementCreateOrConnectWithoutUserInput = {
    where: ApiKeyManagementWhereUniqueInput
    create: XOR<ApiKeyManagementCreateWithoutUserInput, ApiKeyManagementUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyManagementCreateManyUserInputEnvelope = {
    data: ApiKeyManagementCreateManyUserInput | ApiKeyManagementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsCreateWithoutUserInput = {
    openaiApiKeyEncrypted?: string | null
    elevenlabsApiKeyEncrypted?: string | null
    preferredLanguage?: string
    summaryQuality?: string
    theme?: string
    notifications?: JsonNullValueInput | InputJsonValue
    privacy?: JsonNullValueInput | InputJsonValue
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    openaiApiKeyEncrypted?: string | null
    elevenlabsApiKeyEncrypted?: string | null
    preferredLanguage?: string
    summaryQuality?: string
    theme?: string
    notifications?: JsonNullValueInput | InputJsonValue
    privacy?: JsonNullValueInput | InputJsonValue
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SecurityEventCreateWithoutUserInput = {
    id?: string
    eventType: string
    severity: string
    description: string
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type SecurityEventUncheckedCreateWithoutUserInput = {
    id?: string
    eventType: string
    severity: string
    description: string
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type SecurityEventCreateOrConnectWithoutUserInput = {
    where: SecurityEventWhereUniqueInput
    create: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput>
  }

  export type SecurityEventCreateManyUserInputEnvelope = {
    data: SecurityEventCreateManyUserInput | SecurityEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    actionUrl?: string | null
    read?: boolean
    readAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    actionUrl?: string | null
    read?: boolean
    readAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AudioSegmentCreateWithoutUserInput = {
    id?: string
    startTime: number
    endTime: number
    text: string
    speaker?: string | null
    confidence?: number | null
    keywords?: AudioSegmentCreatekeywordsInput | string[]
    sentiment?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    audioHistory: AudioHistoryCreateNestedOneWithoutSegmentsInput
  }

  export type AudioSegmentUncheckedCreateWithoutUserInput = {
    id?: string
    audioHistoryId: string
    startTime: number
    endTime: number
    text: string
    speaker?: string | null
    confidence?: number | null
    keywords?: AudioSegmentCreatekeywordsInput | string[]
    sentiment?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AudioSegmentCreateOrConnectWithoutUserInput = {
    where: AudioSegmentWhereUniqueInput
    create: XOR<AudioSegmentCreateWithoutUserInput, AudioSegmentUncheckedCreateWithoutUserInput>
  }

  export type AudioSegmentCreateManyUserInputEnvelope = {
    data: AudioSegmentCreateManyUserInput | AudioSegmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailPreferenceCreateWithoutUserInput = {
    marketing?: boolean
    transactional?: boolean
    security?: boolean
    newsletter?: boolean
    productUpdates?: boolean
    unsubscribeToken: string
    updatedAt?: Date | string
  }

  export type EmailPreferenceUncheckedCreateWithoutUserInput = {
    marketing?: boolean
    transactional?: boolean
    security?: boolean
    newsletter?: boolean
    productUpdates?: boolean
    unsubscribeToken: string
    updatedAt?: Date | string
  }

  export type EmailPreferenceCreateOrConnectWithoutUserInput = {
    where: EmailPreferenceWhereUniqueInput
    create: XOR<EmailPreferenceCreateWithoutUserInput, EmailPreferenceUncheckedCreateWithoutUserInput>
  }

  export type UserQuotaCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    quotaType: string
    used?: bigint | number
    limit: bigint | number
    resetPeriod: string
    nextResetAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQuotaUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    quotaType: string
    used?: bigint | number
    limit: bigint | number
    resetPeriod: string
    nextResetAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQuotaCreateOrConnectWithoutUserInput = {
    where: UserQuotaWhereUniqueInput
    create: XOR<UserQuotaCreateWithoutUserInput, UserQuotaUncheckedCreateWithoutUserInput>
  }

  export type UserQuotaCreateManyUserInputEnvelope = {
    data: UserQuotaCreateManyUserInput | UserQuotaCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AiTokenUsageCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    provider: string
    model: string
    tokensUsed: number
    cost: Decimal | DecimalJsLike | number | string
    purpose: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiTokenUsageUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    provider: string
    model: string
    tokensUsed: number
    cost: Decimal | DecimalJsLike | number | string
    purpose: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiTokenUsageCreateOrConnectWithoutUserInput = {
    where: AiTokenUsageWhereUniqueInput
    create: XOR<AiTokenUsageCreateWithoutUserInput, AiTokenUsageUncheckedCreateWithoutUserInput>
  }

  export type AiTokenUsageCreateManyUserInputEnvelope = {
    data: AiTokenUsageCreateManyUserInput | AiTokenUsageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUserUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    update: XOR<WorkspaceUserUpdateWithoutUserInput, WorkspaceUserUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    data: XOR<WorkspaceUserUpdateWithoutUserInput, WorkspaceUserUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceUserUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceUserScalarWhereInput
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceUserScalarWhereInput = {
    AND?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
    OR?: WorkspaceUserScalarWhereInput[]
    NOT?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
    id?: StringFilter<"WorkspaceUser"> | string
    workspaceId?: StringFilter<"WorkspaceUser"> | string
    userId?: StringFilter<"WorkspaceUser"> | string
    role?: StringFilter<"WorkspaceUser"> | string
    permissions?: JsonFilter<"WorkspaceUser">
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    lastActiveAt?: DateTimeNullableFilter<"WorkspaceUser"> | Date | string | null
  }

  export type AudioHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: AudioHistoryWhereUniqueInput
    update: XOR<AudioHistoryUpdateWithoutUserInput, AudioHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<AudioHistoryCreateWithoutUserInput, AudioHistoryUncheckedCreateWithoutUserInput>
  }

  export type AudioHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: AudioHistoryWhereUniqueInput
    data: XOR<AudioHistoryUpdateWithoutUserInput, AudioHistoryUncheckedUpdateWithoutUserInput>
  }

  export type AudioHistoryUpdateManyWithWhereWithoutUserInput = {
    where: AudioHistoryScalarWhereInput
    data: XOR<AudioHistoryUpdateManyMutationInput, AudioHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type AudioHistoryScalarWhereInput = {
    AND?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
    OR?: AudioHistoryScalarWhereInput[]
    NOT?: AudioHistoryScalarWhereInput | AudioHistoryScalarWhereInput[]
    id?: StringFilter<"AudioHistory"> | string
    userId?: StringFilter<"AudioHistory"> | string
    workspaceId?: StringNullableFilter<"AudioHistory"> | string | null
    processingJobId?: StringNullableFilter<"AudioHistory"> | string | null
    title?: StringNullableFilter<"AudioHistory"> | string | null
    audioUrl?: StringNullableFilter<"AudioHistory"> | string | null
    fileSizeBytes?: BigIntNullableFilter<"AudioHistory"> | bigint | number | null
    durationSeconds?: IntNullableFilter<"AudioHistory"> | number | null
    transcript?: StringNullableFilter<"AudioHistory"> | string | null
    summary?: StringNullableFilter<"AudioHistory"> | string | null
    keyMoments?: JsonNullableFilter<"AudioHistory">
    processingOptions?: JsonNullableFilter<"AudioHistory">
    language?: StringNullableFilter<"AudioHistory"> | string | null
    confidence?: FloatNullableFilter<"AudioHistory"> | number | null
    speakers?: IntNullableFilter<"AudioHistory"> | number | null
    tags?: StringNullableListFilter<"AudioHistory">
    createdAt?: DateTimeFilter<"AudioHistory"> | Date | string
  }

  export type AudioUploadUpsertWithWhereUniqueWithoutUserInput = {
    where: AudioUploadWhereUniqueInput
    update: XOR<AudioUploadUpdateWithoutUserInput, AudioUploadUncheckedUpdateWithoutUserInput>
    create: XOR<AudioUploadCreateWithoutUserInput, AudioUploadUncheckedCreateWithoutUserInput>
  }

  export type AudioUploadUpdateWithWhereUniqueWithoutUserInput = {
    where: AudioUploadWhereUniqueInput
    data: XOR<AudioUploadUpdateWithoutUserInput, AudioUploadUncheckedUpdateWithoutUserInput>
  }

  export type AudioUploadUpdateManyWithWhereWithoutUserInput = {
    where: AudioUploadScalarWhereInput
    data: XOR<AudioUploadUpdateManyMutationInput, AudioUploadUncheckedUpdateManyWithoutUserInput>
  }

  export type AudioUploadScalarWhereInput = {
    AND?: AudioUploadScalarWhereInput | AudioUploadScalarWhereInput[]
    OR?: AudioUploadScalarWhereInput[]
    NOT?: AudioUploadScalarWhereInput | AudioUploadScalarWhereInput[]
    id?: StringFilter<"AudioUpload"> | string
    userId?: StringFilter<"AudioUpload"> | string
    workspaceId?: StringFilter<"AudioUpload"> | string
    originalFileName?: StringFilter<"AudioUpload"> | string
    fileSize?: BigIntFilter<"AudioUpload"> | bigint | number
    mimeType?: StringFilter<"AudioUpload"> | string
    uploadStatus?: StringFilter<"AudioUpload"> | string
    uploadProgress?: FloatFilter<"AudioUpload"> | number
    storageProvider?: StringFilter<"AudioUpload"> | string
    storagePath?: StringNullableFilter<"AudioUpload"> | string | null
    storageUrl?: StringNullableFilter<"AudioUpload"> | string | null
    cdnUrl?: StringNullableFilter<"AudioUpload"> | string | null
    metadata?: JsonFilter<"AudioUpload">
    createdAt?: DateTimeFilter<"AudioUpload"> | Date | string
    updatedAt?: DateTimeFilter<"AudioUpload"> | Date | string
  }

  export type ApiKeyManagementUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyManagementWhereUniqueInput
    update: XOR<ApiKeyManagementUpdateWithoutUserInput, ApiKeyManagementUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyManagementCreateWithoutUserInput, ApiKeyManagementUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyManagementUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyManagementWhereUniqueInput
    data: XOR<ApiKeyManagementUpdateWithoutUserInput, ApiKeyManagementUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyManagementUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyManagementScalarWhereInput
    data: XOR<ApiKeyManagementUpdateManyMutationInput, ApiKeyManagementUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyManagementScalarWhereInput = {
    AND?: ApiKeyManagementScalarWhereInput | ApiKeyManagementScalarWhereInput[]
    OR?: ApiKeyManagementScalarWhereInput[]
    NOT?: ApiKeyManagementScalarWhereInput | ApiKeyManagementScalarWhereInput[]
    id?: StringFilter<"ApiKeyManagement"> | string
    userId?: StringFilter<"ApiKeyManagement"> | string
    provider?: StringFilter<"ApiKeyManagement"> | string
    keyHash?: StringFilter<"ApiKeyManagement"> | string
    keyPrefix?: StringFilter<"ApiKeyManagement"> | string
    encryptedKey?: StringFilter<"ApiKeyManagement"> | string
    isActive?: BoolFilter<"ApiKeyManagement"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"ApiKeyManagement"> | Date | string | null
    usageCount?: IntFilter<"ApiKeyManagement"> | number
    expiresAt?: DateTimeNullableFilter<"ApiKeyManagement"> | Date | string | null
    metadata?: JsonFilter<"ApiKeyManagement">
    createdAt?: DateTimeFilter<"ApiKeyManagement"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKeyManagement"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    tokenHash?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    openaiApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    elevenlabsApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    summaryQuality?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: JsonNullValueInput | InputJsonValue
    privacy?: JsonNullValueInput | InputJsonValue
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    openaiApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    elevenlabsApiKeyEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    summaryQuality?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: JsonNullValueInput | InputJsonValue
    privacy?: JsonNullValueInput | InputJsonValue
    settingsJson?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    workspaceId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type SecurityEventUpsertWithWhereUniqueWithoutUserInput = {
    where: SecurityEventWhereUniqueInput
    update: XOR<SecurityEventUpdateWithoutUserInput, SecurityEventUncheckedUpdateWithoutUserInput>
    create: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput>
  }

  export type SecurityEventUpdateWithWhereUniqueWithoutUserInput = {
    where: SecurityEventWhereUniqueInput
    data: XOR<SecurityEventUpdateWithoutUserInput, SecurityEventUncheckedUpdateWithoutUserInput>
  }

  export type SecurityEventUpdateManyWithWhereWithoutUserInput = {
    where: SecurityEventScalarWhereInput
    data: XOR<SecurityEventUpdateManyMutationInput, SecurityEventUncheckedUpdateManyWithoutUserInput>
  }

  export type SecurityEventScalarWhereInput = {
    AND?: SecurityEventScalarWhereInput | SecurityEventScalarWhereInput[]
    OR?: SecurityEventScalarWhereInput[]
    NOT?: SecurityEventScalarWhereInput | SecurityEventScalarWhereInput[]
    id?: StringFilter<"SecurityEvent"> | string
    userId?: StringNullableFilter<"SecurityEvent"> | string | null
    eventType?: StringFilter<"SecurityEvent"> | string
    severity?: StringFilter<"SecurityEvent"> | string
    description?: StringFilter<"SecurityEvent"> | string
    ipAddress?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    metadata?: JsonFilter<"SecurityEvent">
    resolved?: BoolFilter<"SecurityEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"SecurityEvent"> | Date | string | null
    resolvedBy?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AudioSegmentUpsertWithWhereUniqueWithoutUserInput = {
    where: AudioSegmentWhereUniqueInput
    update: XOR<AudioSegmentUpdateWithoutUserInput, AudioSegmentUncheckedUpdateWithoutUserInput>
    create: XOR<AudioSegmentCreateWithoutUserInput, AudioSegmentUncheckedCreateWithoutUserInput>
  }

  export type AudioSegmentUpdateWithWhereUniqueWithoutUserInput = {
    where: AudioSegmentWhereUniqueInput
    data: XOR<AudioSegmentUpdateWithoutUserInput, AudioSegmentUncheckedUpdateWithoutUserInput>
  }

  export type AudioSegmentUpdateManyWithWhereWithoutUserInput = {
    where: AudioSegmentScalarWhereInput
    data: XOR<AudioSegmentUpdateManyMutationInput, AudioSegmentUncheckedUpdateManyWithoutUserInput>
  }

  export type AudioSegmentScalarWhereInput = {
    AND?: AudioSegmentScalarWhereInput | AudioSegmentScalarWhereInput[]
    OR?: AudioSegmentScalarWhereInput[]
    NOT?: AudioSegmentScalarWhereInput | AudioSegmentScalarWhereInput[]
    id?: StringFilter<"AudioSegment"> | string
    audioHistoryId?: StringFilter<"AudioSegment"> | string
    userId?: StringFilter<"AudioSegment"> | string
    startTime?: FloatFilter<"AudioSegment"> | number
    endTime?: FloatFilter<"AudioSegment"> | number
    text?: StringFilter<"AudioSegment"> | string
    speaker?: StringNullableFilter<"AudioSegment"> | string | null
    confidence?: FloatNullableFilter<"AudioSegment"> | number | null
    keywords?: StringNullableListFilter<"AudioSegment">
    sentiment?: StringNullableFilter<"AudioSegment"> | string | null
    metadata?: JsonFilter<"AudioSegment">
    createdAt?: DateTimeFilter<"AudioSegment"> | Date | string
  }

  export type EmailPreferenceUpsertWithoutUserInput = {
    update: XOR<EmailPreferenceUpdateWithoutUserInput, EmailPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<EmailPreferenceCreateWithoutUserInput, EmailPreferenceUncheckedCreateWithoutUserInput>
    where?: EmailPreferenceWhereInput
  }

  export type EmailPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: EmailPreferenceWhereInput
    data: XOR<EmailPreferenceUpdateWithoutUserInput, EmailPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type EmailPreferenceUpdateWithoutUserInput = {
    marketing?: BoolFieldUpdateOperationsInput | boolean
    transactional?: BoolFieldUpdateOperationsInput | boolean
    security?: BoolFieldUpdateOperationsInput | boolean
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    productUpdates?: BoolFieldUpdateOperationsInput | boolean
    unsubscribeToken?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailPreferenceUncheckedUpdateWithoutUserInput = {
    marketing?: BoolFieldUpdateOperationsInput | boolean
    transactional?: BoolFieldUpdateOperationsInput | boolean
    security?: BoolFieldUpdateOperationsInput | boolean
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    productUpdates?: BoolFieldUpdateOperationsInput | boolean
    unsubscribeToken?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuotaUpsertWithWhereUniqueWithoutUserInput = {
    where: UserQuotaWhereUniqueInput
    update: XOR<UserQuotaUpdateWithoutUserInput, UserQuotaUncheckedUpdateWithoutUserInput>
    create: XOR<UserQuotaCreateWithoutUserInput, UserQuotaUncheckedCreateWithoutUserInput>
  }

  export type UserQuotaUpdateWithWhereUniqueWithoutUserInput = {
    where: UserQuotaWhereUniqueInput
    data: XOR<UserQuotaUpdateWithoutUserInput, UserQuotaUncheckedUpdateWithoutUserInput>
  }

  export type UserQuotaUpdateManyWithWhereWithoutUserInput = {
    where: UserQuotaScalarWhereInput
    data: XOR<UserQuotaUpdateManyMutationInput, UserQuotaUncheckedUpdateManyWithoutUserInput>
  }

  export type UserQuotaScalarWhereInput = {
    AND?: UserQuotaScalarWhereInput | UserQuotaScalarWhereInput[]
    OR?: UserQuotaScalarWhereInput[]
    NOT?: UserQuotaScalarWhereInput | UserQuotaScalarWhereInput[]
    id?: StringFilter<"UserQuota"> | string
    userId?: StringFilter<"UserQuota"> | string
    workspaceId?: StringFilter<"UserQuota"> | string
    quotaType?: StringFilter<"UserQuota"> | string
    used?: BigIntFilter<"UserQuota"> | bigint | number
    limit?: BigIntFilter<"UserQuota"> | bigint | number
    resetPeriod?: StringFilter<"UserQuota"> | string
    nextResetAt?: DateTimeFilter<"UserQuota"> | Date | string
    createdAt?: DateTimeFilter<"UserQuota"> | Date | string
    updatedAt?: DateTimeFilter<"UserQuota"> | Date | string
  }

  export type AiTokenUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: AiTokenUsageWhereUniqueInput
    update: XOR<AiTokenUsageUpdateWithoutUserInput, AiTokenUsageUncheckedUpdateWithoutUserInput>
    create: XOR<AiTokenUsageCreateWithoutUserInput, AiTokenUsageUncheckedCreateWithoutUserInput>
  }

  export type AiTokenUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: AiTokenUsageWhereUniqueInput
    data: XOR<AiTokenUsageUpdateWithoutUserInput, AiTokenUsageUncheckedUpdateWithoutUserInput>
  }

  export type AiTokenUsageUpdateManyWithWhereWithoutUserInput = {
    where: AiTokenUsageScalarWhereInput
    data: XOR<AiTokenUsageUpdateManyMutationInput, AiTokenUsageUncheckedUpdateManyWithoutUserInput>
  }

  export type AiTokenUsageScalarWhereInput = {
    AND?: AiTokenUsageScalarWhereInput | AiTokenUsageScalarWhereInput[]
    OR?: AiTokenUsageScalarWhereInput[]
    NOT?: AiTokenUsageScalarWhereInput | AiTokenUsageScalarWhereInput[]
    id?: StringFilter<"AiTokenUsage"> | string
    userId?: StringFilter<"AiTokenUsage"> | string
    workspaceId?: StringFilter<"AiTokenUsage"> | string
    provider?: StringFilter<"AiTokenUsage"> | string
    model?: StringFilter<"AiTokenUsage"> | string
    tokensUsed?: IntFilter<"AiTokenUsage"> | number
    cost?: DecimalFilter<"AiTokenUsage"> | Decimal | DecimalJsLike | number | string
    purpose?: StringFilter<"AiTokenUsage"> | string
    metadata?: JsonNullableFilter<"AiTokenUsage">
    createdAt?: DateTimeFilter<"AiTokenUsage"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUserCreateWithoutWorkspaceInput = {
    id?: string
    role?: string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string | null
    user: UserCreateNestedOneWithoutWorkspacesInput
  }

  export type WorkspaceUserUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    role?: string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string | null
  }

  export type WorkspaceUserCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    create: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceUserCreateManyWorkspaceInput | WorkspaceUserCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceInvitationCreateWithoutWorkspaceInput = {
    id?: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    acceptedAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    create: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceInvitationCreateManyWorkspaceInput | WorkspaceInvitationCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type AudioHistoryCreateWithoutWorkspaceInput = {
    id?: string
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAudioHistoryInput
    processingJob?: ProcessingJobCreateNestedOneWithoutAudioHistoryInput
    segments?: AudioSegmentCreateNestedManyWithoutAudioHistoryInput
  }

  export type AudioHistoryUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    processingJobId?: string | null
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
    segments?: AudioSegmentUncheckedCreateNestedManyWithoutAudioHistoryInput
  }

  export type AudioHistoryCreateOrConnectWithoutWorkspaceInput = {
    where: AudioHistoryWhereUniqueInput
    create: XOR<AudioHistoryCreateWithoutWorkspaceInput, AudioHistoryUncheckedCreateWithoutWorkspaceInput>
  }

  export type AudioHistoryCreateManyWorkspaceInputEnvelope = {
    data: AudioHistoryCreateManyWorkspaceInput | AudioHistoryCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type AudioUploadCreateWithoutWorkspaceInput = {
    id?: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAudioUploadsInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkCreateNestedManyWithoutUploadInput
    fileStorage?: FileStorageCreateNestedOneWithoutUploadInput
  }

  export type AudioUploadUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkUncheckedCreateNestedManyWithoutUploadInput
    fileStorage?: FileStorageUncheckedCreateNestedOneWithoutUploadInput
  }

  export type AudioUploadCreateOrConnectWithoutWorkspaceInput = {
    where: AudioUploadWhereUniqueInput
    create: XOR<AudioUploadCreateWithoutWorkspaceInput, AudioUploadUncheckedCreateWithoutWorkspaceInput>
  }

  export type AudioUploadCreateManyWorkspaceInputEnvelope = {
    data: AudioUploadCreateManyWorkspaceInput | AudioUploadCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceSubscriptionCreateWithoutWorkspaceInput = {
    id?: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    billingRecords?: BillingRecordCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    planId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    billingRecords?: BillingRecordUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    create: XOR<WorkspaceSubscriptionCreateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceSubscriptionCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceSubscriptionCreateManyWorkspaceInput | WorkspaceSubscriptionCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type StorageQuotaCreateWithoutWorkspaceInput = {
    id?: string
    totalBytes: bigint | number
    usedBytes: bigint | number
    fileCount: number
    lastCalculated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageQuotaUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    totalBytes: bigint | number
    usedBytes: bigint | number
    fileCount: number
    lastCalculated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageQuotaCreateOrConnectWithoutWorkspaceInput = {
    where: StorageQuotaWhereUniqueInput
    create: XOR<StorageQuotaCreateWithoutWorkspaceInput, StorageQuotaUncheckedCreateWithoutWorkspaceInput>
  }

  export type StorageQuotaCreateManyWorkspaceInputEnvelope = {
    data: StorageQuotaCreateManyWorkspaceInput | StorageQuotaCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type IntegrationCreateWithoutWorkspaceInput = {
    id?: string
    type: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    type: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateOrConnectWithoutWorkspaceInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutWorkspaceInput, IntegrationUncheckedCreateWithoutWorkspaceInput>
  }

  export type IntegrationCreateManyWorkspaceInputEnvelope = {
    data: IntegrationCreateManyWorkspaceInput | IntegrationCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceAutomationCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceAutomationUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceAutomationCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceAutomationWhereUniqueInput
    create: XOR<WorkspaceAutomationCreateWithoutWorkspaceInput, WorkspaceAutomationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceAutomationCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceAutomationCreateManyWorkspaceInput | WorkspaceAutomationCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WebhookCreateWithoutWorkspaceInput = {
    id?: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    lastTriggeredAt?: Date | string | null
    failureCount?: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    lastTriggeredAt?: Date | string | null
    failureCount?: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookCreateOrConnectWithoutWorkspaceInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutWorkspaceInput, WebhookUncheckedCreateWithoutWorkspaceInput>
  }

  export type WebhookCreateManyWorkspaceInputEnvelope = {
    data: WebhookCreateManyWorkspaceInput | WebhookCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type CustomFieldCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    fieldType: string
    isRequired?: boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    fieldType: string
    isRequired?: boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldCreateOrConnectWithoutWorkspaceInput = {
    where: CustomFieldWhereUniqueInput
    create: XOR<CustomFieldCreateWithoutWorkspaceInput, CustomFieldUncheckedCreateWithoutWorkspaceInput>
  }

  export type CustomFieldCreateManyWorkspaceInputEnvelope = {
    data: CustomFieldCreateManyWorkspaceInput | CustomFieldCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    color: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    color: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutWorkspaceInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutWorkspaceInput, TagUncheckedCreateWithoutWorkspaceInput>
  }

  export type TagCreateManyWorkspaceInputEnvelope = {
    data: TagCreateManyWorkspaceInput | TagCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type AiAgentCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    model?: string
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: AiConversationCreateNestedManyWithoutAgentInput
  }

  export type AiAgentUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    model?: string
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: AiConversationUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AiAgentCreateOrConnectWithoutWorkspaceInput = {
    where: AiAgentWhereUniqueInput
    create: XOR<AiAgentCreateWithoutWorkspaceInput, AiAgentUncheckedCreateWithoutWorkspaceInput>
  }

  export type AiAgentCreateManyWorkspaceInputEnvelope = {
    data: AiAgentCreateManyWorkspaceInput | AiAgentCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    update: XOR<WorkspaceUserUpdateWithoutWorkspaceInput, WorkspaceUserUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    data: XOR<WorkspaceUserUpdateWithoutWorkspaceInput, WorkspaceUserUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceUserScalarWhereInput
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    update: XOR<WorkspaceInvitationUpdateWithoutWorkspaceInput, WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    data: XOR<WorkspaceInvitationUpdateWithoutWorkspaceInput, WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceInvitationScalarWhereInput
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationScalarWhereInput = {
    AND?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
    OR?: WorkspaceInvitationScalarWhereInput[]
    NOT?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
    id?: StringFilter<"WorkspaceInvitation"> | string
    workspaceId?: StringFilter<"WorkspaceInvitation"> | string
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: StringFilter<"WorkspaceInvitation"> | string
    token?: StringFilter<"WorkspaceInvitation"> | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"WorkspaceInvitation"> | Date | string | null
  }

  export type AudioHistoryUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AudioHistoryWhereUniqueInput
    update: XOR<AudioHistoryUpdateWithoutWorkspaceInput, AudioHistoryUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AudioHistoryCreateWithoutWorkspaceInput, AudioHistoryUncheckedCreateWithoutWorkspaceInput>
  }

  export type AudioHistoryUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AudioHistoryWhereUniqueInput
    data: XOR<AudioHistoryUpdateWithoutWorkspaceInput, AudioHistoryUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AudioHistoryUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AudioHistoryScalarWhereInput
    data: XOR<AudioHistoryUpdateManyMutationInput, AudioHistoryUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type AudioUploadUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AudioUploadWhereUniqueInput
    update: XOR<AudioUploadUpdateWithoutWorkspaceInput, AudioUploadUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AudioUploadCreateWithoutWorkspaceInput, AudioUploadUncheckedCreateWithoutWorkspaceInput>
  }

  export type AudioUploadUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AudioUploadWhereUniqueInput
    data: XOR<AudioUploadUpdateWithoutWorkspaceInput, AudioUploadUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AudioUploadUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AudioUploadScalarWhereInput
    data: XOR<AudioUploadUpdateManyMutationInput, AudioUploadUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceSubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    update: XOR<WorkspaceSubscriptionUpdateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceSubscriptionCreateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceSubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    data: XOR<WorkspaceSubscriptionUpdateWithoutWorkspaceInput, WorkspaceSubscriptionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceSubscriptionUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceSubscriptionScalarWhereInput
    data: XOR<WorkspaceSubscriptionUpdateManyMutationInput, WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceSubscriptionScalarWhereInput = {
    AND?: WorkspaceSubscriptionScalarWhereInput | WorkspaceSubscriptionScalarWhereInput[]
    OR?: WorkspaceSubscriptionScalarWhereInput[]
    NOT?: WorkspaceSubscriptionScalarWhereInput | WorkspaceSubscriptionScalarWhereInput[]
    id?: StringFilter<"WorkspaceSubscription"> | string
    workspaceId?: StringFilter<"WorkspaceSubscription"> | string
    planId?: StringFilter<"WorkspaceSubscription"> | string
    status?: StringFilter<"WorkspaceSubscription"> | string
    currentPeriodStart?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"WorkspaceSubscription"> | string | null
    trialEnd?: DateTimeNullableFilter<"WorkspaceSubscription"> | Date | string | null
    metadata?: JsonFilter<"WorkspaceSubscription">
    createdAt?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceSubscription"> | Date | string
  }

  export type StorageQuotaUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: StorageQuotaWhereUniqueInput
    update: XOR<StorageQuotaUpdateWithoutWorkspaceInput, StorageQuotaUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<StorageQuotaCreateWithoutWorkspaceInput, StorageQuotaUncheckedCreateWithoutWorkspaceInput>
  }

  export type StorageQuotaUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: StorageQuotaWhereUniqueInput
    data: XOR<StorageQuotaUpdateWithoutWorkspaceInput, StorageQuotaUncheckedUpdateWithoutWorkspaceInput>
  }

  export type StorageQuotaUpdateManyWithWhereWithoutWorkspaceInput = {
    where: StorageQuotaScalarWhereInput
    data: XOR<StorageQuotaUpdateManyMutationInput, StorageQuotaUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type StorageQuotaScalarWhereInput = {
    AND?: StorageQuotaScalarWhereInput | StorageQuotaScalarWhereInput[]
    OR?: StorageQuotaScalarWhereInput[]
    NOT?: StorageQuotaScalarWhereInput | StorageQuotaScalarWhereInput[]
    id?: StringFilter<"StorageQuota"> | string
    workspaceId?: StringFilter<"StorageQuota"> | string
    totalBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    usedBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    fileCount?: IntFilter<"StorageQuota"> | number
    lastCalculated?: DateTimeFilter<"StorageQuota"> | Date | string
    createdAt?: DateTimeFilter<"StorageQuota"> | Date | string
    updatedAt?: DateTimeFilter<"StorageQuota"> | Date | string
  }

  export type IntegrationUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: IntegrationWhereUniqueInput
    update: XOR<IntegrationUpdateWithoutWorkspaceInput, IntegrationUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<IntegrationCreateWithoutWorkspaceInput, IntegrationUncheckedCreateWithoutWorkspaceInput>
  }

  export type IntegrationUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: IntegrationWhereUniqueInput
    data: XOR<IntegrationUpdateWithoutWorkspaceInput, IntegrationUncheckedUpdateWithoutWorkspaceInput>
  }

  export type IntegrationUpdateManyWithWhereWithoutWorkspaceInput = {
    where: IntegrationScalarWhereInput
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type IntegrationScalarWhereInput = {
    AND?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    OR?: IntegrationScalarWhereInput[]
    NOT?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    id?: StringFilter<"Integration"> | string
    workspaceId?: StringFilter<"Integration"> | string
    type?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    config?: JsonFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
  }

  export type WorkspaceAutomationUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceAutomationWhereUniqueInput
    update: XOR<WorkspaceAutomationUpdateWithoutWorkspaceInput, WorkspaceAutomationUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceAutomationCreateWithoutWorkspaceInput, WorkspaceAutomationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceAutomationUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceAutomationWhereUniqueInput
    data: XOR<WorkspaceAutomationUpdateWithoutWorkspaceInput, WorkspaceAutomationUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceAutomationUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceAutomationScalarWhereInput
    data: XOR<WorkspaceAutomationUpdateManyMutationInput, WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceAutomationScalarWhereInput = {
    AND?: WorkspaceAutomationScalarWhereInput | WorkspaceAutomationScalarWhereInput[]
    OR?: WorkspaceAutomationScalarWhereInput[]
    NOT?: WorkspaceAutomationScalarWhereInput | WorkspaceAutomationScalarWhereInput[]
    id?: StringFilter<"WorkspaceAutomation"> | string
    workspaceId?: StringFilter<"WorkspaceAutomation"> | string
    name?: StringFilter<"WorkspaceAutomation"> | string
    description?: StringNullableFilter<"WorkspaceAutomation"> | string | null
    trigger?: JsonFilter<"WorkspaceAutomation">
    actions?: JsonFilter<"WorkspaceAutomation">
    isActive?: BoolFilter<"WorkspaceAutomation"> | boolean
    lastRunAt?: DateTimeNullableFilter<"WorkspaceAutomation"> | Date | string | null
    runCount?: IntFilter<"WorkspaceAutomation"> | number
    createdAt?: DateTimeFilter<"WorkspaceAutomation"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceAutomation"> | Date | string
  }

  export type WebhookUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WebhookWhereUniqueInput
    update: XOR<WebhookUpdateWithoutWorkspaceInput, WebhookUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WebhookCreateWithoutWorkspaceInput, WebhookUncheckedCreateWithoutWorkspaceInput>
  }

  export type WebhookUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WebhookWhereUniqueInput
    data: XOR<WebhookUpdateWithoutWorkspaceInput, WebhookUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WebhookUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WebhookScalarWhereInput
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WebhookScalarWhereInput = {
    AND?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    OR?: WebhookScalarWhereInput[]
    NOT?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    id?: StringFilter<"Webhook"> | string
    workspaceId?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringFilter<"Webhook"> | string
    isActive?: BoolFilter<"Webhook"> | boolean
    lastTriggeredAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    failureCount?: IntFilter<"Webhook"> | number
    metadata?: JsonFilter<"Webhook">
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
  }

  export type CustomFieldUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: CustomFieldWhereUniqueInput
    update: XOR<CustomFieldUpdateWithoutWorkspaceInput, CustomFieldUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<CustomFieldCreateWithoutWorkspaceInput, CustomFieldUncheckedCreateWithoutWorkspaceInput>
  }

  export type CustomFieldUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: CustomFieldWhereUniqueInput
    data: XOR<CustomFieldUpdateWithoutWorkspaceInput, CustomFieldUncheckedUpdateWithoutWorkspaceInput>
  }

  export type CustomFieldUpdateManyWithWhereWithoutWorkspaceInput = {
    where: CustomFieldScalarWhereInput
    data: XOR<CustomFieldUpdateManyMutationInput, CustomFieldUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type CustomFieldScalarWhereInput = {
    AND?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
    OR?: CustomFieldScalarWhereInput[]
    NOT?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
    id?: StringFilter<"CustomField"> | string
    workspaceId?: StringFilter<"CustomField"> | string
    name?: StringFilter<"CustomField"> | string
    fieldType?: StringFilter<"CustomField"> | string
    isRequired?: BoolFilter<"CustomField"> | boolean
    options?: JsonNullableFilter<"CustomField">
    defaultValue?: StringNullableFilter<"CustomField"> | string | null
    sortOrder?: IntFilter<"CustomField"> | number
    createdAt?: DateTimeFilter<"CustomField"> | Date | string
    updatedAt?: DateTimeFilter<"CustomField"> | Date | string
  }

  export type TagUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutWorkspaceInput, TagUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<TagCreateWithoutWorkspaceInput, TagUncheckedCreateWithoutWorkspaceInput>
  }

  export type TagUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutWorkspaceInput, TagUncheckedUpdateWithoutWorkspaceInput>
  }

  export type TagUpdateManyWithWhereWithoutWorkspaceInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    workspaceId?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type AiAgentUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AiAgentWhereUniqueInput
    update: XOR<AiAgentUpdateWithoutWorkspaceInput, AiAgentUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AiAgentCreateWithoutWorkspaceInput, AiAgentUncheckedCreateWithoutWorkspaceInput>
  }

  export type AiAgentUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AiAgentWhereUniqueInput
    data: XOR<AiAgentUpdateWithoutWorkspaceInput, AiAgentUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AiAgentUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AiAgentScalarWhereInput
    data: XOR<AiAgentUpdateManyMutationInput, AiAgentUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type AiAgentScalarWhereInput = {
    AND?: AiAgentScalarWhereInput | AiAgentScalarWhereInput[]
    OR?: AiAgentScalarWhereInput[]
    NOT?: AiAgentScalarWhereInput | AiAgentScalarWhereInput[]
    id?: StringFilter<"AiAgent"> | string
    workspaceId?: StringFilter<"AiAgent"> | string
    name?: StringFilter<"AiAgent"> | string
    description?: StringNullableFilter<"AiAgent"> | string | null
    systemPrompt?: StringFilter<"AiAgent"> | string
    model?: StringFilter<"AiAgent"> | string
    temperature?: FloatFilter<"AiAgent"> | number
    maxTokens?: IntFilter<"AiAgent"> | number
    isActive?: BoolFilter<"AiAgent"> | boolean
    createdAt?: DateTimeFilter<"AiAgent"> | Date | string
    updatedAt?: DateTimeFilter<"AiAgent"> | Date | string
  }

  export type WorkspaceCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldCreateNestedManyWithoutWorkspaceInput
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutUsersInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutWorkspacesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkspacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
  }

  export type WorkspaceUpsertWithoutUsersInput = {
    update: XOR<WorkspaceUpdateWithoutUsersInput, WorkspaceUncheckedUpdateWithoutUsersInput>
    create: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutUsersInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutUsersInput, WorkspaceUncheckedUpdateWithoutUsersInput>
  }

  export type WorkspaceUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutWorkspacesInput = {
    update: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type UserUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutInvitationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldCreateNestedManyWithoutWorkspaceInput
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutInvitationsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
  }

  export type WorkspaceUpsertWithoutInvitationsInput = {
    update: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
    create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
  }

  export type WorkspaceUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutAudioUploadsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAudioUploadsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAudioUploadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAudioUploadsInput, UserUncheckedCreateWithoutAudioUploadsInput>
  }

  export type WorkspaceCreateWithoutAudioUploadsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldCreateNestedManyWithoutWorkspaceInput
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAudioUploadsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAudioUploadsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAudioUploadsInput, WorkspaceUncheckedCreateWithoutAudioUploadsInput>
  }

  export type ProcessingJobCreateWithoutUploadInput = {
    id?: string
    jobType: string
    status?: string
    priority?: number
    progress?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    audioHistory?: AudioHistoryCreateNestedOneWithoutProcessingJobInput
  }

  export type ProcessingJobUncheckedCreateWithoutUploadInput = {
    id?: string
    jobType: string
    status?: string
    priority?: number
    progress?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    audioHistory?: AudioHistoryUncheckedCreateNestedOneWithoutProcessingJobInput
  }

  export type ProcessingJobCreateOrConnectWithoutUploadInput = {
    where: ProcessingJobWhereUniqueInput
    create: XOR<ProcessingJobCreateWithoutUploadInput, ProcessingJobUncheckedCreateWithoutUploadInput>
  }

  export type ProcessingJobCreateManyUploadInputEnvelope = {
    data: ProcessingJobCreateManyUploadInput | ProcessingJobCreateManyUploadInput[]
    skipDuplicates?: boolean
  }

  export type AudioChunkCreateWithoutUploadInput = {
    id?: string
    chunkIndex: number
    startByte: bigint | number
    endByte: bigint | number
    size: bigint | number
    storageKey: string
    checksum: string
    uploadedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AudioChunkUncheckedCreateWithoutUploadInput = {
    id?: string
    chunkIndex: number
    startByte: bigint | number
    endByte: bigint | number
    size: bigint | number
    storageKey: string
    checksum: string
    uploadedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AudioChunkCreateOrConnectWithoutUploadInput = {
    where: AudioChunkWhereUniqueInput
    create: XOR<AudioChunkCreateWithoutUploadInput, AudioChunkUncheckedCreateWithoutUploadInput>
  }

  export type AudioChunkCreateManyUploadInputEnvelope = {
    data: AudioChunkCreateManyUploadInput | AudioChunkCreateManyUploadInput[]
    skipDuplicates?: boolean
  }

  export type FileStorageCreateWithoutUploadInput = {
    id?: string
    storageKey: string
    fileName: string
    fileSize: bigint | number
    mimeType: string
    checksum: string
    publicUrl?: string | null
    cdnUrl?: string | null
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastAccessedAt?: Date | string | null
    provider: StorageProviderCreateNestedOneWithoutFilesInput
  }

  export type FileStorageUncheckedCreateWithoutUploadInput = {
    id?: string
    providerId: string
    storageKey: string
    fileName: string
    fileSize: bigint | number
    mimeType: string
    checksum: string
    publicUrl?: string | null
    cdnUrl?: string | null
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastAccessedAt?: Date | string | null
  }

  export type FileStorageCreateOrConnectWithoutUploadInput = {
    where: FileStorageWhereUniqueInput
    create: XOR<FileStorageCreateWithoutUploadInput, FileStorageUncheckedCreateWithoutUploadInput>
  }

  export type UserUpsertWithoutAudioUploadsInput = {
    update: XOR<UserUpdateWithoutAudioUploadsInput, UserUncheckedUpdateWithoutAudioUploadsInput>
    create: XOR<UserCreateWithoutAudioUploadsInput, UserUncheckedCreateWithoutAudioUploadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAudioUploadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAudioUploadsInput, UserUncheckedUpdateWithoutAudioUploadsInput>
  }

  export type UserUpdateWithoutAudioUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAudioUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutAudioUploadsInput = {
    update: XOR<WorkspaceUpdateWithoutAudioUploadsInput, WorkspaceUncheckedUpdateWithoutAudioUploadsInput>
    create: XOR<WorkspaceCreateWithoutAudioUploadsInput, WorkspaceUncheckedCreateWithoutAudioUploadsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAudioUploadsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAudioUploadsInput, WorkspaceUncheckedUpdateWithoutAudioUploadsInput>
  }

  export type WorkspaceUpdateWithoutAudioUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAudioUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ProcessingJobUpsertWithWhereUniqueWithoutUploadInput = {
    where: ProcessingJobWhereUniqueInput
    update: XOR<ProcessingJobUpdateWithoutUploadInput, ProcessingJobUncheckedUpdateWithoutUploadInput>
    create: XOR<ProcessingJobCreateWithoutUploadInput, ProcessingJobUncheckedCreateWithoutUploadInput>
  }

  export type ProcessingJobUpdateWithWhereUniqueWithoutUploadInput = {
    where: ProcessingJobWhereUniqueInput
    data: XOR<ProcessingJobUpdateWithoutUploadInput, ProcessingJobUncheckedUpdateWithoutUploadInput>
  }

  export type ProcessingJobUpdateManyWithWhereWithoutUploadInput = {
    where: ProcessingJobScalarWhereInput
    data: XOR<ProcessingJobUpdateManyMutationInput, ProcessingJobUncheckedUpdateManyWithoutUploadInput>
  }

  export type ProcessingJobScalarWhereInput = {
    AND?: ProcessingJobScalarWhereInput | ProcessingJobScalarWhereInput[]
    OR?: ProcessingJobScalarWhereInput[]
    NOT?: ProcessingJobScalarWhereInput | ProcessingJobScalarWhereInput[]
    id?: StringFilter<"ProcessingJob"> | string
    uploadId?: StringFilter<"ProcessingJob"> | string
    jobType?: StringFilter<"ProcessingJob"> | string
    status?: StringFilter<"ProcessingJob"> | string
    priority?: IntFilter<"ProcessingJob"> | number
    progress?: FloatFilter<"ProcessingJob"> | number
    startedAt?: DateTimeNullableFilter<"ProcessingJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProcessingJob"> | Date | string | null
    error?: StringNullableFilter<"ProcessingJob"> | string | null
    result?: JsonNullableFilter<"ProcessingJob">
    metadata?: JsonFilter<"ProcessingJob">
    createdAt?: DateTimeFilter<"ProcessingJob"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessingJob"> | Date | string
  }

  export type AudioChunkUpsertWithWhereUniqueWithoutUploadInput = {
    where: AudioChunkWhereUniqueInput
    update: XOR<AudioChunkUpdateWithoutUploadInput, AudioChunkUncheckedUpdateWithoutUploadInput>
    create: XOR<AudioChunkCreateWithoutUploadInput, AudioChunkUncheckedCreateWithoutUploadInput>
  }

  export type AudioChunkUpdateWithWhereUniqueWithoutUploadInput = {
    where: AudioChunkWhereUniqueInput
    data: XOR<AudioChunkUpdateWithoutUploadInput, AudioChunkUncheckedUpdateWithoutUploadInput>
  }

  export type AudioChunkUpdateManyWithWhereWithoutUploadInput = {
    where: AudioChunkScalarWhereInput
    data: XOR<AudioChunkUpdateManyMutationInput, AudioChunkUncheckedUpdateManyWithoutUploadInput>
  }

  export type AudioChunkScalarWhereInput = {
    AND?: AudioChunkScalarWhereInput | AudioChunkScalarWhereInput[]
    OR?: AudioChunkScalarWhereInput[]
    NOT?: AudioChunkScalarWhereInput | AudioChunkScalarWhereInput[]
    id?: StringFilter<"AudioChunk"> | string
    uploadId?: StringFilter<"AudioChunk"> | string
    chunkIndex?: IntFilter<"AudioChunk"> | number
    startByte?: BigIntFilter<"AudioChunk"> | bigint | number
    endByte?: BigIntFilter<"AudioChunk"> | bigint | number
    size?: BigIntFilter<"AudioChunk"> | bigint | number
    storageKey?: StringFilter<"AudioChunk"> | string
    checksum?: StringFilter<"AudioChunk"> | string
    uploadedAt?: DateTimeNullableFilter<"AudioChunk"> | Date | string | null
    createdAt?: DateTimeFilter<"AudioChunk"> | Date | string
  }

  export type FileStorageUpsertWithoutUploadInput = {
    update: XOR<FileStorageUpdateWithoutUploadInput, FileStorageUncheckedUpdateWithoutUploadInput>
    create: XOR<FileStorageCreateWithoutUploadInput, FileStorageUncheckedCreateWithoutUploadInput>
    where?: FileStorageWhereInput
  }

  export type FileStorageUpdateToOneWithWhereWithoutUploadInput = {
    where?: FileStorageWhereInput
    data: XOR<FileStorageUpdateWithoutUploadInput, FileStorageUncheckedUpdateWithoutUploadInput>
  }

  export type FileStorageUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: StorageProviderUpdateOneRequiredWithoutFilesNestedInput
  }

  export type FileStorageUncheckedUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioUploadCreateWithoutProcessingJobsInput = {
    id?: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAudioUploadsInput
    workspace: WorkspaceCreateNestedOneWithoutAudioUploadsInput
    audioChunks?: AudioChunkCreateNestedManyWithoutUploadInput
    fileStorage?: FileStorageCreateNestedOneWithoutUploadInput
  }

  export type AudioUploadUncheckedCreateWithoutProcessingJobsInput = {
    id?: string
    userId: string
    workspaceId: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    audioChunks?: AudioChunkUncheckedCreateNestedManyWithoutUploadInput
    fileStorage?: FileStorageUncheckedCreateNestedOneWithoutUploadInput
  }

  export type AudioUploadCreateOrConnectWithoutProcessingJobsInput = {
    where: AudioUploadWhereUniqueInput
    create: XOR<AudioUploadCreateWithoutProcessingJobsInput, AudioUploadUncheckedCreateWithoutProcessingJobsInput>
  }

  export type AudioHistoryCreateWithoutProcessingJobInput = {
    id?: string
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAudioHistoryInput
    workspace?: WorkspaceCreateNestedOneWithoutAudioHistoryInput
    segments?: AudioSegmentCreateNestedManyWithoutAudioHistoryInput
  }

  export type AudioHistoryUncheckedCreateWithoutProcessingJobInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
    segments?: AudioSegmentUncheckedCreateNestedManyWithoutAudioHistoryInput
  }

  export type AudioHistoryCreateOrConnectWithoutProcessingJobInput = {
    where: AudioHistoryWhereUniqueInput
    create: XOR<AudioHistoryCreateWithoutProcessingJobInput, AudioHistoryUncheckedCreateWithoutProcessingJobInput>
  }

  export type AudioUploadUpsertWithoutProcessingJobsInput = {
    update: XOR<AudioUploadUpdateWithoutProcessingJobsInput, AudioUploadUncheckedUpdateWithoutProcessingJobsInput>
    create: XOR<AudioUploadCreateWithoutProcessingJobsInput, AudioUploadUncheckedCreateWithoutProcessingJobsInput>
    where?: AudioUploadWhereInput
  }

  export type AudioUploadUpdateToOneWithWhereWithoutProcessingJobsInput = {
    where?: AudioUploadWhereInput
    data: XOR<AudioUploadUpdateWithoutProcessingJobsInput, AudioUploadUncheckedUpdateWithoutProcessingJobsInput>
  }

  export type AudioUploadUpdateWithoutProcessingJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioUploadsNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutAudioUploadsNestedInput
    audioChunks?: AudioChunkUpdateManyWithoutUploadNestedInput
    fileStorage?: FileStorageUpdateOneWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateWithoutProcessingJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioChunks?: AudioChunkUncheckedUpdateManyWithoutUploadNestedInput
    fileStorage?: FileStorageUncheckedUpdateOneWithoutUploadNestedInput
  }

  export type AudioHistoryUpsertWithoutProcessingJobInput = {
    update: XOR<AudioHistoryUpdateWithoutProcessingJobInput, AudioHistoryUncheckedUpdateWithoutProcessingJobInput>
    create: XOR<AudioHistoryCreateWithoutProcessingJobInput, AudioHistoryUncheckedCreateWithoutProcessingJobInput>
    where?: AudioHistoryWhereInput
  }

  export type AudioHistoryUpdateToOneWithWhereWithoutProcessingJobInput = {
    where?: AudioHistoryWhereInput
    data: XOR<AudioHistoryUpdateWithoutProcessingJobInput, AudioHistoryUncheckedUpdateWithoutProcessingJobInput>
  }

  export type AudioHistoryUpdateWithoutProcessingJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioHistoryNestedInput
    workspace?: WorkspaceUpdateOneWithoutAudioHistoryNestedInput
    segments?: AudioSegmentUpdateManyWithoutAudioHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateWithoutProcessingJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segments?: AudioSegmentUncheckedUpdateManyWithoutAudioHistoryNestedInput
  }

  export type UserCreateWithoutAudioHistoryInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAudioHistoryInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAudioHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAudioHistoryInput, UserUncheckedCreateWithoutAudioHistoryInput>
  }

  export type WorkspaceCreateWithoutAudioHistoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldCreateNestedManyWithoutWorkspaceInput
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAudioHistoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAudioHistoryInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAudioHistoryInput, WorkspaceUncheckedCreateWithoutAudioHistoryInput>
  }

  export type ProcessingJobCreateWithoutAudioHistoryInput = {
    id?: string
    jobType: string
    status?: string
    priority?: number
    progress?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    upload: AudioUploadCreateNestedOneWithoutProcessingJobsInput
  }

  export type ProcessingJobUncheckedCreateWithoutAudioHistoryInput = {
    id?: string
    uploadId: string
    jobType: string
    status?: string
    priority?: number
    progress?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessingJobCreateOrConnectWithoutAudioHistoryInput = {
    where: ProcessingJobWhereUniqueInput
    create: XOR<ProcessingJobCreateWithoutAudioHistoryInput, ProcessingJobUncheckedCreateWithoutAudioHistoryInput>
  }

  export type AudioSegmentCreateWithoutAudioHistoryInput = {
    id?: string
    startTime: number
    endTime: number
    text: string
    speaker?: string | null
    confidence?: number | null
    keywords?: AudioSegmentCreatekeywordsInput | string[]
    sentiment?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAudioSegmentsInput
  }

  export type AudioSegmentUncheckedCreateWithoutAudioHistoryInput = {
    id?: string
    userId: string
    startTime: number
    endTime: number
    text: string
    speaker?: string | null
    confidence?: number | null
    keywords?: AudioSegmentCreatekeywordsInput | string[]
    sentiment?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AudioSegmentCreateOrConnectWithoutAudioHistoryInput = {
    where: AudioSegmentWhereUniqueInput
    create: XOR<AudioSegmentCreateWithoutAudioHistoryInput, AudioSegmentUncheckedCreateWithoutAudioHistoryInput>
  }

  export type AudioSegmentCreateManyAudioHistoryInputEnvelope = {
    data: AudioSegmentCreateManyAudioHistoryInput | AudioSegmentCreateManyAudioHistoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAudioHistoryInput = {
    update: XOR<UserUpdateWithoutAudioHistoryInput, UserUncheckedUpdateWithoutAudioHistoryInput>
    create: XOR<UserCreateWithoutAudioHistoryInput, UserUncheckedCreateWithoutAudioHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAudioHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAudioHistoryInput, UserUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type UserUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutAudioHistoryInput = {
    update: XOR<WorkspaceUpdateWithoutAudioHistoryInput, WorkspaceUncheckedUpdateWithoutAudioHistoryInput>
    create: XOR<WorkspaceCreateWithoutAudioHistoryInput, WorkspaceUncheckedCreateWithoutAudioHistoryInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAudioHistoryInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAudioHistoryInput, WorkspaceUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type WorkspaceUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ProcessingJobUpsertWithoutAudioHistoryInput = {
    update: XOR<ProcessingJobUpdateWithoutAudioHistoryInput, ProcessingJobUncheckedUpdateWithoutAudioHistoryInput>
    create: XOR<ProcessingJobCreateWithoutAudioHistoryInput, ProcessingJobUncheckedCreateWithoutAudioHistoryInput>
    where?: ProcessingJobWhereInput
  }

  export type ProcessingJobUpdateToOneWithWhereWithoutAudioHistoryInput = {
    where?: ProcessingJobWhereInput
    data: XOR<ProcessingJobUpdateWithoutAudioHistoryInput, ProcessingJobUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type ProcessingJobUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upload?: AudioUploadUpdateOneRequiredWithoutProcessingJobsNestedInput
  }

  export type ProcessingJobUncheckedUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioSegmentUpsertWithWhereUniqueWithoutAudioHistoryInput = {
    where: AudioSegmentWhereUniqueInput
    update: XOR<AudioSegmentUpdateWithoutAudioHistoryInput, AudioSegmentUncheckedUpdateWithoutAudioHistoryInput>
    create: XOR<AudioSegmentCreateWithoutAudioHistoryInput, AudioSegmentUncheckedCreateWithoutAudioHistoryInput>
  }

  export type AudioSegmentUpdateWithWhereUniqueWithoutAudioHistoryInput = {
    where: AudioSegmentWhereUniqueInput
    data: XOR<AudioSegmentUpdateWithoutAudioHistoryInput, AudioSegmentUncheckedUpdateWithoutAudioHistoryInput>
  }

  export type AudioSegmentUpdateManyWithWhereWithoutAudioHistoryInput = {
    where: AudioSegmentScalarWhereInput
    data: XOR<AudioSegmentUpdateManyMutationInput, AudioSegmentUncheckedUpdateManyWithoutAudioHistoryInput>
  }

  export type AudioHistoryCreateWithoutSegmentsInput = {
    id?: string
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAudioHistoryInput
    workspace?: WorkspaceCreateNestedOneWithoutAudioHistoryInput
    processingJob?: ProcessingJobCreateNestedOneWithoutAudioHistoryInput
  }

  export type AudioHistoryUncheckedCreateWithoutSegmentsInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    processingJobId?: string | null
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
  }

  export type AudioHistoryCreateOrConnectWithoutSegmentsInput = {
    where: AudioHistoryWhereUniqueInput
    create: XOR<AudioHistoryCreateWithoutSegmentsInput, AudioHistoryUncheckedCreateWithoutSegmentsInput>
  }

  export type UserCreateWithoutAudioSegmentsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAudioSegmentsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAudioSegmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAudioSegmentsInput, UserUncheckedCreateWithoutAudioSegmentsInput>
  }

  export type AudioHistoryUpsertWithoutSegmentsInput = {
    update: XOR<AudioHistoryUpdateWithoutSegmentsInput, AudioHistoryUncheckedUpdateWithoutSegmentsInput>
    create: XOR<AudioHistoryCreateWithoutSegmentsInput, AudioHistoryUncheckedCreateWithoutSegmentsInput>
    where?: AudioHistoryWhereInput
  }

  export type AudioHistoryUpdateToOneWithWhereWithoutSegmentsInput = {
    where?: AudioHistoryWhereInput
    data: XOR<AudioHistoryUpdateWithoutSegmentsInput, AudioHistoryUncheckedUpdateWithoutSegmentsInput>
  }

  export type AudioHistoryUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioHistoryNestedInput
    workspace?: WorkspaceUpdateOneWithoutAudioHistoryNestedInput
    processingJob?: ProcessingJobUpdateOneWithoutAudioHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    processingJobId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAudioSegmentsInput = {
    update: XOR<UserUpdateWithoutAudioSegmentsInput, UserUncheckedUpdateWithoutAudioSegmentsInput>
    create: XOR<UserCreateWithoutAudioSegmentsInput, UserUncheckedCreateWithoutAudioSegmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAudioSegmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAudioSegmentsInput, UserUncheckedUpdateWithoutAudioSegmentsInput>
  }

  export type UserUpdateWithoutAudioSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAudioSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AudioUploadCreateWithoutAudioChunksInput = {
    id?: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAudioUploadsInput
    workspace: WorkspaceCreateNestedOneWithoutAudioUploadsInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUploadInput
    fileStorage?: FileStorageCreateNestedOneWithoutUploadInput
  }

  export type AudioUploadUncheckedCreateWithoutAudioChunksInput = {
    id?: string
    userId: string
    workspaceId: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUploadInput
    fileStorage?: FileStorageUncheckedCreateNestedOneWithoutUploadInput
  }

  export type AudioUploadCreateOrConnectWithoutAudioChunksInput = {
    where: AudioUploadWhereUniqueInput
    create: XOR<AudioUploadCreateWithoutAudioChunksInput, AudioUploadUncheckedCreateWithoutAudioChunksInput>
  }

  export type AudioUploadUpsertWithoutAudioChunksInput = {
    update: XOR<AudioUploadUpdateWithoutAudioChunksInput, AudioUploadUncheckedUpdateWithoutAudioChunksInput>
    create: XOR<AudioUploadCreateWithoutAudioChunksInput, AudioUploadUncheckedCreateWithoutAudioChunksInput>
    where?: AudioUploadWhereInput
  }

  export type AudioUploadUpdateToOneWithWhereWithoutAudioChunksInput = {
    where?: AudioUploadWhereInput
    data: XOR<AudioUploadUpdateWithoutAudioChunksInput, AudioUploadUncheckedUpdateWithoutAudioChunksInput>
  }

  export type AudioUploadUpdateWithoutAudioChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioUploadsNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutAudioUploadsNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUploadNestedInput
    fileStorage?: FileStorageUpdateOneWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateWithoutAudioChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUploadNestedInput
    fileStorage?: FileStorageUncheckedUpdateOneWithoutUploadNestedInput
  }

  export type FileStorageCreateWithoutProviderInput = {
    id?: string
    storageKey: string
    fileName: string
    fileSize: bigint | number
    mimeType: string
    checksum: string
    publicUrl?: string | null
    cdnUrl?: string | null
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastAccessedAt?: Date | string | null
    upload: AudioUploadCreateNestedOneWithoutFileStorageInput
  }

  export type FileStorageUncheckedCreateWithoutProviderInput = {
    id?: string
    uploadId: string
    storageKey: string
    fileName: string
    fileSize: bigint | number
    mimeType: string
    checksum: string
    publicUrl?: string | null
    cdnUrl?: string | null
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastAccessedAt?: Date | string | null
  }

  export type FileStorageCreateOrConnectWithoutProviderInput = {
    where: FileStorageWhereUniqueInput
    create: XOR<FileStorageCreateWithoutProviderInput, FileStorageUncheckedCreateWithoutProviderInput>
  }

  export type FileStorageCreateManyProviderInputEnvelope = {
    data: FileStorageCreateManyProviderInput | FileStorageCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type FileStorageUpsertWithWhereUniqueWithoutProviderInput = {
    where: FileStorageWhereUniqueInput
    update: XOR<FileStorageUpdateWithoutProviderInput, FileStorageUncheckedUpdateWithoutProviderInput>
    create: XOR<FileStorageCreateWithoutProviderInput, FileStorageUncheckedCreateWithoutProviderInput>
  }

  export type FileStorageUpdateWithWhereUniqueWithoutProviderInput = {
    where: FileStorageWhereUniqueInput
    data: XOR<FileStorageUpdateWithoutProviderInput, FileStorageUncheckedUpdateWithoutProviderInput>
  }

  export type FileStorageUpdateManyWithWhereWithoutProviderInput = {
    where: FileStorageScalarWhereInput
    data: XOR<FileStorageUpdateManyMutationInput, FileStorageUncheckedUpdateManyWithoutProviderInput>
  }

  export type FileStorageScalarWhereInput = {
    AND?: FileStorageScalarWhereInput | FileStorageScalarWhereInput[]
    OR?: FileStorageScalarWhereInput[]
    NOT?: FileStorageScalarWhereInput | FileStorageScalarWhereInput[]
    id?: StringFilter<"FileStorage"> | string
    uploadId?: StringFilter<"FileStorage"> | string
    providerId?: StringFilter<"FileStorage"> | string
    storageKey?: StringFilter<"FileStorage"> | string
    fileName?: StringFilter<"FileStorage"> | string
    fileSize?: BigIntFilter<"FileStorage"> | bigint | number
    mimeType?: StringFilter<"FileStorage"> | string
    checksum?: StringFilter<"FileStorage"> | string
    publicUrl?: StringNullableFilter<"FileStorage"> | string | null
    cdnUrl?: StringNullableFilter<"FileStorage"> | string | null
    expiresAt?: DateTimeNullableFilter<"FileStorage"> | Date | string | null
    metadata?: JsonFilter<"FileStorage">
    createdAt?: DateTimeFilter<"FileStorage"> | Date | string
    lastAccessedAt?: DateTimeNullableFilter<"FileStorage"> | Date | string | null
  }

  export type StorageProviderCreateWithoutFilesInput = {
    id?: string
    name: string
    type: string
    endpoint?: string | null
    region?: string | null
    bucket?: string | null
    cdnEndpoint?: string | null
    isActive?: boolean
    isDefault?: boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageProviderUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    type: string
    endpoint?: string | null
    region?: string | null
    bucket?: string | null
    cdnEndpoint?: string | null
    isActive?: boolean
    isDefault?: boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageProviderCreateOrConnectWithoutFilesInput = {
    where: StorageProviderWhereUniqueInput
    create: XOR<StorageProviderCreateWithoutFilesInput, StorageProviderUncheckedCreateWithoutFilesInput>
  }

  export type AudioUploadCreateWithoutFileStorageInput = {
    id?: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAudioUploadsInput
    workspace: WorkspaceCreateNestedOneWithoutAudioUploadsInput
    processingJobs?: ProcessingJobCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadUncheckedCreateWithoutFileStorageInput = {
    id?: string
    userId: string
    workspaceId: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    processingJobs?: ProcessingJobUncheckedCreateNestedManyWithoutUploadInput
    audioChunks?: AudioChunkUncheckedCreateNestedManyWithoutUploadInput
  }

  export type AudioUploadCreateOrConnectWithoutFileStorageInput = {
    where: AudioUploadWhereUniqueInput
    create: XOR<AudioUploadCreateWithoutFileStorageInput, AudioUploadUncheckedCreateWithoutFileStorageInput>
  }

  export type StorageProviderUpsertWithoutFilesInput = {
    update: XOR<StorageProviderUpdateWithoutFilesInput, StorageProviderUncheckedUpdateWithoutFilesInput>
    create: XOR<StorageProviderCreateWithoutFilesInput, StorageProviderUncheckedCreateWithoutFilesInput>
    where?: StorageProviderWhereInput
  }

  export type StorageProviderUpdateToOneWithWhereWithoutFilesInput = {
    where?: StorageProviderWhereInput
    data: XOR<StorageProviderUpdateWithoutFilesInput, StorageProviderUncheckedUpdateWithoutFilesInput>
  }

  export type StorageProviderUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    cdnEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageProviderUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    cdnEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioUploadUpsertWithoutFileStorageInput = {
    update: XOR<AudioUploadUpdateWithoutFileStorageInput, AudioUploadUncheckedUpdateWithoutFileStorageInput>
    create: XOR<AudioUploadCreateWithoutFileStorageInput, AudioUploadUncheckedCreateWithoutFileStorageInput>
    where?: AudioUploadWhereInput
  }

  export type AudioUploadUpdateToOneWithWhereWithoutFileStorageInput = {
    where?: AudioUploadWhereInput
    data: XOR<AudioUploadUpdateWithoutFileStorageInput, AudioUploadUncheckedUpdateWithoutFileStorageInput>
  }

  export type AudioUploadUpdateWithoutFileStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioUploadsNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutAudioUploadsNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUpdateManyWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateWithoutFileStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUncheckedUpdateManyWithoutUploadNestedInput
  }

  export type WorkspaceSubscriptionCreateWithoutPlanInput = {
    id?: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionsInput
    billingRecords?: BillingRecordCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    workspaceId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    billingRecords?: BillingRecordUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionCreateOrConnectWithoutPlanInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    create: XOR<WorkspaceSubscriptionCreateWithoutPlanInput, WorkspaceSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type WorkspaceSubscriptionCreateManyPlanInputEnvelope = {
    data: WorkspaceSubscriptionCreateManyPlanInput | WorkspaceSubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanPricingCreateWithoutPlanInput = {
    id?: string
    currency?: string
    price: Decimal | DecimalJsLike | number | string
    interval: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPricingUncheckedCreateWithoutPlanInput = {
    id?: string
    currency?: string
    price: Decimal | DecimalJsLike | number | string
    interval: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPricingCreateOrConnectWithoutPlanInput = {
    where: PlanPricingWhereUniqueInput
    create: XOR<PlanPricingCreateWithoutPlanInput, PlanPricingUncheckedCreateWithoutPlanInput>
  }

  export type PlanPricingCreateManyPlanInputEnvelope = {
    data: PlanPricingCreateManyPlanInput | PlanPricingCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceSubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    update: XOR<WorkspaceSubscriptionUpdateWithoutPlanInput, WorkspaceSubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<WorkspaceSubscriptionCreateWithoutPlanInput, WorkspaceSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type WorkspaceSubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    data: XOR<WorkspaceSubscriptionUpdateWithoutPlanInput, WorkspaceSubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type WorkspaceSubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: WorkspaceSubscriptionScalarWhereInput
    data: XOR<WorkspaceSubscriptionUpdateManyMutationInput, WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanPricingUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanPricingWhereUniqueInput
    update: XOR<PlanPricingUpdateWithoutPlanInput, PlanPricingUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanPricingCreateWithoutPlanInput, PlanPricingUncheckedCreateWithoutPlanInput>
  }

  export type PlanPricingUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanPricingWhereUniqueInput
    data: XOR<PlanPricingUpdateWithoutPlanInput, PlanPricingUncheckedUpdateWithoutPlanInput>
  }

  export type PlanPricingUpdateManyWithWhereWithoutPlanInput = {
    where: PlanPricingScalarWhereInput
    data: XOR<PlanPricingUpdateManyMutationInput, PlanPricingUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanPricingScalarWhereInput = {
    AND?: PlanPricingScalarWhereInput | PlanPricingScalarWhereInput[]
    OR?: PlanPricingScalarWhereInput[]
    NOT?: PlanPricingScalarWhereInput | PlanPricingScalarWhereInput[]
    id?: StringFilter<"PlanPricing"> | string
    planId?: StringFilter<"PlanPricing"> | string
    currency?: StringFilter<"PlanPricing"> | string
    price?: DecimalFilter<"PlanPricing"> | Decimal | DecimalJsLike | number | string
    interval?: StringFilter<"PlanPricing"> | string
    isActive?: BoolFilter<"PlanPricing"> | boolean
    createdAt?: DateTimeFilter<"PlanPricing"> | Date | string
    updatedAt?: DateTimeFilter<"PlanPricing"> | Date | string
  }

  export type WorkspaceCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldCreateNestedManyWithoutWorkspaceInput
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutSubscriptionsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutSubscriptionsInput, WorkspaceUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    tier: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingPeriod: string
    features: JsonNullValueInput | InputJsonValue
    quotas: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublic?: boolean
    trialDays?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    planPricing?: PlanPricingCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    tier: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingPeriod: string
    features: JsonNullValueInput | InputJsonValue
    quotas: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublic?: boolean
    trialDays?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    planPricing?: PlanPricingUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type BillingRecordCreateWithoutSubscriptionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: string
    invoiceNumber?: string | null
    invoiceUrl?: string | null
    paymentMethod?: string | null
    paymentIntentId?: string | null
    failureReason?: string | null
    paidAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingRecordUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: string
    invoiceNumber?: string | null
    invoiceUrl?: string | null
    paymentMethod?: string | null
    paymentIntentId?: string | null
    failureReason?: string | null
    paidAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingRecordCreateOrConnectWithoutSubscriptionInput = {
    where: BillingRecordWhereUniqueInput
    create: XOR<BillingRecordCreateWithoutSubscriptionInput, BillingRecordUncheckedCreateWithoutSubscriptionInput>
  }

  export type BillingRecordCreateManySubscriptionInputEnvelope = {
    data: BillingRecordCreateManySubscriptionInput | BillingRecordCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UsageRecordCreateWithoutSubscriptionInput = {
    id?: string
    recordType: string
    quantity: bigint | number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageRecordUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    recordType: string
    quantity: bigint | number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageRecordCreateOrConnectWithoutSubscriptionInput = {
    where: UsageRecordWhereUniqueInput
    create: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput>
  }

  export type UsageRecordCreateManySubscriptionInputEnvelope = {
    data: UsageRecordCreateManySubscriptionInput | UsageRecordCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutSubscriptionsInput = {
    update: XOR<WorkspaceUpdateWithoutSubscriptionsInput, WorkspaceUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<WorkspaceCreateWithoutSubscriptionsInput, WorkspaceUncheckedCreateWithoutSubscriptionsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutSubscriptionsInput, WorkspaceUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type WorkspaceUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type SubscriptionPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    quotas?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    trialDays?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planPricing?: PlanPricingUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    quotas?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    trialDays?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planPricing?: PlanPricingUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type BillingRecordUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: BillingRecordWhereUniqueInput
    update: XOR<BillingRecordUpdateWithoutSubscriptionInput, BillingRecordUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<BillingRecordCreateWithoutSubscriptionInput, BillingRecordUncheckedCreateWithoutSubscriptionInput>
  }

  export type BillingRecordUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: BillingRecordWhereUniqueInput
    data: XOR<BillingRecordUpdateWithoutSubscriptionInput, BillingRecordUncheckedUpdateWithoutSubscriptionInput>
  }

  export type BillingRecordUpdateManyWithWhereWithoutSubscriptionInput = {
    where: BillingRecordScalarWhereInput
    data: XOR<BillingRecordUpdateManyMutationInput, BillingRecordUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type BillingRecordScalarWhereInput = {
    AND?: BillingRecordScalarWhereInput | BillingRecordScalarWhereInput[]
    OR?: BillingRecordScalarWhereInput[]
    NOT?: BillingRecordScalarWhereInput | BillingRecordScalarWhereInput[]
    id?: StringFilter<"BillingRecord"> | string
    subscriptionId?: StringFilter<"BillingRecord"> | string
    amount?: DecimalFilter<"BillingRecord"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"BillingRecord"> | string
    status?: StringFilter<"BillingRecord"> | string
    invoiceNumber?: StringNullableFilter<"BillingRecord"> | string | null
    invoiceUrl?: StringNullableFilter<"BillingRecord"> | string | null
    paymentMethod?: StringNullableFilter<"BillingRecord"> | string | null
    paymentIntentId?: StringNullableFilter<"BillingRecord"> | string | null
    failureReason?: StringNullableFilter<"BillingRecord"> | string | null
    paidAt?: DateTimeNullableFilter<"BillingRecord"> | Date | string | null
    metadata?: JsonFilter<"BillingRecord">
    createdAt?: DateTimeFilter<"BillingRecord"> | Date | string
  }

  export type UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: UsageRecordWhereUniqueInput
    update: XOR<UsageRecordUpdateWithoutSubscriptionInput, UsageRecordUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput>
  }

  export type UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: UsageRecordWhereUniqueInput
    data: XOR<UsageRecordUpdateWithoutSubscriptionInput, UsageRecordUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UsageRecordUpdateManyWithWhereWithoutSubscriptionInput = {
    where: UsageRecordScalarWhereInput
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UsageRecordScalarWhereInput = {
    AND?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
    OR?: UsageRecordScalarWhereInput[]
    NOT?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
    id?: StringFilter<"UsageRecord"> | string
    subscriptionId?: StringFilter<"UsageRecord"> | string
    recordType?: StringFilter<"UsageRecord"> | string
    quantity?: BigIntFilter<"UsageRecord"> | bigint | number
    unitPrice?: DecimalNullableFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"UsageRecord"> | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFilter<"UsageRecord"> | Date | string
    periodEnd?: DateTimeFilter<"UsageRecord"> | Date | string
    metadata?: JsonFilter<"UsageRecord">
    createdAt?: DateTimeFilter<"UsageRecord"> | Date | string
  }

  export type WorkspaceSubscriptionCreateWithoutBillingRecordsInput = {
    id?: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionUncheckedCreateWithoutBillingRecordsInput = {
    id?: string
    workspaceId: string
    planId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionCreateOrConnectWithoutBillingRecordsInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    create: XOR<WorkspaceSubscriptionCreateWithoutBillingRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutBillingRecordsInput>
  }

  export type WorkspaceSubscriptionUpsertWithoutBillingRecordsInput = {
    update: XOR<WorkspaceSubscriptionUpdateWithoutBillingRecordsInput, WorkspaceSubscriptionUncheckedUpdateWithoutBillingRecordsInput>
    create: XOR<WorkspaceSubscriptionCreateWithoutBillingRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutBillingRecordsInput>
    where?: WorkspaceSubscriptionWhereInput
  }

  export type WorkspaceSubscriptionUpdateToOneWithWhereWithoutBillingRecordsInput = {
    where?: WorkspaceSubscriptionWhereInput
    data: XOR<WorkspaceSubscriptionUpdateWithoutBillingRecordsInput, WorkspaceSubscriptionUncheckedUpdateWithoutBillingRecordsInput>
  }

  export type WorkspaceSubscriptionUpdateWithoutBillingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateWithoutBillingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type UserCreateWithoutApiKeysInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type ApiKeyUsageLogCreateWithoutApiKeyInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ApiKeyUsageLogUncheckedCreateWithoutApiKeyInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ApiKeyUsageLogCreateOrConnectWithoutApiKeyInput = {
    where: ApiKeyUsageLogWhereUniqueInput
    create: XOR<ApiKeyUsageLogCreateWithoutApiKeyInput, ApiKeyUsageLogUncheckedCreateWithoutApiKeyInput>
  }

  export type ApiKeyUsageLogCreateManyApiKeyInputEnvelope = {
    data: ApiKeyUsageLogCreateManyApiKeyInput | ApiKeyUsageLogCreateManyApiKeyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ApiKeyUsageLogUpsertWithWhereUniqueWithoutApiKeyInput = {
    where: ApiKeyUsageLogWhereUniqueInput
    update: XOR<ApiKeyUsageLogUpdateWithoutApiKeyInput, ApiKeyUsageLogUncheckedUpdateWithoutApiKeyInput>
    create: XOR<ApiKeyUsageLogCreateWithoutApiKeyInput, ApiKeyUsageLogUncheckedCreateWithoutApiKeyInput>
  }

  export type ApiKeyUsageLogUpdateWithWhereUniqueWithoutApiKeyInput = {
    where: ApiKeyUsageLogWhereUniqueInput
    data: XOR<ApiKeyUsageLogUpdateWithoutApiKeyInput, ApiKeyUsageLogUncheckedUpdateWithoutApiKeyInput>
  }

  export type ApiKeyUsageLogUpdateManyWithWhereWithoutApiKeyInput = {
    where: ApiKeyUsageLogScalarWhereInput
    data: XOR<ApiKeyUsageLogUpdateManyMutationInput, ApiKeyUsageLogUncheckedUpdateManyWithoutApiKeyInput>
  }

  export type ApiKeyUsageLogScalarWhereInput = {
    AND?: ApiKeyUsageLogScalarWhereInput | ApiKeyUsageLogScalarWhereInput[]
    OR?: ApiKeyUsageLogScalarWhereInput[]
    NOT?: ApiKeyUsageLogScalarWhereInput | ApiKeyUsageLogScalarWhereInput[]
    id?: StringFilter<"ApiKeyUsageLog"> | string
    apiKeyId?: StringFilter<"ApiKeyUsageLog"> | string
    endpoint?: StringFilter<"ApiKeyUsageLog"> | string
    method?: StringFilter<"ApiKeyUsageLog"> | string
    statusCode?: IntFilter<"ApiKeyUsageLog"> | number
    responseTime?: IntFilter<"ApiKeyUsageLog"> | number
    tokensUsed?: IntNullableFilter<"ApiKeyUsageLog"> | number | null
    cost?: DecimalNullableFilter<"ApiKeyUsageLog"> | Decimal | DecimalJsLike | number | string | null
    error?: StringNullableFilter<"ApiKeyUsageLog"> | string | null
    metadata?: JsonFilter<"ApiKeyUsageLog">
    createdAt?: DateTimeFilter<"ApiKeyUsageLog"> | Date | string
  }

  export type ApiKeyManagementCreateWithoutUsageLogsInput = {
    id?: string
    provider: string
    keyHash: string
    keyPrefix: string
    encryptedKey: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    usageCount?: number
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyManagementUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    userId: string
    provider: string
    keyHash: string
    keyPrefix: string
    encryptedKey: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    usageCount?: number
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyManagementCreateOrConnectWithoutUsageLogsInput = {
    where: ApiKeyManagementWhereUniqueInput
    create: XOR<ApiKeyManagementCreateWithoutUsageLogsInput, ApiKeyManagementUncheckedCreateWithoutUsageLogsInput>
  }

  export type ApiKeyManagementUpsertWithoutUsageLogsInput = {
    update: XOR<ApiKeyManagementUpdateWithoutUsageLogsInput, ApiKeyManagementUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<ApiKeyManagementCreateWithoutUsageLogsInput, ApiKeyManagementUncheckedCreateWithoutUsageLogsInput>
    where?: ApiKeyManagementWhereInput
  }

  export type ApiKeyManagementUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: ApiKeyManagementWhereInput
    data: XOR<ApiKeyManagementUpdateWithoutUsageLogsInput, ApiKeyManagementUncheckedUpdateWithoutUsageLogsInput>
  }

  export type ApiKeyManagementUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyManagementUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSettingsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpsertWithoutSettingsInput = {
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutQuotaUsageInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuotaUsageInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuotaUsageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuotaUsageInput, UserUncheckedCreateWithoutQuotaUsageInput>
  }

  export type UserUpsertWithoutQuotaUsageInput = {
    update: XOR<UserUpdateWithoutQuotaUsageInput, UserUncheckedUpdateWithoutQuotaUsageInput>
    create: XOR<UserCreateWithoutQuotaUsageInput, UserUncheckedCreateWithoutQuotaUsageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuotaUsageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuotaUsageInput, UserUncheckedUpdateWithoutQuotaUsageInput>
  }

  export type UserUpdateWithoutQuotaUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuotaUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutStorageQuotasInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldCreateNestedManyWithoutWorkspaceInput
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutStorageQuotasInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutStorageQuotasInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutStorageQuotasInput, WorkspaceUncheckedCreateWithoutStorageQuotasInput>
  }

  export type WorkspaceUpsertWithoutStorageQuotasInput = {
    update: XOR<WorkspaceUpdateWithoutStorageQuotasInput, WorkspaceUncheckedUpdateWithoutStorageQuotasInput>
    create: XOR<WorkspaceCreateWithoutStorageQuotasInput, WorkspaceUncheckedCreateWithoutStorageQuotasInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutStorageQuotasInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutStorageQuotasInput, WorkspaceUncheckedUpdateWithoutStorageQuotasInput>
  }

  export type WorkspaceUpdateWithoutStorageQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutStorageQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceSubscriptionCreateWithoutUsageRecordsInput = {
    id?: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    billingRecords?: BillingRecordCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionUncheckedCreateWithoutUsageRecordsInput = {
    id?: string
    workspaceId: string
    planId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    billingRecords?: BillingRecordUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type WorkspaceSubscriptionCreateOrConnectWithoutUsageRecordsInput = {
    where: WorkspaceSubscriptionWhereUniqueInput
    create: XOR<WorkspaceSubscriptionCreateWithoutUsageRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutUsageRecordsInput>
  }

  export type WorkspaceSubscriptionUpsertWithoutUsageRecordsInput = {
    update: XOR<WorkspaceSubscriptionUpdateWithoutUsageRecordsInput, WorkspaceSubscriptionUncheckedUpdateWithoutUsageRecordsInput>
    create: XOR<WorkspaceSubscriptionCreateWithoutUsageRecordsInput, WorkspaceSubscriptionUncheckedCreateWithoutUsageRecordsInput>
    where?: WorkspaceSubscriptionWhereInput
  }

  export type WorkspaceSubscriptionUpdateToOneWithWhereWithoutUsageRecordsInput = {
    where?: WorkspaceSubscriptionWhereInput
    data: XOR<WorkspaceSubscriptionUpdateWithoutUsageRecordsInput, WorkspaceSubscriptionUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type WorkspaceSubscriptionUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    billingRecords?: BillingRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingRecords?: BillingRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSecurityEventsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSecurityEventsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSecurityEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSecurityEventsInput, UserUncheckedCreateWithoutSecurityEventsInput>
  }

  export type UserUpsertWithoutSecurityEventsInput = {
    update: XOR<UserUpdateWithoutSecurityEventsInput, UserUncheckedUpdateWithoutSecurityEventsInput>
    create: XOR<UserCreateWithoutSecurityEventsInput, UserUncheckedCreateWithoutSecurityEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSecurityEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSecurityEventsInput, UserUncheckedUpdateWithoutSecurityEventsInput>
  }

  export type UserUpdateWithoutSecurityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSecurityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailLogCreateWithoutTemplateInput = {
    id?: string
    recipientEmail: string
    subject: string
    status: string
    provider: string
    providerMessageId?: string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailLogUncheckedCreateWithoutTemplateInput = {
    id?: string
    recipientEmail: string
    subject: string
    status: string
    provider: string
    providerMessageId?: string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailLogCreateOrConnectWithoutTemplateInput = {
    where: EmailLogWhereUniqueInput
    create: XOR<EmailLogCreateWithoutTemplateInput, EmailLogUncheckedCreateWithoutTemplateInput>
  }

  export type EmailLogCreateManyTemplateInputEnvelope = {
    data: EmailLogCreateManyTemplateInput | EmailLogCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type EmailLogUpsertWithWhereUniqueWithoutTemplateInput = {
    where: EmailLogWhereUniqueInput
    update: XOR<EmailLogUpdateWithoutTemplateInput, EmailLogUncheckedUpdateWithoutTemplateInput>
    create: XOR<EmailLogCreateWithoutTemplateInput, EmailLogUncheckedCreateWithoutTemplateInput>
  }

  export type EmailLogUpdateWithWhereUniqueWithoutTemplateInput = {
    where: EmailLogWhereUniqueInput
    data: XOR<EmailLogUpdateWithoutTemplateInput, EmailLogUncheckedUpdateWithoutTemplateInput>
  }

  export type EmailLogUpdateManyWithWhereWithoutTemplateInput = {
    where: EmailLogScalarWhereInput
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyWithoutTemplateInput>
  }

  export type EmailLogScalarWhereInput = {
    AND?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
    OR?: EmailLogScalarWhereInput[]
    NOT?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
    id?: StringFilter<"EmailLog"> | string
    templateId?: StringNullableFilter<"EmailLog"> | string | null
    recipientEmail?: StringFilter<"EmailLog"> | string
    subject?: StringFilter<"EmailLog"> | string
    status?: StringFilter<"EmailLog"> | string
    provider?: StringFilter<"EmailLog"> | string
    providerMessageId?: StringNullableFilter<"EmailLog"> | string | null
    openedAt?: DateTimeNullableFilter<"EmailLog"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"EmailLog"> | Date | string | null
    error?: StringNullableFilter<"EmailLog"> | string | null
    metadata?: JsonFilter<"EmailLog">
    createdAt?: DateTimeFilter<"EmailLog"> | Date | string
  }

  export type EmailTemplateCreateWithoutEmailLogsInput = {
    id?: string
    name: string
    subject: string
    htmlContent: string
    textContent: string
    variables: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUncheckedCreateWithoutEmailLogsInput = {
    id?: string
    name: string
    subject: string
    htmlContent: string
    textContent: string
    variables: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateCreateOrConnectWithoutEmailLogsInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutEmailLogsInput, EmailTemplateUncheckedCreateWithoutEmailLogsInput>
  }

  export type EmailTemplateUpsertWithoutEmailLogsInput = {
    update: XOR<EmailTemplateUpdateWithoutEmailLogsInput, EmailTemplateUncheckedUpdateWithoutEmailLogsInput>
    create: XOR<EmailTemplateCreateWithoutEmailLogsInput, EmailTemplateUncheckedCreateWithoutEmailLogsInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutEmailLogsInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutEmailLogsInput, EmailTemplateUncheckedUpdateWithoutEmailLogsInput>
  }

  export type EmailTemplateUpdateWithoutEmailLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    textContent?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateWithoutEmailLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    textContent?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutEmailPreferencesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailPreferencesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
    aiTokenUsage?: AiTokenUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailPreferencesInput, UserUncheckedCreateWithoutEmailPreferencesInput>
  }

  export type UserUpsertWithoutEmailPreferencesInput = {
    update: XOR<UserUpdateWithoutEmailPreferencesInput, UserUncheckedUpdateWithoutEmailPreferencesInput>
    create: XOR<UserCreateWithoutEmailPreferencesInput, UserUncheckedCreateWithoutEmailPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailPreferencesInput, UserUncheckedUpdateWithoutEmailPreferencesInput>
  }

  export type UserUpdateWithoutEmailPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
    aiTokenUsage?: AiTokenUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutIntegrationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldCreateNestedManyWithoutWorkspaceInput
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutIntegrationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutIntegrationsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutIntegrationsInput, WorkspaceUncheckedCreateWithoutIntegrationsInput>
  }

  export type WorkspaceUpsertWithoutIntegrationsInput = {
    update: XOR<WorkspaceUpdateWithoutIntegrationsInput, WorkspaceUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<WorkspaceCreateWithoutIntegrationsInput, WorkspaceUncheckedCreateWithoutIntegrationsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutIntegrationsInput, WorkspaceUncheckedUpdateWithoutIntegrationsInput>
  }

  export type WorkspaceUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutAutomationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldCreateNestedManyWithoutWorkspaceInput
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAutomationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAutomationsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAutomationsInput, WorkspaceUncheckedCreateWithoutAutomationsInput>
  }

  export type WorkspaceUpsertWithoutAutomationsInput = {
    update: XOR<WorkspaceUpdateWithoutAutomationsInput, WorkspaceUncheckedUpdateWithoutAutomationsInput>
    create: XOR<WorkspaceCreateWithoutAutomationsInput, WorkspaceUncheckedCreateWithoutAutomationsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAutomationsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAutomationsInput, WorkspaceUncheckedUpdateWithoutAutomationsInput>
  }

  export type WorkspaceUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutWebhooksInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldCreateNestedManyWithoutWorkspaceInput
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutWebhooksInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutWebhooksInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutWebhooksInput, WorkspaceUncheckedCreateWithoutWebhooksInput>
  }

  export type WorkspaceUpsertWithoutWebhooksInput = {
    update: XOR<WorkspaceUpdateWithoutWebhooksInput, WorkspaceUncheckedUpdateWithoutWebhooksInput>
    create: XOR<WorkspaceCreateWithoutWebhooksInput, WorkspaceUncheckedCreateWithoutWebhooksInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutWebhooksInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutWebhooksInput, WorkspaceUncheckedUpdateWithoutWebhooksInput>
  }

  export type WorkspaceUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutCustomFieldsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookCreateNestedManyWithoutWorkspaceInput
    tags?: TagCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutCustomFieldsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutWorkspaceInput
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutCustomFieldsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutCustomFieldsInput, WorkspaceUncheckedCreateWithoutCustomFieldsInput>
  }

  export type WorkspaceUpsertWithoutCustomFieldsInput = {
    update: XOR<WorkspaceUpdateWithoutCustomFieldsInput, WorkspaceUncheckedUpdateWithoutCustomFieldsInput>
    create: XOR<WorkspaceCreateWithoutCustomFieldsInput, WorkspaceUncheckedCreateWithoutCustomFieldsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutCustomFieldsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutCustomFieldsInput, WorkspaceUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type WorkspaceUpdateWithoutCustomFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutCustomFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutTagsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutTagsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutTagsInput, WorkspaceUncheckedCreateWithoutTagsInput>
  }

  export type WorkspaceUpsertWithoutTagsInput = {
    update: XOR<WorkspaceUpdateWithoutTagsInput, WorkspaceUncheckedUpdateWithoutTagsInput>
    create: XOR<WorkspaceCreateWithoutTagsInput, WorkspaceUncheckedCreateWithoutTagsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutTagsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutTagsInput, WorkspaceUncheckedUpdateWithoutTagsInput>
  }

  export type WorkspaceUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutAiAgentsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldCreateNestedManyWithoutWorkspaceInput
    tags?: TagCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAiAgentsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logo?: string | null
    website?: string | null
    industry?: string | null
    size?: string | null
    isActive?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutWorkspaceInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutWorkspaceInput
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
    storageQuotas?: StorageQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspaceInput
    automations?: WorkspaceAutomationUncheckedCreateNestedManyWithoutWorkspaceInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutWorkspaceInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutWorkspaceInput
    tags?: TagUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAiAgentsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAiAgentsInput, WorkspaceUncheckedCreateWithoutAiAgentsInput>
  }

  export type AiConversationCreateWithoutAgentInput = {
    id?: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: AiMessageCreateNestedManyWithoutConversationInput
  }

  export type AiConversationUncheckedCreateWithoutAgentInput = {
    id?: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: AiMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type AiConversationCreateOrConnectWithoutAgentInput = {
    where: AiConversationWhereUniqueInput
    create: XOR<AiConversationCreateWithoutAgentInput, AiConversationUncheckedCreateWithoutAgentInput>
  }

  export type AiConversationCreateManyAgentInputEnvelope = {
    data: AiConversationCreateManyAgentInput | AiConversationCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutAiAgentsInput = {
    update: XOR<WorkspaceUpdateWithoutAiAgentsInput, WorkspaceUncheckedUpdateWithoutAiAgentsInput>
    create: XOR<WorkspaceCreateWithoutAiAgentsInput, WorkspaceUncheckedCreateWithoutAiAgentsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAiAgentsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAiAgentsInput, WorkspaceUncheckedUpdateWithoutAiAgentsInput>
  }

  export type WorkspaceUpdateWithoutAiAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAiAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutWorkspaceNestedInput
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceNestedInput
    storageQuotas?: StorageQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspaceNestedInput
    automations?: WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutWorkspaceNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutWorkspaceNestedInput
    tags?: TagUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type AiConversationUpsertWithWhereUniqueWithoutAgentInput = {
    where: AiConversationWhereUniqueInput
    update: XOR<AiConversationUpdateWithoutAgentInput, AiConversationUncheckedUpdateWithoutAgentInput>
    create: XOR<AiConversationCreateWithoutAgentInput, AiConversationUncheckedCreateWithoutAgentInput>
  }

  export type AiConversationUpdateWithWhereUniqueWithoutAgentInput = {
    where: AiConversationWhereUniqueInput
    data: XOR<AiConversationUpdateWithoutAgentInput, AiConversationUncheckedUpdateWithoutAgentInput>
  }

  export type AiConversationUpdateManyWithWhereWithoutAgentInput = {
    where: AiConversationScalarWhereInput
    data: XOR<AiConversationUpdateManyMutationInput, AiConversationUncheckedUpdateManyWithoutAgentInput>
  }

  export type AiConversationScalarWhereInput = {
    AND?: AiConversationScalarWhereInput | AiConversationScalarWhereInput[]
    OR?: AiConversationScalarWhereInput[]
    NOT?: AiConversationScalarWhereInput | AiConversationScalarWhereInput[]
    id?: StringFilter<"AiConversation"> | string
    agentId?: StringFilter<"AiConversation"> | string
    userId?: StringFilter<"AiConversation"> | string
    title?: StringNullableFilter<"AiConversation"> | string | null
    context?: JsonNullableFilter<"AiConversation">
    isActive?: BoolFilter<"AiConversation"> | boolean
    createdAt?: DateTimeFilter<"AiConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AiConversation"> | Date | string
  }

  export type AiAgentCreateWithoutConversationsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    model?: string
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutAiAgentsInput
  }

  export type AiAgentUncheckedCreateWithoutConversationsInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    systemPrompt: string
    model?: string
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiAgentCreateOrConnectWithoutConversationsInput = {
    where: AiAgentWhereUniqueInput
    create: XOR<AiAgentCreateWithoutConversationsInput, AiAgentUncheckedCreateWithoutConversationsInput>
  }

  export type AiMessageCreateWithoutConversationInput = {
    id?: string
    role: string
    content: string
    tokensUsed?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiMessageUncheckedCreateWithoutConversationInput = {
    id?: string
    role: string
    content: string
    tokensUsed?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiMessageCreateOrConnectWithoutConversationInput = {
    where: AiMessageWhereUniqueInput
    create: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput>
  }

  export type AiMessageCreateManyConversationInputEnvelope = {
    data: AiMessageCreateManyConversationInput | AiMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type AiAgentUpsertWithoutConversationsInput = {
    update: XOR<AiAgentUpdateWithoutConversationsInput, AiAgentUncheckedUpdateWithoutConversationsInput>
    create: XOR<AiAgentCreateWithoutConversationsInput, AiAgentUncheckedCreateWithoutConversationsInput>
    where?: AiAgentWhereInput
  }

  export type AiAgentUpdateToOneWithWhereWithoutConversationsInput = {
    where?: AiAgentWhereInput
    data: XOR<AiAgentUpdateWithoutConversationsInput, AiAgentUncheckedUpdateWithoutConversationsInput>
  }

  export type AiAgentUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAiAgentsNestedInput
  }

  export type AiAgentUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: AiMessageWhereUniqueInput
    update: XOR<AiMessageUpdateWithoutConversationInput, AiMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput>
  }

  export type AiMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: AiMessageWhereUniqueInput
    data: XOR<AiMessageUpdateWithoutConversationInput, AiMessageUncheckedUpdateWithoutConversationInput>
  }

  export type AiMessageUpdateManyWithWhereWithoutConversationInput = {
    where: AiMessageScalarWhereInput
    data: XOR<AiMessageUpdateManyMutationInput, AiMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type AiMessageScalarWhereInput = {
    AND?: AiMessageScalarWhereInput | AiMessageScalarWhereInput[]
    OR?: AiMessageScalarWhereInput[]
    NOT?: AiMessageScalarWhereInput | AiMessageScalarWhereInput[]
    id?: StringFilter<"AiMessage"> | string
    conversationId?: StringFilter<"AiMessage"> | string
    role?: StringFilter<"AiMessage"> | string
    content?: StringFilter<"AiMessage"> | string
    tokensUsed?: IntNullableFilter<"AiMessage"> | number | null
    metadata?: JsonNullableFilter<"AiMessage">
    createdAt?: DateTimeFilter<"AiMessage"> | Date | string
  }

  export type AiConversationCreateWithoutMessagesInput = {
    id?: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AiAgentCreateNestedOneWithoutConversationsInput
  }

  export type AiConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    agentId: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiConversationCreateOrConnectWithoutMessagesInput = {
    where: AiConversationWhereUniqueInput
    create: XOR<AiConversationCreateWithoutMessagesInput, AiConversationUncheckedCreateWithoutMessagesInput>
  }

  export type AiConversationUpsertWithoutMessagesInput = {
    update: XOR<AiConversationUpdateWithoutMessagesInput, AiConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<AiConversationCreateWithoutMessagesInput, AiConversationUncheckedCreateWithoutMessagesInput>
    where?: AiConversationWhereInput
  }

  export type AiConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: AiConversationWhereInput
    data: XOR<AiConversationUpdateWithoutMessagesInput, AiConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type AiConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AiAgentUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type AiConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAiTokenUsageInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiTokenUsageInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: string
    firstName?: string | null
    lastName?: string | null
    avatar?: string | null
    phoneNumber?: string | null
    timezone?: string
    lastLoginAt?: Date | string | null
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    audioHistory?: AudioHistoryUncheckedCreateNestedManyWithoutUserInput
    audioUploads?: AudioUploadUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyManagementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    securityEvents?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    audioSegments?: AudioSegmentUncheckedCreateNestedManyWithoutUserInput
    emailPreferences?: EmailPreferenceUncheckedCreateNestedOneWithoutUserInput
    quotaUsage?: UserQuotaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiTokenUsageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiTokenUsageInput, UserUncheckedCreateWithoutAiTokenUsageInput>
  }

  export type UserUpsertWithoutAiTokenUsageInput = {
    update: XOR<UserUpdateWithoutAiTokenUsageInput, UserUncheckedUpdateWithoutAiTokenUsageInput>
    create: XOR<UserCreateWithoutAiTokenUsageInput, UserUncheckedCreateWithoutAiTokenUsageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiTokenUsageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiTokenUsageInput, UserUncheckedUpdateWithoutAiTokenUsageInput>
  }

  export type UserUpdateWithoutAiTokenUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiTokenUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    audioHistory?: AudioHistoryUncheckedUpdateManyWithoutUserNestedInput
    audioUploads?: AudioUploadUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyManagementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    securityEvents?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    audioSegments?: AudioSegmentUncheckedUpdateManyWithoutUserNestedInput
    emailPreferences?: EmailPreferenceUncheckedUpdateOneWithoutUserNestedInput
    quotaUsage?: UserQuotaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RolePermissionCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRolesInput = {
    id?: string
    name: string
    description?: string | null
    resource: string
    action: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: string
    name: string
    description?: string | null
    resource: string
    action: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanCreateWithoutPlanPricingInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    tier: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingPeriod: string
    features: JsonNullValueInput | InputJsonValue
    quotas: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublic?: boolean
    trialDays?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateWithoutPlanPricingInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    tier: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    billingPeriod: string
    features: JsonNullValueInput | InputJsonValue
    quotas: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublic?: boolean
    trialDays?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanCreateOrConnectWithoutPlanPricingInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutPlanPricingInput, SubscriptionPlanUncheckedCreateWithoutPlanPricingInput>
  }

  export type SubscriptionPlanUpsertWithoutPlanPricingInput = {
    update: XOR<SubscriptionPlanUpdateWithoutPlanPricingInput, SubscriptionPlanUncheckedUpdateWithoutPlanPricingInput>
    create: XOR<SubscriptionPlanCreateWithoutPlanPricingInput, SubscriptionPlanUncheckedCreateWithoutPlanPricingInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutPlanPricingInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutPlanPricingInput, SubscriptionPlanUncheckedUpdateWithoutPlanPricingInput>
  }

  export type SubscriptionPlanUpdateWithoutPlanPricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    quotas?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    trialDays?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateWithoutPlanPricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    quotas?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    trialDays?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type EwayCustomerCreateWithoutTransactionsInput = {
    id?: string
    customerToken: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: string | null
    cardName?: string | null
    cardExpiryMonth?: string | null
    cardExpiryYear?: string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    recurringSchedules?: EwayRecurringScheduleCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerUncheckedCreateWithoutTransactionsInput = {
    id?: string
    customerToken: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: string | null
    cardName?: string | null
    cardExpiryMonth?: string | null
    cardExpiryYear?: string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    recurringSchedules?: EwayRecurringScheduleUncheckedCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerCreateOrConnectWithoutTransactionsInput = {
    where: EwayCustomerWhereUniqueInput
    create: XOR<EwayCustomerCreateWithoutTransactionsInput, EwayCustomerUncheckedCreateWithoutTransactionsInput>
  }

  export type EwayCustomerUpsertWithoutTransactionsInput = {
    update: XOR<EwayCustomerUpdateWithoutTransactionsInput, EwayCustomerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<EwayCustomerCreateWithoutTransactionsInput, EwayCustomerUncheckedCreateWithoutTransactionsInput>
    where?: EwayCustomerWhereInput
  }

  export type EwayCustomerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: EwayCustomerWhereInput
    data: XOR<EwayCustomerUpdateWithoutTransactionsInput, EwayCustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type EwayCustomerUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerToken?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recurringSchedules?: EwayRecurringScheduleUpdateManyWithoutEwayCustomerNestedInput
  }

  export type EwayCustomerUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerToken?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recurringSchedules?: EwayRecurringScheduleUncheckedUpdateManyWithoutEwayCustomerNestedInput
  }

  export type EwayTransactionCreateWithoutEwayCustomerInput = {
    id?: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    transactionStatus?: string
    responseCode?: string | null
    responseMessage?: string | null
    authCode?: string | null
    beagleScore?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayTransactionUncheckedCreateWithoutEwayCustomerInput = {
    id?: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    transactionStatus?: string
    responseCode?: string | null
    responseMessage?: string | null
    authCode?: string | null
    beagleScore?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayTransactionCreateOrConnectWithoutEwayCustomerInput = {
    where: EwayTransactionWhereUniqueInput
    create: XOR<EwayTransactionCreateWithoutEwayCustomerInput, EwayTransactionUncheckedCreateWithoutEwayCustomerInput>
  }

  export type EwayTransactionCreateManyEwayCustomerInputEnvelope = {
    data: EwayTransactionCreateManyEwayCustomerInput | EwayTransactionCreateManyEwayCustomerInput[]
    skipDuplicates?: boolean
  }

  export type EwayRecurringScheduleCreateWithoutEwayCustomerInput = {
    id?: string
    interval: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    nextPayment: Date | string
    lastPayment?: Date | string | null
    paymentCount?: number
    maxPayments?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput = {
    id?: string
    interval: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    nextPayment: Date | string
    lastPayment?: Date | string | null
    paymentCount?: number
    maxPayments?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayRecurringScheduleCreateOrConnectWithoutEwayCustomerInput = {
    where: EwayRecurringScheduleWhereUniqueInput
    create: XOR<EwayRecurringScheduleCreateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput>
  }

  export type EwayRecurringScheduleCreateManyEwayCustomerInputEnvelope = {
    data: EwayRecurringScheduleCreateManyEwayCustomerInput | EwayRecurringScheduleCreateManyEwayCustomerInput[]
    skipDuplicates?: boolean
  }

  export type EwayTransactionUpsertWithWhereUniqueWithoutEwayCustomerInput = {
    where: EwayTransactionWhereUniqueInput
    update: XOR<EwayTransactionUpdateWithoutEwayCustomerInput, EwayTransactionUncheckedUpdateWithoutEwayCustomerInput>
    create: XOR<EwayTransactionCreateWithoutEwayCustomerInput, EwayTransactionUncheckedCreateWithoutEwayCustomerInput>
  }

  export type EwayTransactionUpdateWithWhereUniqueWithoutEwayCustomerInput = {
    where: EwayTransactionWhereUniqueInput
    data: XOR<EwayTransactionUpdateWithoutEwayCustomerInput, EwayTransactionUncheckedUpdateWithoutEwayCustomerInput>
  }

  export type EwayTransactionUpdateManyWithWhereWithoutEwayCustomerInput = {
    where: EwayTransactionScalarWhereInput
    data: XOR<EwayTransactionUpdateManyMutationInput, EwayTransactionUncheckedUpdateManyWithoutEwayCustomerInput>
  }

  export type EwayTransactionScalarWhereInput = {
    AND?: EwayTransactionScalarWhereInput | EwayTransactionScalarWhereInput[]
    OR?: EwayTransactionScalarWhereInput[]
    NOT?: EwayTransactionScalarWhereInput | EwayTransactionScalarWhereInput[]
    id?: StringFilter<"EwayTransaction"> | string
    transactionId?: StringFilter<"EwayTransaction"> | string
    customerToken?: StringNullableFilter<"EwayTransaction"> | string | null
    amount?: DecimalFilter<"EwayTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"EwayTransaction"> | string
    status?: StringFilter<"EwayTransaction"> | string
    transactionStatus?: StringFilter<"EwayTransaction"> | string
    responseCode?: StringNullableFilter<"EwayTransaction"> | string | null
    responseMessage?: StringNullableFilter<"EwayTransaction"> | string | null
    authCode?: StringNullableFilter<"EwayTransaction"> | string | null
    beagleScore?: IntNullableFilter<"EwayTransaction"> | number | null
    metadata?: JsonFilter<"EwayTransaction">
    createdAt?: DateTimeFilter<"EwayTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"EwayTransaction"> | Date | string
  }

  export type EwayRecurringScheduleUpsertWithWhereUniqueWithoutEwayCustomerInput = {
    where: EwayRecurringScheduleWhereUniqueInput
    update: XOR<EwayRecurringScheduleUpdateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedUpdateWithoutEwayCustomerInput>
    create: XOR<EwayRecurringScheduleCreateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedCreateWithoutEwayCustomerInput>
  }

  export type EwayRecurringScheduleUpdateWithWhereUniqueWithoutEwayCustomerInput = {
    where: EwayRecurringScheduleWhereUniqueInput
    data: XOR<EwayRecurringScheduleUpdateWithoutEwayCustomerInput, EwayRecurringScheduleUncheckedUpdateWithoutEwayCustomerInput>
  }

  export type EwayRecurringScheduleUpdateManyWithWhereWithoutEwayCustomerInput = {
    where: EwayRecurringScheduleScalarWhereInput
    data: XOR<EwayRecurringScheduleUpdateManyMutationInput, EwayRecurringScheduleUncheckedUpdateManyWithoutEwayCustomerInput>
  }

  export type EwayRecurringScheduleScalarWhereInput = {
    AND?: EwayRecurringScheduleScalarWhereInput | EwayRecurringScheduleScalarWhereInput[]
    OR?: EwayRecurringScheduleScalarWhereInput[]
    NOT?: EwayRecurringScheduleScalarWhereInput | EwayRecurringScheduleScalarWhereInput[]
    id?: StringFilter<"EwayRecurringSchedule"> | string
    customerToken?: StringFilter<"EwayRecurringSchedule"> | string
    interval?: StringFilter<"EwayRecurringSchedule"> | string
    amount?: DecimalFilter<"EwayRecurringSchedule"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"EwayRecurringSchedule"> | string
    status?: StringFilter<"EwayRecurringSchedule"> | string
    nextPayment?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    lastPayment?: DateTimeNullableFilter<"EwayRecurringSchedule"> | Date | string | null
    paymentCount?: IntFilter<"EwayRecurringSchedule"> | number
    maxPayments?: IntNullableFilter<"EwayRecurringSchedule"> | number | null
    metadata?: JsonFilter<"EwayRecurringSchedule">
    createdAt?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"EwayRecurringSchedule"> | Date | string
  }

  export type EwayCustomerCreateWithoutRecurringSchedulesInput = {
    id?: string
    customerToken: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: string | null
    cardName?: string | null
    cardExpiryMonth?: string | null
    cardExpiryYear?: string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: EwayTransactionCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerUncheckedCreateWithoutRecurringSchedulesInput = {
    id?: string
    customerToken: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: string | null
    cardName?: string | null
    cardExpiryMonth?: string | null
    cardExpiryYear?: string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: EwayTransactionUncheckedCreateNestedManyWithoutEwayCustomerInput
  }

  export type EwayCustomerCreateOrConnectWithoutRecurringSchedulesInput = {
    where: EwayCustomerWhereUniqueInput
    create: XOR<EwayCustomerCreateWithoutRecurringSchedulesInput, EwayCustomerUncheckedCreateWithoutRecurringSchedulesInput>
  }

  export type EwayCustomerUpsertWithoutRecurringSchedulesInput = {
    update: XOR<EwayCustomerUpdateWithoutRecurringSchedulesInput, EwayCustomerUncheckedUpdateWithoutRecurringSchedulesInput>
    create: XOR<EwayCustomerCreateWithoutRecurringSchedulesInput, EwayCustomerUncheckedCreateWithoutRecurringSchedulesInput>
    where?: EwayCustomerWhereInput
  }

  export type EwayCustomerUpdateToOneWithWhereWithoutRecurringSchedulesInput = {
    where?: EwayCustomerWhereInput
    data: XOR<EwayCustomerUpdateWithoutRecurringSchedulesInput, EwayCustomerUncheckedUpdateWithoutRecurringSchedulesInput>
  }

  export type EwayCustomerUpdateWithoutRecurringSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerToken?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: EwayTransactionUpdateManyWithoutEwayCustomerNestedInput
  }

  export type EwayCustomerUncheckedUpdateWithoutRecurringSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerToken?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: EwayTransactionUncheckedUpdateManyWithoutEwayCustomerNestedInput
  }

  export type WorkspaceUserCreateManyUserInput = {
    id?: string
    workspaceId: string
    role?: string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string | null
  }

  export type AudioHistoryCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    processingJobId?: string | null
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
  }

  export type AudioUploadCreateManyUserInput = {
    id?: string
    workspaceId: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyManagementCreateManyUserInput = {
    id?: string
    provider: string
    keyHash: string
    keyPrefix: string
    encryptedKey: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    usageCount?: number
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SecurityEventCreateManyUserInput = {
    id?: string
    eventType: string
    severity: string
    description: string
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    message: string
    actionUrl?: string | null
    read?: boolean
    readAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AudioSegmentCreateManyUserInput = {
    id?: string
    audioHistoryId: string
    startTime: number
    endTime: number
    text: string
    speaker?: string | null
    confidence?: number | null
    keywords?: AudioSegmentCreatekeywordsInput | string[]
    sentiment?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserQuotaCreateManyUserInput = {
    id?: string
    workspaceId: string
    quotaType: string
    used?: bigint | number
    limit: bigint | number
    resetPeriod: string
    nextResetAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiTokenUsageCreateManyUserInput = {
    id?: string
    workspaceId: string
    provider: string
    model: string
    tokensUsed: number
    cost: Decimal | DecimalJsLike | number | string
    purpose: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WorkspaceUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutUsersNestedInput
  }

  export type WorkspaceUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneWithoutAudioHistoryNestedInput
    processingJob?: ProcessingJobUpdateOneWithoutAudioHistoryNestedInput
    segments?: AudioSegmentUpdateManyWithoutAudioHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    processingJobId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segments?: AudioSegmentUncheckedUpdateManyWithoutAudioHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    processingJobId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioUploadUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAudioUploadsNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUpdateManyWithoutUploadNestedInput
    fileStorage?: FileStorageUpdateOneWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUncheckedUpdateManyWithoutUploadNestedInput
    fileStorage?: FileStorageUncheckedUpdateOneWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyManagementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: ApiKeyUsageLogUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyManagementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: ApiKeyUsageLogUncheckedUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyManagementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    encryptedKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioSegmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: AudioSegmentUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioHistory?: AudioHistoryUpdateOneRequiredWithoutSegmentsNestedInput
  }

  export type AudioSegmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioHistoryId?: StringFieldUpdateOperationsInput | string
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: AudioSegmentUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioSegmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioHistoryId?: StringFieldUpdateOperationsInput | string
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: AudioSegmentUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuotaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    quotaType?: StringFieldUpdateOperationsInput | string
    used?: BigIntFieldUpdateOperationsInput | bigint | number
    limit?: BigIntFieldUpdateOperationsInput | bigint | number
    resetPeriod?: StringFieldUpdateOperationsInput | string
    nextResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuotaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    quotaType?: StringFieldUpdateOperationsInput | string
    used?: BigIntFieldUpdateOperationsInput | bigint | number
    limit?: BigIntFieldUpdateOperationsInput | bigint | number
    resetPeriod?: StringFieldUpdateOperationsInput | string
    nextResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuotaUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    quotaType?: StringFieldUpdateOperationsInput | string
    used?: BigIntFieldUpdateOperationsInput | bigint | number
    limit?: BigIntFieldUpdateOperationsInput | bigint | number
    resetPeriod?: StringFieldUpdateOperationsInput | string
    nextResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiTokenUsageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiTokenUsageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiTokenUsageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserCreateManyWorkspaceInput = {
    id?: string
    userId: string
    role?: string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string | null
  }

  export type WorkspaceInvitationCreateManyWorkspaceInput = {
    id?: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    acceptedAt?: Date | string | null
  }

  export type AudioHistoryCreateManyWorkspaceInput = {
    id?: string
    userId: string
    processingJobId?: string | null
    title?: string | null
    audioUrl?: string | null
    fileSizeBytes?: bigint | number | null
    durationSeconds?: number | null
    transcript?: string | null
    summary?: string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    confidence?: number | null
    speakers?: number | null
    tags?: AudioHistoryCreatetagsInput | string[]
    createdAt?: Date | string
  }

  export type AudioUploadCreateManyWorkspaceInput = {
    id?: string
    userId: string
    originalFileName: string
    fileSize: bigint | number
    mimeType: string
    uploadStatus?: string
    uploadProgress?: number
    storageProvider: string
    storagePath?: string | null
    storageUrl?: string | null
    cdnUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceSubscriptionCreateManyWorkspaceInput = {
    id?: string
    planId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageQuotaCreateManyWorkspaceInput = {
    id?: string
    totalBytes: bigint | number
    usedBytes: bigint | number
    fileCount: number
    lastCalculated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateManyWorkspaceInput = {
    id?: string
    type: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceAutomationCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookCreateManyWorkspaceInput = {
    id?: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    lastTriggeredAt?: Date | string | null
    failureCount?: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldCreateManyWorkspaceInput = {
    id?: string
    name: string
    fieldType: string
    isRequired?: boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateManyWorkspaceInput = {
    id?: string
    name: string
    color: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiAgentCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt: string
    model?: string
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUserUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
  }

  export type WorkspaceUserUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioHistoryUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioHistoryNestedInput
    processingJob?: ProcessingJobUpdateOneWithoutAudioHistoryNestedInput
    segments?: AudioSegmentUpdateManyWithoutAudioHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    processingJobId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segments?: AudioSegmentUncheckedUpdateManyWithoutAudioHistoryNestedInput
  }

  export type AudioHistoryUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    processingJobId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyMoments?: NullableJsonNullValueInput | InputJsonValue
    processingOptions?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    speakers?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: AudioHistoryUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioUploadUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioUploadsNestedInput
    processingJobs?: ProcessingJobUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUpdateManyWithoutUploadNestedInput
    fileStorage?: FileStorageUpdateOneWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingJobs?: ProcessingJobUncheckedUpdateManyWithoutUploadNestedInput
    audioChunks?: AudioChunkUncheckedUpdateManyWithoutUploadNestedInput
    fileStorage?: FileStorageUncheckedUpdateOneWithoutUploadNestedInput
  }

  export type AudioUploadUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    originalFileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadStatus?: StringFieldUpdateOperationsInput | string
    uploadProgress?: FloatFieldUpdateOperationsInput | number
    storageProvider?: StringFieldUpdateOperationsInput | string
    storagePath?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceSubscriptionUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    billingRecords?: BillingRecordUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingRecords?: BillingRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceAutomationUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceAutomationUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceAutomationUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAgentUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: AiConversationUpdateManyWithoutAgentNestedInput
  }

  export type AiAgentUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: AiConversationUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AiAgentUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessingJobCreateManyUploadInput = {
    id?: string
    jobType: string
    status?: string
    priority?: number
    progress?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioChunkCreateManyUploadInput = {
    id?: string
    chunkIndex: number
    startByte: bigint | number
    endByte: bigint | number
    size: bigint | number
    storageKey: string
    checksum: string
    uploadedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProcessingJobUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioHistory?: AudioHistoryUpdateOneWithoutProcessingJobNestedInput
  }

  export type ProcessingJobUncheckedUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioHistory?: AudioHistoryUncheckedUpdateOneWithoutProcessingJobNestedInput
  }

  export type ProcessingJobUncheckedUpdateManyWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioChunkUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startByte?: BigIntFieldUpdateOperationsInput | bigint | number
    endByte?: BigIntFieldUpdateOperationsInput | bigint | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    storageKey?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioChunkUncheckedUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startByte?: BigIntFieldUpdateOperationsInput | bigint | number
    endByte?: BigIntFieldUpdateOperationsInput | bigint | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    storageKey?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioChunkUncheckedUpdateManyWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    startByte?: BigIntFieldUpdateOperationsInput | bigint | number
    endByte?: BigIntFieldUpdateOperationsInput | bigint | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    storageKey?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    uploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioSegmentCreateManyAudioHistoryInput = {
    id?: string
    userId: string
    startTime: number
    endTime: number
    text: string
    speaker?: string | null
    confidence?: number | null
    keywords?: AudioSegmentCreatekeywordsInput | string[]
    sentiment?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AudioSegmentUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: AudioSegmentUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAudioSegmentsNestedInput
  }

  export type AudioSegmentUncheckedUpdateWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: AudioSegmentUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioSegmentUncheckedUpdateManyWithoutAudioHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    keywords?: AudioSegmentUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileStorageCreateManyProviderInput = {
    id?: string
    uploadId: string
    storageKey: string
    fileName: string
    fileSize: bigint | number
    mimeType: string
    checksum: string
    publicUrl?: string | null
    cdnUrl?: string | null
    expiresAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastAccessedAt?: Date | string | null
  }

  export type FileStorageUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upload?: AudioUploadUpdateOneRequiredWithoutFileStorageNestedInput
  }

  export type FileStorageUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileStorageUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadId?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    mimeType?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cdnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceSubscriptionCreateManyPlanInput = {
    id?: string
    workspaceId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPricingCreateManyPlanInput = {
    id?: string
    currency?: string
    price: Decimal | DecimalJsLike | number | string
    interval: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceSubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionsNestedInput
    billingRecords?: BillingRecordUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingRecords?: BillingRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WorkspaceSubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPricingUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPricingUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPricingUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRecordCreateManySubscriptionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: string
    invoiceNumber?: string | null
    invoiceUrl?: string | null
    paymentMethod?: string | null
    paymentIntentId?: string | null
    failureReason?: string | null
    paidAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageRecordCreateManySubscriptionInput = {
    id?: string
    recordType: string
    quantity: bigint | number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    periodStart: Date | string
    periodEnd: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingRecordUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRecordUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingRecordUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUsageLogCreateManyApiKeyInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ApiKeyUsageLogUpdateWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUsageLogUncheckedUpdateWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUsageLogUncheckedUpdateManyWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateManyTemplateInput = {
    id?: string
    recipientEmail: string
    subject: string
    status: string
    provider: string
    providerMessageId?: string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailLogUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiConversationCreateManyAgentInput = {
    id?: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiConversationUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AiMessageUpdateManyWithoutConversationNestedInput
  }

  export type AiConversationUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AiMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AiConversationUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageCreateManyConversationInput = {
    id?: string
    role: string
    content: string
    tokensUsed?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiMessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayTransactionCreateManyEwayCustomerInput = {
    id?: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    transactionStatus?: string
    responseCode?: string | null
    responseMessage?: string | null
    authCode?: string | null
    beagleScore?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayRecurringScheduleCreateManyEwayCustomerInput = {
    id?: string
    interval: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status: string
    nextPayment: Date | string
    lastPayment?: Date | string | null
    paymentCount?: number
    maxPayments?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EwayTransactionUpdateWithoutEwayCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayTransactionUncheckedUpdateWithoutEwayCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayTransactionUncheckedUpdateManyWithoutEwayCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    beagleScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayRecurringScheduleUpdateWithoutEwayCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextPayment?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentCount?: IntFieldUpdateOperationsInput | number
    maxPayments?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayRecurringScheduleUncheckedUpdateWithoutEwayCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextPayment?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentCount?: IntFieldUpdateOperationsInput | number
    maxPayments?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwayRecurringScheduleUncheckedUpdateManyWithoutEwayCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextPayment?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentCount?: IntFieldUpdateOperationsInput | number
    maxPayments?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceCountOutputTypeDefaultArgs instead
     */
    export type WorkspaceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioUploadCountOutputTypeDefaultArgs instead
     */
    export type AudioUploadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioUploadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioHistoryCountOutputTypeDefaultArgs instead
     */
    export type AudioHistoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioHistoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageProviderCountOutputTypeDefaultArgs instead
     */
    export type StorageProviderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageProviderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlanCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceSubscriptionCountOutputTypeDefaultArgs instead
     */
    export type WorkspaceSubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyManagementCountOutputTypeDefaultArgs instead
     */
    export type ApiKeyManagementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyManagementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailTemplateCountOutputTypeDefaultArgs instead
     */
    export type EmailTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiAgentCountOutputTypeDefaultArgs instead
     */
    export type AiAgentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiAgentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiConversationCountOutputTypeDefaultArgs instead
     */
    export type AiConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EwayCustomerCountOutputTypeDefaultArgs instead
     */
    export type EwayCustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EwayCustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceDefaultArgs instead
     */
    export type WorkspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceUserDefaultArgs instead
     */
    export type WorkspaceUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceInvitationDefaultArgs instead
     */
    export type WorkspaceInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceInvitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioUploadDefaultArgs instead
     */
    export type AudioUploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioUploadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessingJobDefaultArgs instead
     */
    export type ProcessingJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessingJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioHistoryDefaultArgs instead
     */
    export type AudioHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioSegmentDefaultArgs instead
     */
    export type AudioSegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioSegmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioChunkDefaultArgs instead
     */
    export type AudioChunkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioChunkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageProviderDefaultArgs instead
     */
    export type StorageProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageProviderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileStorageDefaultArgs instead
     */
    export type FileStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileStorageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlanDefaultArgs instead
     */
    export type SubscriptionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceSubscriptionDefaultArgs instead
     */
    export type WorkspaceSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BillingRecordDefaultArgs instead
     */
    export type BillingRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillingRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentMethodDefaultArgs instead
     */
    export type PaymentMethodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentMethodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyManagementDefaultArgs instead
     */
    export type ApiKeyManagementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyManagementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyUsageLogDefaultArgs instead
     */
    export type ApiKeyUsageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyUsageLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSettingsDefaultArgs instead
     */
    export type UserSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsageMetricDefaultArgs instead
     */
    export type UsageMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsageMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserQuotaDefaultArgs instead
     */
    export type UserQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserQuotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageQuotaDefaultArgs instead
     */
    export type StorageQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageQuotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsageRecordDefaultArgs instead
     */
    export type UsageRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsageRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SecurityEventDefaultArgs instead
     */
    export type SecurityEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SecurityEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailTemplateDefaultArgs instead
     */
    export type EmailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailLogDefaultArgs instead
     */
    export type EmailLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailPreferenceDefaultArgs instead
     */
    export type EmailPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailPreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegrationDefaultArgs instead
     */
    export type IntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceAutomationDefaultArgs instead
     */
    export type WorkspaceAutomationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceAutomationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookDefaultArgs instead
     */
    export type WebhookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomFieldDefaultArgs instead
     */
    export type CustomFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomFieldDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiAgentDefaultArgs instead
     */
    export type AiAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiAgentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiConversationDefaultArgs instead
     */
    export type AiConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiMessageDefaultArgs instead
     */
    export type AiMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiTokenUsageDefaultArgs instead
     */
    export type AiTokenUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiTokenUsageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionDefaultArgs instead
     */
    export type RolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsageTrackingDefaultArgs instead
     */
    export type UsageTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsageTrackingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsageReportDefaultArgs instead
     */
    export type UsageReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsageReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentGatewayConfigDefaultArgs instead
     */
    export type PaymentGatewayConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentGatewayConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanPricingDefaultArgs instead
     */
    export type PlanPricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanPricingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EwayTransactionDefaultArgs instead
     */
    export type EwayTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EwayTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EwayCustomerDefaultArgs instead
     */
    export type EwayCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EwayCustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EwayRecurringScheduleDefaultArgs instead
     */
    export type EwayRecurringScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EwayRecurringScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EwayWebhookEventDefaultArgs instead
     */
    export type EwayWebhookEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EwayWebhookEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemConfigDefaultArgs instead
     */
    export type SystemConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthCheckDefaultArgs instead
     */
    export type HealthCheckArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthCheckDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}